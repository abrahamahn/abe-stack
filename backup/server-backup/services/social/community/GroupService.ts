import {
  Group,
  GroupStatus,
  GroupVisibility,
} from "@/server/database/models/community/Group";
import { MembershipStatus } from "@/server/database/models/community/GroupMember";
import { GroupMemberRepository } from "@/server/database/repositories/community/GroupMemberRepository";
import { GroupRepository } from "@/server/database/repositories/community/GroupRepository";
import { PaginatedResult, PaginationOptions } from "@/server/shared/types";
import { BaseService } from "@/server/services/shared/base/BaseService";
import {
  ResourceNotFoundError,
  AccessDeniedError,
  ValidationError,
} from "@/server/services/shared/errors/ServiceError";

/**
 * Data transfer object for creating a group
 */
export interface GroupCreateDTO {
  name: string;
  description?: string;
  imageUrl?: string;
  bannerUrl?: string;
  visibility?: GroupVisibility;
}

/**
 * Data transfer object for updating a group
 */
export interface GroupUpdateDTO {
  name?: string;
  description?: string;
  imageUrl?: string;
  bannerUrl?: string;
  visibility?: GroupVisibility;
  status?: GroupStatus;
}

/**
 * Service responsible for managing groups in the social platform
 * Features:
 * 1. Group creation and management
 * 2. Group discovery and recommendations
 * 3. Group content organization
 * 4. Group settings and permissions
 * 5. Group analytics and insights
 */
export class GroupService extends BaseService {
  /**
   * Creates a new GroupService instance
   * @param groupRepository Repository for group operations
   * @param groupMemberRepository Repository for group member operations
   */
  constructor(
    private readonly groupRepository: GroupRepository,
    private readonly groupMemberRepository: GroupMemberRepository
  ) {
    super("GroupService");
  }

  /**
   * Create a new group
   * @param creatorId ID of the user creating the group
   * @param groupData Group creation data
   * @returns The created group
   */
  async createGroup(
    creatorId: string,
    groupData: GroupCreateDTO
  ): Promise<Group> {
    try {
      this.logger.info(`Creating group with name: ${groupData.name}`, {
        creatorId,
      });

      // Validate input
      if (!groupData.name || groupData.name.trim().length === 0) {
        throw new ValidationError("Group name is required");
      }

      if (groupData.name.length > 100) {
        throw new ValidationError("Group name cannot exceed 100 characters");
      }

      if (groupData.description && groupData.description.length > 1000) {
        throw new ValidationError(
          "Group description cannot exceed 1000 characters"
        );
      }

      // Create the group
      const group = await this.groupRepository.create({
        name: groupData.name,
        description: groupData.description || null,
        imageUrl: groupData.imageUrl || null,
        bannerUrl: groupData.bannerUrl || null,
        ownerId: creatorId,
        visibility: groupData.visibility || GroupVisibility.PRIVATE,
        status: GroupStatus.ACTIVE,
        memberCount: 1, // Creator is automatically a member
        slug: "", // Will be generated by the model
      });

      // Add the creator as an admin member
      await this.groupMemberRepository.create({
        groupId: group.id,
        userId: creatorId,
        role: "admin",
        status: MembershipStatus.APPROVED,
        notificationSettings: {
          posts: true,
          events: true,
          announcements: true,
        },
        lastActivity: new Date(),
      });

      return group;
    } catch (error) {
      this.logger.error("Failed to create group", {
        error,
        creatorId,
        groupData,
      });
      throw error;
    }
  }

  /**
   * Get a group by ID
   * @param groupId ID of the group to retrieve
   * @returns The group or null if not found
   */
  async getGroup(groupId: string): Promise<Group | null> {
    try {
      this.logger.info(`Getting group by ID: ${groupId}`);
      return await this.groupRepository.findById(groupId);
    } catch (error) {
      this.logger.error(`Failed to get group with ID: ${groupId}`, { error });
      throw new ResourceNotFoundError("Group", groupId);
    }
  }

  /**
   * Update a group
   * @param groupId ID of the group to update
   * @param updates Update data
   * @param userId ID of the user performing the update (for authorization)
   * @returns The updated group
   */
  async updateGroup(
    groupId: string,
    updates: GroupUpdateDTO,
    userId: string
  ): Promise<Group> {
    try {
      this.logger.info(`Updating group with ID: ${groupId}`, {
        userId,
        updates,
      });

      // Get the group
      const group = await this.groupRepository.findById(groupId);
      if (!group) {
        throw new ResourceNotFoundError("Group", groupId);
      }

      // Check if user is authorized to update the group
      const membership = await this.groupMemberRepository.findByGroupAndUserId(
        groupId,
        userId
      );
      const isOwner = group.ownerId === userId;
      const isAdmin = membership?.role === "admin";

      if (!isOwner && !isAdmin) {
        throw new AccessDeniedError(
          "Only the group owner or admins can update the group"
        );
      }

      // Regular admins cannot change group status (only owner can)
      if (updates.status && !isOwner) {
        throw new AccessDeniedError(
          "Only the group owner can change the group status"
        );
      }

      // Validate input
      if (updates.name && updates.name.length > 100) {
        throw new ValidationError("Group name cannot exceed 100 characters");
      }

      if (updates.description && updates.description.length > 1000) {
        throw new ValidationError(
          "Group description cannot exceed 1000 characters"
        );
      }

      // Update the group
      const updatedGroup = await this.groupRepository.update(groupId, updates);
      if (!updatedGroup) {
        throw new ResourceNotFoundError("Group", groupId);
      }

      return updatedGroup;
    } catch (error) {
      this.logger.error(`Failed to update group with ID: ${groupId}`, {
        error,
        userId,
        updates,
      });
      throw error;
    }
  }

  /**
   * Delete a group
   * @param groupId ID of the group to delete
   * @param userId ID of the user performing the deletion (for authorization)
   * @returns True if the group was deleted successfully
   */
  async deleteGroup(groupId: string, userId: string): Promise<boolean> {
    try {
      this.logger.info(`Deleting group with ID: ${groupId}`, { userId });

      // Get the group
      const group = await this.groupRepository.findById(groupId);
      if (!group) {
        throw new ResourceNotFoundError("Group", groupId);
      }

      // Check if user is authorized to delete the group
      if (group.ownerId !== userId) {
        throw new AccessDeniedError(
          "Only the group owner can delete the group"
        );
      }

      // Update the status to archived instead of actually deleting
      const updateResult = await this.groupRepository.update(groupId, {
        status: GroupStatus.ARCHIVED,
      });

      return !!updateResult;
    } catch (error) {
      this.logger.error(`Failed to delete group with ID: ${groupId}`, {
        error,
        userId,
      });
      throw error;
    }
  }

  /**
   * Get members of a group with pagination
   * @param groupId ID of the group
   * @param options Pagination options
   * @returns Paginated list of users who are members of the group
   */
  async getGroupMembers(
    groupId: string,
    options: PaginationOptions = {}
  ): Promise<
    PaginatedResult<{
      id: string;
      role: string;
      joinedAt: Date;
      lastActivity: Date | null;
    }>
  > {
    try {
      const { page = 1, limit = 20 } = options;
      const offset = (page - 1) * limit;

      this.logger.info(`Getting members of group with ID: ${groupId}`, {
        page,
        limit,
      });

      // Get the group to ensure it exists
      const group = await this.groupRepository.findById(groupId);
      if (!group) {
        throw new ResourceNotFoundError("Group", groupId);
      }

      // For a real implementation, this would join with the users table
      // For now, we'll just get the member records
      const members = await this.groupMemberRepository.findByGroupId(
        groupId,
        limit,
        offset,
        MembershipStatus.APPROVED
      );

      // Get the total count
      const totalMembers = group.memberCount;

      // For a real implementation, this would include user details
      // For now, we'll return a simplified structure
      return {
        items: members.map((member) => ({
          id: member.userId,
          role: member.role,
          joinedAt: member.createdAt,
          lastActivity: member.lastActivity,
          // In a real implementation, this would include user profile data
        })),
        total: totalMembers,
        page,
        limit,
        totalPages: Math.ceil(totalMembers / limit),
      };
    } catch (error) {
      this.logger.error(`Failed to get members of group with ID: ${groupId}`, {
        error,
      });
      throw error;
    }
  }

  /**
   * Get groups that a user is a member of
   * @param userId ID of the user
   * @param options Pagination options
   * @returns Paginated list of groups that the user is a member of
   */
  async getUserGroups(
    userId: string,
    options: PaginationOptions = {}
  ): Promise<PaginatedResult<Group>> {
    try {
      const { page = 1, limit = 20 } = options;
      const offset = (page - 1) * limit;

      this.logger.info(`Getting groups for user with ID: ${userId}`, {
        page,
        limit,
      });

      // Get the member records
      const memberships = await this.groupMemberRepository.findByUserId(
        userId,
        limit,
        offset,
        MembershipStatus.APPROVED
      );

      // If there are no memberships, return empty result
      if (memberships.length === 0) {
        return {
          items: [],
          total: 0,
          page,
          limit,
          totalPages: 0,
        };
      }

      // Get the groups
      const groupIds = memberships.map((m) => m.groupId);
      const groups: Group[] = [];

      // In a real implementation, this would be a batch query
      // For simplicity, we'll do individual queries
      for (const groupId of groupIds) {
        const group = await this.groupRepository.findById(groupId);
        if (group) {
          groups.push(group);
        }
      }

      // Get total count - in a real implementation, this would be a COUNT query
      // For simplicity, we'll assume the total is the current page * limit
      const estimatedTotal = page * limit;

      return {
        items: groups,
        total: Math.max(estimatedTotal, groups.length), // Ensure total is at least the number of items
        page,
        limit,
        totalPages: Math.ceil(Math.max(estimatedTotal, groups.length) / limit),
      };
    } catch (error) {
      this.logger.error(`Failed to get groups for user with ID: ${userId}`, {
        error,
      });
      throw error;
    }
  }

  /**
   * Find popular groups
   * @param limit Maximum number of groups to return
   * @param offset Number of groups to skip
   * @returns Array of groups sorted by popularity
   */
  async findPopularGroups(limit = 10, offset = 0): Promise<Group[]> {
    try {
      this.logger.info(`Finding popular groups`, { limit, offset });
      return await this.groupRepository.findPublic(limit, offset);
    } catch (error) {
      this.logger.error(`Failed to find popular groups`, { error });
      throw error;
    }
  }

  /**
   * Search for groups by name
   * @param searchTerm The search term
   * @param limit Maximum number of groups to return
   * @param offset Number of groups to skip
   * @returns Array of groups matching the search term
   */
  async searchGroups(
    searchTerm: string,
    limit = 20,
    offset = 0
  ): Promise<Group[]> {
    try {
      this.logger.info(`Searching for groups with term: ${searchTerm}`, {
        limit,
        offset,
      });
      return await this.groupRepository.searchByName(searchTerm, limit, offset);
    } catch (error) {
      this.logger.error(
        `Failed to search for groups with term: ${searchTerm}`,
        { error }
      );
      throw error;
    }
  }

  /**
   * Check if a user is a member of a group
   * @param groupId ID of the group
   * @param userId ID of the user
   * @returns True if the user is a member of the group
   */
  async isGroupMember(groupId: string, userId: string): Promise<boolean> {
    try {
      this.logger.info(
        `Checking if user ${userId} is a member of group ${groupId}`
      );
      const membership = await this.groupMemberRepository.findByGroupAndUserId(
        groupId,
        userId
      );
      return !!membership && membership.status === MembershipStatus.APPROVED;
    } catch (error) {
      this.logger.error(
        `Failed to check if user ${userId} is a member of group ${groupId}`,
        { error }
      );
      throw error;
    }
  }

  /**
   * Get group analytics
   * @param groupId ID of the group
   * @returns Group analytics data
   */
  async getGroupAnalytics(groupId: string): Promise<{
    memberCount: number;
    activeMembers: number;
    memberGrowth: number;
    postsPerDay: number;
    engagementRate: number;
    topContributors: { userId: string; contributions: number }[];
  }> {
    try {
      this.logger.info(`Getting analytics for group with ID: ${groupId}`);

      // Get the group
      const group = await this.groupRepository.findById(groupId);
      if (!group) {
        throw new ResourceNotFoundError("Group", groupId);
      }

      // In a real implementation, this would query actual analytics data
      // For now, we'll return simulated data
      return {
        memberCount: group.memberCount,
        activeMembers: Math.round(
          group.memberCount * (Math.random() * 0.3 + 0.4)
        ), // 40-70% of members are active
        memberGrowth: Math.random() * 0.2 + 0.05, // 5-25% growth
        postsPerDay: Math.round(Math.random() * 10 + 1), // 1-11 posts per day
        engagementRate: Math.random() * 0.3 + 0.1, // 10-40% engagement
        topContributors: Array.from({ length: 5 }, (_, i) => ({
          userId: `user-${i + 1}`,
          contributions: Math.round(Math.random() * 50 + 10), // 10-60 contributions
        })),
      };
    } catch (error) {
      this.logger.error(
        `Failed to get analytics for group with ID: ${groupId}`,
        { error }
      );
      throw error;
    }
  }
}
