name: Deploy

on:
  workflow_run:
    workflows: ['CI']
    types: [completed]
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - staging
          - production
      provider:
        description: 'Cloud provider where infrastructure is deployed'
        required: true
        default: 'digitalocean'
        type: choice
        options:
          - digitalocean
          - gcp
      image_tag:
        description: 'Fallback Docker image tag (manual runs only)'
        required: false
        type: string
      app_name:
        description: 'Application slug used to isolate deployment resources (e.g., portfolio-api)'
        required: false
        default: 'abe-stack'
        type: string
      instance_ip:
        description: 'Optional target server IP (used if deployment artifact is unavailable)'
        required: false
        type: string
      domain:
        description: 'Optional domain override (used if deployment artifact is unavailable)'
        required: false
        type: string

permissions:
  contents: read
  actions: read

concurrency:
  group: deploy-${{ inputs.environment || 'production' }}-${{ inputs.app_name || 'abe-stack' }}
  cancel-in-progress: false

jobs:
  get-infrastructure-info:
    if: github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success'
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment || 'production' }}
    outputs:
      instance_ip: ${{ steps.get-deployment-info.outputs.instance_ip }}
      domain: ${{ steps.get-deployment-info.outputs.domain }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha || github.sha }}

      - name: Download deployment info artifact
        uses: actions/download-artifact@v4
        with:
          name: deployment-info-${{ inputs.environment || 'production' }}-${{ inputs.provider || 'digitalocean' }}
          path: .deploy/
        continue-on-error: true

      - name: Extract infrastructure information
        id: get-deployment-info
        env:
          INPUT_ENVIRONMENT: ${{ inputs.environment || 'production' }}
          INPUT_PROVIDER: ${{ inputs.provider || 'digitalocean' }}
          MANUAL_INSTANCE_IP: ${{ inputs.instance_ip || vars.INSTANCE_IP || vars.DEPLOY_HOST || secrets.SERVER_HOST || '' }}
          MANUAL_DOMAIN: ${{ inputs.domain || vars.DOMAIN || secrets.DOMAIN || '' }}
        run: |
          DEPLOY_FILE=".deploy/${INPUT_ENVIRONMENT}-${INPUT_PROVIDER}.json"

          if [ -f "$DEPLOY_FILE" ]; then
            INSTANCE_IP=$(jq -r '.instance_ip // empty' "$DEPLOY_FILE")
            DOMAIN=$(jq -r '.domain // empty' "$DEPLOY_FILE")
          elif [ -n "$MANUAL_INSTANCE_IP" ]; then
            INSTANCE_IP="$MANUAL_INSTANCE_IP"
            DOMAIN="$MANUAL_DOMAIN"
          else
            echo "No deployment info artifact found and no manual host provided."
            exit 1
          fi

          if [ -z "$INSTANCE_IP" ] || [ "$INSTANCE_IP" = "N/A" ]; then
            echo "Instance IP is empty."
            exit 1
          fi

          if [ -z "$DOMAIN" ] || [ "$DOMAIN" = "N/A" ]; then
            DOMAIN="$INSTANCE_IP"
          fi

          echo "instance_ip=$INSTANCE_IP" >> "$GITHUB_OUTPUT"
          echo "domain=$DOMAIN" >> "$GITHUB_OUTPUT"

  deploy:
    if: github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success'
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment || 'production' }}
    needs: get-infrastructure-info
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha || github.sha }}

      - name: Resolve image variables
        id: image-vars
        env:
          INPUT_REGISTRY: ${{ vars.REGISTRY || secrets.REGISTRY || 'ghcr.io' }}
          INPUT_IMAGE_NAME_RAW: ${{ vars.IMAGE_NAME || github.event.repository.name }}
          INPUT_COMMIT_SHA: ${{ github.event.workflow_run.head_sha || github.sha }}
          INPUT_IMAGE_TAG: ${{ inputs.image_tag || github.event.workflow_run.head_sha || github.sha }}
          INPUT_REPO_OWNER: ${{ github.repository_owner }}
        run: |
          REGISTRY="$INPUT_REGISTRY"
          IMAGE_NAME_RAW="$INPUT_IMAGE_NAME_RAW"
          COMMIT_SHA="$INPUT_COMMIT_SHA"
          IMAGE_TAG="$INPUT_IMAGE_TAG"

          if [[ "$IMAGE_NAME_RAW" != */* ]]; then
            IMAGE_NAME="${INPUT_REPO_OWNER}/$IMAGE_NAME_RAW"
          else
            IMAGE_NAME="$IMAGE_NAME_RAW"
          fi

          echo "registry=$REGISTRY" >> "$GITHUB_OUTPUT"
          echo "image_name=$IMAGE_NAME" >> "$GITHUB_OUTPUT"
          echo "commit_sha=$COMMIT_SHA" >> "$GITHUB_OUTPUT"
          echo "image_tag=$IMAGE_TAG" >> "$GITHUB_OUTPUT"

      - name: Download CI deployment image artifact
        if: github.event_name == 'workflow_run'
        uses: actions/download-artifact@v4
        with:
          name: deployment-images
          path: .deploy-image/
          run-id: ${{ github.event.workflow_run.id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true

      - name: Resolve deployment image references
        id: image-refs
        env:
          IMAGE_REGISTRY: ${{ steps.image-vars.outputs.registry }}
          IMAGE_NAME: ${{ steps.image-vars.outputs.image_name }}
          IMAGE_TAG: ${{ steps.image-vars.outputs.image_tag }}
        run: |
          ARTIFACT_FILE=".deploy-image/deployment-images.json"
          DEFAULT_API_IMAGE="${IMAGE_REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG}-api"
          DEFAULT_WEB_IMAGE="${IMAGE_REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG}-web"

          if [ -f "$ARTIFACT_FILE" ]; then
            API_IMAGE=$(jq -r '.api_image // empty' "$ARTIFACT_FILE")
            WEB_IMAGE=$(jq -r '.web_image // empty' "$ARTIFACT_FILE")
            SOURCE="ci-artifact"
          else
            API_IMAGE="$DEFAULT_API_IMAGE"
            WEB_IMAGE="$DEFAULT_WEB_IMAGE"
            SOURCE="fallback-tag"
          fi

          if [ -z "$API_IMAGE" ] || [ -z "$WEB_IMAGE" ]; then
            echo "Could not resolve image references."
            exit 1
          fi

          echo "api_image=$API_IMAGE" >> "$GITHUB_OUTPUT"
          echo "web_image=$WEB_IMAGE" >> "$GITHUB_OUTPUT"
          echo "source=$SOURCE" >> "$GITHUB_OUTPUT"

      - name: Prepare SSH key for deployment
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          INSTANCE_IP: ${{ needs.get-infrastructure-info.outputs.instance_ip }}
        run: |
          mkdir -p ~/.ssh
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H "$INSTANCE_IP" >> ~/.ssh/known_hosts

      - name: Deploy to Server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ needs.get-infrastructure-info.outputs.instance_ip }}
          username: ${{ vars.SSH_USERNAME || secrets.SERVER_USER || 'root' }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ vars.SSH_PORT || secrets.SERVER_PORT || 22 }}
          script: |
            export DEPLOY_ENV="${{ inputs.environment || 'production' }}"
            export DOMAIN="${{ needs.get-infrastructure-info.outputs.domain }}"
            export APP_NAME_INPUT="${{ inputs.app_name || 'abe-stack' }}"
            export DEPLOY_COMMIT_SHA="${{ steps.image-vars.outputs.commit_sha }}"
            export API_IMAGE="${{ steps.image-refs.outputs.api_image }}"
            export WEB_IMAGE="${{ steps.image-refs.outputs.web_image }}"

            APP_NAME=$(echo "$APP_NAME_INPUT" | tr '[:upper:]' '[:lower:]' | tr -cs 'a-z0-9-' '-' | sed 's/^-//; s/-$//')
            if [ -z "$APP_NAME" ]; then
              APP_NAME="abe-stack"
            fi

            export APP_NAME
            export COMPOSE_PROJECT_NAME="${APP_NAME}-${DEPLOY_ENV}"
            DEPLOY_ROOT="$HOME/deployments/$APP_NAME/$DEPLOY_ENV"
            mkdir -p "$DEPLOY_ROOT"
            cd "$DEPLOY_ROOT"

            curl -sSL "https://raw.githubusercontent.com/${{ github.repository }}/\${DEPLOY_COMMIT_SHA}/infra/docker/production/docker-compose.prod.yml" -o docker-compose.prod.yml
            curl -sSL "https://raw.githubusercontent.com/${{ github.repository }}/\${DEPLOY_COMMIT_SHA}/infra/runtime/caddy/Caddyfile" -o Caddyfile

            cat > ".env" << EOF
            APP_NAME=\${APP_NAME}
            COMPOSE_PROJECT_NAME=\${COMPOSE_PROJECT_NAME}
            DOMAIN=\${DOMAIN}
            ACME_EMAIL=${{ secrets.ACME_EMAIL }}
            POSTGRES_PASSWORD=${{ secrets.DB_PASSWORD || secrets.POSTGRES_PASSWORD }}
            POSTGRES_DB=abe_stack
            POSTGRES_USER=postgres
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            SESSION_SECRET=${{ secrets.SESSION_SECRET }}
            TRUST_PROXY=true
            TRUSTED_PROXIES=172.16.0.0/12,10.0.0.0/8
            MAX_PROXY_DEPTH=1
            STORAGE_PROVIDER=local
            STORAGE_LOCAL_PATH=/app/uploads
            STORAGE_LOCAL_PUBLIC_URL=/uploads
            EMAIL_PROVIDER=console
            EMAIL_FROM_NAME=ABE Stack
            EMAIL_FROM_ADDRESS=noreply@\${DOMAIN}
            EOF

            sed -i '/^name:/d' docker-compose.prod.yml
            sed -i '/container_name:/d' docker-compose.prod.yml
            sed -i '/^[[:space:]]\{2,\}name:[[:space:]]/d' docker-compose.prod.yml
            sed -i 's|../caddy/Caddyfile:|./Caddyfile:|g' docker-compose.prod.yml

            awk '
              BEGIN { skip = 0 }
              /^    env_file:$/ { skip = 1; next }
              skip == 1 && /^      - / { next }
              skip == 1 { skip = 0 }
              { print }
            ' docker-compose.prod.yml > docker-compose.prod.tmp && mv docker-compose.prod.tmp docker-compose.prod.yml

            awk -v api="$API_IMAGE" -v web="$WEB_IMAGE" '
              BEGIN { in_api=0; in_web=0; in_build=0 }
              /^  api:$/ { in_api=1; in_web=0; print; next }
              /^  web:$/ { in_web=1; in_api=0; print; next }
              /^  [a-zA-Z0-9_-]+:$/ { in_api=0; in_web=0 }
              (in_api || in_web) && /^    build:$/ {
                in_build=1
                if (in_api) print "    image: " api
                if (in_web) print "    image: " web
                next
              }
              in_build && /^      / { next }
              in_build && !/^      / { in_build=0 }
              (in_api || in_web) && /^      VITE_API_URL:/ { next }
              { print }
            ' docker-compose.prod.yml > docker-compose.prod.tmp && mv docker-compose.prod.tmp docker-compose.prod.yml

            docker compose --project-name "$COMPOSE_PROJECT_NAME" -f docker-compose.prod.yml down --timeout 30 || true
            docker pull "$API_IMAGE"
            docker pull "$WEB_IMAGE"
            docker compose --project-name "$COMPOSE_PROJECT_NAME" -f docker-compose.prod.yml up -d

            timeout=600
            elapsed=0
            while [ "$elapsed" -lt "$timeout" ]; do
              healthy_count=$(docker compose --project-name "$COMPOSE_PROJECT_NAME" -f docker-compose.prod.yml ps | grep -c "healthy")
              total_services=$(docker compose --project-name "$COMPOSE_PROJECT_NAME" -f docker-compose.prod.yml ps | grep -c "Up")
              if [ "$healthy_count" -eq "$total_services" ] && [ "$total_services" -gt 0 ]; then
                break
              fi
              sleep 10
              elapsed=$((elapsed + 10))
            done

            if [ "$elapsed" -ge "$timeout" ]; then
              docker compose --project-name "$COMPOSE_PROJECT_NAME" -f docker-compose.prod.yml logs
              exit 1
            fi

      - name: Verify Deployment
        env:
          DEPLOY_DOMAIN: ${{ needs.get-infrastructure-info.outputs.domain }}
        run: |
          TARGET="$DEPLOY_DOMAIN"
          HTTPS_URL="https://$TARGET/health"
          HTTP_URL="http://$TARGET/health"
          sleep 10
          if curl -f -s "$HTTPS_URL" >/dev/null; then
            exit 0
          fi
          curl -f -s "$HTTP_URL" >/dev/null

      - name: Deployment Summary
        env:
          DEPLOY_ENV: ${{ inputs.environment || 'production' }}
          APP_NAME: ${{ inputs.app_name || 'abe-stack' }}
          IMAGE_SOURCE: ${{ steps.image-refs.outputs.source }}
          API_IMAGE: ${{ steps.image-refs.outputs.api_image }}
          WEB_IMAGE: ${{ steps.image-refs.outputs.web_image }}
          DEPLOY_DOMAIN: ${{ needs.get-infrastructure-info.outputs.domain }}
        run: |
          echo "## Deployment Completed Successfully" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "**Environment:** $DEPLOY_ENV" >> "$GITHUB_STEP_SUMMARY"
          echo "**App Name:** $APP_NAME" >> "$GITHUB_STEP_SUMMARY"
          echo "**Image Source:** $IMAGE_SOURCE" >> "$GITHUB_STEP_SUMMARY"
          echo "**API Image:** \`$API_IMAGE\`" >> "$GITHUB_STEP_SUMMARY"
          echo "**Web Image:** \`$WEB_IMAGE\`" >> "$GITHUB_STEP_SUMMARY"
          echo "**Domain:** https://$DEPLOY_DOMAIN" >> "$GITHUB_STEP_SUMMARY"

  smoke-test:
    needs: [get-infrastructure-info, deploy]
    runs-on: ubuntu-latest
    steps:
      - name: Wait for deployment to stabilize
        run: sleep 30

      - name: Health check
        env:
          DEPLOY_DOMAIN: ${{ needs.get-infrastructure-info.outputs.domain }}
        run: |
          DOMAIN="$DEPLOY_DOMAIN"
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://${DOMAIN}/api/health" || echo "000")
          if [ "$STATUS" != "200" ]; then
            echo "Health check failed with status: $STATUS"
            exit 1
          fi
          echo "Health check passed (200 OK)"
