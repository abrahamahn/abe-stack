name: Deploy to Infrastructure

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      provider:
        description: 'Cloud provider where infrastructure is deployed'
        required: true
        default: 'digitalocean'
        type: choice
        options:
          - digitalocean
          - gcp
      image_tag:
        description: 'Docker image tag to deploy (leave empty for latest commit SHA)'
        required: false
        type: string
      app_name:
        description: 'Application slug used to isolate deployment resources (e.g., portfolio-api)'
        required: false
        default: 'abe-stack'
        type: string
      instance_ip:
        description: 'Optional target server IP (used if deployment artifact is unavailable)'
        required: false
        type: string
      domain:
        description: 'Optional domain override (used if deployment artifact is unavailable)'
        required: false
        type: string

permissions:
  contents: read
  packages: write

jobs:
  get-infrastructure-info:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment || 'staging' }}
    outputs:
      instance_ip: ${{ steps.get-deployment-info.outputs.instance_ip }}
      ssh_connection: ${{ steps.get-deployment-info.outputs.ssh_connection }}
      domain: ${{ steps.get-deployment-info.outputs.domain }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download Deployment Info
        uses: actions/download-artifact@v4
        with:
          name: deployment-info-${{ inputs.environment }}-${{ inputs.provider }}
          path: .deploy/
        continue-on-error: true
      - name: Extract Infrastructure Information
        id: get-deployment-info
        run: |
          DEPLOY_FILE=".deploy/${{ inputs.environment }}-${{ inputs.provider }}.json"
          MANUAL_INSTANCE_IP="${{ inputs.instance_ip || vars.INSTANCE_IP || vars.DEPLOY_HOST || '' }}"
          MANUAL_DOMAIN="${{ inputs.domain || vars.DOMAIN || '' }}"

          if [ -f "$DEPLOY_FILE" ]; then
            echo "ðŸ“‹ Found deployment info for ${{ inputs.environment }} on ${{ inputs.provider }}"
            INFO_SOURCE="artifact"

            INSTANCE_IP=$(jq -r '.instance_ip // empty' "$DEPLOY_FILE")
            SSH_CONNECTION=$(jq -r '.ssh_connection // empty' "$DEPLOY_FILE")
            DOMAIN=$(jq -r '.domain // empty' "$DEPLOY_FILE")
          elif [ -n "$MANUAL_INSTANCE_IP" ]; then
            echo "âš ï¸ Deployment artifact not found. Falling back to manual instance IP."
            INFO_SOURCE="manual"

            INSTANCE_IP="$MANUAL_INSTANCE_IP"
            SSH_CONNECTION="ssh ${{ vars.SSH_USERNAME || 'root' }}@$MANUAL_INSTANCE_IP"
            DOMAIN="$MANUAL_DOMAIN"
          else
            echo "âŒ Deployment info not found for ${{ inputs.environment }} on ${{ inputs.provider }}."
            echo "Provide workflow input 'instance_ip' (or repository variable INSTANCE_IP/DEPLOY_HOST),"
            echo "or run 'Infrastructure Deploy' first to generate deployment-info artifact."
            exit 1
          fi

          if [ -z "$INSTANCE_IP" ] || [ "$INSTANCE_IP" = "N/A" ]; then
            echo "âŒ Instance IP is empty."
            exit 1
          fi

          if [ -z "$DOMAIN" ] || [ "$DOMAIN" = "N/A" ]; then
            DOMAIN="$INSTANCE_IP"
          fi

          echo "instance_ip=$INSTANCE_IP" >> $GITHUB_OUTPUT
          echo "ssh_connection=$SSH_CONNECTION" >> $GITHUB_OUTPUT
          echo "domain=$DOMAIN" >> $GITHUB_OUTPUT

          echo "## ðŸš€ Target Infrastructure" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Provider:** ${{ inputs.provider }}" >> $GITHUB_STEP_SUMMARY
          echo "**Info Source:** $INFO_SOURCE" >> $GITHUB_STEP_SUMMARY
          echo "**Instance IP:** $INSTANCE_IP" >> $GITHUB_STEP_SUMMARY
          echo "**Domain:** $DOMAIN" >> $GITHUB_STEP_SUMMARY
          echo "**SSH:** \`$SSH_CONNECTION\`" >> $GITHUB_STEP_SUMMARY

  build-and-deploy:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment || 'staging' }}
    needs: get-infrastructure-info

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.26.2

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: pnpm

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Check configuration
        run: pnpm config:generate:check

      - name: Check file headers
        run: pnpm sync:headers:check

      - name: Cache Turbo
        uses: actions/cache@v4
        with:
          path: .cache/turbo
          key: ${{ runner.os }}-turbo-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-turbo-

      - name: Run build and verification pipeline
        run: pnpm build

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ vars.REGISTRY }}
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ vars.REGISTRY }}/${{ vars.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=tag
            type=raw,value=${{ inputs.image_tag || github.sha }}
            type=raw,value=deploy-${{ inputs.environment }}

      - name: Build and push API Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./infra/docker/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}-api
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push Web Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./infra/docker/Dockerfile.web
          push: true
          tags: ${{ steps.meta.outputs.tags }}-web
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            VITE_API_URL=
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Prepare SSH key for deployment
        run: |
          # Create SSH key file from secret
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ needs.get-infrastructure-info.outputs.instance_ip }} >> ~/.ssh/known_hosts

      - name: Deploy to Infrastructure
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ needs.get-infrastructure-info.outputs.instance_ip }}
          username: ${{ vars.SSH_USERNAME || 'root' }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ vars.SSH_PORT || 22 }}
          script: |
            # Set deployment environment variables
            export DEPLOY_ENV="${{ inputs.environment }}"
            export IMAGE_TAG="${{ inputs.image_tag || github.sha }}"
            export REGISTRY="${{ vars.REGISTRY }}"
            export IMAGE_NAME="${{ vars.IMAGE_NAME }}"
            export DOMAIN="${{ needs.get-infrastructure-info.outputs.domain }}"
            export APP_NAME_INPUT="${{ inputs.app_name || 'abe-stack' }}"

            # Normalize app name for filesystem/compose project safety
            APP_NAME=$(echo "$APP_NAME_INPUT" | tr '[:upper:]' '[:lower:]' | tr -cs 'a-z0-9-' '-' | sed 's/^-//; s/-$//')
            if [ -z "$APP_NAME" ]; then
              APP_NAME="abe-stack"
            fi
            export APP_NAME
            export COMPOSE_PROJECT_NAME="${APP_NAME}-${DEPLOY_ENV}"

            # Create deployment directory if it doesn't exist
            DEPLOY_ROOT="$HOME/deployments/$APP_NAME/$DEPLOY_ENV"
            mkdir -p "$DEPLOY_ROOT"

            # Navigate to deployment directory
            cd "$DEPLOY_ROOT"

            echo "ðŸš€ Starting deployment of $APP_NAME:$IMAGE_TAG to $DEPLOY_ENV environment..."

            # Download docker-compose.prod.yml
            echo "ðŸ“¦ Downloading production docker-compose file..."
            curl -sSL "https://raw.githubusercontent.com/${{ github.repository }}/${{ github.sha }}/infra/docker/production/docker-compose.prod.yml" -o docker-compose.prod.yml

            # Download Caddyfile
            echo "ðŸ” Downloading Caddyfile..."
            curl -sSL "https://raw.githubusercontent.com/${{ github.repository }}/${{ github.sha }}/infra/runtime/caddy/Caddyfile" -o Caddyfile

            # Create environment file
            echo "âš™ï¸ Creating environment configuration..."
            cat > ".env" << EOF
            # Deployment metadata
            APP_NAME=\${APP_NAME}
            COMPOSE_PROJECT_NAME=\${COMPOSE_PROJECT_NAME}

            # Domain Configuration
            DOMAIN=\${DOMAIN}
            ACME_EMAIL=${{ secrets.ACME_EMAIL }}

            # Database Secrets
            POSTGRES_PASSWORD=${{ secrets.DB_PASSWORD }}
            POSTGRES_DB=abe_stack
            POSTGRES_USER=postgres

            # Application Secrets
            JWT_SECRET=${{ secrets.JWT_SECRET }}
            SESSION_SECRET=${{ secrets.SESSION_SECRET }}

            # Trust Proxy (for correct IP extraction)
            TRUST_PROXY=true
            TRUSTED_PROXIES=172.16.0.0/12,10.0.0.0/8
            MAX_PROXY_DEPTH=1

            # Storage Configuration
            STORAGE_PROVIDER=local
            STORAGE_LOCAL_PATH=/app/uploads
            STORAGE_LOCAL_PUBLIC_URL=/uploads

            # Email Configuration (disabled for now)
            EMAIL_PROVIDER=console
            EMAIL_FROM_NAME=ABE Stack
            EMAIL_FROM_ADDRESS=noreply@\${DOMAIN}
            EOF

            # Make compose file reusable for namespaced multi-app deploys
            # - Remove hardcoded project/container/volume names that collide
            # - Use local Caddyfile path in deployment directory
            sed -i '/^name:/d' docker-compose.prod.yml
            sed -i '/container_name:/d' docker-compose.prod.yml
            sed -i '/^[[:space:]]\{2,\}name:[[:space:]]/d' docker-compose.prod.yml
            sed -i 's|../caddy/Caddyfile:|./Caddyfile:|g' docker-compose.prod.yml

            # Optional env_file paths in source compose are repo-specific and not valid on target host
            awk '
              BEGIN { skip = 0 }
              /^    env_file:$/ { skip = 1; next }
              skip == 1 && /^      - / { next }
              skip == 1 { skip = 0 }
              { print }
            ' docker-compose.prod.yml > docker-compose.prod.tmp && mv docker-compose.prod.tmp docker-compose.prod.yml

            # Update docker-compose to use deployed images
            echo "ðŸ³ Updating docker-compose with deployed images..."
            awk -v reg="$REGISTRY" -v img="$IMAGE_NAME" -v tag="$IMAGE_TAG" '
              BEGIN { in_api=0; in_web=0; in_build=0 }
              /^  api:$/ { in_api=1; in_web=0; print; next }
              /^  web:$/ { in_web=1; in_api=0; print; next }
              /^  [a-zA-Z0-9_-]+:$/ { in_api=0; in_web=0 }
              (in_api || in_web) && /^    build:$/ {
                in_build=1
                if (in_api) print "    image: " reg "/" img ":" tag "-api"
                if (in_web) print "    image: " reg "/" img ":" tag "-web"
                next
              }
              in_build && /^      / { next }
              in_build && !/^      / { in_build=0 }
              (in_api || in_web) && /^      VITE_API_URL:/ { next }
              { print }
            ' docker-compose.prod.yml > docker-compose.prod.tmp && mv docker-compose.prod.tmp docker-compose.prod.yml

            # Stop existing containers gracefully
            echo "ðŸ›‘ Stopping existing containers..."
            docker compose --project-name "$COMPOSE_PROJECT_NAME" -f docker-compose.prod.yml down --timeout 30 || true

            # Pull latest images
            echo "ðŸ“¥ Pulling latest Docker images..."
            docker pull \${REGISTRY}/\${IMAGE_NAME}:\${IMAGE_TAG}-api
            docker pull \${REGISTRY}/\${IMAGE_NAME}:\${IMAGE_TAG}-web

            # Start new containers
            echo "ðŸš€ Starting new containers..."
            docker compose --project-name "$COMPOSE_PROJECT_NAME" -f docker-compose.prod.yml up -d

            # Wait for services to be healthy
            echo "ðŸ¥ Waiting for services to be healthy..."
            timeout=600
            elapsed=0

            while [ \$elapsed -lt \$timeout ]; do
              healthy_count=\$(docker compose --project-name "$COMPOSE_PROJECT_NAME" -f docker-compose.prod.yml ps | grep -c "healthy")
              total_services=\$(docker compose --project-name "$COMPOSE_PROJECT_NAME" -f docker-compose.prod.yml ps | grep -c "Up")

              if [ "\$healthy_count" -eq "\$total_services" ] && [ "\$total_services" -gt 0 ]; then
                echo "âœ… All \$total_services services are healthy!"
                break
              fi

              echo "â³ Waiting... (\$healthy_count/\$total_services services healthy, \$elapsed/\$timeout seconds)"
              sleep 10
              elapsed=\$((elapsed + 10))
            done

            if [ \$elapsed -ge \$timeout ]; then
              echo "âŒ Timeout waiting for services to be healthy"
              docker compose --project-name "$COMPOSE_PROJECT_NAME" -f docker-compose.prod.yml logs
              echo "ðŸ”„ Attempting rollback..."
              # TODO: Implement rollback to previous version
              exit 1
            fi

            # Clean up old images
            echo "ðŸ§¹ Cleaning up old Docker images..."
            docker image prune -f

            echo "ðŸŽ‰ Deployment completed successfully!"
            echo "ðŸŒ Application is available at: https://\${DOMAIN}"
            echo "ðŸ§© Compose project: \${COMPOSE_PROJECT_NAME}"
            echo "ðŸ“ Deploy path: \${DEPLOY_ROOT}"
            echo "ðŸ“Š Deployment summary:"
            docker compose --project-name "$COMPOSE_PROJECT_NAME" -f docker-compose.prod.yml ps

      - name: Verify Deployment
        run: |
          echo "ðŸ” Verifying deployment..."
          TARGET="${{ needs.get-infrastructure-info.outputs.domain }}"
          HEALTH_URL="https://$TARGET/health"

          # Wait a moment for DNS propagation if needed
          sleep 10

          # Test health endpoint
          if curl -f -s "$HEALTH_URL" > /dev/null; then
            echo "âœ… Application health check passed"
          else
            FALLBACK_URL="http://$TARGET/health"
            if curl -f -s "$FALLBACK_URL" > /dev/null; then
              echo "âœ… Application health check passed over HTTP fallback"
            else
              echo "âš ï¸ Health check failed on both HTTPS and HTTP"
            fi
          fi

      - name: Deployment Summary
        run: |
          echo "## ðŸŽ‰ Deployment Completed Successfully!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ inputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Provider:** ${{ inputs.provider }}" >> $GITHUB_STEP_SUMMARY
          echo "**App Name:** ${{ inputs.app_name || 'abe-stack' }}" >> $GITHUB_STEP_SUMMARY
          echo "**Domain:** https://${{ needs.get-infrastructure-info.outputs.domain }}" >> $GITHUB_STEP_SUMMARY
          echo "**Image Tag:** ${{ inputs.image_tag || github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deployed at:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ”— Quick Links" >> $GITHUB_STEP_SUMMARY
          echo "- **Application:** https://${{ needs.get-infrastructure-info.outputs.domain }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Health Check:** https://${{ needs.get-infrastructure-info.outputs.domain }}/health" >> $GITHUB_STEP_SUMMARY
          echo "- **API Docs:** https://${{ needs.get-infrastructure-info.outputs.domain }}/api/docs" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“Š Deployment Status" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Infrastructure: Deployed" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Docker Images: Built & Pushed" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Application: Deployed & Running" >> $GITHUB_STEP_SUMMARY
