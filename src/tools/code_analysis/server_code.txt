SERVER DIRECTORY SUMMARY
================================================================================
Total Files: 111
Total Lines: 14867
================================================================================

DIRECTORY STRUCTURE:
--------------------------------------------------------------------------------
├── apis
│   ├── auth.ts
│   ├── autoindex.ts
│   ├── hello.ts
│   └── media.ts
├── config
│   ├── database.ts
│   ├── email.ts
│   ├── environment.ts
│   └── serverConfig.ts
├── controllers
│   ├── AuthController.ts
│   ├── media.controller.ts
│   ├── post.controller.ts
│   ├── social.controller.ts
│   └── stream.controller.ts
├── database
│   ├── migrations
│   │   ├── 001_create_users_table.sql
│   │   ├── 002_create_artists_table.sql
│   │   ├── 003_create_albums_table.sql
│   │   ├── 004_create_tracks_table.sql
│   │   ├── 005_create_playlists_table.sql
│   │   ├── 006_create_playlist_tracks_table.sql
│   │   ├── 007_create_social_tables.sql
│   │   ├── 008_add_email_verification.sql
│   │   └── 008_update_users_table.sql
│   ├── BaseRepository.ts
│   ├── config.ts
│   ├── migrationConfig.ts
│   ├── migrationManager.ts
│   └── transactionManager.ts
├── errors
│   └── UnauthorizedError.ts
├── helpers
│   ├── fileHelpers.ts
│   ├── loginHelpers.ts
│   ├── path.ts
│   └── signatureHelpers.ts
├── lib
│   ├── database.ts
│   └── storage.ts
├── middleware
│   ├── auth.ts
│   ├── authenticateJWT.ts
│   ├── customValidate.ts
│   ├── error.ts
│   ├── errorHandler.ts
│   ├── logger.ts
│   ├── notFound.ts
│   ├── rateLimiter.ts
│   ├── upload.ts
│   └── validate.ts
├── models
│   ├── Album.ts
│   ├── Artist.ts
│   ├── associations.ts
│   ├── Comment.ts
│   ├── CommentLike.ts
│   ├── Follow.ts
│   ├── index.ts
│   ├── Like.ts
│   ├── Media.ts
│   ├── Playlist.ts
│   ├── PlaylistTrack.ts
│   ├── Post.ts
│   ├── Track.ts
│   ├── TwoFactorAuth.ts
│   └── User.ts
├── routes
│   ├── admin.ts
│   ├── auth.ts
│   ├── comments.ts
│   ├── index.ts
│   ├── media.ts
│   ├── moderator.ts
│   ├── social.ts
│   └── users.ts
├── scripts
│   ├── checkUsers.ts
│   ├── createMigration.ts
│   ├── resetMigration.ts
│   ├── runMigration.ts
│   ├── seedDemoDatabase.ts
│   ├── testRegistration.ts
│   └── undoMigration.ts
├── services
│   ├── media
│   │   ├── AudioProcessor.ts
│   │   ├── BaseMediaProcessor.ts
│   │   ├── ImageProcessor.ts
│   │   ├── index.ts
│   │   ├── MediaProcessingService.ts
│   │   └── VideoProcessor.ts
│   ├── AuthService.ts
│   ├── AuthTokenService.ts
│   ├── Database.ts
│   ├── EmailService.ts
│   ├── InMemoryQueue.ts
│   ├── LoggerService.ts
│   ├── MediaService.ts
│   ├── QueueDatabase.ts
│   ├── QueueService.ts
│   ├── ServerConfig.ts
│   ├── ServerEnvironment.ts
│   └── WebsocketPubsubServer.ts
├── tasks
│   ├── autoindex.ts
│   └── followup.ts
├── types
│   ├── express.d.ts
│   ├── index.ts
│   ├── media.types.ts
│   └── request.types.ts
├── utils
│   └── validation.ts
├── validators
│   ├── auth.validator.ts
│   ├── custom-social.validator.ts
│   └── social.validator.ts
├── api.ts
├── ApiServer.ts
├── FileServer.ts
├── index.ts
├── PubsubServer.ts
├── QueueServer.ts
├── server.ts
├── tasks.ts
└── types.ts
================================================================================


================================================================================
File: api.ts
Lines: 3
--------------------------------------------------------------------------------
import * as api from "./apis/autoindex"

export { api }

================================================================================
File: ApiServer.ts
Lines: 90
--------------------------------------------------------------------------------
// src/server/ApiServer.ts
import type { Options, OptionsUrlencoded } from 'body-parser';
import compression from 'compression';
import cookieParser from 'cookie-parser';
import cors from 'cors';
import express, { Express, RequestHandler } from 'express';
import helmet from 'helmet';

import { NotFoundError } from '../shared/errors/ApiError';

import { env } from './config/environment';
import { path } from './helpers/path';
import { errorHandler } from './middleware/errorHandler';
import { requestLogger, detailedLogger } from './middleware/logger';
import apiRoutes from './routes';
import { ServerEnvironment } from './services/ServerEnvironment';

const expressApp = express as unknown as {
  (): Express;
  json: (options?: Options) => RequestHandler;
  urlencoded: (options?: OptionsUrlencoded) => RequestHandler;
  static: (path: string) => RequestHandler;
};

const jsonParser = expressApp.json({ limit: '10mb' });
const urlencodedParser = expressApp.urlencoded({ extended: true, limit: '10mb' });

export function ApiServer(_environment: ServerEnvironment, app: Express) {
  // Security middlewares - disable in development for easier debugging
  if (env.NODE_ENV === 'production') {
    app.use(helmet as unknown as () => RequestHandler);
  }
  
  // Add CORS middleware specifically for API routes
  app.use(cors({
    origin: '*', // Allow all origins in development
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'PATCH'],
    allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'Accept'],
    credentials: true,
    preflightContinue: false,
    optionsSuccessStatus: 204
  }) as RequestHandler);
  
  // Request parsing middleware
  app.use(jsonParser);
  app.use(urlencodedParser);
  app.use(cookieParser() as RequestHandler);
  
  // Compression for better performance
  app.use(compression());
  
  // Logging middleware
  app.use(requestLogger);
  if (env.NODE_ENV === 'development') {
    app.use(detailedLogger);
  }
  
  // Serve static assets
  if (env.NODE_ENV === 'production') {
    app.use(expressApp.static(path('build')));
    app.use('/uploads', expressApp.static(path('uploads')));
  }
  
  // API routes
  app.use('/api', apiRoutes as RequestHandler);
  
  // Fallback to HTML for client-side routing in production only
  if (env.NODE_ENV === 'production') {
    const handler: RequestHandler = (req, res, next) => {
      // Skip API routes (they should have been handled by now)
      const url = req.originalUrl as string;
      if (url.startsWith('/api')) {
        return next(new NotFoundError('API endpoint not found'));
      }
      
      // Serve the SPA index.html
      (res.sendFile as (path: string) => void)(path('build/index.html'));
    };
    app.use('*', handler);
  } else {
    // In development, only handle API 404s
    const handler: RequestHandler = (_req, _res, next) => {
      next(new NotFoundError('API endpoint not found'));
    };
    app.use('/api/*', handler);
  }
  
  // Error handling middleware (must be last)
  app.use(errorHandler);
}
================================================================================
File: FileServer.ts
Lines: 211
--------------------------------------------------------------------------------
import fs, { promises as fsPromises } from 'fs';
import path from 'path';

import express, { Application, Request, Response, NextFunction, RequestHandler } from 'express';

import { DayS } from "../shared/dateHelpers";

import { FileSignatureData } from "./helpers/fileHelpers";
import { verifySignature } from "./helpers/signatureHelpers";
import { ServerConfig } from "./services/ServerConfig";

// Define interfaces for typed requests
interface FileParams {
  id: string;
  filename: string;
  [key: string]: string; // Add index signature for compatibility with ParamsDictionary
}

interface FileQueryParams {
  expiration: string;
  signature: string;
  [key: string]: string; // Add index signature for compatibility with ParsedQs
}

interface FileUploadResponse {
  message: string;
  path?: string;
}

/**
 * Type guard for the file request
 */
function isValidFileRequest(
  req: unknown
): req is Request<FileParams, unknown, unknown, FileQueryParams> {
  if (!req || typeof req !== 'object') return false;
  const typedReq = req as { params?: unknown; query?: unknown };
  
  if (!typedReq.params || !typedReq.query || typeof typedReq.params !== 'object' || typeof typedReq.query !== 'object') {
    return false;
  }
  
  const params = typedReq.params as { id?: unknown; filename?: unknown };
  const query = typedReq.query as { expiration?: unknown; signature?: unknown };
  
  return (
    typeof params.id === 'string' &&
    typeof params.filename === 'string' &&
    typeof query.expiration === 'string' &&
    typeof query.signature === 'string'
  );
}

/**
 * Verify the authenticity and validity of the request
 */
function verifyRequest(
  config: ServerConfig,
  req: Request<FileParams, unknown, unknown, FileQueryParams>,
  res: Response
): boolean {
  const typedReq = req as unknown as { params: FileParams; query: FileQueryParams; method: string };
  
  if (!isValidFileRequest(req)) {
    res.status(400).json({ message: "Invalid request parameters" });
    return false;
  }

  const id = typedReq.params.id;
  const filename = typedReq.params.filename;
  const expiration = typedReq.query.expiration;
  const signature = typedReq.query.signature;
  
  // Validate expiration
  const expirationMs = parseInt(expiration, 10);
  if (isNaN(expirationMs)) {
    res.status(400).json({ message: "Invalid expiration format." });
    return false;
  }
  
  const now = Date.now();
  if (expirationMs < now) {
    res.status(400).json({ message: "Request has expired." });
    return false;
  }
  
  // Validate signature
  if (!signature) {
    res.status(400).json({ message: "Missing signature parameter." });
    return false;
  }
  
  const method = typedReq.method.toLowerCase().trim() as "get" | "put";
  const data: FileSignatureData = { 
    method, 
    id, 
    filename, 
    expirationMs 
  };
  
  const secretKey = config.signatureSecret;
  const validSignature = verifySignature({ 
    data, 
    signature, 
    secretKey 
  });
  
  if (!validSignature) {
    res.status(400).json({ message: "Invalid signature." });
    return false;
  }
  
  return true;
}

/**
 * Middleware to validate file requests
 */
function validateFileRequest(
  config: ServerConfig
): RequestHandler {
  return (req: Request, res: Response, next: NextFunction): void => {
    if (!isValidFileRequest(req as Request<FileParams, unknown, unknown, FileQueryParams>)) {
      res.status(400).json({ message: "Invalid request parameters." });
      return;
    }
    
    if (!verifyRequest(config, req as Request<FileParams, unknown, unknown, FileQueryParams>, res)) {
      return; // Response is already sent in verifyRequest
    }
    
    next();
  };
}

/**
 * Setup file server routes for uploading and retrieving files
 */
export function FileServer(environment: { config: ServerConfig }, app: Application): void {
  const uploadDir = path.resolve("uploads");
  fs.mkdirSync(uploadDir, { recursive: true });
  
  const MB = 1024 * 1024;
  const typedApp = app as unknown as { 
    put: (path: string, ...handlers: RequestHandler[]) => void;
    get: (path: string, ...handlers: RequestHandler[]) => void;
  };
  
  // File upload endpoint
  typedApp.put(
    '/uploads/:id/:filename',
    (express.raw as unknown as (options: { limit: number; type: string }) => RequestHandler)({ limit: 100 * MB, type: "*/*" }),
    validateFileRequest(environment.config),
    async (req: Request, res: Response): Promise<void> => {
      if (!isValidFileRequest(req as Request<FileParams, unknown, unknown, FileQueryParams>)) {
        res.status(400).json({ message: "Invalid request parameters" });
        return;
      }
      
      // Type-safe assignments after validation
      const id = (req.params as FileParams).id;
      const filename = (req.params as FileParams).filename;
      
      const fileDir = path.join(uploadDir, id);
      const filePath = path.join(fileDir, filename);
      
      try {
        await fsPromises.mkdir(fileDir, { recursive: true });
        await fsPromises.writeFile(filePath, req.body as Buffer);
        res.status(200).json({ 
          message: "File uploaded successfully", 
          path: filePath 
        } as FileUploadResponse);
      } catch (err) {
        const error = err as Error;
        res.status(500).json({ 
          message: `Upload failed: ${error.message}` 
        } as FileUploadResponse);
      }
    }
  );
  
  // File retrieval endpoint
  typedApp.get(
    '/uploads/:id/:filename',
    validateFileRequest(environment.config),
    async (req: Request, res: Response & { setHeader: (name: string, value: string) => void; sendFile: (path: string) => void }): Promise<void> => {
      if (!isValidFileRequest(req as Request<FileParams, unknown, unknown, FileQueryParams>)) {
        res.status(400).json({ message: "Invalid request parameters" });
        return;
      }
      
      // Type-safe assignments after validation
      const params = req.params as FileParams;
      const id = params.id;
      const filename = params.filename;
      
      const fileDir = path.join(uploadDir, id);
      const filePath = path.join(fileDir, filename);
      
      try {
        await fsPromises.access(filePath, fs.constants.F_OK);
        const expiration = 60 * DayS;
        res.setHeader("Cache-Control", `private, max-age=${expiration}`);
        res.sendFile(filePath);
      } catch {
        res.status(404).json({ message: "File not found." });
      }
    }
  );
}

================================================================================
File: index.ts
Lines: 212
--------------------------------------------------------------------------------
// Load environment variables from .env file
import fs from 'fs';
import http from 'http';
import path from 'path';

import cookieParser from 'cookie-parser';
import cors, { CorsOptions } from 'cors';
import dotenv from 'dotenv';
import express, { Express, RequestHandler as ExpressHandler } from 'express';
import { Pool } from 'pg';
import { WebSocketServer } from 'ws';

import { DatabaseConnectionManager } from './database/config';

// Load environment-specific .env file
const NODE_ENV = process.env.NODE_ENV || 'development';
const envFile = `.env.${NODE_ENV}`;
const envPath = path.resolve(process.cwd(), envFile);

// First try to load environment-specific file, then fall back to .env
dotenv.config({ path: envPath });
dotenv.config({ path: path.resolve(process.cwd(), '.env') });

console.log(`Loading environment from ${envFile}`);

// Create Express app
const app: Express = express();
const server = http.createServer(app as unknown as http.RequestListener);

// Apply CORS middleware
const corsOptions: CorsOptions = {
  origin: '*',
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'PATCH'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'Accept'],
  credentials: true,
  preflightContinue: false,
  optionsSuccessStatus: 204
};

const corsMiddleware = cors(corsOptions) as ExpressHandler;
const jsonMiddleware = (express.json as () => ExpressHandler)();
const cookieMiddleware = cookieParser() as ExpressHandler;

app.use(corsMiddleware);
app.use(jsonMiddleware);
app.use(cookieMiddleware);

// Server configuration
const config = {
  port: parseInt(process.env.PORT || '8080'),
  dbConnectionString: process.env.DATABASE_URL || 'postgresql://postgres:postgres@localhost:5432/abe_stack',
  production: process.env.NODE_ENV === 'production',
  domain: process.env.DOMAIN || 'localhost',
  baseUrl: process.env.BASE_URL || 'http://localhost:8080',
  corsOrigin: process.env.CORS_ORIGIN || '*',
  corsOrigins: (process.env.CORS_ORIGIN || '*').split(','),
  jwtSecret: process.env.JWT_SECRET || 'your-secret-key',
  uploadDir: process.env.UPLOAD_DIR || path.join(process.cwd(), 'uploads'),
  queuePath: process.env.QUEUE_PATH || path.join(process.cwd(), 'queue'),
  signatureSecret: Buffer.from(process.env.SIGNATURE_SECRET || 'signature-secret-key'),
  passwordSalt: Buffer.from(process.env.PASSWORD_SALT || 'password-salt'),
  dbPath: process.env.DB_PATH || path.join(process.cwd(), 'db'),
  db: {
    host: process.env.DB_HOST || 'localhost',
    port: parseInt(process.env.DB_PORT || '5432'),
    database: process.env.DB_NAME || 'abe_stack',
    username: process.env.DB_USER || 'postgres',
    password: process.env.DB_PASSWORD || 'postgres'
  }
};

// Initialize DatabaseConnectionManager
void (async () => {
  try {
    await DatabaseConnectionManager.initialize();
    console.log('DatabaseConnectionManager initialized successfully');
  } catch (error) {
    console.error('Failed to initialize DatabaseConnectionManager:', error);
  }
})();

// Database connection
const dbConfig = new URL(config.dbConnectionString);
export const pool = new Pool({
  user: dbConfig.username,
  password: dbConfig.password,
  host: dbConfig.hostname,
  port: parseInt(dbConfig.port || '5432'),
  database: dbConfig.pathname.split('/')[1],
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : undefined
});

// WebSocket server
const wss = new WebSocketServer({ server });

// Type definition for WebSocket with proper methods
interface TypedWebSocket {
  send(data: string): void;
  on(event: string, listener: (...args: unknown[]) => void): this;
}

// Handle WebSocket connections
wss.on('connection', (ws, _req) => {
  const typedWs = ws as TypedWebSocket;
  console.log('WebSocket connection established');
  
  // Send a welcome message
  const welcomeMessage = JSON.stringify({ type: 'welcome', message: 'Connected to WebSocket server' });
  typedWs.send(welcomeMessage);
  
  // Handle messages
  typedWs.on('message', (...args) => {
    const messageData = args[0];
    if (!(messageData instanceof Buffer || typeof messageData === 'string')) return;
    
    try {
      const messageStr = messageData instanceof Buffer ? messageData.toString() : messageData;
      const data = JSON.parse(messageStr as string) as { type: string; [key: string]: unknown };
      
      // Handle different message types
      if (data.type === 'ping') {
        typedWs.send(JSON.stringify({ type: 'pong' }));
      } else {
        console.log('Received message:', data);
      }
    } catch (error) {
      if (error instanceof Error) {
        console.error('Error parsing WebSocket message:', error.message);
      } else {
        console.error('Error parsing WebSocket message:', error);
      }
      typedWs.send(JSON.stringify({ type: 'error', message: 'Invalid message format' }));
    }
  });
  
  // Handle close
  typedWs.on('close', () => {
    console.log('WebSocket connection closed');
  });
});

// Find an available port
function findAvailablePort(startPort: number): number {
  // This is a placeholder implementation since the actual implementation was removed
  // In a real scenario, you would implement port checking logic here
  return startPort;
}

// Start the server
void startServer();

async function startServer() {
  try {
    // Try to use port 8080 first, then fall back to other ports
    // We'll avoid port 5432 (PostgreSQL) and 3000-3005 (likely used by the client)
    const preferredPorts = [8080, 8081, 8082, 8083, 8084, 8085];
    let port = config.port;
    
    // Try each preferred port in order
    for (const preferredPort of preferredPorts) {
      try {
        const testServer = http.createServer();
        await new Promise<void>((resolve, _reject) => {
          testServer.on('error', () => {
            console.log(`Port ${preferredPort} is in use, trying next port...`);
            resolve();
          });
          
          testServer.on('listening', () => {
            port = preferredPort;
            testServer.close(() => resolve());
          });
          
          testServer.listen(preferredPort);
        });
        
        if (port === preferredPort) {
          // We found an available port from our preferred list
          break;
        }
      } catch (err) {
        console.log(`Error testing port ${preferredPort}:`, err);
      }
    }
    
    // If none of our preferred ports are available, find any available port
    if (!preferredPorts.includes(port)) {
      port = findAvailablePort(8086); // Start from 8086 if all preferred ports are taken
    }
    
    // Update the config with the actual port
    config.port = port;
    config.baseUrl = `http://localhost:${port}`;
    
    // Start listening
    server.listen(port, () => {
      console.log(`Server is running on port ${port}`);
      console.log(`API available at http://localhost:${port}/api`);
      
      // Write the port to a file so the client can read it
      const portFilePath = path.join(process.cwd(), '.port');
      fs.writeFileSync(portFilePath, port.toString());
    });
  } catch (error) {
    if (error instanceof Error) {
      console.error('Failed to start server:', error.message);
    } else {
      console.error('Failed to start server:', error);
    }
    process.exit(1);
  }
}
================================================================================
File: PubsubServer.ts
Lines: 14
--------------------------------------------------------------------------------
import type { Server } from "http"

import { WebsocketPubsubServer } from "./services/WebsocketPubsubServer"

// Turn on request logging.
// https://expressjs.com/en/guide/debugging.html
// process.env.DEBUG = "express:*"


export function PubsubServer(_environment: Record<string, never>, server: Server) {
	return new WebsocketPubsubServer(server, function (_key) {
		// this.publish([{ key, value }])
	})
}

================================================================================
File: QueueServer.ts
Lines: 8
--------------------------------------------------------------------------------
import { ServerEnvironment } from './services/ServerEnvironment';

export default function QueueServer(environment: ServerEnvironment) {
  // Queue server implementation
  const { queue } = environment;
  // Queue is automatically initialized in its constructor
  return queue;
}
================================================================================
File: server.ts
Lines: 132
--------------------------------------------------------------------------------
// abe-stack\src\server\server.ts
import http from "http"
import path from "path"

import express, { Express, Request, Response, NextFunction, RequestHandler } from "express"
import helmet from "helmet"

import { ApiServer } from "./ApiServer"
import { FileServer } from "./FileServer"
import { PubsubServer } from "./PubsubServer"
import QueueServer from "./QueueServer"
import { Database } from "./services/Database"
import { Logger } from "./services/LoggerService"
import { QueueDatabase } from "./services/QueueDatabase"
import { ServerConfig, DatabaseApi, PubsubApi, ServerEnvironment } from "./services/ServerEnvironment"

const logger = new Logger('Server');

// Create a complete config object that matches ServerConfig type
const config: ServerConfig = {
  port: parseInt(process.env.PORT || '8080'),
  dbConnectionString: process.env.DATABASE_URL || 'postgresql://postgres:postgres@localhost:5432/abe_stack',
  production: process.env.NODE_ENV === 'production',
  domain: process.env.DOMAIN || 'localhost',
  baseUrl: process.env.BASE_URL || 'http://localhost:8080',
  corsOrigin: process.env.CORS_ORIGIN || '*',
  corsOrigins: (process.env.CORS_ORIGIN || '*').split(','),
  jwtSecret: process.env.JWT_SECRET || 'your-secret-key',
  uploadDir: process.env.UPLOAD_DIR || path.join(process.cwd(), 'uploads'),
  queuePath: process.env.QUEUE_PATH || path.join(process.cwd(), 'queue'),
  signatureSecret: Buffer.from(process.env.SIGNATURE_SECRET || 'signature-secret-key'),
  passwordSalt: Buffer.from(process.env.PASSWORD_SALT || 'password-salt'),
  dbPath: process.env.DB_PATH || path.join(process.cwd(), 'db'),
  db: {
    host: process.env.DB_HOST || 'localhost',
    port: parseInt(process.env.DB_PORT || '5432'),
    database: process.env.DB_NAME || 'abe_stack',
    username: process.env.DB_USER || 'postgres',
    password: process.env.DB_PASSWORD || 'postgres'
  }
}

async function startServer() {
  const app: Express = express();

  if (config.production) {
    // Basic server hardening settings including CORS
    const helmetMiddleware = (helmet as () => RequestHandler)();
    app.use(helmetMiddleware);
  }

  // Request logging
  app.use((req: Request, res: Response, next: NextFunction) => {
    const start = Date.now();
    (res as unknown as { on: (event: string, callback: () => void) => void })
      .on('finish', () => {
        const duration = Date.now() - start;
        logger.info(`${req.method} ${req.url} ${res.statusCode} ${duration}ms`);
      });
    next();
  });

  // Serve static files from the uploads directory
  app.use('/uploads', (express.static as unknown as (path: string) => RequestHandler)(path.join(process.cwd(), 'uploads')));

  // Initialize databases
  const dbInstance = new Database(config.dbPath);
  await dbInstance.initialize();
  
  // Create a wrapper that implements the DatabaseApi interface
  const db: DatabaseApi = {
    query: async <T = unknown>(text: string, params?: unknown[]): Promise<{ rows: T[] }> => {
      // Use the pool from the Database instance to perform queries
      const pool = dbInstance.getPool();
      if (!pool) {
        throw new Error("Database pool not initialized");
      }
      const result = await pool.query(text, params);
      return { rows: result.rows as T[] };
    },
    getClient: async () => {
      // Get a client from the pool
      const pool = dbInstance.getPool();
      if (!pool) {
        throw new Error("Database pool not initialized");
      }
      
      // Check if pool is a Pool instance with connect method
      if ('connect' in pool) {
        return await pool.connect();
      } else {
        throw new Error("Pool does not support client connections");
      }
    }
  };
  
  const queue = new QueueDatabase();

  // Type assertion to convert Express Application to RequestListener
  const server = http.createServer(app as unknown as http.RequestListener)
  
  // Use a direct type assertion to bypass type checking
  // @ts-expect-error PubsubServer expects a different type structure
  const pubsubServer = PubsubServer({ config, db }, server)
  
  // Create a wrapper that implements the PubsubApi interface
  const pubsub: PubsubApi = {
    broadcast: (key: string, value: unknown) => {
      // Use WebsocketPubsubServer's publish method
      void pubsubServer.publish([{ key, value }]);
    },
    subscribe: (_key: string, _callback: (value: unknown) => void) => {
      // Return unsubscribe function
      return () => {};
    }
  };

  // Setup the server environment.
  const environment: ServerEnvironment = { config, db, queue, pubsub }

  // Use type assertions for server functions
  FileServer(environment, app)
  QueueServer(environment)
  ApiServer(environment, app)

  server.listen(config.port, () => console.log(`Listening: http://localhost:${config.port}`))
}

startServer().catch(err => {
  console.error('Failed to start server:', err)
  process.exit(1)
})
================================================================================
File: tasks.ts
Lines: 16
--------------------------------------------------------------------------------
import * as queueTasks from "./tasks/autoindex"

type Q = typeof queueTasks
export type TaskName = keyof Q

// Assert proper types.
export type Tasks = { [K in keyof Q]: Extract<Q[K], Record<K, unknown>>[K] }

const tasks = Object.fromEntries(
  Object.entries(queueTasks).map(([key, value]) => [
    key,
    value[key as keyof typeof value]
  ])
) as Tasks;

export { tasks }

================================================================================
File: types.ts
Lines: 12
--------------------------------------------------------------------------------
export enum MediaType {
  IMAGE = 'image',
  VIDEO = 'video',
  AUDIO = 'audio'
}

export enum ProcessingStatus {
  PENDING = 'pending',
  PROCESSING = 'processing',
  COMPLETED = 'completed',
  FAILED = 'failed'
} 
================================================================================
File: apis\auth.ts
Lines: 126
--------------------------------------------------------------------------------
import { Request, Response } from "express"

import * as t from "../../shared/dataTypes"
import { AuthService } from "../services/AuthService"
import { AuthTokenService, TokenType } from "../services/AuthTokenService"

// Register API
interface RegisterInput {
  username: string;
  email: string;
  password: string;
  displayName: string;
  firstName: string;
  lastName: string;
}

interface LoginInput {
  email: string;
  password: string;
}

interface RefreshTokenInput {
  refreshToken: string;
}

const registerInput = t.object({
  username: t.string(),
  email: t.string(),
  password: t.string(),
  displayName: t.string(),
  firstName: t.string(),
  lastName: t.string(),
});

const loginInput = t.object({
  email: t.string(),
  password: t.string(),
});

const refreshTokenInput = t.object({
  refreshToken: t.string(),
});

// Get AuthService instance
const authService = AuthService.getInstance()

interface AuthRequest extends Request {
  headers: {
    authorization?: string;
  };
}

export async function register(
  req: Request & { body: RegisterInput },
  res: Response
) {
  const args = registerInput.validate(req.body);
  if (!args) {
    return res.status(400).json({ error: 'Invalid input' });
  }

  try {
    const result = await authService.register(args);
    return res.status(201).json(result);
  } catch (error) {
    return res.status(400).json({ error: (error as Error).message });
  }
}

export async function login(
  req: Request & { body: LoginInput },
  res: Response
) {
  const args = loginInput.validate(req.body);
  if (!args) {
    return res.status(400).json({ error: 'Invalid input' });
  }

  try {
    const result = await authService.login(args);
    return res.status(200).json(result);
  } catch (error) {
    return res.status(401).json({ error: (error as Error).message });
  }
}

// Get Current User API
export const getCurrentUserInput = t.object({})

export async function getCurrentUser(
  req: AuthRequest,
  res: Response
) {
  const authHeader = req.headers.authorization;
  const token = typeof authHeader === 'string' ? authHeader.split(' ')[1] : undefined;
  if (!token) {
    return res.status(401).json({ error: 'No token provided' });
  }

  try {
    const user = await authService.getCurrentUser(token);
    return res.status(200).json(user);
  } catch (error) {
    return res.status(401).json({ error: (error as Error).message });
  }
}

// Refresh Token API
export async function refreshToken(
  req: Request & { body: RefreshTokenInput },
  res: Response
) {
  const args = refreshTokenInput.validate(req.body);
  if (!args) {
    return res.status(400).json({ error: 'Invalid input' });
  }

  try {
    const result = await authService.refreshToken(args.refreshToken);
    const tokenService = AuthTokenService.getInstance();
    tokenService.blacklistToken(args.refreshToken, TokenType.REFRESH);
    return res.status(200).json(result);
  } catch (error) {
    return res.status(401).json({ error: (error as Error).message });
  }
}

================================================================================
File: apis\autoindex.ts
Lines: 13
--------------------------------------------------------------------------------
// This file is auto-generated. Do not edit manually.
// It serves as an index for all API handlers

import { createValidator } from '../../shared/dataTypes';
import { ServerEnvironment } from '../services/ServerEnvironment';

// Example export format - add actual handlers as needed
export const example = {
  handler: (_environment: ServerEnvironment, _args: Record<string, never>) => {
    return { success: true };
  },
  input: createValidator((_value: unknown) => true, 'example')
}; 
================================================================================
File: apis\hello.ts
Lines: 30
--------------------------------------------------------------------------------
/*

This API is a template.

*/

import type { Request, Response } from "express"

import * as t from "../../shared/dataTypes"
import type { ServerEnvironment } from "../services/ServerEnvironment"

// Used for request validation.
export const input = t.object({ name: t.string() })

// It's helpful to be able to call this api functionality internally so we definite a separate
// function that isn't the API request handler.
export function hello(name: string) {
	return { message: `Hello ${name}!` }
}

// This is the actual HTTP request handler. You can call this API from the client with:
// environment.api.hello({name: "World"})
export function handler(
	_environment: ServerEnvironment,
	args: { name: string },
	_req: Request,
	_res: Response
) {
	return hello(args.name)
}

================================================================================
File: apis\media.ts
Lines: 99
--------------------------------------------------------------------------------
// src/server/apis/media.ts
import * as fs from 'fs';
import * as path from 'path';

import { Request, Response } from 'express';
import multer from 'multer';

import * as t from '../../shared/dataTypes';
import { MediaService } from '../services/MediaService';



type RequestWithFile = Request & { 
  file?: Express.Multer.File;
  protocol: string; // Optional, already included in Request
  get: (name: string) => string; // Optional, already included in Request
};

// Setup storage
const storage = multer.diskStorage({
  destination: (_req, _file, cb) => {
    const mediaService = new MediaService();
    cb(null, mediaService['mediaPath']); // Access private property
  },
  filename: (_req, file, cb) => {
    const mediaService = new MediaService();
    cb(null, mediaService.generateFilename(file.originalname));
  }
});

export const upload = multer({ storage });
const mediaService = new MediaService();

// Stream media
export const streamInput = t.object({
  filename: t.string()
});

export function streamMedia(req: Request, res: Response) {
  try {
    const params = streamInput.validate(req.params);
    if (!params) {
      return res.status(400).json({ error: 'Invalid filename parameter' });
    }
    
    const mediaService = new MediaService();
    mediaService.streamMedia(req, res, params.filename);
  } catch (error) {
    console.error('Error streaming media:', error);
    return res.status(500).json({ error: 'Failed to stream media' });
  }
}

// Handle file upload in ApiServer.ts with middleware
export const uploadHandler = (req: RequestWithFile, res: Response) => {
  const file = req.file;
  if (!file) {
    return res.status(400).json({ error: 'No file provided' });
  }
  
  const mediaType = mediaService.getMediaType(file.originalname);
  
  return res.status(200).json({
    filename: file.filename,
    originalname: file.originalname,
    size: file.size,
    mimetype: file.mimetype,
    mediaType
  });
};

// Upload media endpoint
export async function uploadMedia(req: RequestWithFile, res: Response) {
  try {
    const file = req.file;
    if (!file) {
      return res.status(400).json({ error: 'No file uploaded' });
    }

    const mediaService = new MediaService();
    const filename = mediaService.generateFilename(file.originalname);
    
    // Save the file
    const filePath = path.join(mediaService['mediaPath'], filename);
    await fs.promises.writeFile(filePath, file.buffer);
    
    // Generate URL
    const baseUrl = req.protocol + '://' + req.get('host');
    const fileUrl = `${baseUrl}/media/${filename}`;
    
    return res.status(201).json({
      filename,
      url: fileUrl
    });
  } catch (error) {
    console.error('Error uploading media:', error);
    return res.status(500).json({ error: 'Failed to upload media' });
  }
}
================================================================================
File: config\database.ts
Lines: 14
--------------------------------------------------------------------------------
import { Pool } from 'pg';

import { envConfig } from './environment';

export const db = new Pool({
  user: envConfig.DB_USER,
  password: envConfig.DB_PASSWORD,
  host: envConfig.DB_HOST,
  port: envConfig.DB_PORT,
  database: envConfig.DB_NAME,
  ssl: {
    rejectUnauthorized: false
  }
}); 
================================================================================
File: config\email.ts
Lines: 15
--------------------------------------------------------------------------------
import { env } from './environment';

export const emailConfig = {
  host: env.EMAIL_HOST,
  port: env.EMAIL_PORT,
  secure: env.EMAIL_SECURE,
  user: env.EMAIL_USER,
  password: env.EMAIL_PASSWORD,
  appName: env.APP_NAME,
  appUrl: env.APP_URL,
  isDevelopment: env.NODE_ENV === 'development',
  serverPort: env.PORT
};

export default emailConfig; 
================================================================================
File: config\environment.ts
Lines: 189
--------------------------------------------------------------------------------
// src/server/config/environment.ts
import { path } from '../helpers/path';

// Environment configuration
export const env = {
  NODE_ENV: process.env.NODE_ENV || 'development',
  PORT: parseInt(process.env.PORT || '8080', 10),
  CORS_ORIGINS: (process.env.CORS_ORIGIN || '*').split(','),
  HOST: process.env.HOST || 'localhost',
  BASE_URL: process.env.BASE_URL || 'http://localhost:8080',
  JWT_SECRET: process.env.JWT_SECRET || 'development-jwt-secret',
  JWT_REFRESH_SECRET: process.env.JWT_REFRESH_SECRET || 'development-jwt-refresh-secret',
  ACCESS_TOKEN_SECRET: process.env.ACCESS_TOKEN_SECRET || 'development-access-token-secret',
  REFRESH_TOKEN_SECRET: process.env.REFRESH_TOKEN_SECRET || 'development-refresh-token-secret',
  ACCESS_TOKEN_EXPIRY: process.env.ACCESS_TOKEN_EXPIRY || '15',
  REFRESH_TOKEN_EXPIRY: process.env.REFRESH_TOKEN_EXPIRY || '7',
  DB_HOST: process.env.DB_HOST || 'localhost',
  DB_PORT: parseInt(process.env.DB_PORT || '5432', 10),
  DB_USER: process.env.DB_USER || 'postgres',
  DB_PASSWORD: process.env.DB_PASSWORD || '1083035',
  DB_NAME: process.env.DB_NAME || 'abe_stack',
  // Email configuration
  EMAIL_HOST: process.env.EMAIL_HOST || 'smtp.gmail.com',
  EMAIL_PORT: parseInt(process.env.EMAIL_PORT || '587', 10),
  EMAIL_SECURE: process.env.EMAIL_SECURE === 'true',
  EMAIL_USER: process.env.EMAIL_USER || 'test@example.com',
  EMAIL_PASSWORD: process.env.EMAIL_PASSWORD || 'password',
  APP_NAME: process.env.APP_NAME || 'ABE Stack',
  APP_URL: process.env.APP_URL || 'http://localhost:8080'
};

// Define the configuration schema with types and validation
export interface EnvConfig {
  // Server
  NODE_ENV: 'development' | 'test' | 'staging' | 'production';
  PORT: number;
  HOST: string;
  BASE_URL: string;
  
  // Database
  DB_HOST: string;
  DB_PORT: number;
  DB_NAME: string;
  DB_USER: string;
  DB_PASSWORD: string;
  
  // Auth
  JWT_SECRET: string;
  JWT_REFRESH_SECRET: string;
  ACCESS_TOKEN_SECRET: string;
  REFRESH_TOKEN_SECRET: string;
  ACCESS_TOKEN_EXPIRY: string;
  REFRESH_TOKEN_EXPIRY: string;
  
  // Cors
  CORS_ORIGINS: string[];

  // File Storage
  UPLOADS_DIR: string;
  MAX_FILE_SIZE: number;
  
  // Email
  EMAIL_HOST: string;
  EMAIL_PORT: number;
  EMAIL_SECURE: boolean;
  EMAIL_USER: string;
  EMAIL_PASSWORD: string;
  APP_NAME: string;
  APP_URL: string;
}

// Helper function to parse environment variables with type conversion
function parseEnv<T>(key: string, defaultValue?: T, parser?: (value: string) => T): T {
  const value = process.env[key];
  
  // Return default if no value found
  if (value === undefined) {
    if (defaultValue !== undefined) {
      return defaultValue;
    }
    throw new Error(`Environment variable ${key} is required but not set`);
  }
  
  // Parse the value if parser provided
  if (parser) {
    try {
      return parser(value);
    } catch (error: unknown) {
      // Type guard for error object with message property
      if (error instanceof Error) {
        throw new Error(`Failed to parse environment variable ${key}: ${error.message}`);
      }
      // For other types of errors
      throw new Error(`Failed to parse environment variable ${key}: Unknown error`);
    }
  }
  
  return value as unknown as T;
}

// Parse array from comma-separated string
function parseArray(value: string): string[] {
  return value.split(',').map(item => item.trim()).filter(Boolean);
}

// Create and validate the config object
export const envConfig: EnvConfig = {
  // Server
  NODE_ENV: parseEnv<'development' | 'test' | 'staging' | 'production'>(
    'NODE_ENV', 
    'development',
    (v) => {
      if (!['development', 'test', 'staging', 'production'].includes(v)) {
        throw new Error(`Invalid NODE_ENV: ${v}`);
      }
      return v as 'development' | 'test' | 'staging' | 'production';
    }
  ),
  PORT: parseEnv<number>('PORT', 8080, parseInt),
  HOST: parseEnv<string>('HOST', 'localhost'),
  BASE_URL: parseEnv<string>(
    'BASE_URL', 
    process.env.NODE_ENV === 'production' 
      ? undefined 
      : `http://localhost:${parseEnv<number>('PORT', 8080)}`
  ),
  
  // Database
  DB_HOST: parseEnv<string>('DB_HOST', 'localhost'),
  DB_PORT: parseEnv<number>('DB_PORT', 5432, parseInt),
  DB_NAME: parseEnv<string>('DB_NAME', 'abe_stack'),
  DB_USER: parseEnv<string>('DB_USER', 'postgres'),
  DB_PASSWORD: parseEnv<string>('DB_PASSWORD', '1083035'),
  
  // Auth
  JWT_SECRET: parseEnv<string>(
    'JWT_SECRET', 
    process.env.NODE_ENV === 'production' 
      ? undefined 
      : 'development-jwt-secret-key-change-in-production'
  ),
  JWT_REFRESH_SECRET: parseEnv<string>(
    'JWT_REFRESH_SECRET', 
    process.env.NODE_ENV === 'production' 
      ? undefined 
      : 'development-jwt-refresh-secret-key-change-in-production'
  ),
  ACCESS_TOKEN_SECRET: parseEnv<string>(
    'ACCESS_TOKEN_SECRET', 
    process.env.NODE_ENV === 'production' 
      ? undefined 
      : 'development-access-token-secret-key-change-in-production'
  ),
  REFRESH_TOKEN_SECRET: parseEnv<string>(
    'REFRESH_TOKEN_SECRET', 
    process.env.NODE_ENV === 'production' 
      ? undefined 
      : 'development-refresh-token-secret-key-change-in-production'
  ),
  ACCESS_TOKEN_EXPIRY: parseEnv<string>('ACCESS_TOKEN_EXPIRY', '15'),
  REFRESH_TOKEN_EXPIRY: parseEnv<string>('REFRESH_TOKEN_EXPIRY', '7'),
  
  // Cors
  CORS_ORIGINS: parseEnv<string[]>(
    'CORS_ORIGINS', 
    process.env.NODE_ENV === 'production' 
      ? undefined 
      : ['http://localhost:3000', 'http://localhost:3001', 'http://localhost:3002', 'http://localhost:3003'],
    parseArray
  ),

  // File Storage
  UPLOADS_DIR: parseEnv<string>('UPLOADS_DIR', path.resolve(process.cwd(), 'uploads')),
  MAX_FILE_SIZE: parseEnv<number>('MAX_FILE_SIZE', 10 * 1024 * 1024, parseInt),
  
  // Email
  EMAIL_HOST: parseEnv<string>('EMAIL_HOST', 'smtp.gmail.com'),
  EMAIL_PORT: parseEnv<number>('EMAIL_PORT', 587, parseInt),
  EMAIL_SECURE: parseEnv<boolean>('EMAIL_SECURE', false, (v) => v === 'true'),
  EMAIL_USER: parseEnv<string>('EMAIL_USER', 'test@example.com'),
  EMAIL_PASSWORD: parseEnv<string>('EMAIL_PASSWORD', 'password'),
  APP_NAME: parseEnv<string>('APP_NAME', 'ABE Stack'),
  APP_URL: parseEnv<string>('APP_URL', 'http://localhost:8080')
};

// Freeze the config object to prevent modifications
Object.freeze(envConfig);

export default envConfig;
================================================================================
File: config\serverConfig.ts
Lines: 25
--------------------------------------------------------------------------------
import path from 'path';

// Server configuration
export const serverConfig = {
  port: parseInt(process.env.PORT || '3003'), // Use port 3003 by default
  dbConnectionString: process.env.DATABASE_URL || 'postgresql://postgres:postgres@localhost:5432/abe_stack',
  production: process.env.NODE_ENV === 'production',
  domain: process.env.DOMAIN || 'localhost',
  baseUrl: process.env.BASE_URL || 'http://localhost:3003', // Updated to match default port
  corsOrigin: process.env.CORS_ORIGIN || '*',
  corsOrigins: (process.env.CORS_ORIGIN || '*').split(','),
  jwtSecret: process.env.JWT_SECRET || 'your-secret-key',
  uploadDir: process.env.UPLOAD_DIR || path.join(process.cwd(), 'uploads'),
  queuePath: process.env.QUEUE_PATH || path.join(process.cwd(), 'queue'),
  signatureSecret: Buffer.from(process.env.SIGNATURE_SECRET || 'signature-secret-key'),
  passwordSalt: Buffer.from(process.env.PASSWORD_SALT || 'password-salt'),
  dbPath: process.env.DB_PATH || path.join(process.cwd(), 'db'),
  db: {
    host: process.env.DB_HOST || 'localhost',
    port: parseInt(process.env.DB_PORT || '5432'),
    database: process.env.DB_NAME || 'abe_stack',
    username: process.env.DB_USER || 'postgres',
    password: process.env.DB_PASSWORD || 'postgres'
  }
}; 
================================================================================
File: controllers\AuthController.ts
Lines: 236
--------------------------------------------------------------------------------
import type { Request, Response, NextFunction } from 'express';

import { ConflictError, UnauthorizedError } from '../../shared/errors/ApiError';
import { User } from '../models/User';
import { AuthService } from '../services/AuthService';
import { Database } from '../services/Database';

export class AuthController {
  private db: Database;
  
  constructor() {
    // Pass a default path to the Database constructor
    this.db = new Database(process.env.DB_PATH || './db');
    // Initialize the database connection
    void this.initializeDatabase();
  }

  // Initialize the database connection
  private async initializeDatabase() {
    try {
      await this.db.initialize();
      console.log('Database initialized successfully in AuthController');
    } catch (error) {
      console.error('Failed to initialize database in AuthController:', error);
    }
  }

  // Login handler
  login = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const { email, password } = req.body as { email: string; password: string };
      
      const authService = AuthService.getInstance();
      const { token, refreshToken, user } = await authService.login({ email, password });
      
      // Return successful response
      return res.status(200).json({
        status: 'success',
        data: {
          token,
          refreshToken,
          user
        }
      });
    } catch (error) {
      // Handle email confirmation error
      if (error instanceof UnauthorizedError && error.message.includes('confirm your email')) {
        return res.status(401).json({
          status: 'error',
          message: error.message,
          requireEmailConfirmation: true
        });
      }
      
      // Pass to error handler middleware
      next(error);
    }
  };

  // Register handler
  register = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const { username, email, password, displayName, firstName, lastName } = req.body as { username: string; email: string; password: string; displayName: string; firstName: string; lastName: string };
      
      // Check if user already exists
      const existingUserByEmail = await User.findByEmail(email);
      
      // We'll only check by email since findByUsername isn't available in the User type
      const existingUser = existingUserByEmail;
      
      if (existingUser && existingUser.emailConfirmed) {
        const errors = {
          email: [`This email is already in use`]
        };
        
        throw new ConflictError('User already exists', errors);
      }
      
      // Register user
      const authService = AuthService.getInstance();
      const { token, refreshToken, user } = await authService.register({
        username,
        email,
        password,
        displayName: displayName || `${firstName} ${lastName}`,
        firstName,
        lastName
      });
      
      // Return successful response
      return res.status(201).json({
        status: 'success',
        message: 'Registration successful. Please check your email to verify your account.',
        data: {
          token,
          refreshToken,
          user
        }
      });
    } catch (error) {
      // Pass to error handler middleware
      next(error);
    }
  };

  // Logout handler
  logout = (req: Request, res: Response, next: NextFunction) => {
    try {
      // Get the token from the request (assuming it's in the Authorization header)
      const authHeader = (req.headers as Record<string, string | string[] | undefined>).authorization as string | undefined;
      const token = authHeader?.split(' ')[1];
      
      if (!token) {
        return res.status(401).json({
          status: 'error',
          message: 'No token provided'
        });
      }

      // Call AuthService to invalidate the token
      const authService = AuthService.getInstance();
      authService.logout(token);
      
      // Return successful response
      return res.status(200).json({
        status: 'success',
        message: 'Logged out successfully'
      });
    } catch (error) {
      // Pass to error handler middleware
      next(error);
    }
  };

  // Refresh Token handler
  refreshToken = async (req: Request, res: Response, next: NextFunction) => {
    try {
      // Get the refresh token from the request body
      const { refreshToken } = req.body as { refreshToken: string };
      
      if (!refreshToken) {
        return res.status(400).json({
          status: 'error',
          message: 'Refresh token is required'
        });
      }

      // Call AuthService to refresh the token
      const authService = AuthService.getInstance();
      const result = await authService.refreshToken(refreshToken);
      const { token, refreshToken: newRefreshToken } = result;
      
      // Return successful response
      return res.status(200).json({
        status: 'success',
        data: {
          token,
          refreshToken: newRefreshToken
        }
      });
    } catch (error) {
      // Pass to error handler middleware
      next(error);
    }
  };

  // Get current user handler
  getCurrentUser = (req: Request, res: Response, next: NextFunction) => {
    try {
      // User should be attached to the request by the authentication middleware
      if (!req.user) {
        return res.status(401).json({
          status: 'error',
          message: 'Not authenticated'
        });
      }

      // Return the user data
      return res.status(200).json({
        status: 'success',
        data: {
          user: req.user as Record<string, unknown>
        }
      });
    } catch (error) {
      next(error);
    }
  };

  // Email confirmation handler
  confirmEmail = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const { token } = req.query as { token: string | string[] | undefined };
      
      if (!token || typeof token !== 'string') {
        return res.status(400).json({
          status: 'error',
          message: 'Invalid token'
        });
      }

      const authService = AuthService.getInstance();
      await authService.confirmEmail(token);
      
      // Redirect to the login page with a success message
      res.status(302).json({ redirectUrl: '/login?verified=true' });
      return;
    } catch (error) {
      next(error);
    }
  };

  // Resend confirmation email handler
  resendConfirmationEmail = async (req: Request, res: Response, next: NextFunction) => {
    try {
      const { email } = req.body as { email: string };
      
      if (!email) {
        return res.status(400).json({
          status: 'error',
          message: 'Email is required'
        });
      }

      const authService = AuthService.getInstance();
      await authService.resendConfirmationEmail(email);
      
      return res.status(200).json({
        status: 'success',
        message: 'Confirmation email sent successfully'
      });
    } catch (error) {
      next(error);
    }
  };
}
================================================================================
File: controllers\media.controller.ts
Lines: 422
--------------------------------------------------------------------------------
import fs from 'fs';
import path from 'path';

import { Request, Response } from 'express';
import rangeParser from 'range-parser';

import { NotFoundError } from '../middleware/error';
import { Logger } from '../services/LoggerService';
import { MediaProcessingService } from '../services/media/MediaProcessingService';

interface MediaRequest extends Request {
  file?: Express.Multer.File;
  body: {
    generateHLS?: string;
    generateDASH?: string;
    generateWaveform?: string;
    quality?: ('1080p' | '720p' | '480p' | '360p' | '240p')[];
  };
}

interface StreamRequest extends Request {
  params: {
    videoId?: string;
    audioId?: string;
    file?: string;
    quality?: '1080p' | '720p' | '480p' | '360p' | '240p';
    format?: string;
  };
  query: {
    format?: string;
  };
  headers: {
    range?: string;
  };
}

interface StreamResponse extends Response {
  writeHead(statusCode: number, statusMessage?: string, headers?: Record<string, string | number>): this;
  writeHead(statusCode: number, headers?: Record<string, string | number>): this;
  end(cb?: () => void): this;
  end(data: string | Buffer, cb?: () => void): this;
  end(str: string, encoding?: BufferEncoding, cb?: () => void): this;
}

interface AudioRequest extends Request {
  params: {
    audioId: string;
    format?: string;
  };
  headers: {
    range?: string;
  };
}

interface WaveformRequest extends Request {
  params: {
    audioId: string;
  };
}

interface JobRequest extends Request {
  params: {
    jobId: string;
  };
}

/**
 * Controller for handling media uploads and streaming
 */
export class MediaController {
  private mediaService: MediaProcessingService;
  private logger: Logger;
  private uploadDir: string;

  constructor() {
    this.mediaService = MediaProcessingService.getInstance();
    this.logger = new Logger('MediaController');
    this.uploadDir = path.join(process.cwd(), 'uploads');
  }

  /**
   * Handle image upload
   */
  public async uploadImage(req: MediaRequest, res: Response): Promise<void> {
    try {
      if (!req.file) {
        res.status(400).json({ error: 'No file provided' });
        return;
      }

      const filePath = req.file.path;
      const result = await this.mediaService.processImage(filePath);

      res.status(202).json({
        message: 'Image upload accepted and processed',
        mediaId: result.mediaId,
        status: 'completed'
      });
    } catch (error) {
      this.logger.error('Error uploading image:', error);
      res.status(500).json({ error: 'Failed to upload image' });
    }
  }

  /**
   * Handle video upload
   */
  public async uploadVideo(req: MediaRequest, res: Response): Promise<void> {
    try {
      if (!req.file) {
        res.status(400).json({ error: 'No file provided' });
        return;
      }

      const filePath = req.file.path;
      const generateHLS = req.body.generateHLS !== 'false';
      const generateDASH = req.body.generateDASH === 'true';
      const quality = req.body.quality;

      const result = await this.mediaService.processVideo(filePath, {
        generateHLS,
        generateDASH,
        quality: this.mapQualityToEnum(quality)
      });

      res.status(202).json({
        message: 'Video upload accepted and processed',
        mediaId: result.mediaId,
        status: 'completed'
      });
    } catch (error) {
      this.logger.error('Error uploading video:', error);
      res.status(500).json({ error: 'Failed to upload video' });
    }
  }

  /**
   * Handle audio upload
   */
  public async uploadAudio(req: MediaRequest, res: Response): Promise<void> {
    try {
      if (!req.file) {
        res.status(400).json({ error: 'No file provided' });
        return;
      }

      const filePath = req.file.path;
      const generateWaveform = req.body.generateWaveform !== 'false';

      const result = await this.mediaService.processAudio(filePath, {
        generateWaveform
      });

      res.status(202).json({
        message: 'Audio upload accepted and processed',
        mediaId: result.mediaId,
        status: 'completed'
      });
    } catch (error) {
      this.logger.error('Error uploading audio:', error);
      res.status(500).json({ error: 'Failed to upload audio' });
    }
  }

  /**
   * Stream a video file with support for HLS
   */
  public async streamVideo(req: StreamRequest, res: Response): Promise<void> {
    try {
      const { videoId, quality } = req.params;
      
      if (!videoId) {
        res.status(400).json({ error: 'Video ID is required' });
        return;
      }

      if (req.query.format === 'hls') {
        await this.streamHLS(videoId, req, res);
        return;
      }

      const videoPath = this.getVideoPath(videoId, quality);
      await this.streamFile(videoPath, 'video/mp4', req, res);
    } catch (error) {
      this.handleStreamError(error, res);
    }
  }

  /**
   * Stream HLS content
   */
  private async streamHLS(videoId: string, req: StreamRequest, res: Response): Promise<void> {
    try {
      const { file } = req.params;
      const hlsDir = path.join(this.uploadDir, 'videos', 'hls', videoId);

      if (!fs.existsSync(hlsDir)) {
        throw new NotFoundError('HLS stream not found');
      }

      const filePath = file 
        ? path.join(hlsDir, file)
        : path.join(hlsDir, 'master.m3u8');

      if (!fs.existsSync(filePath)) {
        throw new NotFoundError('HLS file not found');
      }

      const contentType = path.extname(filePath) === '.m3u8'
        ? 'application/vnd.apple.mpegurl'
        : 'video/mp2t';

      await this.streamFile(filePath, contentType, req, res);
    } catch (error) {
      this.handleStreamError(error, res);
    }
  }

  private getVideoPath(videoId: string, quality?: string): string {
    if (quality && ['1080p', '720p', '480p', '360p', '240p'].includes(quality)) {
      return path.join(this.uploadDir, 'videos', 'transcoded', `${videoId}_${quality}.mp4`);
    }
    return path.join(this.uploadDir, 'videos', 'original', `${videoId}.mp4`);
  }

  private async streamFile(filePath: string, contentType: string, req: StreamRequest, res: StreamResponse): Promise<void> {
    if (!fs.existsSync(filePath)) {
      throw new NotFoundError('File not found');
    }

    const stat = await fs.promises.stat(filePath);
    const fileSize = stat.size;
    const range = req.headers.range;

    if (range) {
      const ranges = rangeParser(fileSize, range);
      if (Array.isArray(ranges) && ranges.length > 0) {
        const { start, end } = ranges[0];
        const stream = fs.createReadStream(filePath, { start, end });
        
        res.writeHead(206, {
          'Content-Range': `bytes ${start}-${end}/${fileSize}`,
          'Accept-Ranges': 'bytes',
          'Content-Length': end - start + 1,
          'Content-Type': contentType
        });
        
        stream.pipe(res);
        return;
      }
    }

    res.writeHead(200, {
      'Content-Length': fileSize,
      'Content-Type': contentType
    });
    
    fs.createReadStream(filePath).pipe(res);
  }

  private handleStreamError(error: unknown, res: Response): void {
    if (error instanceof NotFoundError) {
      res.status(404).json({ error: error.message });
    } else {
      this.logger.error('Error streaming:', error);
      res.status(500).json({ error: 'Failed to stream content' });
    }
  }

  private mapQualityToEnum(quality?: ('1080p' | '720p' | '480p' | '360p' | '240p')[]): 'low' | 'medium' | 'high' | undefined {
    if (!quality?.length) return undefined;
    
    const highestQuality = quality[0];
    switch (highestQuality) {
      case '1080p':
      case '720p':
        return 'high';
      case '480p':
        return 'medium';
      case '360p':
      case '240p':
        return 'low';
      default:
        return undefined;
    }
  }

  /**
   * Stream an audio file
   */
  public async streamAudio(req: AudioRequest, res: StreamResponse): Promise<void> {
    try {
      const { audioId, format } = req.params;
      
      // Determine the audio path based on format
      let audioPath: string;
      if (format === 'mp3') {
        audioPath = path.join(this.uploadDir, 'audio', 'transcoded', `${audioId}.mp3`);
      } else {
        audioPath = path.join(this.uploadDir, 'audio', 'original', `${audioId}.${format || 'mp3'}`);
      }
      
      // Check if the file exists
      if (!fs.existsSync(audioPath)) {
        throw new NotFoundError('Audio not found');
      }
      
      // Get file stats
      const stat = fs.promises.stat(audioPath);
      const fileSize = (await stat).size;
      
      // Handle range requests
      const range = req.headers.range;
      if (range) {
        const ranges = rangeParser(fileSize, range);
        
        // Check if ranges is a valid range object (not -1 or -2)
        if (typeof ranges === 'object' && ranges !== null) {
          // Use the first range
          const { start, end } = ranges[0];
          
          // Create read stream for the range
          const stream = fs.createReadStream(audioPath, { start, end });
          
          // Set headers
          res.writeHead(206, {
            'Content-Range': `bytes ${start}-${end}/${fileSize}`,
            'Accept-Ranges': 'bytes',
            'Content-Length': end - start + 1,
            'Content-Type': format === 'mp3' ? 'audio/mpeg' : 'audio/mpeg'
          });
          
          // Pipe the stream to the response
          stream.pipe(res);
        } else {
          // Handle case where range is not specified or invalid
          const stream = fs.createReadStream(audioPath);
          
          // Set headers for full file
          res.writeHead(200, {
            'Content-Length': fileSize,
            'Content-Type': format === 'mp3' ? 'audio/mpeg' : 'audio/mpeg'
          });
          
          // Pipe the stream to the response
          stream.pipe(res);
        }
      } else {
        // Set headers for full file
        res.writeHead(200, {
          'Content-Length': fileSize,
          'Content-Type': format === 'mp3' ? 'audio/mpeg' : 'audio/mpeg'
        });
        
        // Create read stream for the entire file
        const stream = fs.createReadStream(audioPath);
        
        // Pipe the stream to the response
        stream.pipe(res);
      }
    } catch (error) {
      if (error instanceof NotFoundError) {
        res.status(404).json({ error: error.message });
      } else {
        this.logger.error('Error streaming audio:', error);
        res.status(500).json({ error: 'Failed to stream audio' });
      }
    }
  }
  
  /**
   * Get audio waveform data
   */
  public async getWaveform(req: WaveformRequest, res: StreamResponse): Promise<void> {
    try {
      const { audioId } = req.params;
      const waveformPath = path.join(this.uploadDir, 'audio', 'waveforms', `${audioId}.json`);
      
      // Check if the file exists
      if (!fs.existsSync(waveformPath)) {
        throw new NotFoundError('Waveform data not found');
      }
      
      // Read the waveform data
      const waveformData = await fs.promises.readFile(waveformPath, 'utf8');
      
      // Send the data
      res.writeHead(200, {
        'Content-Type': 'application/json'
      });
      res.end(waveformData);
    } catch (error) {
      if (error instanceof NotFoundError) {
        res.status(404).json({ error: error.message });
      } else {
        this.logger.error('Error getting waveform data:', error);
        res.status(500).json({ error: 'Failed to get waveform data' });
      }
    }
  }
  
  /**
   * Get job status
   */
  public async getJobStatus(req: JobRequest, res: Response): Promise<void> {
    try {
      const { jobId } = req.params;
      
      // Simulate checking job status asynchronously
      await Promise.resolve();
      
      res.status(200).json({
        jobId,
        status: 'processing',
        message: 'Job is being processed'
      });
    } catch (error) {
      this.logger.error('Error getting job status:', error);
      res.status(500).json({ error: 'Failed to get job status' });
    }
  }
} 
================================================================================
File: controllers\post.controller.ts
Lines: 62
--------------------------------------------------------------------------------
import { Response, NextFunction } from 'express';

import { AppError } from '../middleware/error';
import { Post, Like } from '../models';
import { PostParamRequest } from '../types/request.types';

/**
 * Get a single post by ID
 */
export const getPostById = async (req: PostParamRequest, res: Response, next: NextFunction): Promise<void> => {
  try {
    const { postId } = req.params;
    const post = await Post.findByPk(postId);

    if (!post) {
      throw new AppError('Post not found', 404);
    }

    // Check if current user liked the post
    let like = null;
    if (req.user) {
      like = await Like.findByUserAndPost(req.user.id, post.id);
    }

    const postData = post.toJSON();
    postData.isLiked = !!like;

    res.json({
      status: 'success',
      data: { post: postData }
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Delete a post
 */
export const deletePost = async (req: PostParamRequest, res: Response, next: NextFunction): Promise<void> => {
  try {
    const { postId } = req.params;
    const post = await Post.findByPk(postId);

    if (!post) {
      throw new AppError('Post not found', 404);
    }

    if (post.userId !== req.user?.id) {
      throw new AppError('Not authorized to delete this post', 403);
    }

    await post.delete();

    res.json({
      status: 'success',
      message: 'Post deleted successfully'
    });
  } catch (error) {
    next(error);
  }
}; 
================================================================================
File: controllers\social.controller.ts
Lines: 563
--------------------------------------------------------------------------------
import { Request, Response } from 'express';

import { uploadToStorage } from '../lib/storage';
import { Post, Comment, Like, CommentLike, Follow, User } from '../models';
import { UserJSON } from '../models/User';

interface AuthenticatedRequest extends Request {
  user?: {
    id: string;
  };
  params: {
    userId?: string;
    postId?: string;
    commentId?: string;
  };
  body: {
    content?: string;
  };
  query: {
    cursor?: string;
  };
  file?: Express.Multer.File;
}

// User Profile
export const getUserProfileHandler = async (req: AuthenticatedRequest, res: Response): Promise<void> => {
  try {
    const userId = req.params.userId;
    if (!userId) {
      res.status(400).json({ error: 'User ID is required' });
      return;
    }
    const currentUserId = req.user?.id;

    // Get user with followers
    const user = await User.findWithFollowers(userId);
    if (!user) {
      res.status(404).json({ error: 'User not found' });
      return;
    }

    // Check if current user is following this user
    let isFollowing = false;
    if (currentUserId) {
      const follow = await Follow.findByFollowerAndFollowing(currentUserId, userId);
      isFollowing = !!follow;
    }

    // Get counts
    const [followers, following, posts] = await Promise.all([
      Follow.findFollowers(userId),
      Follow.findFollowing(userId),
      Post.findByUserId(userId)
    ]);

    const followersCount = followers.length;
    const followingCount = following.length;
    const postsCount = posts.length;

    // Convert to safe user data
    const userData = {
      ...user,
      followers: undefined
    } as UserJSON;

    res.json({
      ...userData,
      isFollowing,
      followersCount,
      followingCount,
      postsCount
    });
  } catch (error) {
    console.error('Error fetching user profile:', error);
    res.status(500).json({ error: 'Failed to fetch user profile' });
  }
};

// Helper function for other parts of the application
export async function getUserProfile(userId: string, currentUserId?: string): Promise<UserJSON> {
  const user = await User.findById(userId);
  
  if (!user) {
    throw new Error('User not found');
  }
  
  // Get user data without sensitive information
  const userData = {
    ...user,
    password: undefined,
    emailToken: undefined,
    emailTokenExpire: undefined
  } as UserJSON;
  
  // Check if current user is following this user
  let isFollowing = false;
  if (currentUserId) {
    const follow = await Follow.findByFollowerAndFollowing(currentUserId, userId);
    isFollowing = !!follow;
  }
  
  // Add isFollowing flag to the response
  return {
    ...userData,
    isFollowing
  };
}

// Follow/Unfollow
export const followUser = async (req: AuthenticatedRequest, res: Response): Promise<void> => {
  try {
    const userId = req.params.userId;
    const followerId = req.user?.id;

    if (!userId || !followerId) {
      res.status(400).json({ error: 'Missing required parameters' });
      return;
    }

    if (followerId === userId) {
      res.status(400).json({ error: 'Cannot follow yourself' });
      return;
    }

    // Check if already following
    const existingFollow = await Follow.findByFollowerAndFollowing(followerId, userId);
    if (existingFollow) {
      res.status(400).json({ error: 'Already following this user' });
      return;
    }

    await Follow.create({
      followerId,
      followingId: userId
    });

    res.status(200).json({ message: 'Successfully followed user' });
  } catch (error) {
    console.error('Error following user:', error);
    res.status(500).json({ error: 'Failed to follow user' });
  }
};

export const unfollowUser = async (req: AuthenticatedRequest, res: Response): Promise<void> => {
  try {
    const userId = req.params.userId;
    const followerId = req.user?.id;

    if (!userId || !followerId) {
      res.status(400).json({ error: 'Missing required parameters' });
      return;
    }

    const follow = await Follow.findByFollowerAndFollowing(followerId, userId);
    if (!follow) {
      res.status(404).json({ error: 'Follow relationship not found' });
      return;
    }

    await follow.delete();
    res.status(200).json({ message: 'Successfully unfollowed user' });
  } catch (error) {
    console.error('Error unfollowing user:', error);
    res.status(500).json({ error: 'Failed to unfollow user' });
  }
};

// Feed
export const getFeed = async (req: AuthenticatedRequest, res: Response): Promise<void> => {
  try {
    const userId = req.user?.id;
    const limit = 10;

    // Get following users first
    const following = await Follow.findFollowing(userId || '');
    const followingIds = following.map(f => f.followingId);

    // Get posts from followed users
    const posts = await Post.findByUserIds(followingIds, {
      limit: limit + 1
    });

    const hasMore = posts.length > limit;
    const formattedPosts = await Promise.all(
      posts.slice(0, limit).map(async post => {
        const user = await User.findById(post.userId);
        const isLiked = userId ? await Like.findByUserAndPost(userId, post.id) : false;

        return {
          id: post.id,
          userId: post.userId,
          username: user?.username || 'Unknown User',
          userAvatar: user?.profileImage,
          content: post.content,
          media: post.media,
          likesCount: post.likesCount,
          commentsCount: post.commentsCount,
          sharesCount: post.sharesCount,
          isLiked: !!isLiked,
          createdAt: post.createdAt.toISOString()
        };
      })
    );

    res.json({
      posts: formattedPosts,
      hasMore,
      nextCursor: hasMore && posts.length > 0 ? posts[posts.length - 1].createdAt.toISOString() : null
    });
  } catch (error) {
    console.error('Error fetching feed:', error);
    res.status(500).json({ error: 'Failed to fetch feed' });
  }
};

// Posts
export const createPost = async (req: AuthenticatedRequest, res: Response): Promise<void> => {
  try {
    const { content } = req.body;
    const userId = req.user?.id;

    if (!userId) {
      res.status(401).json({ error: 'Authentication required' });
      return;
    }

    let media: string[] = [];

    // Handle file upload if present
    if (req.file) {
      const url = await uploadToStorage(req.file);
      media = [url];
    }

    const post = await Post.create({
      userId,
      content: content || '',
      media,
      likesCount: 0,
      commentsCount: 0,
      sharesCount: 0,
      status: 'active',
      moderationReason: null,
      moderatedBy: null,
      moderatedAt: null
    });

    const user = await User.findById(userId);

    res.status(201).json({
      id: post.id,
      userId: post.userId,
      username: user?.username || 'Unknown User',
      userAvatar: user?.profileImage,
      content: post.content,
      media: post.media,
      likesCount: post.likesCount,
      commentsCount: post.commentsCount,
      sharesCount: post.sharesCount,
      isLiked: false,
      createdAt: post.createdAt.toISOString()
    });
  } catch (error) {
    console.error('Error creating post:', error);
    res.status(500).json({ error: 'Failed to create post' });
  }
};

export const likePost = async (req: AuthenticatedRequest, res: Response): Promise<void> => {
  try {
    const { postId } = req.params;
    const userId = req.user?.id;

    if (!postId || !userId) {
      res.status(400).json({ error: 'Missing required parameters' });
      return;
    }

    // Check if already liked
    const existingLike = await Like.findByUserAndPost(userId, postId);
    if (existingLike) {
      res.status(400).json({ error: 'Already liked this post' });
      return;
    }

    await Like.create({
      userId,
      postId,
      updatedAt: new Date()
    });

    const post = await Post.findByPk(postId);
    if (post) {
      await post.update({ likesCount: (post.likesCount || 0) + 1 });
    }

    res.status(200).json({ message: 'Post liked successfully' });
  } catch (error) {
    console.error('Error liking post:', error);
    res.status(500).json({ error: 'Failed to like post' });
  }
};

export const unlikePost = async (req: AuthenticatedRequest, res: Response): Promise<void> => {
  try {
    const { postId } = req.params;
    const userId = req.user?.id;

    if (!postId || !userId) {
      res.status(400).json({ error: 'Missing required parameters' });
      return;
    }

    const like = await Like.findByUserAndPost(userId, postId);
    if (!like) {
      res.status(404).json({ error: 'Like not found' });
      return;
    }

    await like.delete();

    const post = await Post.findByPk(postId);
    if (post) {
      await post.update({ likesCount: Math.max(0, (post.likesCount || 1) - 1) });
    }

    res.status(200).json({ message: 'Post unliked successfully' });
  } catch (error) {
    console.error('Error unliking post:', error);
    res.status(500).json({ error: 'Failed to unlike post' });
  }
};

export const sharePost = async (req: AuthenticatedRequest, res: Response): Promise<void> => {
  try {
    const { postId } = req.params;

    if (!postId) {
      res.status(400).json({ error: 'Post ID is required' });
      return;
    }

    const post = await Post.findByPk(postId);
    if (post) {
      await post.update({ sharesCount: (post.sharesCount || 0) + 1 });
    }

    res.status(200).json({ message: 'Post shared successfully' });
  } catch (error) {
    console.error('Error sharing post:', error);
    res.status(500).json({ error: 'Failed to share post' });
  }
};

// Comments
export const getComments = async (req: AuthenticatedRequest, res: Response): Promise<void> => {
  try {
    const { postId } = req.params;
    const userId = req.user?.id;
    const limit = 10;

    if (!postId) {
      res.status(400).json({ error: 'Post ID is required' });
      return;
    }

    const comments = await Comment.findByPostId({
      postId,
      limit: limit + 1
    });

    const hasMore = comments.length > limit;
    const formattedComments = await Promise.all(
      comments.slice(0, limit).map(async comment => {
        const user = await User.findById(comment.userId);
        const isLiked = userId ? await CommentLike.findByUserAndComment(userId, comment.id) : false;

        return {
          id: comment.id,
          userId: comment.userId,
          username: user?.username || 'Unknown User',
          userAvatar: user?.profileImage,
          content: comment.content,
          likesCount: comment.likesCount,
          isLiked: !!isLiked,
          createdAt: comment.createdAt.toISOString()
        };
      })
    );

    res.json({
      comments: formattedComments,
      hasMore,
      nextCursor: hasMore && comments.length > 0 ? comments[comments.length - 1].createdAt.toISOString() : null
    });
  } catch (error) {
    console.error('Error fetching comments:', error);
    res.status(500).json({ error: 'Failed to fetch comments' });
  }
};

export const createComment = async (req: AuthenticatedRequest, res: Response): Promise<void> => {
  try {
    const { postId } = req.params;
    const { content } = req.body;
    const userId = req.user?.id;

    if (!postId || !userId || !content) {
      res.status(400).json({ error: 'Missing required parameters' });
      return;
    }

    const comment = await Comment.create({
      userId,
      postId,
      parentId: null,
      content,
      likesCount: 0,
      status: 'active',
      moderationReason: null,
      moderatedBy: null,
      moderatedAt: null
    });

    const post = await Post.findByPk(postId);
    if (post) {
      await post.update({ commentsCount: (post.commentsCount || 0) + 1 });
    }

    const user = await User.findById(userId);

    res.status(201).json({
      id: comment.id,
      userId: comment.userId,
      username: user?.username || 'Unknown User',
      userAvatar: user?.profileImage,
      content: comment.content,
      likesCount: comment.likesCount,
      isLiked: false,
      createdAt: comment.createdAt.toISOString()
    });
  } catch (error) {
    console.error('Error creating comment:', error);
    res.status(500).json({ error: 'Failed to create comment' });
  }
};

export const likeComment = async (req: AuthenticatedRequest, res: Response): Promise<void> => {
  try {
    const { commentId } = req.params;
    const userId = req.user?.id;

    if (!commentId || !userId) {
      res.status(400).json({ error: 'Missing required parameters' });
      return;
    }

    // Check if already liked
    const existingLike = await CommentLike.findByUserAndComment(userId, commentId);
    if (existingLike) {
      res.status(400).json({ error: 'Already liked this comment' });
      return;
    }

    await CommentLike.create({
      userId,
      commentId,
      updatedAt: new Date()
    });

    const comment = await Comment.findByPk(commentId);
    if (comment) {
      await comment.update({ likesCount: (comment.likesCount || 0) + 1 });
    }

    res.status(200).json({ message: 'Comment liked successfully' });
  } catch (error) {
    console.error('Error liking comment:', error);
    res.status(500).json({ error: 'Failed to like comment' });
  }
};

export const unlikeComment = async (req: AuthenticatedRequest, res: Response): Promise<void> => {
  try {
    const { commentId } = req.params;
    const userId = req.user?.id;

    if (!commentId || !userId) {
      res.status(400).json({ error: 'Missing required parameters' });
      return;
    }

    const like = await CommentLike.findByUserAndComment(userId, commentId);
    if (!like) {
      res.status(404).json({ error: 'Like not found' });
      return;
    }

    await like.delete();

    const comment = await Comment.findByPk(commentId);
    if (comment) {
      await comment.update({ likesCount: Math.max(0, (comment.likesCount || 1) - 1) });
    }

    res.status(200).json({ message: 'Comment unliked successfully' });
  } catch (error) {
    console.error('Error unliking comment:', error);
    res.status(500).json({ error: 'Failed to unlike comment' });
  }
};

export const replyToComment = async (req: AuthenticatedRequest, res: Response): Promise<void> => {
  try {
    const { commentId } = req.params;
    const { content } = req.body;
    const userId = req.user?.id;

    if (!commentId || !userId || !content) {
      res.status(400).json({ error: 'Missing required parameters' });
      return;
    }

    const parentComment = await Comment.findByPk(commentId);
    if (!parentComment) {
      res.status(404).json({ error: 'Parent comment not found' });
      return;
    }

    const reply = await Comment.create({
      userId,
      postId: parentComment.postId,
      parentId: commentId,
      content,
      likesCount: 0,
      status: 'active',
      moderationReason: null,
      moderatedBy: null,
      moderatedAt: null
    });

    const post = await Post.findByPk(parentComment.postId);
    if (post) {
      await post.update({ commentsCount: (post.commentsCount || 0) + 1 });
    }

    const user = await User.findById(userId);

    res.status(201).json({
      id: reply.id,
      userId: reply.userId,
      username: user?.username || 'Unknown User',
      userAvatar: user?.profileImage,
      content: reply.content,
      likesCount: reply.likesCount,
      isLiked: false,
      createdAt: reply.createdAt.toISOString()
    });
  } catch (error) {
    console.error('Error replying to comment:', error);
    res.status(500).json({ error: 'Failed to reply to comment' });
  }
}; 
================================================================================
File: controllers\stream.controller.ts
Lines: 137
--------------------------------------------------------------------------------
import fs from 'fs';

import { Request, Response } from 'express';
import rangeParser from 'range-parser';

import { Track } from '../models';

interface TrackModel extends Track {
  playCount: number;
  fileUrl: string;
  save(): Promise<TrackModel>;
}

interface StreamRequest extends Request {
  params: {
    trackId: string;
  };
  headers: {
    range?: string;
  };
}

interface StreamResponse extends Response {
  set(field: Record<string, string>): this;
  set(field: string, value?: string | string[]): this;
}

class StreamController {
  /**
   * Stream an audio file with support for range requests (important for seeking)
   */
  async streamAudio(req: StreamRequest, res: StreamResponse): Promise<void> {
    try {
      const trackId = req.params.trackId;
      
      // Get track from database
      const track = await Track.findByPk(trackId) as TrackModel;
      if (!track) {
        res.status(404).json({ error: 'Track not found' });
        return;
      }
      
      // Get file path
      const filePath = track.fileUrl;
      if (!fs.existsSync(filePath)) {
        res.status(404).json({ error: 'Audio file not found' });
        return;
      }
      
      // Get file stats
      const stat = fs.statSync(filePath);
      const fileSize = stat.size;
      const mimeType = 'audio/mpeg'; // assuming MP3 format
      
      // Handle range requests (for seeking)
      const rangeHeader = req.headers.range;
      
      if (rangeHeader) {
        // Parse range
        const ranges = rangeParser(fileSize, rangeHeader);
        
        // Handle invalid range
        if (ranges === -1 || ranges === -2) {
          res.status(416).json({ error: 'Range Not Satisfiable' });
          return;
        }
        
        // We'll handle just the first range for simplicity
        const range = ranges[0];
        
        // Create read stream with range
        const stream = fs.createReadStream(filePath, { start: range.start, end: range.end });
        
        // Send partial content
        res.status(206);
        res.set({
          'Content-Range': `bytes ${range.start}-${range.end}/${fileSize}`,
          'Accept-Ranges': 'bytes',
          'Content-Length': (range.end - range.start + 1).toString(),
          'Content-Type': mimeType,
        });
          
        // Pipe stream to response
        stream.pipe(res);
      } else {
        // Send full file
        res.set({
          'Content-Length': fileSize.toString(),
          'Content-Type': mimeType,
          'Accept-Ranges': 'bytes',
        });
        
        // Create read stream
        const stream = fs.createReadStream(filePath);
        
        // Pipe stream to response
        stream.pipe(res);
      }
      
      // Update play count
      track.playCount += 1;
      await track.save();
      
    } catch (error) {
      console.error('Error streaming audio:', error);
      res.status(500).json({ error: 'Failed to stream audio' });
    }
  }
  
  /**
   * Generate a waveform representation for a track
   */
  async getWaveform(req: StreamRequest, res: Response): Promise<void> {
    try {
      const trackId = req.params.trackId;
      
      // Get track from database
      const track = await Track.findByPk(trackId) as TrackModel;
      if (!track) {
        res.status(404).json({ error: 'Track not found' });
        return;
      }
      
      // Return mock waveform data for now
      // In production, you would generate this when the track is uploaded and save to DB
      const waveformData = Array.from({ length: 100 }, () => Math.random());
      
      res.json({ waveform: waveformData });
      
    } catch (error) {
      console.error('Error getting waveform:', error);
      res.status(500).json({ error: 'Failed to get waveform' });
    }
  }
}

export default StreamController; 
================================================================================
File: database\BaseRepository.ts
Lines: 209
--------------------------------------------------------------------------------
import { Pool } from 'pg';

import { Logger } from '../services/LoggerService';

import { DatabaseConnectionManager } from './config';

export interface BaseModel {
  id: string;
  createdAt: Date;
  updatedAt: Date;
}

export abstract class BaseRepository<T extends BaseModel> {
  protected abstract tableName: string;
  protected abstract columns: string[];
  protected logger: Logger;

  constructor() {
    this.logger = new Logger(this.constructor.name);
  }

  /**
   * Convert an object to SQL parameters for prepared statements
   */
  protected objectToParams(obj: Partial<T>, startIndex: number = 1): [string[], (string | number | boolean | Date | null)[]] {
    const values: (string | number | boolean | Date | null)[] = [];
    const placeholders: string[] = [];
    
    Object.entries(obj).forEach(([_key, value], index) => {
      if (value !== undefined && (
        typeof value === 'string' ||
        typeof value === 'number' ||
        typeof value === 'boolean' ||
        value instanceof Date ||
        value === null
      )) {
        values.push(value as string | number | boolean | Date | null);
        placeholders.push(`$${startIndex + index}`);
      }
    });
    
    return [placeholders, values];
  }

  /**
   * Find a record by its ID
   */
  async findById(id: string, client?: Pool): Promise<T | null> {
    const query = `
      SELECT ${this.columns.join(', ')}
      FROM ${this.tableName}
      WHERE id = $1
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query<T>(query, [id]);
      return result.rows[0] as T | null;
    } catch (error) {
      this.logger.error('Error in findById', { id, error });
      throw error;
    }
  }

  /**
   * Find all records matching the given criteria
   */
  async findAll(
    where: Partial<T> = {},
    options: {
      limit?: number;
      offset?: number;
      orderBy?: string;
      client?: Pool;
    } = {}
  ): Promise<T[]> {
    const conditions: string[] = [];
    const values: (string | number | boolean | Date | null)[] = [];
    let paramIndex = 1;

    Object.entries(where).forEach(([key, value]) => {
      if (value !== undefined) {
        conditions.push(`${key} = $${paramIndex}`);
        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean' || value instanceof Date || value === null) {
          values.push(value as string | number | boolean | Date | null);
          paramIndex++;
        }
      }
    });

    const query = `
      SELECT ${this.columns.join(', ')}
      FROM ${this.tableName}
      ${conditions.length ? 'WHERE ' + conditions.join(' AND ') : ''}
      ${options.orderBy ? `ORDER BY ${options.orderBy}` : ''}
      ${options.limit ? `LIMIT $${paramIndex++}` : ''}
      ${options.offset ? `OFFSET $${paramIndex}` : ''}
    `;

    if (options.limit) values.push(options.limit);
    if (options.offset) values.push(options.offset);

    try {
      const result = await (options.client || DatabaseConnectionManager.getPool()).query<T>(query, values);
      return result.rows;
    } catch (error) {
      this.logger.error('Error in findAll', { where, options, error });
      throw error;
    }
  }

  /**
   * Create a new record
   */
  async create(data: Partial<T>, client?: Pool): Promise<T> {
    const [placeholders, values] = this.objectToParams(data);
    const columns = Object.keys(data).join(', ');

    const query = `
      INSERT INTO ${this.tableName} (${columns})
      VALUES (${placeholders.join(', ')})
      RETURNING ${this.columns.join(', ')}
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query<T>(query, values);
      return result.rows[0];
    } catch (error) {
      this.logger.error('Error in create', { data, error });
      throw error;
    }
  }

  /**
   * Update an existing record
   */
  async update(id: string, data: Partial<T>, client?: Pool): Promise<T> {
    const [placeholders, values] = this.objectToParams(data);
    const setClause = Object.keys(data)
      .map((key, index) => `${key} = ${placeholders[index]}`)
      .join(', ');

    const query = `
      UPDATE ${this.tableName}
      SET ${setClause}, updated_at = NOW()
      WHERE id = $${values.length + 1}
      RETURNING ${this.columns.join(', ')}
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query<T>(query, [...values, id]);
      return result.rows[0];
    } catch (error) {
      this.logger.error('Error in update', { id, data, error });
      throw error;
    }
  }

  /**
   * Delete a record
   */
  async delete(id: string, client?: Pool): Promise<boolean> {
    const query = `
      DELETE FROM ${this.tableName}
      WHERE id = $1
      RETURNING id
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query<T>(query, [id]);
      return result.rowCount != null && result.rowCount > 0;
    } catch (error) {
      this.logger.error('Error in delete', { id, error });
      throw error;
    }
  }

  /**
   * Count records matching the given criteria
   */
  async count(where: Partial<T> = {}, client?: Pool): Promise<number> {
    const conditions: string[] = [];
    const values: (string | number | boolean | Date | null)[] = [];
    let paramIndex = 1;

    Object.entries(where).forEach(([key, value]) => {
      if (value !== undefined) {
        conditions.push(`${key} = $${paramIndex}`);
        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean' || value instanceof Date || value === null) {
          values.push(value as string | number | boolean | Date | null);
          paramIndex++;
        }
      }
    });

    const query = `
      SELECT COUNT(*) as count
      FROM ${this.tableName}
      ${conditions.length ? 'WHERE ' + conditions.join(' AND ') : ''}
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query<{ count: string }>(query, values);
      return parseInt(result.rows[0].count);
    } catch (error) {
      this.logger.error('Error in count', { where, error });
      throw error;
    }
  }
} 
================================================================================
File: database\config.ts
Lines: 64
--------------------------------------------------------------------------------
// src/server/database/config.ts
import { Pool } from 'pg';

import { envConfig } from '../config/environment';
import { Logger } from '../services/LoggerService';

export class DatabaseConnectionManager {
  private static instance: DatabaseConnectionManager;
  private static pool: Pool | null = null;
  private static logger: Logger = new Logger('DatabaseConnectionManager');
  private static connected: boolean = false;

  private constructor() {}

  public static getInstance(): DatabaseConnectionManager {
    if (!DatabaseConnectionManager.instance) {
      DatabaseConnectionManager.instance = new DatabaseConnectionManager();
    }
    return DatabaseConnectionManager.instance;
  }

  public static async initialize(): Promise<void> {
    try {
      this.pool = new Pool({
        host: envConfig.DB_HOST,
        port: envConfig.DB_PORT,
        user: envConfig.DB_USER,
        password: envConfig.DB_PASSWORD,
        database: envConfig.DB_NAME,
        ssl: {
          rejectUnauthorized: false
        }
      });

      // Test the connection
      await this.pool.query('SELECT NOW()');
      this.connected = true;
      this.logger.info('Database connection established');
    } catch (error) {
      this.connected = false;
      this.logger.error('Failed to initialize database connection', { error });
      throw error;
    }
  }

  public static getPool(): Pool {
    if (!this.pool) {
      throw new Error('Database connection not initialized');
    }
    return this.pool;
  }

  public static isConnected(): boolean {
    return this.connected && this.pool !== null;
  }

  public static async closePool(): Promise<void> {
    if (this.pool) {
      await this.pool.end();
      this.pool = null;
      this.connected = false;
    }
  }
}
================================================================================
File: database\migrationConfig.ts
Lines: 18
--------------------------------------------------------------------------------
import path from 'path';

export const migrationConfig = {
  migrations_path: path.join(__dirname, 'migrations')
};

export function createMigrationTemplate(_name: string): string {
  return `import { MigrationFn } from 'node-pg-migrate';

export const up: MigrationFn = (pgm) => {
  // Add migration code here
};

export const down: MigrationFn = (pgm) => {
  // Add rollback code here
};
`;
} 
================================================================================
File: database\migrationManager.ts
Lines: 175
--------------------------------------------------------------------------------
// src/server/database/migrationManager.ts
import { readdir, readFile } from 'fs/promises';
import { join } from 'path';

import { Pool } from 'pg';

import { Logger } from '../services/LoggerService';

import { DatabaseConnectionManager } from './config';

export class MigrationManager {
  private logger: Logger;
  private pool: Pool;
  private migrationsPath = join(__dirname, 'migrations');

  constructor() {
    this.logger = new Logger('MigrationManager');
    this.pool = DatabaseConnectionManager.getPool();
  }

  /**
   * Create migrations table if it doesn't exist
   */
  async createMigrationsTable(): Promise<void> {
    const query = `
      CREATE TABLE IF NOT EXISTS migrations (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `;

    try {
      await this.pool.query(query);
    } catch (error) {
      this.logger.error('Failed to create migrations table', { error });
      throw error;
    }
  }

  /**
   * Get list of executed migrations
   */
  async getExecutedMigrations(): Promise<string[]> {
    const query = 'SELECT name FROM migrations ORDER BY id ASC';
    
    try {
      const result = await this.pool.query<{ name: string }>(query);
      return result.rows.map((row: { name: string }) => row.name);
    } catch (error) {
      this.logger.error('Failed to get executed migrations', { error });
      throw error;
    }
  }

  /**
   * Get list of pending migrations
   */
  private async getPendingMigrations(): Promise<string[]> {
    const files = await readdir(this.migrationsPath);
    const sqlFiles = files.filter(file => file.endsWith('.sql'));
    const executedMigrations = await this.getExecutedMigrations();
    
    return sqlFiles.filter(file => !executedMigrations.includes(file));
  }

  /**
   * Execute a single migration
   */
  private async executeMigration(filename: string): Promise<void> {
    const filePath = join(this.migrationsPath, filename);
    const sql = await readFile(filePath, 'utf8');

    const client = await this.pool.connect();

    try {
      await client.query('BEGIN');

      // Execute the migration
      await client.query(sql);

      // Record the migration
      await client.query(
        'INSERT INTO migrations (name) VALUES ($1)',
        [filename]
      );

      await client.query('COMMIT');
      this.logger.info(`Executed migration: ${filename}`);
    } catch (error) {
      await client.query('ROLLBACK');
      this.logger.error(`Error executing migration ${filename}:`, error);
      throw error;
    } finally {
      client.release();
    }
  }

  /**
   * Run all pending migrations
   */
  async migrate(): Promise<void> {
    await this.createMigrationsTable();
    const pendingMigrations = await this.getPendingMigrations();

    if (pendingMigrations.length === 0) {
      this.logger.info('No pending migrations');
      return;
    }

    this.logger.info(`Found ${pendingMigrations.length} pending migrations`);

    // Sort migrations by filename to ensure correct order
    pendingMigrations.sort();

    for (const migration of pendingMigrations) {
      await this.executeMigration(migration);
    }

    this.logger.info('All migrations completed successfully');
  }

  /**
   * Get migration status
   */
  async status(): Promise<{ executed: string[]; pending: string[] }> {
    await this.createMigrationsTable();
    const executed = await this.getExecutedMigrations();
    const pending = await this.getPendingMigrations();

    return { executed, pending };
  }

  async resetMigrations(): Promise<void> {
    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');
      await client.query('DROP TABLE IF EXISTS pgmigrations');
      await client.query('DROP TABLE IF EXISTS users, posts, comments, likes, follows CASCADE');
      await client.query('COMMIT');
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  async rollbackMigration(): Promise<void> {
    const client = await this.pool.connect();
    try {
      await client.query('BEGIN');
      const result = await client.query<{ name: string }>(
        'DELETE FROM migrations WHERE id = (SELECT MAX(id) FROM migrations) RETURNING name'
      );
      if (result.rows.length === 0) {
        this.logger.info('No migrations to roll back');
        await client.query('ROLLBACK');
        return;
      }
      const migrationName = result.rows[0].name;
      const downSql = await readFile(join(this.migrationsPath, `${migrationName}.down.sql`), 'utf8');
      await client.query(downSql);
      await client.query('COMMIT');
      this.logger.info(`Rolled back migration: ${migrationName}`);
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }
}

export default new MigrationManager();
================================================================================
File: database\transactionManager.ts
Lines: 69
--------------------------------------------------------------------------------
// src/server/database/transactionManager.ts
import { PoolClient } from 'pg';

import { DatabaseConnectionManager } from './config';

export type TransactionCallback<T> = (client: PoolClient) => Promise<T>;

export class TransactionManager {
  /**
   * Execute a callback within a transaction
   * @param callback Function to execute within the transaction
   * @returns Result of the callback
   */
  static async execute<T>(callback: TransactionCallback<T>): Promise<T> {
    const client = await DatabaseConnectionManager.getPool().connect();
    
    try {
      await client.query('BEGIN');
      const result = await callback(client);
      await client.query('COMMIT');
      return result;
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }

  /**
   * Execute multiple operations within a single transaction
   * @param operations Array of operations to perform
   * @returns Array of results from each operation
   */
  static async multiOperationTransaction<T>(
    operations: Array<TransactionCallback<T>>
  ): Promise<T[]> {
    return this.execute(async (client) => {
      const results: T[] = [];
      for (const operation of operations) {
        results.push(await operation(client));
      }
      return results;
    });
  }

  /**
   * Execute a read-only transaction
   * @param callback Function to execute within the transaction
   * @returns Result of the callback
   */
  static async readTransaction<T>(callback: TransactionCallback<T>): Promise<T> {
    const client = await DatabaseConnectionManager.getPool().connect();
    
    try {
      await client.query('BEGIN TRANSACTION READ ONLY');
      const result = await callback(client);
      await client.query('COMMIT');
      return result;
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  }
}

export default TransactionManager;
================================================================================
File: database\migrations\001_create_users_table.sql
Lines: 29
--------------------------------------------------------------------------------
-- Create users table
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  username VARCHAR(255) NOT NULL UNIQUE,
  email VARCHAR(255) NOT NULL UNIQUE,
  password VARCHAR(255) NOT NULL,
  display_name VARCHAR(255),
  bio TEXT,
  profile_image VARCHAR(255),
  banner_image VARCHAR(255),
  role VARCHAR(50) NOT NULL DEFAULT 'user',
  is_verified BOOLEAN NOT NULL DEFAULT false,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Create a trigger to automatically update updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = CURRENT_TIMESTAMP;
  RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_users_updated_at
  BEFORE UPDATE ON users
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column(); 
================================================================================
File: database\migrations\002_create_artists_table.sql
Lines: 19
--------------------------------------------------------------------------------
-- Create artists table
CREATE TABLE artists (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255) NOT NULL,
  bio TEXT,
  profile_image_url VARCHAR(255),
  banner_image_url VARCHAR(255),
  verified BOOLEAN NOT NULL DEFAULT false,
  followers_count INTEGER NOT NULL DEFAULT 0,
  user_id UUID UNIQUE REFERENCES users(id) ON DELETE SET NULL,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Create a trigger to automatically update updated_at
CREATE TRIGGER update_artists_updated_at
  BEFORE UPDATE ON artists
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column(); 
================================================================================
File: database\migrations\003_create_albums_table.sql
Lines: 24
--------------------------------------------------------------------------------
-- Create albums table
CREATE TABLE albums (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  title VARCHAR(255) NOT NULL,
  cover_art_url VARCHAR(255),
  release_date TIMESTAMP WITH TIME ZONE,
  genre VARCHAR(100),
  is_public BOOLEAN NOT NULL DEFAULT true,
  track_count INTEGER NOT NULL DEFAULT 0,
  artist_id UUID NOT NULL REFERENCES artists(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Create indexes
CREATE INDEX idx_albums_artist_id ON albums(artist_id);
CREATE INDEX idx_albums_release_date ON albums(release_date);
CREATE INDEX idx_albums_genre ON albums(genre);

-- Create a trigger to automatically update updated_at
CREATE TRIGGER update_albums_updated_at
  BEFORE UPDATE ON albums
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column(); 
================================================================================
File: database\migrations\004_create_tracks_table.sql
Lines: 31
--------------------------------------------------------------------------------
-- Create tracks table
CREATE TABLE tracks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  title VARCHAR(255) NOT NULL,
  duration INTEGER NOT NULL,
  file_url VARCHAR(255) NOT NULL,
  file_size INTEGER NOT NULL,
  file_type VARCHAR(50) NOT NULL,
  cover_art_url VARCHAR(255),
  release_date TIMESTAMP WITH TIME ZONE,
  genre VARCHAR(100),
  is_public BOOLEAN NOT NULL DEFAULT true,
  play_count INTEGER NOT NULL DEFAULT 0,
  artist_id UUID NOT NULL REFERENCES artists(id) ON DELETE CASCADE,
  album_id UUID REFERENCES albums(id) ON DELETE SET NULL,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Create indexes
CREATE INDEX idx_tracks_artist_id ON tracks(artist_id);
CREATE INDEX idx_tracks_album_id ON tracks(album_id);
CREATE INDEX idx_tracks_release_date ON tracks(release_date);
CREATE INDEX idx_tracks_genre ON tracks(genre);
CREATE INDEX idx_tracks_play_count ON tracks(play_count);

-- Create a trigger to automatically update updated_at
CREATE TRIGGER update_tracks_updated_at
  BEFORE UPDATE ON tracks
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column(); 
================================================================================
File: database\migrations\005_create_playlists_table.sql
Lines: 23
--------------------------------------------------------------------------------
-- Create playlists table
CREATE TABLE playlists (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255) NOT NULL,
  description TEXT,
  cover_art_url VARCHAR(255),
  is_public BOOLEAN NOT NULL DEFAULT true,
  track_count INTEGER NOT NULL DEFAULT 0,
  followers_count INTEGER NOT NULL DEFAULT 0,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Create indexes
CREATE INDEX idx_playlists_user_id ON playlists(user_id);
CREATE INDEX idx_playlists_followers_count ON playlists(followers_count);

-- Create a trigger to automatically update updated_at
CREATE TRIGGER update_playlists_updated_at
  BEFORE UPDATE ON playlists
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column(); 
================================================================================
File: database\migrations\006_create_playlist_tracks_table.sql
Lines: 25
--------------------------------------------------------------------------------
-- Create playlist_tracks table
CREATE TABLE playlist_tracks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  playlist_id UUID NOT NULL REFERENCES playlists(id) ON DELETE CASCADE,
  track_id UUID NOT NULL REFERENCES tracks(id) ON DELETE CASCADE,
  order_position INTEGER NOT NULL,
  added_by UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Create indexes
CREATE INDEX idx_playlist_tracks_playlist_id ON playlist_tracks(playlist_id);
CREATE INDEX idx_playlist_tracks_track_id ON playlist_tracks(track_id);
CREATE INDEX idx_playlist_tracks_added_by ON playlist_tracks(added_by);
CREATE INDEX idx_playlist_tracks_order ON playlist_tracks(order_position);

-- Create unique constraint to prevent duplicate tracks in a playlist
CREATE UNIQUE INDEX idx_playlist_tracks_unique ON playlist_tracks(playlist_id, track_id);

-- Create a trigger to automatically update updated_at
CREATE TRIGGER update_playlist_tracks_updated_at
  BEFORE UPDATE ON playlist_tracks
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column(); 
================================================================================
File: database\migrations\007_create_social_tables.sql
Lines: 77
--------------------------------------------------------------------------------
-- Create follows table
CREATE TABLE follows (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  follower_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  following_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(follower_id, following_id)
);

-- Create indexes for follows
CREATE INDEX idx_follows_follower_id ON follows(follower_id);
CREATE INDEX idx_follows_following_id ON follows(following_id);

-- Create posts table
CREATE TABLE posts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  media_type VARCHAR(50),
  media_url VARCHAR(255),
  media_thumbnail VARCHAR(255),
  likes_count INTEGER NOT NULL DEFAULT 0,
  comments_count INTEGER NOT NULL DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Create indexes for posts
CREATE INDEX idx_posts_user_id ON posts(user_id);
CREATE INDEX idx_posts_created_at ON posts(created_at);

-- Create a trigger to automatically update updated_at for posts
CREATE TRIGGER update_posts_updated_at
  BEFORE UPDATE ON posts
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Create comments table
CREATE TABLE comments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  post_id UUID NOT NULL REFERENCES posts(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  likes_count INTEGER NOT NULL DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- Create indexes for comments
CREATE INDEX idx_comments_post_id ON comments(post_id);
CREATE INDEX idx_comments_user_id ON comments(user_id);
CREATE INDEX idx_comments_created_at ON comments(created_at);

-- Create a trigger to automatically update updated_at for comments
CREATE TRIGGER update_comments_updated_at
  BEFORE UPDATE ON comments
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Create likes table
CREATE TABLE likes (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  post_id UUID REFERENCES posts(id) ON DELETE CASCADE,
  comment_id UUID REFERENCES comments(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
  CONSTRAINT likes_target_check CHECK (
    (post_id IS NOT NULL AND comment_id IS NULL) OR
    (post_id IS NULL AND comment_id IS NOT NULL)
  ),
  UNIQUE(user_id, post_id, comment_id)
);

-- Create indexes for likes
CREATE INDEX idx_likes_user_id ON likes(user_id);
CREATE INDEX idx_likes_post_id ON likes(post_id);
CREATE INDEX idx_likes_comment_id ON likes(comment_id); 
================================================================================
File: database\migrations\008_add_email_verification.sql
Lines: 10
--------------------------------------------------------------------------------
-- Add email verification fields to users table

ALTER TABLE users
ADD COLUMN email_confirmed BOOLEAN DEFAULT FALSE,
ADD COLUMN email_token VARCHAR(255),
ADD COLUMN email_token_expire TIMESTAMP,
ADD COLUMN last_email_sent TIMESTAMP;

-- Add index for email token lookups
CREATE INDEX idx_users_email_token ON users(email_token); 
================================================================================
File: database\migrations\008_update_users_table.sql
Lines: 22
--------------------------------------------------------------------------------
-- Add first_name and last_name columns to users table
ALTER TABLE users ADD COLUMN first_name VARCHAR(100);
ALTER TABLE users ADD COLUMN last_name VARCHAR(100);

-- Update existing users to have first_name and last_name based on display_name
-- This splits display_name on the first space and uses the parts as first_name and last_name
UPDATE users 
SET 
  first_name = CASE 
    WHEN display_name IS NULL THEN NULL
    WHEN position(' ' in display_name) = 0 THEN display_name
    ELSE substring(display_name from 1 for position(' ' in display_name) - 1)
  END,
  last_name = CASE
    WHEN display_name IS NULL THEN NULL
    WHEN position(' ' in display_name) = 0 THEN NULL
    ELSE substring(display_name from position(' ' in display_name) + 1)
  END;

-- Create indexes for the new columns
CREATE INDEX idx_users_first_name ON users(first_name);
CREATE INDEX idx_users_last_name ON users(last_name); 
================================================================================
File: errors\UnauthorizedError.ts
Lines: 6
--------------------------------------------------------------------------------
export class UnauthorizedError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'UnauthorizedError';
  }
} 
================================================================================
File: helpers\fileHelpers.ts
Lines: 36
--------------------------------------------------------------------------------
import { ServerConfig } from "../services/ServerConfig"

import { createSignature } from "./signatureHelpers"

export type FileSignatureData = {
	method: "get" | "put"
	id: string
	filename: string
	expirationMs: number
}

export function normalizeFilename(filename: string) {
	// Replace non-alphanumeric stuff with _.
	filename = filename.replace(/[^a-zA-Z0-9\s\-_.]+/g, "_")

	// Lowercase extension because that gets annoying.
	const [ext, ...rest] = filename.split(".").reverse()
	filename = [...rest.reverse(), ext.toLowerCase()].join(".")

	return filename
}

export function getSignedFileUrl(
	environment: { config: ServerConfig },
	data: FileSignatureData
) {
	const secretKey = environment.config.signatureSecret

	const { id, filename, expirationMs } = data
	const signature = createSignature({ data, secretKey })

	const url = new URL(`${environment.config.baseUrl}/uploads/${id}/${filename}`)
	url.searchParams.set("expiration", expirationMs.toString())
	url.searchParams.set("signature", signature)
	return url
}

================================================================================
File: helpers\loginHelpers.ts
Lines: 55
--------------------------------------------------------------------------------
import { scrypt } from "crypto"

import type { Request, Response } from "express"

import { ServerConfig } from "../services/ServerConfig"
import { ServerEnvironment } from "../services/ServerEnvironment"

export async function getPasswordHash(environment: { config: ServerConfig }, password: string) {
	const passwordHash = await new Promise<string>((resolve, reject) => {
		scrypt(password, environment.config.passwordSalt, 64, (error, hash) => {
			if (error) return reject(error)
			else resolve(hash.toString("base64"))
		})
	})
	return passwordHash
}

export function setAuthCookies(
	environment: ServerEnvironment,
	args: {
		authToken: string
		expiration: Date
		userId: string
	},
	res: Response
) {
	const { config } = environment
	const { authToken, expiration, userId } = args

	// Set the cookie on the response.
	res.cookie("authToken", authToken, {
		secure: config.production,
		httpOnly: true,
		expires: expiration,
		domain: config.production ? (typeof config.corsOrigin === 'string' ? config.corsOrigin : undefined) : undefined,
	})

	// Set the current logged in userId so the client knows.
	res.cookie("userId", userId, {
		secure: config.production,
		httpOnly: false,
		expires: expiration,
		domain: config.production ? (typeof config.corsOrigin === 'string' ? config.corsOrigin : undefined) : undefined,
	})
}

export function getAuthTokenCookie(req: Request & { cookies: { [key: string]: string | undefined } }): string | undefined {
	const cookies = req.cookies as { [key: string]: string | undefined };
	return cookies['authToken'];
}

export function clearAuthCookies(res: Response) {
	res.clearCookie("authToken")
	res.clearCookie("userId")
}

================================================================================
File: helpers\path.ts
Lines: 9
--------------------------------------------------------------------------------
import * as p from "path"

/** This is a utility function for specifying the path of a file based on the
 * root directory of this repo */
function rootPath(...str: string[]) {
	return p.join(__dirname, "../../..", ...str)
}

export const path: typeof rootPath & typeof p = Object.assign(rootPath, p)

================================================================================
File: helpers\signatureHelpers.ts
Lines: 40
--------------------------------------------------------------------------------
import { createHmac, timingSafeEqual } from "crypto"

type Data = { [key: string]: string | number }

export function createSignature(args: { data: string | Data; secretKey: Buffer }) {
	const { data, secretKey } = args
	const str = typeof data === "string" ? data : serialize(data)
	const hmac = createHmac("sha512", secretKey)
	hmac.update(str)
	return hmac.digest("base64")
}

export function verifySignature(args: {
	data: string | Data
	signature: string
	secretKey: Buffer
}): boolean {
	const { data, signature, secretKey } = args
	const validSignature = createSignature({ data, secretKey })
	
	// Convert strings to buffers for timingSafeEqual
	const validBuffer = Buffer.from(validSignature, 'utf8')
	const signatureBuffer = Buffer.from(signature, 'utf8')
	
	// Ensure buffers are the same length (required by timingSafeEqual)
	if (validBuffer.length !== signatureBuffer.length) {
		return false
	}
	
	// Use Node.js's native timing-safe comparison
	return timingSafeEqual(validBuffer, signatureBuffer)
}

function serialize(data: Data) {
	return JSON.stringify(
		Object.keys(data)
			.sort()
			.map((key) => [key, data[key]])
	)
}

================================================================================
File: lib\database.ts
Lines: 100
--------------------------------------------------------------------------------
import { EventEmitter } from 'events';

import { Pool, PoolClient } from 'pg';

import { env } from '../config/environment';
import { Logger } from '../services/LoggerService';

const logger = new Logger('Database');

let pool: Pool;

export function getPool(): Pool {
  if (!pool) {
    pool = new Pool({
      user: env.DB_USER,
      password: env.DB_PASSWORD,
      host: env.DB_HOST,
      port: Number(env.DB_PORT),
      database: env.DB_NAME,
      ssl: env.NODE_ENV === 'production' ? {
        rejectUnauthorized: false
      } : undefined,
      max: 20, // Maximum number of clients in the pool
      idleTimeoutMillis: 30000, // Close idle clients after 30 seconds
      connectionTimeoutMillis: 2000 // Return an error after 2 seconds if connection could not be established
    });

    // Handle pool events using the pool as an EventEmitter
    (pool as unknown as EventEmitter).on('connect', (_client: PoolClient) => {
      logger.info('New client connected to database');
    });

    (pool as unknown as EventEmitter).on('error', (err: Error) => {
      logger.error('Unexpected error on idle client', err);
    });
  }
  return pool;
}

export async function initializeDatabase(): Promise<boolean> {
  try {
    const pool = getPool();
    
    // Test database connection
    const client = await pool.connect();
    try {
      await client.query('SELECT NOW()');
      logger.info('Database connection established successfully.');
    } finally {
      client.release();
    }

    // Run migrations
    // Note: Migrations should be handled separately using a migration tool
    // like node-pg-migrate or a custom migration system

    return true;
  } catch (error) {
    logger.error('Unable to initialize database:', error);
    throw error;
  }
}

export async function closeDatabase(): Promise<void> {
  try {
    if (pool) {
      await pool.end();
      logger.info('Database connection closed successfully.');
    }
  } catch (error) {
    logger.error('Error closing database connection:', error);
    throw error;
  }
}

// Helper function to get a client from the pool with error handling
export async function withClient<T>(callback: (client: PoolClient) => Promise<T>): Promise<T> {
  const client = await getPool().connect();
  try {
    return await callback(client);
  } finally {
    client.release();
  }
}

// Transaction helper function
export async function withTransaction<T>(callback: (client: PoolClient) => Promise<T>): Promise<T> {
  const client = await getPool().connect();
  try {
    await client.query('BEGIN');
    const result = await callback(client);
    await client.query('COMMIT');
    return result;
  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
} 
================================================================================
File: lib\storage.ts
Lines: 51
--------------------------------------------------------------------------------
import crypto from 'crypto';
import fs, { promises as fsPromises } from 'fs';
import path from 'path';

// Define a generic storage interface
export interface StorageProvider {
  uploadFile(file: Express.Multer.File): Promise<string>;
  getFileUrl(filename: string): string;
}

// Local file storage implementation
export class LocalFileStorage implements StorageProvider {
  private uploadDir: string;
  private baseUrl: string;

  constructor(uploadDir = 'uploads', baseUrl = '/uploads') {
    this.uploadDir = path.resolve(process.cwd(), uploadDir);
    this.baseUrl = baseUrl;
    
    // Ensure upload directory exists
    fs.mkdirSync(this.uploadDir, { recursive: true });
  }

  async uploadFile(file: Express.Multer.File): Promise<string> {
    const fileExtension = path.extname(file.originalname);
    const fileName = `${crypto.randomUUID()}${fileExtension}`;
    const filePath = path.join(this.uploadDir, fileName);
    
    // Write file to disk
    await fsPromises.writeFile(filePath, file.buffer);
    
    // Return the URL to access the file
    return this.getFileUrl(fileName);
  }

  getFileUrl(filename: string): string {
    // Return a URL that can be used to access the file
    return `${this.baseUrl}/${filename}`;
  }
}

// Create and export a default storage provider
// This can be replaced with other implementations as needed
const storageProvider: StorageProvider = new LocalFileStorage();

// Export the uploadToStorage function for backward compatibility
export const uploadToStorage = async (file: Express.Multer.File): Promise<string> => {
  return storageProvider.uploadFile(file);
};

export default storageProvider; 
================================================================================
File: middleware\auth.ts
Lines: 78
--------------------------------------------------------------------------------
// src/server/middleware/auth.ts
import { Request, Response, NextFunction } from 'express';

import { UnauthorizedError, ForbiddenError } from '../../shared/errors/ApiError';
import { userRepository, UserAttributes } from '../models/User';
import { AuthTokenService } from '../services/AuthTokenService';
import { Logger } from '../services/LoggerService';

interface AuthUser extends UserAttributes {
  role: string;
}

interface AuthRequest extends Request {
  headers: {
    authorization?: string;
  };
  user?: AuthUser;
}

const logger = new Logger('AuthMiddleware');
const tokenService = AuthTokenService.getInstance();

/**
 * Authentication middleware
 * Verifies the JWT token and attaches the user to the request
 */
export const authenticate = async (
  req: AuthRequest,
  _res: Response,
  next: NextFunction
) => {
  try {
    // Get token from header
    const authHeader = req.headers.authorization;
    if (!authHeader?.startsWith('Bearer ')) {
      throw new UnauthorizedError('No token provided');
    }

    const token = authHeader.split(' ')[1];

    // Verify token
    const decoded = tokenService.verifyAccessToken(token);

    // Get user from database
    const user = await userRepository.findById(decoded.userId);
    if (!user) {
      throw new UnauthorizedError('User not found');
    }

    // Attach user and token to request
    req.user = user;
    req.token = token;
    next();
  } catch (error) {
    logger.error('Authentication error', { error });
    next(error);
  }
};

/**
 * Role-based authorization middleware
 * Checks if the user has the required role(s)
 * @param roles Array of allowed roles
 */
export const authorize = (...roles: string[]) => {
  return (req: AuthRequest, _res: Response, next: NextFunction) => {
    if (!req.user) {
      return next(new UnauthorizedError('Authentication required'));
    }
    
    if (roles.length > 0 && !roles.includes(req.user.role)) {
      return next(new ForbiddenError(`Role '${req.user.role}' not authorized to access this resource`));
    }
    
    next();
  };
};


================================================================================
File: middleware\authenticateJWT.ts
Lines: 72
--------------------------------------------------------------------------------
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

import { UnauthorizedError } from '../../shared/errors/ApiError';
import { env } from '../config/environment';
import { userRepository, UserAttributes } from '../models/User';
import { AuthTokenService } from '../services/AuthTokenService';

interface AuthRequest extends Request {
  headers: {
    authorization?: string;
  };
  user?: UserAttributes;
  token?: string;
}

/**
 * JWT Authentication middleware
 * Verifies the JWT token and attaches the user to the request
 */
export const authenticateJWT = async (
  req: AuthRequest,
  _res: Response,
  next: NextFunction
) => {
  try {
    // Get token from header
    const authHeader = req.headers.authorization;
    if (!authHeader?.startsWith('Bearer ')) {
      throw new UnauthorizedError('No token provided');
    }

    const token = authHeader.split(' ')[1];
    const tokenService = AuthTokenService.getInstance();

    // Check if token is blacklisted
    if ((tokenService as unknown as { isTokenBlacklisted(token: string): boolean }).isTokenBlacklisted(token)) {
      throw new UnauthorizedError('Token has been revoked');
    }

    // Verify token
    try {
      const decoded = jwt.verify(token, env.JWT_SECRET) as { id: string };
      
      // Get user from database
      const user = await userRepository.findById(decoded.id);
      if (!user) {
        throw new UnauthorizedError('User not found');
      }

      // Check if email is confirmed
      if (!user.emailConfirmed) {
        throw new UnauthorizedError('Email not confirmed');
      }

      // Attach user and token to request
      req.user = user;
      req.token = token;
      next();
    } catch (error) {
      if (error instanceof jwt.JsonWebTokenError) {
        throw new UnauthorizedError('Invalid token');
      }
      if (error instanceof jwt.TokenExpiredError) {
        throw new UnauthorizedError('Token expired');
      }
      throw error;
    }
  } catch (error) {
    next(error);
  }
}; 
================================================================================
File: middleware\customValidate.ts
Lines: 108
--------------------------------------------------------------------------------
import express, { Response, NextFunction } from 'express';
import { z } from 'zod';

import { Validator } from '../../shared/dataTypes';

import { ValidationFailedError } from './error';

type ZodValidator<T> = z.ZodType<T>;

interface ValidatedData<T> {
  body: T;
  query: Record<string, string>;
  params: Record<string, string>;
}

interface ValidatedRequest<T> extends express.Request {
  body: T;
  query: Record<string, string>;
  params: Record<string, string>;
}

function adaptZodValidator<T>(validator: ZodValidator<T>): Validator<T> {
  return {
    validate: (value: unknown) => {
      try {
        return validator.parse(value);
      } catch (error) {
        if (error instanceof z.ZodError) {
          const errorMessages = error.errors.map(err => 
            `${err.path.join('.')}: ${err.message}`
          );
          throw new Error(errorMessages.join(', '));
        }
        throw error;
      }
    }
  };
}

/**
 * Middleware to validate request data against a validator schema
 * @param schema Validator schema (can be either Zod schema or custom validator)
 * @param source Where to find the data to validate (body, query, params)
 */
export const customValidate = <T>(
  schema: ZodValidator<T> | Validator<T>,
  source: 'body' | 'query' | 'params' | 'all' = 'body'
) => {
  const validator = schema instanceof z.ZodType ? adaptZodValidator(schema) : schema;
  
  return (req: express.Request, _res: Response, next: NextFunction) => {
    try {
      const typedReq = req as ValidatedRequest<T>;
      let validatedData: T;
      let validatedStructure: ValidatedData<T>;
      
      switch (source) {
        case 'body':
          validatedData = validator.validate(typedReq.body);
          typedReq.body = validatedData;
          break;
        case 'query':
          validatedData = validator.validate(typedReq.query);
          typedReq.query = validatedData as Record<string, string>;
          break;
        case 'params':
          validatedData = validator.validate(typedReq.params);
          typedReq.params = validatedData as Record<string, string>;
          break;
        default:
          validatedStructure = validator.validate({
            body: typedReq.body,
            query: typedReq.query,
            params: typedReq.params
          }) as ValidatedData<T>;
          typedReq.body = validatedStructure.body;
          typedReq.query = validatedStructure.query;
          typedReq.params = validatedStructure.params;
          validatedData = validatedStructure.body;
      }
      
      next();
    } catch (error) {
      // Format the error message
      const errorMessage = (error as Error).message;
      const formattedErrors: Record<string, string[]> = {};
      
      // Parse Zod error messages which are already in field: message format
      const errorParts = errorMessage.split(', ');
      errorParts.forEach(part => {
        const [field, message] = part.split(': ');
        if (field && message) {
          if (!formattedErrors[field]) {
            formattedErrors[field] = [];
          }
          formattedErrors[field].push(message);
        } else {
          if (!formattedErrors['_error']) {
            formattedErrors['_error'] = [];
          }
          formattedErrors['_error'].push(part);
        }
      });
      
      next(new ValidationFailedError('Validation failed', formattedErrors));
    }
  };
};
================================================================================
File: middleware\error.ts
Lines: 158
--------------------------------------------------------------------------------
import { Request as ExpressRequest, Response as ExpressResponse, NextFunction as ExpressNextFunction, ErrorRequestHandler } from 'express';
import { JsonWebTokenError, TokenExpiredError } from 'jsonwebtoken';
import { DatabaseError } from 'pg';

import { Logger } from '../services/LoggerService';

interface ErrorResponse {
  status: string;
  message: string;
  errors?: Record<string, string[]>;
}

const logger = new Logger('ErrorHandler');

type Request = ExpressRequest;
type Response = ExpressResponse;
type NextFunction = ExpressNextFunction;

export class AppError extends Error {
  statusCode: number;
  status: string;
  isOperational: boolean;

  constructor(message: string, statusCode: number) {
    super(message);
    this.statusCode = statusCode;
    this.status = `${statusCode}`.startsWith('4') ? 'fail' : 'error';
    this.isOperational = true;

    Error.captureStackTrace(this, this.constructor);
  }
}

// Specific error types
export class NotFoundError extends AppError {
  constructor(message = 'Resource not found') {
    super(message, 404);
  }
}

export class UnauthorizedError extends AppError {
  constructor(message = 'Unauthorized access') {
    super(message, 401);
  }
}

export class ForbiddenError extends AppError {
  constructor(message = 'Forbidden access') {
    super(message, 403);
  }
}

export class ValidationFailedError extends AppError {
  errors: Record<string, string[]>;
  
  constructor(message = 'Validation failed', errors: Record<string, string[]> = {}) {
    super(message, 400);
    this.errors = errors;
  }
}

export interface ValidationErrorItem {
  path: string;
  message: string;
}

export class ValidationError extends Error {
  errors: ValidationErrorItem[];
  
  constructor(message: string, errors: ValidationErrorItem[]) {
    super(message);
    this.name = 'ValidationError';
    this.errors = errors;
  }
}

// Export the error handler with the correct Express ErrorRequestHandler type
export const errorHandler: ErrorRequestHandler = (
  err: Error | AppError | DatabaseError | ValidationError,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  // Log all errors
  logger.error(`${req.method} ${req.path} - ${err.message}`, err);

  // Handle AppError (our custom error)
  if (err instanceof AppError) {
    const response: ErrorResponse = {
      status: err.status,
      message: err.message
    };
    
    // Add validation errors if available
    if (err instanceof ValidationFailedError && Object.keys(err.errors).length > 0) {
      response.errors = err.errors;
    }
    
    res.status(err.statusCode).json(response);
    return next();
  }
  
  // Handle our custom validation errors
  if (err instanceof ValidationError) {
    const formattedErrors: Record<string, string[]> = {};
    
    err.errors.forEach((error) => {
      const path = error.path;
      if (!formattedErrors[path]) {
        formattedErrors[path] = [];
      }
      formattedErrors[path].push(error.message);
    });
    
    res.status(400).json({
      status: 'fail',
      message: 'Validation failed',
      errors: formattedErrors
    });
    return next();
  }
  
  // Handle JWT errors
  if (err instanceof JsonWebTokenError || err instanceof TokenExpiredError) {
    res.status(401).json({
      status: 'fail',
      message: err instanceof TokenExpiredError ? 'Token expired' : 'Invalid token'
    });
    return next();
  }
  
  // Handle PostgreSQL database errors
  if (err instanceof DatabaseError) {
    logger.error('Database error:', {
      code: err.code,
      detail: err.detail,
      table: err.table,
      constraint: err.constraint
    });

    res.status(500).json({
      status: 'error',
      message: process.env.NODE_ENV === 'production' 
        ? 'Database error occurred' 
        : err.message
    });
    return next();
  }

  // Handle all other errors
  res.status(500).json({
    status: 'error',
    message: process.env.NODE_ENV === 'production' 
      ? 'Something went wrong!' 
      : err.message || 'Unknown error'
  });
  return next();
};
================================================================================
File: middleware\errorHandler.ts
Lines: 7
--------------------------------------------------------------------------------
// src/server/middleware/errorHandler.ts
import { ErrorRequestHandler } from 'express';

import { errorHandler as enhancedErrorHandler } from './error';

// Re-export the enhanced error handler
export const errorHandler: ErrorRequestHandler = enhancedErrorHandler;
================================================================================
File: middleware\logger.ts
Lines: 158
--------------------------------------------------------------------------------
// src/server/middleware/logger.ts
import { RequestHandler, Request, Response } from 'express';
import winston from 'winston';

import { env } from '../config/environment';

// Configure winston logger
const logger = winston.createLogger({
  level: env.NODE_ENV === 'production' ? 'info' : 'debug',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.printf((info) => {
          const { level, message, timestamp, ...rest } = info;
          // Format the metadata with proper indentation
          let meta = '';
          if (Object.keys(rest).length > 0) {
            try {
              meta = '\n' + JSON.stringify(rest, null, 2);
            } catch (e) {
              meta = ' ' + JSON.stringify(rest);
            }
          }
          
          // Add visual separator for debug level
          const separator = level.includes('debug') ? 
            '\n----------------------------------------' : '';
            
          return `${String(timestamp)} ${String(level)}: ${String(message)}${meta}${separator}`;
        })
      )
    })
  ]
});

/**
 * Helper function to format objects for better readability
 */
const formatObject = (obj: unknown): string => {
  if (!obj) return '';
  
  try {
    // For strings that look like JSON, parse and then stringify with indentation
    if (typeof obj === 'string' && (obj.startsWith('{') || obj.startsWith('['))) {
      try {
        const parsed = JSON.parse(obj) as Record<string, unknown>;
        return JSON.stringify(parsed, null, 2);
      } catch {
        // If parsing fails, treat as regular string
        return obj;
      }
    }
    
    // For objects, stringify with indentation
    if (typeof obj === 'object') {
      return JSON.stringify(obj, null, 2);
    }
    
    // For other types, convert to string
    return String(obj);
  } catch (error) {
    return `[Unformattable object: ${(error as Error).message}]`;
  }
};

// Sanitize sensitive data from objects
const sanitizeData = (data: Record<string, unknown>): Record<string, unknown> => {
  if (!data) return data;
  const sanitized = { ...data };
  
  // Remove sensitive fields
  if (sanitized.password) sanitized.password = '***';
  if (sanitized.passwordConfirmation) sanitized.passwordConfirmation = '***';
  if (sanitized.token) sanitized.token = '***';
  if (sanitized.refreshToken) sanitized.refreshToken = '***';
  
  return sanitized;
};

// Request logger middleware
export const requestLogger: RequestHandler = (req: Request, res: Response, next) => {
  const start = Date.now();
  
  // Log request
  const logData = {
    method: String(req.method),
    url: String(req.url),
    body: sanitizeData(req.body as Record<string, unknown>),
    query: sanitizeData(req.query as Record<string, unknown>),
    ip: String(req.ip ?? ''),
    userAgent: String((req as { get(name: string): string | undefined }).get('user-agent') ?? '')
  };

  // Only log request body in development
  if (env.NODE_ENV === 'development') {
    logger.debug('Incoming request', logData);
  }

  // Log response when finished
  (res as { on(event: string, handler: () => void): void }).on('finish', (): void => {
    const duration = Date.now() - start;
    const responseData: Record<string, unknown> = {
      ...logData,
      status: res.statusCode,
      duration: `${duration}ms`,
      timestamp: new Date().toISOString()
    };

    // In production, only log errors (status >= 400)
    if (env.NODE_ENV === 'production' && res.statusCode >= 400) {
      logger.error('Request error', responseData);
    } else if (env.NODE_ENV === 'development') {
      logger.info('Request completed', responseData);
    }
  });

  next();
};

// Detailed logger middleware for development
export const detailedLogger: RequestHandler = (req: Request, res: Response, next) => {
  // Only log in development
  if (env.NODE_ENV !== 'development') {
    return next();
  }
  
  // Log request headers
  logger.debug('Request Headers:', { headers: req.headers as Record<string, string> });
  
  // Capture original methods with proper typing
  const originalSend = (res.send as { bind(res: Response): (body: unknown) => Response }).bind(res);
  const originalJson = (res.json as { bind(res: Response): (body: unknown) => Response }).bind(res);
  
  // Override send method to log response
  res.send = function(body?: unknown) {
    const sanitizedBody = sanitizeData(body as Record<string, unknown>);
    logger.debug('Response Body:', { 
      body: typeof sanitizedBody === 'string' ? sanitizedBody : formatObject(sanitizedBody) 
    });
    return originalSend(body);
  };
  
  // Override json method to log response
  res.json = function(body?: unknown) {
    const sanitizedBody = sanitizeData(body as Record<string, unknown>);
    logger.debug('Response JSON:', { 
      body: formatObject(sanitizedBody)
    });
    return originalJson(body);
  };
  
  next();
};
================================================================================
File: middleware\notFound.ts
Lines: 11
--------------------------------------------------------------------------------
import type { Request, Response, NextFunction } from 'express';

import { AppError } from './error';

export const notFoundHandler = (
  req: Request,
  _res: Response,
  next: NextFunction
) => {
  next(new AppError(`Can't find ${req.originalUrl} on this server!`, 404));
}; 
================================================================================
File: middleware\rateLimiter.ts
Lines: 84
--------------------------------------------------------------------------------
// src/server/middleware/rateLimiter.ts
import type { Request, Response, NextFunction } from 'express';

import { TooManyRequestsError } from '../../shared/errors/ApiError';
import { env } from '../config/environment';

interface RateLimitStore {
  [key: string]: {
    count: number;
    resetTime: number;
  };
}

interface RateLimitConfig {
  windowMs: number;
  maxRequests: number;
  message: string;
}

const stores: { [key: string]: RateLimitStore } = {};

const createLimiter = (config: RateLimitConfig, storeKey: string) => {
  if (!stores[storeKey]) {
    stores[storeKey] = {};
  }

  return (req: Request, res: Response, next: NextFunction) => {
    const ip = (req.ip || (req.socket as { remoteAddress?: string }).remoteAddress || 'unknown') as string;
    const now = Date.now();
    
    if (stores[storeKey][ip] && now > stores[storeKey][ip].resetTime) {
      delete stores[storeKey][ip];
    }
    
    if (!stores[storeKey][ip]) {
      stores[storeKey][ip] = {
        count: 1,
        resetTime: now + config.windowMs
      };
    } else {
      stores[storeKey][ip].count++;
    }
    
    if (stores[storeKey][ip].count > config.maxRequests) {
      return next(new TooManyRequestsError(config.message));
    }
    
    (res as { setHeader: (name: string, value: number) => void }).setHeader('X-RateLimit-Limit', config.maxRequests);
    (res as { setHeader: (name: string, value: number) => void }).setHeader('X-RateLimit-Remaining', Math.max(0, config.maxRequests - stores[storeKey][ip].count));
    (res as { setHeader: (name: string, value: number) => void }).setHeader('X-RateLimit-Reset', Math.ceil(stores[storeKey][ip].resetTime / 1000));
    
    next();
  };
};

// General API rate limiter
export const apiLimiter = createLimiter(
  {
    windowMs: 15 * 60 * 1000, // 15 minutes
    maxRequests: env.NODE_ENV === 'production' ? 100 : 1000,
    message: 'Too many requests, please try again later.'
  },
  'api'
);

// More restrictive limiter for auth endpoints
export const authLimiter = createLimiter(
  {
    windowMs: 60 * 60 * 1000, // 1 hour
    maxRequests: env.NODE_ENV === 'production' ? 10 : 100,
    message: 'Too many authentication attempts, please try again later.'
  },
  'auth'
);

// Media rate limiter
export const mediaLimiter = createLimiter(
  {
    windowMs: 60 * 1000, // 1 minute
    maxRequests: 10,
    message: 'Too many media requests, please try again later.'
  },
  'media'
);
================================================================================
File: middleware\upload.ts
Lines: 35
--------------------------------------------------------------------------------
import path from 'path';

import { Request } from 'express';
import multer from 'multer';

// Configure storage
const storage = multer.diskStorage({
  destination: (_req, _file, cb) => {
    cb(null, 'uploads/');
  },
  filename: (_req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
  }
});

// File filter
const fileFilter = (_req: Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
  const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'video/mp4', 'audio/mpeg'];
  
  if (allowedTypes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error('Invalid file type. Only JPEG, PNG, GIF, MP4, and MP3 files are allowed.'));
  }
};

// Create multer instance
export const upload = multer({
  storage: storage,
  fileFilter: fileFilter,
  limits: {
    fileSize: 100 * 1024 * 1024, // 100MB limit
  }
}); 
================================================================================
File: middleware\validate.ts
Lines: 78
--------------------------------------------------------------------------------
// src/server/middleware/validate.ts
import { Request, Response, NextFunction } from 'express';
import { ParsedQs } from 'qs';
import { AnyZodObject, ZodError } from 'zod';

import { ValidationFailedError } from './error';

type RequestData = {
  body: unknown;
  query: ParsedQs;
  params: Record<string, string>;
};

/**
 * Middleware to validate request data against a Zod schema
 * @param schema Zod schema to validate against
 * @param source Where to find the data to validate (body, query, params)
 */
export const validate = (
  schema: AnyZodObject,
  source: 'body' | 'query' | 'params' | 'all' = 'body'
) => {
  return async (req: Request, _res: Response, next: NextFunction) => {
    try {
      let dataToValidate: unknown;
      
      switch (source) {
        case 'body':
          dataToValidate = req.body;
          break;
        case 'query':
          dataToValidate = req.query;
          break;
        case 'params':
          dataToValidate = req.params;
          break;
        case 'all':
          dataToValidate = {
            body: req.body,
            query: req.query as ParsedQs,
            params: req.params as Record<string, string>
          } as RequestData;
          break;
      }
      
      const validatedData = await schema.parseAsync(dataToValidate);
      
      // Replace the request data with the validated data
      if (source === 'body') req.body = validatedData;
      else if (source === 'query') req.query = validatedData as ParsedQs;
      else if (source === 'params') req.params = validatedData as Record<string, string>;
      else if (source === 'all') {
        const data = validatedData as RequestData;
        req.body = data.body;
        req.query = data.query;
        req.params = data.params;
      }
      
      next();
    } catch (error) {
      if (error instanceof ZodError) {
        const formattedErrors: Record<string, string[]> = {};
        
        error.errors.forEach((err) => {
          const path = err.path.join('.');
          if (!formattedErrors[path]) {
            formattedErrors[path] = [];
          }
          formattedErrors[path].push(err.message);
        });
        
        next(new ValidationFailedError('Validation failed', formattedErrors));
      } else {
        next(error);
      }
    }
  };
};
================================================================================
File: models\Album.ts
Lines: 222
--------------------------------------------------------------------------------
import { Pool } from 'pg';

import { BaseModel, BaseRepository } from '../database/BaseRepository';
import { DatabaseConnectionManager } from '../database/config';

import { Artist } from './Artist';
import { Track } from './Track';

export interface AlbumAttributes extends BaseModel {
  title: string;
  coverArtUrl: string | null;
  releaseDate: Date | null;
  genre: string | null;
  isPublic: boolean;
  trackCount: number;
  artistId: string;
}

export class AlbumRepository extends BaseRepository<AlbumAttributes> {
  protected tableName = 'albums';
  protected columns = [
    'id',
    'title',
    'cover_art_url as coverArtUrl',
    'release_date as releaseDate',
    'genre',
    'is_public as isPublic',
    'track_count as trackCount',
    'artist_id as artistId',
    'created_at as createdAt',
    'updated_at as updatedAt'
  ];

  /**
   * Find albums by artist ID
   */
  async findByArtistId(artistId: string, client?: Pool): Promise<AlbumAttributes[]> {
    const query = `
      SELECT ${this.columns.join(', ')}
      FROM ${this.tableName}
      WHERE artist_id = $1
      ORDER BY release_date DESC NULLS LAST
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [artistId]);
      return result.rows as AlbumAttributes[];
    } catch (error) {
      this.logger.error('Error in findByArtistId', { artistId, error });
      throw error;
    }
  }

  /**
   * Find public albums by genre
   */
  async findByGenre(genre: string, client?: Pool): Promise<AlbumAttributes[]> {
    const query = `
      SELECT ${this.columns.join(', ')}
      FROM ${this.tableName}
      WHERE genre = $1 AND is_public = true
      ORDER BY release_date DESC NULLS LAST
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [genre]);
      return result.rows as AlbumAttributes[];
    } catch (error) {
      this.logger.error('Error in findByGenre', { genre, error });
      throw error;
    }
  }

  /**
   * Increment track count
   */
  async incrementTrackCount(id: string, client?: Pool): Promise<void> {
    const query = `
      UPDATE ${this.tableName}
      SET track_count = track_count + 1
      WHERE id = $1
    `;

    try {
      await (client || DatabaseConnectionManager.getPool()).query(query, [id]);
    } catch (error) {
      this.logger.error('Error in incrementTrackCount', { id, error });
      throw error;
    }
  }

  /**
   * Decrement track count
   */
  async decrementTrackCount(id: string, client?: Pool): Promise<void> {
    const query = `
      UPDATE ${this.tableName}
      SET track_count = GREATEST(track_count - 1, 0)
      WHERE id = $1
    `;

    try {
      await (client || DatabaseConnectionManager.getPool()).query(query, [id]);
    } catch (error) {
      this.logger.error('Error in decrementTrackCount', { id, error });
      throw error;
    }
  }
}

// Singleton instance
export const albumRepository = new AlbumRepository();

export class Album implements AlbumAttributes {
  static belongsTo(_Artist: typeof Artist, _options: { foreignKey: string; as: string; }) {
    throw new Error('Method not implemented.');
  }
  static hasMany(_Track: typeof Track, _options: { foreignKey: string; as: string; }) {
    throw new Error('Method not implemented.');
  }
  id: string;
  title: string;
  coverArtUrl: string | null;
  releaseDate: Date | null;
  genre: string | null;
  isPublic: boolean;
  trackCount: number;
  artistId: string;
  createdAt: Date;
  updatedAt: Date;

  constructor(data: AlbumAttributes) {
    this.id = data.id;
    this.title = data.title;
    this.coverArtUrl = data.coverArtUrl;
    this.releaseDate = data.releaseDate ? new Date(data.releaseDate) : null;
    this.genre = data.genre;
    this.isPublic = data.isPublic;
    this.trackCount = data.trackCount;
    this.artistId = data.artistId;
    this.createdAt = new Date(data.createdAt);
    this.updatedAt = new Date(data.updatedAt);
  }

  // Static methods that use the repository
  static async findByPk(id: string): Promise<Album | null> {
    const album = await albumRepository.findById(id);
    return album ? new Album(album) : null;
  }

  static async findByArtistId(artistId: string): Promise<Album[]> {
    const albums = await albumRepository.findByArtistId(artistId);
    return albums.map(album => new Album(album));
  }

  static async findByGenre(genre: string): Promise<Album[]> {
    const albums = await albumRepository.findByGenre(genre);
    return albums.map(album => new Album(album));
  }

  static async create(data: Omit<AlbumAttributes, 'id' | 'createdAt' | 'updatedAt'>): Promise<Album> {
    const { coverArtUrl, releaseDate, isPublic, trackCount, artistId, ...rest } = data;
    const album = await albumRepository.create({
      ...rest,
      cover_art_url: coverArtUrl,
      release_date: releaseDate,
      is_public: isPublic,
      track_count: trackCount,
      artist_id: artistId
    } as Partial<AlbumAttributes>);
    return new Album(album);
  }

  // Instance methods
  async update(data: Partial<AlbumAttributes>): Promise<Album> {
    const { coverArtUrl, releaseDate, isPublic, trackCount, artistId, ...rest } = data;
    const updateData = {
      ...rest,
      ...(coverArtUrl !== undefined && { cover_art_url: coverArtUrl }),
      ...(releaseDate !== undefined && { release_date: releaseDate }),
      ...(isPublic !== undefined && { is_public: isPublic }),
      ...(trackCount !== undefined && { track_count: trackCount }),
      ...(artistId !== undefined && { artist_id: artistId })
    };
    const updated = await albumRepository.update(this.id, updateData as Partial<AlbumAttributes>);
    Object.assign(this, updated);
    return this;
  }

  async delete(): Promise<boolean> {
    return albumRepository.delete(this.id);
  }

  async incrementTrackCount(): Promise<void> {
    await albumRepository.incrementTrackCount(this.id);
    this.trackCount++;
  }

  async decrementTrackCount(): Promise<void> {
    await albumRepository.decrementTrackCount(this.id);
    this.trackCount = Math.max(0, this.trackCount - 1);
  }

  async getArtist(): Promise<Artist | null> {
    return Artist.findByPk(this.artistId);
  }

  async getTracks(): Promise<Track[]> {
    return Track.findByAlbumId(this.id);
  }

  toJSON() {
    return {
      ...this,
      releaseDate: this.releaseDate?.toISOString() || null,
      createdAt: this.createdAt.toISOString(),
      updatedAt: this.updatedAt.toISOString()
    };
  }
}

export default Album; 
================================================================================
File: models\Artist.ts
Lines: 212
--------------------------------------------------------------------------------
import { Pool } from 'pg';

import { BaseModel, BaseRepository } from '../database/BaseRepository';
import { DatabaseConnectionManager } from '../database/config';

import { Album } from './Album';
import { userRepository, UserAttributes } from './User';

export interface ArtistAttributes extends BaseModel {
  name: string;
  bio: string | null;
  profileImageUrl: string | null;
  bannerImageUrl: string | null;
  verified: boolean;
  followersCount: number;
  userId: string | null;
}

export class ArtistRepository extends BaseRepository<ArtistAttributes> {
  protected tableName = 'artists';
  protected columns = [
    'id',
    'name',
    'bio',
    'profile_image_url as profileImageUrl',
    'banner_image_url as bannerImageUrl',
    'verified',
    'followers_count as followersCount',
    'user_id as userId',
    'created_at as createdAt',
    'updated_at as updatedAt'
  ];

  /**
   * Find an artist by their user ID
   */
  async findByUserId(userId: string, client?: Pool): Promise<ArtistAttributes | null> {
    const query = `
      SELECT ${this.columns.join(', ')}
      FROM ${this.tableName}
      WHERE user_id = $1
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [userId]);
      return (result.rows[0] || null) as ArtistAttributes | null;
    } catch (error) {
      this.logger.error('Error in findByUserId', { userId, error });
      throw error;
    }
  }

  /**
   * Find artists by verification status
   */
  async findByVerified(verified: boolean, client?: Pool): Promise<ArtistAttributes[]> {
    const query = `
      SELECT ${this.columns.join(', ')}
      FROM ${this.tableName}
      WHERE verified = $1
      ORDER BY name ASC
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [verified]);
      return result.rows as ArtistAttributes[];
    } catch (error) {
      this.logger.error('Error in findByVerified', { verified, error });
      throw error;
    }
  }

  /**
   * Increment followers count
   */
  async incrementFollowers(id: string, client?: Pool): Promise<void> {
    const query = `
      UPDATE ${this.tableName}
      SET followers_count = followers_count + 1
      WHERE id = $1
    `;

    try {
      await (client || DatabaseConnectionManager.getPool()).query(query, [id]);
    } catch (error) {
      this.logger.error('Error in incrementFollowers', { id, error });
      throw error;
    }
  }

  /**
   * Decrement followers count
   */
  async decrementFollowers(id: string, client?: Pool): Promise<void> {
    const query = `
      UPDATE ${this.tableName}
      SET followers_count = GREATEST(followers_count - 1, 0)
      WHERE id = $1
    `;

    try {
      await (client || DatabaseConnectionManager.getPool()).query(query, [id]);
    } catch (error) {
      this.logger.error('Error in decrementFollowers', { id, error });
      throw error;
    }
  }
}

// Singleton instance
export const artistRepository = new ArtistRepository();

export class Artist implements ArtistAttributes {
  static hasMany(_album: typeof Album, _options: { foreignKey: string; as: string; }) {
    throw new Error('Method not implemented.');
  }
  id: string;
  name: string;
  bio: string | null;
  profileImageUrl: string | null;
  bannerImageUrl: string | null;
  verified: boolean;
  followersCount: number;
  userId: string | null;
  createdAt: Date;
  updatedAt: Date;

  constructor(data: ArtistAttributes) {
    this.id = data.id;
    this.name = data.name;
    this.bio = data.bio;
    this.profileImageUrl = data.profileImageUrl;
    this.bannerImageUrl = data.bannerImageUrl;
    this.verified = data.verified;
    this.followersCount = data.followersCount;
    this.userId = data.userId;
    this.createdAt = new Date(data.createdAt);
    this.updatedAt = new Date(data.updatedAt);
  }

  // Static methods that use the repository
  static async findByPk(id: string): Promise<Artist | null> {
    const artist = await artistRepository.findById(id);
    return artist ? new Artist(artist) : null;
  }

  static async findByUserId(userId: string): Promise<Artist | null> {
    const artist = await artistRepository.findByUserId(userId);
    return artist ? new Artist(artist) : null;
  }

  static async findVerified(): Promise<Artist[]> {
    const artists = await artistRepository.findByVerified(true);
    return artists.map(artist => new Artist(artist));
  }

  static async create(data: Omit<ArtistAttributes, 'id' | 'createdAt' | 'updatedAt'>): Promise<Artist> {
    const { profileImageUrl, bannerImageUrl, followersCount, userId, ...rest } = data;
    const artist = await artistRepository.create({
      ...rest,
      profile_image_url: profileImageUrl,
      banner_image_url: bannerImageUrl,
      followers_count: followersCount,
      user_id: userId
    } as Partial<ArtistAttributes>);
    return new Artist(artist);
  }

  // Instance methods
  async update(data: Partial<ArtistAttributes>): Promise<Artist> {
    const { profileImageUrl, bannerImageUrl, followersCount, userId, ...rest } = data;
    const updateData = {
      ...rest,
      ...(profileImageUrl !== undefined && { profile_image_url: profileImageUrl }),
      ...(bannerImageUrl !== undefined && { banner_image_url: bannerImageUrl }),
      ...(followersCount !== undefined && { followers_count: followersCount }),
      ...(userId !== undefined && { user_id: userId })
    };
    const updated = await artistRepository.update(this.id, updateData as Partial<ArtistAttributes>);
    Object.assign(this, updated);
    return this;
  }

  async delete(): Promise<boolean> {
    return artistRepository.delete(this.id);
  }

  async incrementFollowers(): Promise<void> {
    await artistRepository.incrementFollowers(this.id);
    this.followersCount++;
  }

  async decrementFollowers(): Promise<void> {
    await artistRepository.decrementFollowers(this.id);
    this.followersCount = Math.max(0, this.followersCount - 1);
  }

  async getUser(): Promise<UserAttributes | null> {
    if (!this.userId) return null;
    return await userRepository.findById(this.userId);
  }

  toJSON() {
    return {
      ...this,
      createdAt: this.createdAt.toISOString(),
      updatedAt: this.updatedAt.toISOString()
    };
  }
}

export default Artist; 
================================================================================
File: models\associations.ts
Lines: 68
--------------------------------------------------------------------------------
/**
 * This file documents the relationships between models.
 * 
 * Note: We're using raw SQL with PostgreSQL repositories instead of Sequelize ORM.
 * These relationships are documented here for reference only and are implemented
 * in the respective repository classes using SQL queries.
 */

// User relationships
// - User has many Posts
// - User has many Comments
// - User has many Likes
// - User has many Playlists
// - User has many Follows (as follower)
// - User has many Follows (as following)
// - User has one TwoFactorAuth

// Post relationships
// - Post belongs to User
// - Post has many Comments
// - Post has many Likes

// Comment relationships
// - Comment belongs to User
// - Comment belongs to Post
// - Comment has many CommentLikes

// Like relationships
// - Like belongs to User
// - Like belongs to Post

// CommentLike relationships
// - CommentLike belongs to User
// - CommentLike belongs to Comment

// Follow relationships
// - Follow belongs to User (as follower)
// - Follow belongs to User (as following)

// Track relationships
// - Track belongs to Artist
// - Track belongs to Album (optional)
// - Track belongs to many Playlists (through PlaylistTrack)

// Album relationships
// - Album belongs to Artist
// - Album has many Tracks

// Playlist relationships
// - Playlist belongs to User
// - Playlist has many Tracks (through PlaylistTrack)

// PlaylistTrack relationships
// - PlaylistTrack belongs to Playlist
// - PlaylistTrack belongs to Track

// Artist relationships
// - Artist has many Albums
// - Artist has many Tracks

// Media relationships
// - Media belongs to User

// TwoFactorAuth relationships
// - TwoFactorAuth belongs to User

// Export an empty object to satisfy the import
export default {}; 
================================================================================
File: models\Comment.ts
Lines: 546
--------------------------------------------------------------------------------
import { Pool, QueryResult } from 'pg';

import { BaseModel, BaseRepository } from '../database/BaseRepository';
import { DatabaseConnectionManager } from '../database/config';

export interface CommentAttributes extends BaseModel {
  userId: string;
  postId: string;
  parentId: string | null;
  content: string;
  likesCount: number;
  status: string;
  moderationReason: string | null;
  moderatedBy: string | null;
  moderatedAt: Date | null;
}

export interface CommentJSON extends Omit<Comment, 'moderatedAt' | 'createdAt' | 'updatedAt'> {
  moderatedAt: string | null;
  createdAt: string;
  updatedAt: string;
  isLiked?: boolean;
}

interface UserData {
  id: string;
  username: string;
  displayName: string;
  profileImage: string | null;
}

interface CommentLike {
  id: string;
  userId: string;
  commentId: string;
  createdAt: Date;
  updatedAt: Date;
  user: UserData;
}

export class CommentRepository extends BaseRepository<CommentAttributes> {
  protected tableName = 'comments';
  protected columns = [
    'id',
    'user_id as userId',
    'post_id as postId',
    'parent_id as parentId',
    'content',
    'likes_count as likesCount',
    'status',
    'moderation_reason as moderationReason',
    'moderated_by as moderatedBy',
    'moderated_at as moderatedAt',
    'created_at as createdAt',
    'updated_at as updatedAt'
  ];

  protected async query(sql: string, params: unknown[] = []): Promise<QueryResult> {
    return DatabaseConnectionManager.getPool().query(sql, params);
  }

  /**
   * Find comments by post ID
   */
  async findByPostId(options: {
    postId: string;
    parentId?: string | null;
    limit?: number;
    offset?: number;
  }): Promise<CommentAttributes[]> {
    const { postId, parentId = null, limit = 20, offset = 0 } = options;
    const params = [postId];
    let query = `
      SELECT ${this.columns.join(', ')}
      FROM ${this.tableName}
      WHERE post_id = $1
    `;

    if (parentId !== undefined) {
      query += ` AND parent_id ${parentId === null ? 'IS NULL' : '= $2'}`;
      if (parentId !== null) {
        params.push(parentId);
      }
    }

    query += `
      ORDER BY created_at ASC
      LIMIT $${params.length + 1} OFFSET $${params.length + 2}
    `;
    params.push(limit.toString(), offset.toString());

    try {
      const result = await this.query(query, params);
      return result.rows as CommentAttributes[];
    } catch (error) {
      this.logger.error('Error in findByPostId', { options, error });
      throw error;
    }
  }

  /**
   * Find replies to a comment
   */
  async findReplies(parentId: string): Promise<CommentAttributes[]> {
    const query = `
      SELECT ${this.columns.join(', ')}
      FROM ${this.tableName}
      WHERE parent_id = $1
      ORDER BY created_at ASC
    `;

    try {
      const result = await this.query(query, [parentId]);
      return result.rows as CommentAttributes[];
    } catch (error) {
      this.logger.error('Error in findReplies', { parentId, error });
      throw error;
    }
  }

  /**
   * Increment likes count
   */
  async incrementLikes(id: string): Promise<void> {
    const query = `
      UPDATE ${this.tableName}
      SET likes_count = likes_count + 1
      WHERE id = $1
    `;

    try {
      await this.query(query, [id]);
    } catch (error) {
      this.logger.error('Error in incrementLikes', { id, error });
      throw error;
    }
  }

  /**
   * Decrement likes count
   */
  async decrementLikes(id: string): Promise<void> {
    const query = `
      UPDATE ${this.tableName}
      SET likes_count = GREATEST(likes_count - 1, 0)
      WHERE id = $1
    `;

    try {
      await this.query(query, [id]);
    } catch (error) {
      this.logger.error('Error in decrementLikes', { id, error });
      throw error;
    }
  }

  /**
   * Find comment with user data
   */
  async findWithUser(id: string): Promise<(CommentAttributes & { user: UserData }) | null> {
    const query = `
      SELECT 
        c.*,
        json_build_object(
          'id', u.id,
          'username', u.username,
          'displayName', u.display_name,
          'profileImage', u.profile_image
        ) as user
      FROM 
        comments c
      LEFT JOIN 
        users u ON c.user_id = u.id
      WHERE 
        c.id = $1
    `;

    try {
      const result = await this.query(query, [id]);
      if (!result.rows[0]) return null;

      const row = result.rows[0] as {
        id: string;
        user_id: string;
        post_id: string;
        parent_id: string | null;
        content: string;
        likes_count: number;
        status: string;
        moderation_reason: string | null;
        moderated_by: string | null;
        moderated_at: Date | null;
        created_at: Date;
        updated_at: Date;
        username: string;
        display_name: string;
        profile_image: string | null;
      };
      return {
        id: row.id,
        userId: row.user_id,
        postId: row.post_id,
        parentId: row.parent_id,
        content: row.content,
        likesCount: row.likes_count,
        status: row.status,
        moderationReason: row.moderation_reason,
        moderatedBy: row.moderated_by,
        moderatedAt: row.moderated_at,
        createdAt: row.created_at,
        updatedAt: row.updated_at,
        user: {
          id: row.user_id,
          username: row.username,
          displayName: row.display_name,
          profileImage: row.profile_image
        }
      };
    } catch (error) {
      console.error('Error in findWithUser:', error);
      throw error;
    }
  }

  /**
   * Find comment with likes
   */
  async findWithLikes(id: string, limit: number = 20, offset: number = 0): Promise<(CommentAttributes & { likes: CommentLike[] }) | null> {
    const query = `
      SELECT 
        c.*,
        COALESCE(
          json_agg(
            json_build_object(
              'id', cl.id,
              'userId', cl.user_id,
              'commentId', cl.comment_id,
              'createdAt', cl.created_at,
              'updatedAt', cl.updated_at,
              'user', json_build_object(
                'id', u.id,
                'username', u.username,
                'displayName', u.display_name,
                'profileImage', u.profile_image
              )
            ) ORDER BY cl.created_at DESC
          ) FILTER (WHERE cl.id IS NOT NULL), '[]'
        ) as likes
      FROM 
        comments c
      LEFT JOIN 
        comment_likes cl ON c.id = cl.comment_id
      LEFT JOIN
        users u ON cl.user_id = u.id
      WHERE 
        c.id = $1
      GROUP BY 
        c.id
      LIMIT $2 OFFSET $3
    `;

    try {
      const result = await this.query(query, [id, limit, offset]);
      if (!result.rows[0]) return null;

      const row = result.rows[0] as {
        id: string;
        user_id: string;
        post_id: string;
        parent_id: string | null;
        content: string;
        likes_count: number;
        status: string;
        moderation_reason: string | null;
        moderated_by: string | null;
        moderated_at: Date | null;
        created_at: Date;
        updated_at: Date;
        likes: CommentLike[];
      };
      return {
        ...row,
        userId: row.user_id,
        postId: row.post_id,
        parentId: row.parent_id,
        likesCount: row.likes_count,
        moderationReason: row.moderation_reason,
        moderatedBy: row.moderated_by,
        moderatedAt: row.moderated_at,
        createdAt: row.created_at,
        updatedAt: row.updated_at,
        likes: row.likes || []
      };
    } catch (error) {
      console.error('Error in findWithLikes:', error);
      throw error;
    }
  }

  /**
   * Find complete comment with all relationships
   */
  async findComplete(id: string, options: {
    likesLimit?: number;
    likesOffset?: number;
  } = {}, client?: Pool): Promise<(CommentAttributes & { user: UserData, likes: CommentLike[] }) | null> {
    const {
      likesLimit = 20,
      likesOffset = 0
    } = options;

    const query = `
      WITH comment_data AS (
        SELECT 
          c.*,
          u.id as "user.id",
          u.username as "user.username",
          u.display_name as "user.displayName",
          u.profile_image as "user.profileImage"
        FROM ${this.tableName} c
        LEFT JOIN users u ON c.user_id = u.id
        WHERE c.id = $1
      ),
      like_data AS (
        SELECT 
          l.id,
          l.user_id,
          l.created_at,
          u.username,
          u.display_name as displayName,
          u.profile_image as profileImage
        FROM comment_likes l
        JOIN users u ON l.user_id = u.id
        WHERE l.comment_id = $1
        ORDER BY l.created_at DESC
        LIMIT $2 OFFSET $3
      )
      SELECT 
        cd.*,
        json_agg(ld.*) FILTER (WHERE ld.id IS NOT NULL) as likes
      FROM comment_data cd
      LEFT JOIN like_data ld ON true
      GROUP BY 
        cd.id, cd.user_id, cd.post_id, cd.content,
        cd.likes_count, cd.created_at, cd.updated_at,
        cd."user.id", cd."user.username", cd."user.displayName", cd."user.profileImage"
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool())
        .query(query, [id, likesLimit, likesOffset]);
      
      if (!result.rows[0]) return null;

      const row = result.rows[0] as {
        id: string;
        user_id: string;
        post_id: string;
        content: string;
        likes_count: number;
        created_at: Date;
        updated_at: Date;
        'user.id': string;
        'user.username': string;
        'user.displayName': string;
        'user.profileImage': string | null;
        likes: CommentLike[];
      };
      return {
        id: row.id,
        userId: row.user_id,
        postId: row.post_id,
        content: row.content,
        likesCount: row.likes_count,
        createdAt: row.created_at,
        updatedAt: row.updated_at,
        user: {
          id: row['user.id'],
          username: row['user.username'],
          displayName: row['user.displayName'],
          profileImage: row['user.profileImage']
        },
        likes: row.likes || []
      } as CommentAttributes & { user: UserData; likes: CommentLike[] };
    } catch (error) {
      this.logger.error('Error in findComplete', { id, options, error });
      throw error;
    }
  }

  /**
   * Find comments by post ID with user data
   */
  async findByPostIdWithUser(postId: string, limit: number = 20, offset: number = 0, client?: Pool): Promise<(CommentAttributes & { user: UserData })[]> {
    const query = `
      SELECT 
        c.*,
        u.id as "user.id",
        u.username as "user.username",
        u.display_name as "user.displayName",
        u.profile_image as "user.profileImage"
      FROM ${this.tableName} c
      LEFT JOIN users u ON c.user_id = u.id
      WHERE c.post_id = $1
      ORDER BY c.created_at DESC
      LIMIT $2 OFFSET $3
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [postId, limit, offset]);
      return result.rows.map((row: {
        'user.id': string;
        'user.username': string;
        'user.displayName': string;
        'user.profileImage': string | null;
      } & CommentAttributes) => ({
        ...row,
        user: {
          id: row['user.id'],
          username: row['user.username'],
          displayName: row['user.displayName'],
          profileImage: row['user.profileImage']
        }
      })) as (CommentAttributes & { user: UserData })[];
    } catch (error) {
      this.logger.error('Error in findByPostIdWithUser', { postId, limit, offset, error });
      throw error;
    }
  }
}

// Singleton instance
export const commentRepository = new CommentRepository();

export class Comment implements CommentAttributes {
  id: string;
  userId: string;
  postId: string;
  parentId: string | null;
  content: string;
  likesCount: number;
  status: string;
  moderationReason: string | null;
  moderatedBy: string | null;
  moderatedAt: Date | null;
  createdAt: Date;
  updatedAt: Date;

  constructor(data: CommentAttributes) {
    this.id = data.id;
    this.userId = data.userId;
    this.postId = data.postId;
    this.parentId = data.parentId;
    this.content = data.content;
    this.likesCount = data.likesCount;
    this.status = data.status;
    this.moderationReason = data.moderationReason;
    this.moderatedBy = data.moderatedBy;
    this.moderatedAt = data.moderatedAt ? new Date(data.moderatedAt) : null;
    this.createdAt = new Date(data.createdAt);
    this.updatedAt = new Date(data.updatedAt);
  }

  // Static methods that use the repository
  static async findByPk(id: string): Promise<Comment | null> {
    const comment = await commentRepository.findById(id);
    return comment ? new Comment(comment) : null;
  }

  static async findByPostId(options: {
    postId: string;
    parentId?: string | null;
    limit?: number;
    offset?: number;
  }): Promise<Comment[]> {
    const comments = await commentRepository.findByPostId(options);
    return comments.map(comment => new Comment(comment));
  }

  static async findReplies(parentId: string): Promise<Comment[]> {
    const replies = await commentRepository.findReplies(parentId);
    return replies.map(reply => new Comment(reply));
  }

  static async create(data: Omit<CommentAttributes, 'id' | 'createdAt' | 'updatedAt'>): Promise<Comment> {
    const {
      userId, postId, parentId, moderationReason,
      moderatedBy, moderatedAt, ...rest
    } = data;
    const comment = await commentRepository.create({
      ...rest,
      user_id: userId,
      post_id: postId,
      parent_id: parentId,
      moderation_reason: moderationReason,
      moderated_by: moderatedBy,
      moderated_at: moderatedAt
    } as Partial<CommentAttributes>);
    return new Comment(comment);
  }

  // Instance methods
  async update(data: Partial<CommentAttributes>): Promise<Comment> {
    const {
      userId, postId, parentId, moderationReason,
      moderatedBy, moderatedAt, ...rest
    } = data;
    const updateData = {
      ...rest,
      ...(userId !== undefined && { user_id: userId }),
      ...(postId !== undefined && { post_id: postId }),
      ...(parentId !== undefined && { parent_id: parentId }),
      ...(moderationReason !== undefined && { moderation_reason: moderationReason }),
      ...(moderatedBy !== undefined && { moderated_by: moderatedBy }),
      ...(moderatedAt !== undefined && { moderated_at: moderatedAt })
    };
    const updated = await commentRepository.update(this.id, updateData as Partial<CommentAttributes>);
    Object.assign(this, updated);
    return this;
  }

  async delete(): Promise<boolean> {
    return commentRepository.delete(this.id);
  }

  async incrementLikes(): Promise<void> {
    await commentRepository.incrementLikes(this.id);
    this.likesCount++;
  }

  async decrementLikes(): Promise<void> {
    await commentRepository.decrementLikes(this.id);
    this.likesCount = Math.max(0, this.likesCount - 1);
  }

  toJSON(): CommentJSON {
    return {
      ...this,
      moderatedAt: this.moderatedAt?.toISOString() || null,
      createdAt: this.createdAt.toISOString(),
      updatedAt: this.updatedAt.toISOString()
    };
  }
}

export default Comment; 
================================================================================
File: models\CommentLike.ts
Lines: 96
--------------------------------------------------------------------------------
import { Pool } from 'pg';

import { BaseModel, BaseRepository } from '../database/BaseRepository';
import { DatabaseConnectionManager } from '../database/config';

import { UserAttributes } from './User';

export interface CommentLikeAttributes extends BaseModel {
  userId: string;
  commentId: string;
}

export class CommentLikeRepository extends BaseRepository<CommentLikeAttributes> {
  protected tableName = 'comment_likes';
  protected columns = [
    'id',
    'user_id as userId',
    'comment_id as commentId',
    'created_at as createdAt'
  ];

  /**
   * Find a like by user and comment
   */
  async findByUserAndComment(userId: string, commentId: string, client?: Pool): Promise<CommentLikeAttributes | null> {
    const query = `
      SELECT ${this.columns.join(', ')}
      FROM ${this.tableName}
      WHERE user_id = $1 AND comment_id = $2
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [userId, commentId]);
      return (result.rows[0] || null) as CommentLikeAttributes | null;
    } catch (error) {
      this.logger.error('Error in findByUserAndComment', { userId, commentId, error });
      throw error;
    }
  }
}

// Singleton instance
export const commentLikeRepository = new CommentLikeRepository();

export class CommentLike implements CommentLikeAttributes {
  static belongsTo(_User: UserAttributes, _arg1: { foreignKey: string; as: string; }) {
      throw new Error('Method not implemented.');
  }
  id: string;
  userId: string;
  commentId: string;
  createdAt: Date;
  updatedAt: Date;

  constructor(data: CommentLikeAttributes) {
    this.id = data.id;
    this.userId = data.userId;
    this.commentId = data.commentId;
    this.createdAt = new Date(data.createdAt);
    this.updatedAt = new Date(data.updatedAt);
  }

  // Static methods that use the repository
  static async findByPk(id: string): Promise<CommentLike | null> {
    const commentLike = await commentLikeRepository.findById(id);
    return commentLike ? new CommentLike(commentLike) : null;
  }

  static async findByUserAndComment(userId: string, commentId: string): Promise<CommentLike | null> {
    const commentLike = await commentLikeRepository.findByUserAndComment(userId, commentId);
    return commentLike ? new CommentLike(commentLike) : null;
  }

  static async create(data: Omit<CommentLikeAttributes, 'id' | 'createdAt'>): Promise<CommentLike> {
    const { userId, commentId } = data;
    const commentLike = await commentLikeRepository.create({
      user_id: userId,
      comment_id: commentId
    } as Partial<CommentLikeAttributes>);
    return new CommentLike(commentLike);
  }

  async delete(): Promise<boolean> {
    return commentLikeRepository.delete(this.id);
  }

  toJSON() {
    return {
      ...this,
      createdAt: this.createdAt.toISOString(),
      updatedAt: this.updatedAt.toISOString()
    };
  }
}

export default CommentLike; 
================================================================================
File: models\Follow.ts
Lines: 392
--------------------------------------------------------------------------------
import { Pool } from 'pg';

import { BaseModel, BaseRepository } from '../database/BaseRepository';
import { DatabaseConnectionManager } from '../database/config';

interface UserData {
  id: string;
  username: string;
  displayName: string;
  profileImage: string | null;
}

interface FollowWithData extends FollowAttributes {
  follower: UserData;
}

interface FollowWithFollowed extends FollowAttributes {
  followed: UserData;
}

interface MutualFollower extends UserData {
  id: string;
  username: string;
  displayName: string;
  profileImage: string | null;
}

export interface FollowAttributes extends BaseModel {
  followerId: string;
  followingId: string;
}

export class FollowRepository extends BaseRepository<FollowAttributes> {
  protected tableName = 'follows';
  protected columns = [
    'id',
    'follower_id as followerId',
    'following_id as followingId',
    'created_at as createdAt'
  ];

  /**
   * Find a follow relationship by follower and following IDs
   */
  async findByFollowerAndFollowing(followerId: string, followingId: string, client?: Pool): Promise<FollowAttributes | null> {
    const query = `
      SELECT ${this.columns.join(', ')}
      FROM ${this.tableName}
      WHERE follower_id = $1 AND following_id = $2
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [followerId, followingId]);
      return (result.rows[0] || null) as FollowAttributes | null;
    } catch (error) {
      this.logger.error('Error in findByFollowerAndFollowing', { followerId, followingId, error });
      throw error;
    }
  }

  /**
   * Find all users that a user is following
   */
  async findFollowing(followerId: string, limit: number = 20, offset: number = 0, client?: Pool): Promise<FollowAttributes[]> {
    const query = `
      SELECT ${this.columns.join(', ')}
      FROM ${this.tableName}
      WHERE follower_id = $1
      ORDER BY created_at DESC
      LIMIT $2 OFFSET $3
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [followerId, limit, offset]);
      return result.rows as FollowAttributes[];
    } catch (error) {
      this.logger.error('Error in findFollowing', { followerId, limit, offset, error });
      throw error;
    }
  }

  /**
   * Find all followers of a user
   */
  async findFollowers(followingId: string, limit: number = 20, offset: number = 0, client?: Pool): Promise<FollowAttributes[]> {
    const query = `
      SELECT ${this.columns.join(', ')}
      FROM ${this.tableName}
      WHERE following_id = $1
      ORDER BY created_at DESC
      LIMIT $2 OFFSET $3
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [followingId, limit, offset]);
      return result.rows as FollowAttributes[];
    } catch (error) {
      this.logger.error('Error in findFollowers', { followingId, limit, offset, error });
      throw error;
    }
  }

  /**
   * Find follow with follower data
   */
  async findWithFollower(id: string, client?: Pool): Promise<FollowWithData | null> {
    const query = `
      SELECT 
        f.*,
        json_build_object(
          'id', u.id,
          'username', u.username,
          'displayName', u.display_name,
          'profileImage', u.profile_image
        ) as follower
      FROM 
        follows f
      LEFT JOIN 
        users u ON f.follower_id = u.id
      WHERE 
        f.id = $1
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [id]);
      if (!result.rows[0]) return null;

      const row = result.rows[0] as {
        id: string;
        follower_id: string;
        following_id: string;
        created_at: Date;
        updated_at: Date;
        follower: UserData;
      };
      return {
        id: row.id,
        followerId: row.follower_id,
        followingId: row.following_id,
        createdAt: row.created_at,
        updatedAt: row.updated_at,
        follower: row.follower
      };
    } catch (error) {
      console.error('Error in findWithFollower:', error);
      throw error;
    }
  }

  /**
   * Find follow with followed user data
   */
  async findWithFollowed(id: string, client?: Pool): Promise<FollowWithFollowed | null> {
    const query = `
      SELECT 
        f.*,
        json_build_object(
          'id', u.id,
          'username', u.username,
          'displayName', u.display_name,
          'profileImage', u.profile_image
        ) as followed
      FROM 
        follows f
      LEFT JOIN 
        users u ON f.following_id = u.id
      WHERE 
        f.id = $1
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [id]);
      if (!result.rows[0]) return null;

      const row = result.rows[0] as {
        id: string;
        follower_id: string;
        following_id: string;
        created_at: Date;
        updated_at: Date;
        followed: UserData;
      };
      return {
        id: row.id,
        followerId: row.follower_id,
        followingId: row.following_id,
        createdAt: row.created_at,
        updatedAt: row.updated_at,
        followed: row.followed
      };
    } catch (error) {
      console.error('Error in findWithFollowed:', error);
      throw error;
    }
  }

  /**
   * Find followers of a user with user data
   */
  async findFollowersWithData(userId: string, limit: number = 20, offset: number = 0, client?: Pool): Promise<FollowWithData[]> {
    const query = `
      SELECT 
        f.*,
        u.id as "follower.id",
        u.username as "follower.username",
        u.display_name as "follower.displayName",
        u.profile_image as "follower.profileImage"
      FROM ${this.tableName} f
      LEFT JOIN users u ON f.follower_id = u.id
      WHERE f.followed_id = $1
      ORDER BY f.created_at DESC
      LIMIT $2 OFFSET $3
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [userId, limit, offset]);
      return result.rows.map((row: {
        'follower.id': string;
        'follower.username': string;
        'follower.displayName': string;
        'follower.profileImage': string | null;
      } & FollowAttributes) => ({
        ...row,
        follower: {
          id: row['follower.id'],
          username: row['follower.username'],
          displayName: row['follower.displayName'],
          profileImage: row['follower.profileImage']
        }
      })) as FollowWithData[];
    } catch (error) {
      this.logger.error('Error in findFollowersWithData', { userId, limit, offset, error });
      throw error;
    }
  }

  /**
   * Find users followed by a user with user data
   */
  async findFollowingWithData(userId: string, limit: number = 20, offset: number = 0, client?: Pool): Promise<FollowWithFollowed[]> {
    const query = `
      SELECT 
        f.*,
        u.id as "followed.id",
        u.username as "followed.username",
        u.display_name as "followed.displayName",
        u.profile_image as "followed.profileImage"
      FROM ${this.tableName} f
      LEFT JOIN users u ON f.followed_id = u.id
      WHERE f.follower_id = $1
      ORDER BY f.created_at DESC
      LIMIT $2 OFFSET $3
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [userId, limit, offset]);
      return result.rows.map((row: {
        'followed.id': string;
        'followed.username': string;
        'followed.displayName': string;
        'followed.profileImage': string | null;
      } & FollowAttributes) => ({
        ...row,
        followed: {
          id: row['followed.id'],
          username: row['followed.username'],
          displayName: row['followed.displayName'],
          profileImage: row['followed.profileImage']
        }
      })) as FollowWithFollowed[];
    } catch (error) {
      this.logger.error('Error in findFollowingWithData', { userId, limit, offset, error });
      throw error;
    }
  }

  /**
   * Check if a user follows another user
   */
  async isFollowing(followerId: string, followedId: string, client?: Pool): Promise<boolean> {
    const query = `
      SELECT EXISTS (
        SELECT 1
        FROM ${this.tableName}
        WHERE follower_id = $1 AND followed_id = $2
      ) as is_following
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [followerId, followedId]);
      const row = result.rows[0] as { is_following: boolean };
      return row.is_following;
    } catch (error) {
      this.logger.error('Error in isFollowing', { followerId, followedId, error });
      throw error;
    }
  }

  /**
   * Get mutual followers between two users
   */
  async findMutualFollowers(userId1: string, userId2: string, limit: number = 20, offset: number = 0, client?: Pool): Promise<MutualFollower[]> {
    const query = `
      WITH mutual_followers AS (
        SELECT DISTINCT f1.follower_id
        FROM ${this.tableName} f1
        JOIN ${this.tableName} f2 ON f1.follower_id = f2.follower_id
        WHERE f1.followed_id = $1 AND f2.followed_id = $2
      )
      SELECT 
        u.id,
        u.username,
        u.display_name as "displayName",
        u.profile_image as "profileImage"
      FROM mutual_followers mf
      JOIN users u ON mf.follower_id = u.id
      ORDER BY u.username
      LIMIT $3 OFFSET $4
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [userId1, userId2, limit, offset]);
      return result.rows as MutualFollower[];
    } catch (error) {
      this.logger.error('Error in findMutualFollowers', { userId1, userId2, limit, offset, error });
      throw error;
    }
  }
}

// Singleton instance
export const followRepository = new FollowRepository();

export class Follow implements FollowAttributes {
  id: string;
  followerId: string;
  followingId: string;
  createdAt: Date;
  updatedAt: Date;

  constructor(data: FollowAttributes) {
    this.id = data.id;
    this.followerId = data.followerId;
    this.followingId = data.followingId;
    this.createdAt = new Date(data.createdAt);
    this.updatedAt = new Date(data.updatedAt);
  }

  // Static methods that use the repository
  static async findByPk(id: string): Promise<Follow | null> {
    const follow = await followRepository.findById(id);
    return follow ? new Follow(follow) : null;
  }

  static async findByFollowerAndFollowing(followerId: string, followingId: string): Promise<Follow | null> {
    const follow = await followRepository.findByFollowerAndFollowing(followerId, followingId);
    return follow ? new Follow(follow) : null;
  }

  static async findFollowing(followerId: string, limit?: number, offset?: number): Promise<Follow[]> {
    const follows = await followRepository.findFollowing(followerId, limit, offset);
    return follows.map(follow => new Follow(follow));
  }

  static async findFollowers(followingId: string, limit?: number, offset?: number): Promise<Follow[]> {
    const follows = await followRepository.findFollowers(followingId, limit, offset);
    return follows.map(follow => new Follow(follow));
  }

  static async create(data: Omit<FollowAttributes, 'id' | 'createdAt' | 'updatedAt'>): Promise<Follow> {
    const { followerId, followingId } = data;
    const follow = await followRepository.create({
      follower_id: followerId,
      following_id: followingId
    } as Partial<FollowAttributes>);
    return new Follow(follow);
  }

  async delete(): Promise<boolean> {
    return followRepository.delete(this.id);
  }

  toJSON() {
    return {
      ...this,
      createdAt: this.createdAt.toISOString(),
      updatedAt: this.updatedAt.toISOString()
    };
  }
}

export default Follow; 
================================================================================
File: models\index.ts
Lines: 24
--------------------------------------------------------------------------------
import AlbumModel from './Album';
import ArtistModel from './Artist';
import CommentModel from './Comment';
import CommentLikeModel from './CommentLike';
import FollowModel from './Follow';
import LikeModel from './Like';
import PostModel from './Post';
import TrackModel from './Track';
import TwoFactorAuthModel from './TwoFactorAuth';
import { userRepository } from './User';

// Export models
export {
  userRepository as User,
  PostModel as Post,
  CommentModel as Comment,
  LikeModel as Like,
  CommentLikeModel as CommentLike,
  FollowModel as Follow,
  AlbumModel as Album,
  ArtistModel as Artist,
  TrackModel as Track,
  TwoFactorAuthModel as TwoFactorAuth,
}; 
================================================================================
File: models\Like.ts
Lines: 291
--------------------------------------------------------------------------------
import { Pool } from 'pg';

import { BaseModel, BaseRepository } from '../database/BaseRepository';
import { DatabaseConnectionManager } from '../database/config';

interface UserData {
  id: string;
  username: string;
  displayName: string;
  profileImage: string | null;
}

interface PostData {
  id: string;
  content: string;
  media: string | null;
  likesCount: number;
  commentsCount: number;
  createdAt: Date;
}

export interface LikeAttributes extends BaseModel {
  userId: string;
  postId: string;
}

export class LikeRepository extends BaseRepository<LikeAttributes> {
  protected tableName = 'likes';
  protected columns = [
    'id',
    'user_id as userId',
    'post_id as postId',
    'created_at as createdAt'
  ];

  /**
   * Find a like by user and post
   */
  async findByUserAndPost(userId: string, postId: string, client?: Pool): Promise<LikeAttributes | null> {
    const query = `
      SELECT ${this.columns.join(', ')}
      FROM ${this.tableName}
      WHERE user_id = $1 AND post_id = $2
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [userId, postId]);
      return (result.rows[0] || null) as LikeAttributes | null;
    } catch (error) {
      this.logger.error('Error in findByUserAndPost', { userId, postId, error });
      throw error;
    }
  }

  /**
   * Find likes by user and multiple posts
   */
  async findByUserAndPosts(userId: string, postIds: string[], client?: Pool): Promise<LikeAttributes[]> {
    const query = `
      SELECT ${this.columns.join(', ')}
      FROM ${this.tableName}
      WHERE user_id = $1 AND post_id = ANY($2)
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [userId, postIds]);
      return result.rows as LikeAttributes[];
    } catch (error) {
      this.logger.error('Error in findByUserAndPosts', { userId, postIds, error });
      throw error;
    }
  }

  /**
   * Find like with user data
   */
  async findWithUser(id: string, client?: Pool): Promise<(LikeAttributes & { user: UserData }) | null> {
    const query = `
      SELECT 
        l.*,
        json_build_object(
          'id', u.id,
          'username', u.username,
          'displayName', u.display_name,
          'profileImage', u.profile_image
        ) as user
      FROM 
        likes l
      LEFT JOIN 
        users u ON l.user_id = u.id
      WHERE 
        l.id = $1
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [id]);
      if (!result.rows[0]) return null;

      const row = result.rows[0] as {
        id: string;
        user_id: string;
        post_id: string;
        created_at: Date;
        updated_at: Date;
        user: UserData;
      };
      return {
        id: row.id,
        userId: row.user_id,
        postId: row.post_id,
        createdAt: row.created_at,
        updatedAt: row.updated_at,
        user: {
          id: row.user.id,
          username: row.user.username,
          displayName: row.user.displayName,
          profileImage: row.user.profileImage
        }
      };
    } catch (error) {
      console.error('Error in findWithUser:', error);
      throw error;
    }
  }

  /**
   * Find likes by post ID with user data
   */
  async findByPostIdWithUser(postId: string, limit: number = 20, offset: number = 0, client?: Pool): Promise<(LikeAttributes & { user: UserData })[]> {
    const query = `
      SELECT 
        l.*,
        u.id as "user.id",
        u.username as "user.username",
        u.display_name as "user.displayName",
        u.profile_image as "user.profileImage"
      FROM ${this.tableName} l
      LEFT JOIN users u ON l.user_id = u.id
      WHERE l.post_id = $1
      ORDER BY l.created_at DESC
      LIMIT $2 OFFSET $3
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [postId, limit, offset]);
      return result.rows.map((row: {
        'user.id': string;
        'user.username': string;
        'user.displayName': string;
        'user.profileImage': string | null;
      } & LikeAttributes) => ({
        ...row,
        user: {
          id: row['user.id'],
          username: row['user.username'],
          displayName: row['user.displayName'],
          profileImage: row['user.profileImage']
        }
      }));
    } catch (error) {
      this.logger.error('Error in findByPostIdWithUser', { postId, limit, offset, error });
      throw error;
    }
  }

  /**
   * Find likes by user ID with post data
   */
  async findByUserIdWithPost(userId: string, limit: number = 20, offset: number = 0, client?: Pool): Promise<(LikeAttributes & { post: PostData })[]> {
    const query = `
      SELECT 
        l.*,
        p.id as "post.id",
        p.content as "post.content",
        p.media as "post.media",
        p.likes_count as "post.likesCount",
        p.comments_count as "post.commentsCount",
        p.created_at as "post.createdAt"
      FROM ${this.tableName} l
      LEFT JOIN posts p ON l.post_id = p.id
      WHERE l.user_id = $1
      ORDER BY l.created_at DESC
      LIMIT $2 OFFSET $3
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [userId, limit, offset]);
      return result.rows.map((row: {
        'post.id': string;
        'post.content': string;
        'post.media': string | null;
        'post.likesCount': number;
        'post.commentsCount': number;
        'post.createdAt': Date;
      } & LikeAttributes  ) => ({
        ...row,
        post: {
          id: row['post.id'],
          content: row['post.content'],
          media: row['post.media'],
          likesCount: row['post.likesCount'],
          commentsCount: row['post.commentsCount'],
          createdAt: row['post.createdAt']
        }
      }));
    } catch (error) {
      this.logger.error('Error in findByUserIdWithPost', { userId, limit, offset, error });
      throw error;
    }
  }

  /**
   * Check if a user has liked a post
   */
  async hasUserLikedPost(userId: string, postId: string, client?: Pool): Promise<boolean> {
    const query = `
      SELECT EXISTS (
        SELECT 1
        FROM ${this.tableName}
        WHERE user_id = $1 AND post_id = $2
      ) as has_liked
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [userId, postId]);
      const row = result.rows[0] as { has_liked: boolean };
      return row.has_liked;
    } catch (error) {
      this.logger.error('Error in hasUserLikedPost', { userId, postId, error });
      throw error;
    }
  }
}

// Singleton instance
export const likeRepository = new LikeRepository();

export class Like implements LikeAttributes {
  id: string;
  userId: string;
  postId: string;
  createdAt: Date;
  updatedAt: Date;

  constructor(data: LikeAttributes) {
    this.id = data.id;
    this.userId = data.userId;
    this.postId = data.postId;
    this.createdAt = new Date(data.createdAt);
    this.updatedAt = new Date(data.updatedAt);
  }

  // Static methods that use the repository
  static async findByPk(id: string): Promise<Like | null> {
    const like = await likeRepository.findById(id);
    return like ? new Like(like) : null;
  }

  static async findByUserAndPost(userId: string, postId: string): Promise<Like | null> {
    const like = await likeRepository.findByUserAndPost(userId, postId);
    return like ? new Like(like) : null;
  }

  static async findByUserAndPosts(userId: string, postIds: string[]): Promise<Like[]> {
    const likes = await likeRepository.findByUserAndPosts(userId, postIds);
    return likes.map(like => new Like(like));
  }

  static async create(data: Omit<LikeAttributes, 'id' | 'createdAt'>): Promise<Like> {
    const { userId, postId } = data;
    const like = await likeRepository.create({
      user_id: userId,
      post_id: postId
    } as Partial<LikeAttributes>);
    return new Like(like);
  }

  async delete(): Promise<boolean> {
    return likeRepository.delete(this.id);
  }

  toJSON() {
    return {
      ...this,
      createdAt: this.createdAt.toISOString(),
      updatedAt: this.updatedAt.toISOString()
    };
  }
}

export default Like; 
================================================================================
File: models\Media.ts
Lines: 226
--------------------------------------------------------------------------------
import { Pool } from 'pg';

import { BaseModel, BaseRepository } from '../database/BaseRepository';
import { DatabaseConnectionManager } from '../database/config';

import { Post } from './Post';

// Media types
export enum MediaType {
  IMAGE = 'image',
  VIDEO = 'video',
  AUDIO = 'audio'
}

// Processing status
export enum ProcessingStatus {
  PENDING = 'pending',
  PROCESSING = 'processing',
  COMPLETED = 'completed',
  FAILED = 'failed'
}

interface MediaMetadata {
  [key: string]: string | number | boolean | null;
}

export interface MediaAttributes extends BaseModel {
  userId: string;
  type: string;
  originalFilename: string;
  filename: string;
  path: string;
  mimeType: string;
  size: number;
  width: number | null;
  height: number | null;
  duration: number | null;
  thumbnailPath: string | null;
  processingStatus: string;
  processingJobId: string | null;
  metadata: MediaMetadata | null;
  isPublic: boolean;
}

export class MediaRepository extends BaseRepository<MediaAttributes> {
  protected tableName = 'media';
  protected columns = [
    'id',
    'user_id as userId',
    'type',
    'original_filename as originalFilename',
    'filename',
    'path',
    'mime_type as mimeType',
    'size',
    'width',
    'height',
    'duration',
    'thumbnail_path as thumbnailPath',
    'processing_status as processingStatus',
    'processing_job_id as processingJobId',
    'metadata',
    'is_public as isPublic',
    'created_at as createdAt',
    'updated_at as updatedAt'
  ];

  /**
   * Find media by user ID
   */
  async findByUserId(userId: string, client?: Pool): Promise<MediaAttributes[]> {
    const query = `
      SELECT ${this.columns.join(', ')}
      FROM ${this.tableName}
      WHERE user_id = $1
      ORDER BY created_at DESC
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [userId]);
      return result.rows as MediaAttributes[];
    } catch (error) {
      this.logger.error('Error in findByUserId', { userId, error });
      throw error;
    }
  }

  /**
   * Find public media
   */
  async findPublic(limit: number = 20, offset: number = 0, client?: Pool): Promise<MediaAttributes[]> {
    const query = `
      SELECT ${this.columns.join(', ')}
      FROM ${this.tableName}
      WHERE is_public = true
      ORDER BY created_at DESC
      LIMIT $1 OFFSET $2
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [limit, offset]);
      return result.rows as MediaAttributes[];
    } catch (error) {
      this.logger.error('Error in findPublic', { limit, offset, error });
      throw error;
    }
  }
}

// Singleton instance
export const mediaRepository = new MediaRepository();

export class Media implements MediaAttributes {
  static scope(_undefined: undefined): import("./Comment").Comment {
      throw new Error('Method not implemented.');
  }
  static belongsTo(_Post: Post, _arg1: { foreignKey: string; as: string; }) {
      throw new Error('Method not implemented.');
  }
  id: string;
  userId: string;
  type: string;
  originalFilename: string;
  filename: string;
  path: string;
  mimeType: string;
  size: number;
  width: number | null;
  height: number | null;
  duration: number | null;
  thumbnailPath: string | null;
  processingStatus: string;
  processingJobId: string | null;
  metadata: MediaMetadata | null;
  isPublic: boolean;
  createdAt: Date;
  updatedAt: Date;

  constructor(data: MediaAttributes) {
    this.id = data.id;
    this.userId = data.userId;
    this.type = data.type;
    this.originalFilename = data.originalFilename;
    this.filename = data.filename;
    this.path = data.path;
    this.mimeType = data.mimeType;
    this.size = data.size;
    this.width = data.width;
    this.height = data.height;
    this.duration = data.duration;
    this.thumbnailPath = data.thumbnailPath;
    this.processingStatus = data.processingStatus;
    this.processingJobId = data.processingJobId;
    this.metadata = data.metadata;
    this.isPublic = data.isPublic;
    this.createdAt = new Date(data.createdAt);
    this.updatedAt = new Date(data.updatedAt);
  }

  // Static methods that use the repository
  static async findByPk(id: string): Promise<Media | null> {
    const media = await mediaRepository.findById(id);
    return media ? new Media(media) : null;
  }

  static async findByUserId(userId: string): Promise<Media[]> {
    const mediaItems = await mediaRepository.findByUserId(userId);
    return mediaItems.map(media => new Media(media));
  }

  static async findPublic(limit?: number, offset?: number): Promise<Media[]> {
    const mediaItems = await mediaRepository.findPublic(limit, offset);
    return mediaItems.map(media => new Media(media));
  }

  static async create(data: Omit<MediaAttributes, 'id' | 'createdAt' | 'updatedAt'>): Promise<Media> {
    const {
      userId, originalFilename, thumbnailPath, processingStatus,
      processingJobId, isPublic, ...rest
    } = data;
    const media = await mediaRepository.create({
      ...rest,
      user_id: userId,
      original_filename: originalFilename,
      thumbnail_path: thumbnailPath,
      processing_status: processingStatus,
      processing_job_id: processingJobId,
      is_public: isPublic
    } as Partial<MediaAttributes>);
    return new Media(media);
  }

  // Instance methods
  async update(data: Partial<MediaAttributes>): Promise<Media> {
    const {
      userId, originalFilename, thumbnailPath, processingStatus,
      processingJobId, isPublic, ...rest
    } = data;
    const updateData = {
      ...rest,
      ...(userId !== undefined && { user_id: userId }),
      ...(originalFilename !== undefined && { original_filename: originalFilename }),
      ...(thumbnailPath !== undefined && { thumbnail_path: thumbnailPath }),
      ...(processingStatus !== undefined && { processing_status: processingStatus }),
      ...(processingJobId !== undefined && { processing_job_id: processingJobId }),
      ...(isPublic !== undefined && { is_public: isPublic })
    };
    const updated = await mediaRepository.update(this.id, updateData as Partial<MediaAttributes>);
    Object.assign(this, updated);
    return this;
  }

  async delete(): Promise<boolean> {
    return mediaRepository.delete(this.id);
  }

  toJSON() {
    return {
      ...this,
      createdAt: this.createdAt.toISOString(),
      updatedAt: this.updatedAt.toISOString()
    };
  }
}

export default Media; 
================================================================================
File: models\Playlist.ts
Lines: 278
--------------------------------------------------------------------------------
import { Pool } from 'pg';

import { BaseModel, BaseRepository } from '../database/BaseRepository';
import { DatabaseConnectionManager } from '../database/config';

import { PlaylistTrack } from './PlaylistTrack';
import { Track } from './Track';
import { userRepository, UserAttributes } from './User';

export interface PlaylistAttributes extends BaseModel {
  name: string;
  description: string | null;
  coverArtUrl: string | null;
  isPublic: boolean;
  trackCount: number;
  followersCount: number;
  userId: string;
}

export class PlaylistRepository extends BaseRepository<PlaylistAttributes> {
  protected tableName = 'playlists';
  protected columns = [
    'id',
    'name',
    'description',
    'cover_art_url as coverArtUrl',
    'is_public as isPublic',
    'track_count as trackCount',
    'followers_count as followersCount',
    'user_id as userId',
    'created_at as createdAt',
    'updated_at as updatedAt'
  ];

  /**
   * Find playlists by user ID
   */
  async findByUserId(userId: string, client?: Pool): Promise<PlaylistAttributes[]> {
    const query = `
      SELECT ${this.columns.join(', ')}
      FROM ${this.tableName}
      WHERE user_id = $1
      ORDER BY name ASC
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [userId]);
      return result.rows as PlaylistAttributes[];
    } catch (error) {
      this.logger.error('Error in findByUserId', { userId, error });
      throw error;
    }
  }

  /**
   * Find public playlists
   */
  async findPublic(limit: number = 20, offset: number = 0, client?: Pool): Promise<PlaylistAttributes[]> {
    const query = `
      SELECT ${this.columns.join(', ')}
      FROM ${this.tableName}
      WHERE is_public = true
      ORDER BY followers_count DESC, name ASC
      LIMIT $1 OFFSET $2
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [limit, offset]);
      return result.rows as PlaylistAttributes[];
    } catch (error) {
      this.logger.error('Error in findPublic', { limit, offset, error });
      throw error;
    }
  }

  /**
   * Increment track count
   */
  async incrementTrackCount(id: string, client?: Pool): Promise<void> {
    const query = `
      UPDATE ${this.tableName}
      SET track_count = track_count + 1
      WHERE id = $1
    `;

    try {
      await (client || DatabaseConnectionManager.getPool()).query(query, [id]);
    } catch (error) {
      this.logger.error('Error in incrementTrackCount', { id, error });
      throw error;
    }
  }

  /**
   * Decrement track count
   */
  async decrementTrackCount(id: string, client?: Pool): Promise<void> {
    const query = `
      UPDATE ${this.tableName}
      SET track_count = GREATEST(track_count - 1, 0)
      WHERE id = $1
    `;

    try {
      await (client || DatabaseConnectionManager.getPool()).query(query, [id]);
    } catch (error) {
      this.logger.error('Error in decrementTrackCount', { id, error });
      throw error;
    }
  }

  /**
   * Increment followers count
   */
  async incrementFollowersCount(id: string, client?: Pool): Promise<void> {
    const query = `
      UPDATE ${this.tableName}
      SET followers_count = followers_count + 1
      WHERE id = $1
    `;

    try {
      await (client || DatabaseConnectionManager.getPool()).query(query, [id]);
    } catch (error) {
      this.logger.error('Error in incrementFollowersCount', { id, error });
      throw error;
    }
  }

  /**
   * Decrement followers count
   */
  async decrementFollowersCount(id: string, client?: Pool): Promise<void> {
    const query = `
      UPDATE ${this.tableName}
      SET followers_count = GREATEST(followers_count - 1, 0)
      WHERE id = $1
    `;

    try {
      await (client || DatabaseConnectionManager.getPool()).query(query, [id]);
    } catch (error) {
      this.logger.error('Error in decrementFollowersCount', { id, error });
      throw error;
    }
  }
}

// Singleton instance
export const playlistRepository = new PlaylistRepository();

export class Playlist implements PlaylistAttributes {
  static belongsTo(_User: UserAttributes, _options: { foreignKey: string; as: string; }) {
      throw new Error('Method not implemented.');
  }
  static belongsToMany(_Track: Track, _options: { through: PlaylistTrack; foreignKey: string; as: string; }) {
      throw new Error('Method not implemented.');
  }
  id: string;
  name: string;
  description: string | null;
  coverArtUrl: string | null;
  isPublic: boolean;
  trackCount: number;
  followersCount: number;
  userId: string;
  createdAt: Date;
  updatedAt: Date;

  constructor(data: PlaylistAttributes) {
    this.id = data.id;
    this.name = data.name;
    this.description = data.description;
    this.coverArtUrl = data.coverArtUrl;
    this.isPublic = data.isPublic;
    this.trackCount = data.trackCount;
    this.followersCount = data.followersCount;
    this.userId = data.userId;
    this.createdAt = new Date(data.createdAt);
    this.updatedAt = new Date(data.updatedAt);
  }

  // Static methods that use the repository
  static async findByPk(id: string): Promise<Playlist | null> {
    const playlist = await playlistRepository.findById(id);
    return playlist ? new Playlist(playlist) : null;
  }

  static async findByUserId(userId: string): Promise<Playlist[]> {
    const playlists = await playlistRepository.findByUserId(userId);
    return playlists.map(playlist => new Playlist(playlist));
  }

  static async findPublic(limit?: number, offset?: number): Promise<Playlist[]> {
    const playlists = await playlistRepository.findPublic(limit, offset);
    return playlists.map(playlist => new Playlist(playlist));
  }

  static async create(data: Omit<PlaylistAttributes, 'id' | 'createdAt' | 'updatedAt'>): Promise<Playlist> {
    const {
      coverArtUrl, isPublic, trackCount, followersCount, userId,
      ...rest
    } = data;
    const playlist = await playlistRepository.create({
      ...rest,
      cover_art_url: coverArtUrl,
      is_public: isPublic,
      track_count: trackCount,
      followers_count: followersCount,
      user_id: userId
    } as Partial<PlaylistAttributes>);
    return new Playlist(playlist);
  }

  // Instance methods
  async update(data: Partial<PlaylistAttributes>): Promise<Playlist> {
    const {
      coverArtUrl, isPublic, trackCount, followersCount, userId,
      ...rest
    } = data;
    const updateData = {
      ...rest,
      ...(coverArtUrl !== undefined && { cover_art_url: coverArtUrl }),
      ...(isPublic !== undefined && { is_public: isPublic }),
      ...(trackCount !== undefined && { track_count: trackCount }),
      ...(followersCount !== undefined && { followers_count: followersCount }),
      ...(userId !== undefined && { user_id: userId })
    };
    const updated = await playlistRepository.update(this.id, updateData as Partial<PlaylistAttributes>);
    Object.assign(this, updated);
    return this;
  }

  async delete(): Promise<boolean> {
    return playlistRepository.delete(this.id);
  }

  async incrementTrackCount(): Promise<void> {
    await playlistRepository.incrementTrackCount(this.id);
    this.trackCount++;
  }

  async decrementTrackCount(): Promise<void> {
    await playlistRepository.decrementTrackCount(this.id);
    this.trackCount = Math.max(0, this.trackCount - 1);
  }

  async incrementFollowersCount(): Promise<void> {
    await playlistRepository.incrementFollowersCount(this.id);
    this.followersCount++;
  }

  async decrementFollowersCount(): Promise<void> {
    await playlistRepository.decrementFollowersCount(this.id);
    this.followersCount = Math.max(0, this.followersCount - 1);
  }

  async getUser(): Promise<UserAttributes | null> {
    return await userRepository.findById(this.userId);
  }

  async getTracks(): Promise<Track[]> {
    const playlistTracks = await PlaylistTrack.findByPlaylistId(this.id);
    const trackIds = playlistTracks.map(pt => pt.trackId);
    const tracks = await Promise.all(trackIds.map(id => Track.findByPk(id)));
    return tracks.filter((track): track is Track => track !== null);
  }

  toJSON() {
    return {
      ...this,
      createdAt: this.createdAt.toISOString(),
      updatedAt: this.updatedAt.toISOString()
    };
  }
}

export default Playlist; 
================================================================================
File: models\PlaylistTrack.ts
Lines: 247
--------------------------------------------------------------------------------
import { Pool } from 'pg';

import { BaseModel, BaseRepository } from '../database/BaseRepository';
import { DatabaseConnectionManager } from '../database/config';

import { Playlist } from './Playlist';
import { Track } from './Track';
import { userRepository, UserAttributes } from './User';

export interface PlaylistTrackAttributes extends BaseModel {
  playlistId: string;
  trackId: string;
  orderPosition: number;
  addedBy: string;
}

export class PlaylistTrackRepository extends BaseRepository<PlaylistTrackAttributes> {
  protected tableName = 'playlist_tracks';
  protected columns = [
    'id',
    'playlist_id as playlistId',
    'track_id as trackId',
    'order_position as orderPosition',
    'added_by as addedBy',
    'created_at as createdAt',
    'updated_at as updatedAt'
  ];

  /**
   * Find tracks in a playlist
   */
  async findByPlaylistId(playlistId: string, client?: Pool): Promise<PlaylistTrackAttributes[]> {
    const query = `
      SELECT ${this.columns.join(', ')}
      FROM ${this.tableName}
      WHERE playlist_id = $1
      ORDER BY order_position ASC
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [playlistId]);
      return result.rows as PlaylistTrackAttributes[];
    } catch (error) {
      this.logger.error('Error in findByPlaylistId', { playlistId, error });
      throw error;
    }
  }

  /**
   * Find playlists containing a track
   */
  async findByTrackId(trackId: string, client?: Pool): Promise<PlaylistTrackAttributes[]> {
    const query = `
      SELECT ${this.columns.join(', ')}
      FROM ${this.tableName}
      WHERE track_id = $1
      ORDER BY created_at DESC
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [trackId]);
      return result.rows as PlaylistTrackAttributes[];
    } catch (error) {
      this.logger.error('Error in findByTrackId', { trackId, error });
      throw error;
    }
  }

  /**
   * Get the next order position for a playlist
   */
  async getNextOrderPosition(playlistId: string, client?: Pool): Promise<number> {
    const query = `
      SELECT COALESCE(MAX(order_position), 0) + 1 as next_position
      FROM ${this.tableName}
      WHERE playlist_id = $1
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [playlistId]);
      const row = result.rows[0] as { next_position: number };
      return row.next_position;
    } catch (error) {
      this.logger.error('Error in getNextOrderPosition', { playlistId, error });
      throw error;
    }
  }

  /**
   * Reorder tracks in a playlist
   */
  async reorder(playlistId: string, trackId: string, newPosition: number, client?: Pool): Promise<void> {
    const pool = client || DatabaseConnectionManager.getPool();
    const transaction = await pool.connect();

    try {
      await transaction.query('BEGIN');

      // Get current position
      const currentQuery = `
        SELECT order_position
        FROM ${this.tableName}
        WHERE playlist_id = $1 AND track_id = $2
      `;
      const currentResult = await transaction.query(currentQuery, [playlistId, trackId]);
      const row = currentResult.rows[0] as { order_position: number } | undefined;
      const currentPosition = row?.order_position;

      if (currentPosition === undefined) {
        throw new Error('Track not found in playlist');
      }

      if (currentPosition < newPosition) {
        // Moving down: shift tracks up
        await transaction.query(`
          UPDATE ${this.tableName}
          SET order_position = order_position - 1
          WHERE playlist_id = $1
            AND order_position > $2
            AND order_position <= $3
        `, [playlistId, currentPosition, newPosition]);
      } else if (currentPosition > newPosition) {
        // Moving up: shift tracks down
        await transaction.query(`
          UPDATE ${this.tableName}
          SET order_position = order_position + 1
          WHERE playlist_id = $1
            AND order_position >= $2
            AND order_position < $3
        `, [playlistId, newPosition, currentPosition]);
      }

      // Update track position
      await transaction.query(`
        UPDATE ${this.tableName}
        SET order_position = $3
        WHERE playlist_id = $1 AND track_id = $2
      `, [playlistId, trackId, newPosition]);

      await transaction.query('COMMIT');
    } catch (error) {
      await transaction.query('ROLLBACK');
      this.logger.error('Error in reorder', { playlistId, trackId, newPosition, error });
      throw error;
    } finally {
      transaction.release();
    }
  }
}

// Singleton instance
export const playlistTrackRepository = new PlaylistTrackRepository();

export class PlaylistTrack implements PlaylistTrackAttributes {
  id: string;
  playlistId: string;
  trackId: string;
  orderPosition: number;
  addedBy: string;
  createdAt: Date;
  updatedAt: Date;

  constructor(data: PlaylistTrackAttributes) {
    this.id = data.id;
    this.playlistId = data.playlistId;
    this.trackId = data.trackId;
    this.orderPosition = data.orderPosition;
    this.addedBy = data.addedBy;
    this.createdAt = new Date(data.createdAt);
    this.updatedAt = new Date(data.updatedAt);
  }

  // Static methods that use the repository
  static async findByPk(id: string): Promise<PlaylistTrack | null> {
    const playlistTrack = await playlistTrackRepository.findById(id);
    return playlistTrack ? new PlaylistTrack(playlistTrack) : null;
  }

  static async findByPlaylistId(playlistId: string): Promise<PlaylistTrack[]> {
    const playlistTracks = await playlistTrackRepository.findByPlaylistId(playlistId);
    return playlistTracks.map(pt => new PlaylistTrack(pt));
  }

  static async findByTrackId(trackId: string): Promise<PlaylistTrack[]> {
    const playlistTracks = await playlistTrackRepository.findByTrackId(trackId);
    return playlistTracks.map(pt => new PlaylistTrack(pt));
  }

  static async create(data: Omit<PlaylistTrackAttributes, 'id' | 'createdAt' | 'updatedAt'>): Promise<PlaylistTrack> {
    const { playlistId, trackId, orderPosition, addedBy } = data;
    const nextPosition = orderPosition ?? await playlistTrackRepository.getNextOrderPosition(playlistId);
    
    const playlistTrack = await playlistTrackRepository.create({
      playlist_id: playlistId,
      track_id: trackId,
      order_position: nextPosition,
      added_by: addedBy
    } as Partial<PlaylistTrackAttributes>);
    return new PlaylistTrack(playlistTrack);
  }

  // Instance methods
  async update(data: Partial<PlaylistTrackAttributes>): Promise<PlaylistTrack> {
    const { playlistId, trackId, orderPosition, addedBy, ...rest } = data;
    const updateData = {
      ...rest,
      ...(playlistId !== undefined && { playlist_id: playlistId }),
      ...(trackId !== undefined && { track_id: trackId }),
      ...(orderPosition !== undefined && { order_position: orderPosition }),
      ...(addedBy !== undefined && { added_by: addedBy })
    };
    const updated = await playlistTrackRepository.update(this.id, updateData as Partial<PlaylistTrackAttributes>);
    Object.assign(this, updated);
    return this;
  }

  async delete(): Promise<boolean> {
    return playlistTrackRepository.delete(this.id);
  }

  async reorder(newPosition: number): Promise<void> {
    await playlistTrackRepository.reorder(this.playlistId, this.trackId, newPosition);
    this.orderPosition = newPosition;
  }

  async getPlaylist(): Promise<Playlist | null> {
    return Playlist.findByPk(this.playlistId);
  }

  async getTrack(): Promise<Track | null> {
    return Track.findByPk(this.trackId);
  }

  async getAddedByUser(): Promise<UserAttributes | null> {
    return await userRepository.findById(this.addedBy);
  }

  toJSON() {
    return {
      ...this,
      createdAt: this.createdAt.toISOString(),
      updatedAt: this.updatedAt.toISOString()
    };
  }
}

export default PlaylistTrack; 
================================================================================
File: models\Post.ts
Lines: 785
--------------------------------------------------------------------------------
import { Pool } from 'pg';

import { BaseModel, BaseRepository } from '../database/BaseRepository';
import { DatabaseConnectionManager } from '../database/config';

interface UserData {
  id: string;
  username: string;
  displayName: string;
  profileImage: string | null;
}

interface CommentData {
  id: string;
  userId: string;
  postId: string;
  parentId: string | null;
  content: string;
  likesCount: number;
  status: string;
  createdAt: Date;
  updatedAt: Date;
  user: UserData;
}

interface LikeData {
  id: string;
  userId: string;
  postId: string;
  createdAt: Date;
  updatedAt: Date;
  user: UserData;
}

export interface PostAttributes extends BaseModel {
  userId: string;
  content: string;
  media: string[];
  likesCount: number;
  commentsCount: number;
  sharesCount: number;
  status: string;
  moderationReason: string | null;
  moderatedBy: string | null;
  moderatedAt: Date | null;
}

export interface PostJSON extends Omit<Post, 'moderatedAt' | 'createdAt' | 'updatedAt'> {
  moderatedAt: string | null;
  createdAt: string;
  updatedAt: string;
  isLiked?: boolean;
}

export class PostRepository extends BaseRepository<PostAttributes> {
  protected tableName = 'posts';
  protected columns = [
    'id',
    'user_id as userId',
    'content',
    'media',
    'likes_count as likesCount',
    'comments_count as commentsCount',
    'shares_count as sharesCount',
    'status',
    'moderation_reason as moderationReason',
    'moderated_by as moderatedBy',
    'moderated_at as moderatedAt',
    'created_at as createdAt',
    'updated_at as updatedAt'
  ];

  /**
   * Find posts by user ID
   */
  async findByUserId(userId: string, limit: number = 20, offset: number = 0, client?: Pool): Promise<PostAttributes[]> {
    const query = `
      SELECT ${this.columns.join(', ')}
      FROM ${this.tableName}
      WHERE user_id = $1
      ORDER BY created_at DESC
      LIMIT $2 OFFSET $3
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [userId, limit, offset]);
      return result.rows as PostAttributes[];
    } catch (error) {
      this.logger.error('Error in findByUserId', { userId, limit, offset, error });
      throw error;
    }
  }

  /**
   * Find public posts
   */
  async findPublic(limit: number = 20, offset: number = 0, client?: Pool): Promise<PostAttributes[]> {
    const query = `
      SELECT ${this.columns.join(', ')}
      FROM ${this.tableName}
      WHERE status = 'published'
      ORDER BY created_at DESC
      LIMIT $1 OFFSET $2
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [limit, offset]);
      return result.rows as PostAttributes[];
    } catch (error) {
      this.logger.error('Error in findPublic', { limit, offset, error });
      throw error;
    }
  }

  /**
   * Increment likes count
   */
  async incrementLikes(id: string, client?: Pool): Promise<void> {
    const query = `
      UPDATE ${this.tableName}
      SET likes_count = likes_count + 1
      WHERE id = $1
    `;

    try {
      await (client || DatabaseConnectionManager.getPool()).query(query, [id]);
    } catch (error) {
      this.logger.error('Error in incrementLikes', { id, error });
      throw error;
    }
  }

  /**
   * Decrement likes count
   */
  async decrementLikes(id: string, client?: Pool): Promise<void> {
    const query = `
      UPDATE ${this.tableName}
      SET likes_count = GREATEST(likes_count - 1, 0)
      WHERE id = $1
    `;

    try {
      await (client || DatabaseConnectionManager.getPool()).query(query, [id]);
    } catch (error) {
      this.logger.error('Error in decrementLikes', { id, error });
      throw error;
    }
  }

  /**
   * Increment comments count
   */
  async incrementComments(id: string, client?: Pool): Promise<void> {
    const query = `
      UPDATE ${this.tableName}
      SET comments_count = comments_count + 1
      WHERE id = $1
    `;

    try {
      await (client || DatabaseConnectionManager.getPool()).query(query, [id]);
    } catch (error) {
      this.logger.error('Error in incrementComments', { id, error });
      throw error;
    }
  }

  /**
   * Decrement comments count
   */
  async decrementComments(id: string, client?: Pool): Promise<void> {
    const query = `
      UPDATE ${this.tableName}
      SET comments_count = GREATEST(comments_count - 1, 0)
      WHERE id = $1
    `;

    try {
      await (client || DatabaseConnectionManager.getPool()).query(query, [id]);
    } catch (error) {
      this.logger.error('Error in decrementComments', { id, error });
      throw error;
    }
  }

  /**
   * Increment shares count
   */
  async incrementShares(id: string, client?: Pool): Promise<void> {
    const query = `
      UPDATE ${this.tableName}
      SET shares_count = shares_count + 1
      WHERE id = $1
    `;

    try {
      await (client || DatabaseConnectionManager.getPool()).query(query, [id]);
    } catch (error) {
      this.logger.error('Error in incrementShares', { id, error });
      throw error;
    }
  }

  async find(options: { 
    limit?: number;
    offset?: number;
    filters?: {
      userId?: string;
      status?: string;
    }
  } = {}): Promise<PostAttributes[]> {
    const { limit = 50, offset = 0, filters = {} } = options;
    const conditions = [];
    const params = [];

    if (filters.userId) {
      conditions.push(`user_id = $${params.length + 1}`);
      params.push(filters.userId);
    }

    if (filters.status) {
      conditions.push(`status = $${params.length + 1}`);
      params.push(filters.status);
    }

    const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

    const query = `
      SELECT ${this.columns.join(', ')}
      FROM ${this.tableName}
      ${whereClause}
      ORDER BY created_at DESC
      LIMIT $${params.length + 1} 
      OFFSET $${params.length + 2}
    `;

    try {
      const result = await DatabaseConnectionManager.getPool().query(query, [...params, limit, offset]);
      return result.rows as PostAttributes[];
    } catch (error) {
      this.logger.error('Error in find', { options, error });
      throw error;
    }
  }

  async countLastWeek(): Promise<number> {
    const query = `
      SELECT COUNT(*) as count
      FROM ${this.tableName}
      WHERE created_at >= NOW() - INTERVAL '7 days'
    `;

    try {
      const result = await DatabaseConnectionManager.getPool().query(query);
      const row = result.rows[0] as { count: string };
      return parseInt(row.count);
    } catch (error) {
      this.logger.error('Error in countLastWeek', { error });
      throw error;
    }
  }

  /**
   * Find posts by multiple user IDs
   */
  async findByUserIds(userIds: string[], options: { limit?: number; offset?: number } = {}): Promise<PostAttributes[]> {
    const { limit = 20, offset = 0 } = options;
    const query = `
      SELECT ${this.columns.join(', ')}
      FROM ${this.tableName}
      WHERE user_id = ANY($1)
      ORDER BY created_at DESC
      LIMIT $2 OFFSET $3
    `;

    try {
      const result = await DatabaseConnectionManager.getPool().query(query, [userIds, limit, offset]);
      return result.rows as PostAttributes[];
    } catch (error) {
      this.logger.error('Error in findByUserIds', { userIds, options, error });
      throw error;
    }
  }

  /**
   * Find posts with user data
   */
  async findWithUser(id: string, client?: Pool): Promise<(PostAttributes & { user: UserData }) | null> {
    const query = `
      SELECT 
        p.*,
        json_build_object(
          'id', u.id,
          'username', u.username,
          'displayName', u.display_name,
          'profileImage', u.profile_image
        ) as user
      FROM 
        posts p
      LEFT JOIN 
        users u ON p.user_id = u.id
      WHERE 
        p.id = $1
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [id]);
      if (!result.rows[0]) return null;

      const row = result.rows[0] as {
        id: string;
        user_id: string;
        content: string;
        media: string[];
        likes_count: number;
        comments_count: number;
        shares_count: number;
        status: string;
        moderation_reason: string | null;
        moderated_by: string | null;
        moderated_at: Date | null;
        created_at: Date;
        updated_at: Date;
        user: {
          id: string;
          username: string;
          displayName: string;
          profileImage: string | null;
        };
      };
      const post = {
        id: row.id,
        userId: row.user_id,
        content: row.content,
        media: row.media,
        likesCount: row.likes_count,
        commentsCount: row.comments_count,
        sharesCount: row.shares_count,
        status: row.status,
        moderationReason: row.moderation_reason,
        moderatedBy: row.moderated_by,
        moderatedAt: row.moderated_at,
        createdAt: row.created_at,
        updatedAt: row.updated_at,
        user: {
          id: row.user.id,
          username: row.user.username,
          displayName: row.user.displayName,
          profileImage: row.user.profileImage
        } as UserData
      };

      return post;
    } catch (error) {
      console.error('Error in findWithUser:', error);
      throw error;
    }
  }

  /**
   * Find posts with comments
   */
  async findWithComments(id: string, limit: number = 20, offset: number = 0, client?: Pool): Promise<(PostAttributes & { comments: CommentData[] }) | null> {
    const query = `
      SELECT 
        p.*,
        COALESCE(
          json_agg(
            json_build_object(
              'id', c.id,
              'userId', c.user_id,
              'postId', c.post_id,
              'parentId', c.parent_id,
              'content', c.content,
              'likesCount', c.likes_count,
              'status', c.status,
              'createdAt', c.created_at,
              'updatedAt', c.updated_at,
              'user', json_build_object(
                'id', u.id,
                'username', u.username,
                'displayName', u.display_name,
                'profileImage', u.profile_image
              )
            ) ORDER BY c.created_at DESC
          ) FILTER (WHERE c.id IS NOT NULL), '[]'
        ) as comments
      FROM 
        posts p
      LEFT JOIN 
        comments c ON p.id = c.post_id
      LEFT JOIN
        users u ON c.user_id = u.id
      WHERE 
        p.id = $1
      GROUP BY 
        p.id
      LIMIT $2 OFFSET $3
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [id, limit, offset]);
      if (!result.rows[0]) return null;

      const row = result.rows[0] as {
        id: string;
        user_id: string;
        content: string;
        media: string[];
        likes_count: number;
        comments_count: number;
        shares_count: number;
        status: string;
        moderation_reason: string | null;
        moderated_by: string | null;
        moderated_at: Date | null;
        created_at: Date;
        updated_at: Date;
        comments: CommentData[];
      };

      const post = {
        id: row.id,
        userId: row.user_id,
        content: row.content,
        media: row.media,
        likesCount: row.likes_count,
        commentsCount: row.comments_count,
        sharesCount: row.shares_count,
        status: row.status,
        moderationReason: row.moderation_reason,
        moderatedBy: row.moderated_by,
        moderatedAt: row.moderated_at,
        createdAt: row.created_at,
        updatedAt: row.updated_at,
        comments: row.comments || []
      };

      return post;
    } catch (error) {
      console.error('Error in findWithComments:', error);
      throw error;
    }
  }

  /**
   * Find posts with likes
   */
  async findWithLikes(id: string, limit: number = 20, offset: number = 0, client?: Pool): Promise<(PostAttributes & { likes: LikeData[] }) | null> {
    const query = `
      SELECT 
        p.*,
        COALESCE(
          json_agg(
            json_build_object(
              'id', l.id,
              'userId', l.user_id,
              'postId', l.post_id,
              'createdAt', l.created_at,
              'updatedAt', l.updated_at,
              'user', json_build_object(
                'id', u.id,
                'username', u.username,
                'displayName', u.display_name,
                'profileImage', u.profile_image
              )
            ) ORDER BY l.created_at DESC
          ) FILTER (WHERE l.id IS NOT NULL), '[]'
        ) as likes
      FROM 
        posts p
      LEFT JOIN 
        likes l ON p.id = l.post_id
      LEFT JOIN
        users u ON l.user_id = u.id
      WHERE 
        p.id = $1
      GROUP BY 
        p.id
      LIMIT $2 OFFSET $3
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [id, limit, offset]);
      if (!result.rows[0]) return null;

      const row = result.rows[0] as {
        id: string;
        user_id: string;
        content: string;
        media: string[];
        likes_count: number;
        comments_count: number;
        shares_count: number;
        status: string;
        moderation_reason: string | null;
        moderated_by: string | null;
        moderated_at: Date | null;
        created_at: Date;
        updated_at: Date;
        likes: LikeData[];
      };

      const post = {
        id: row.id,
        userId: row.user_id,
        content: row.content,
        media: row.media,
        likesCount: row.likes_count,
        commentsCount: row.comments_count,
        sharesCount: row.shares_count,
        status: row.status,
        moderationReason: row.moderation_reason,
        moderatedBy: row.moderated_by,
        moderatedAt: row.moderated_at,
        createdAt: row.created_at,
        updatedAt: row.updated_at,
        likes: row.likes || []
      };

      return post;
    } catch (error) {
      console.error('Error in findWithLikes:', error);
      throw error;
    }
  }

  /**
   * Find complete post with all relationships
   */
  async findComplete(id: string, options: { 
    commentsLimit?: number, 
    commentsOffset?: number,
    likesLimit?: number,
    likesOffset?: number
  } = {}, client?: Pool): Promise<(PostAttributes & { user: UserData, comments: CommentData[], likes: LikeData[] }) | null> {
    const {
      commentsLimit = 20,
      commentsOffset = 0,
      likesLimit = 20,
      likesOffset = 0
    } = options;

    const query = `
      WITH post_data AS (
        SELECT 
          p.*,
          u.id as "user.id",
          u.username as "user.username",
          u.display_name as "user.displayName",
          u.profile_image as "user.profileImage"
        FROM ${this.tableName} p
        LEFT JOIN users u ON p.user_id = u.id
        WHERE p.id = $1
      ),
      comment_data AS (
        SELECT 
          c.id,
          c.content,
          c.user_id,
          c.created_at,
          u.username,
          u.display_name,
          u.profile_image
        FROM comments c
        LEFT JOIN users u ON c.user_id = u.id
        WHERE c.post_id = $1
        ORDER BY c.created_at DESC
        LIMIT $2 OFFSET $3
      ),
      like_data AS (
        SELECT 
          l.id,
          l.user_id,
          l.created_at,
          u.username,
          u.display_name,
          u.profile_image
        FROM likes l
        LEFT JOIN users u ON l.user_id = u.id
        WHERE l.post_id = $1
        ORDER BY l.created_at DESC
        LIMIT $4 OFFSET $5
      )
      SELECT 
        pd.*,
        json_agg(DISTINCT cd.*) FILTER (WHERE cd.id IS NOT NULL) as comments,
        json_agg(DISTINCT ld.*) FILTER (WHERE ld.id IS NOT NULL) as likes
      FROM post_data pd
      LEFT JOIN comment_data cd ON true
      LEFT JOIN like_data ld ON true
      GROUP BY 
        pd.id, pd.user_id, pd.content, pd.media, pd.likes_count,
        pd.comments_count, pd.shares_count, pd.status, pd.moderation_reason,
        pd.moderated_by, pd.moderated_at, pd.created_at, pd.updated_at,
        pd."user.id", pd."user.username", pd."user.displayName", pd."user.profileImage"
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool())
        .query(query, [id, commentsLimit, commentsOffset, likesLimit, likesOffset]);
      
      if (!result.rows[0]) return null;

      const row = result.rows[0] as {
        id: string;
        user_id: string;
        content: string;
        media: string[];
        likes_count: number;
        comments_count: number;
        shares_count: number;
        status: string;
        moderation_reason: string | null;
        moderated_by: string | null;
        moderated_at: Date | null;
        created_at: Date;
        updated_at: Date;
        'user.id': string;
        'user.username': string;
        'user.displayName': string;
        'user.profileImage': string | null;
        comments: CommentData[];
        likes: LikeData[];
      };

      return {
        id: row.id,
        userId: row.user_id,
        content: row.content,
        media: row.media,
        likesCount: row.likes_count,
        commentsCount: row.comments_count,
        sharesCount: row.shares_count,
        status: row.status,
        moderationReason: row.moderation_reason,
        moderatedBy: row.moderated_by,
        moderatedAt: row.moderated_at,
        createdAt: row.created_at,
        updatedAt: row.updated_at,
        user: {
          id: row['user.id'],
          username: row['user.username'],
          displayName: row['user.displayName'],
          profileImage: row['user.profileImage']
        } as UserData,
        comments: row.comments || [],
        likes: row.likes || []
      };
    } catch (error) {
      this.logger.error('Error in findComplete', { id, options, error });
      throw error;
    }
  }
}

// Singleton instance
export const postRepository = new PostRepository();

export class Post implements PostAttributes {
  id: string;
  userId: string;
  content: string;
  media: string[];
  likesCount: number;
  commentsCount: number;
  sharesCount: number;
  status: string;
  moderationReason: string | null;
  moderatedBy: string | null;
  moderatedAt: Date | null;
  createdAt: Date;
  updatedAt: Date;

  constructor(data: PostAttributes) {
    this.id = data.id;
    this.userId = data.userId;
    this.content = data.content;
    this.media = data.media;
    this.likesCount = data.likesCount;
    this.commentsCount = data.commentsCount;
    this.sharesCount = data.sharesCount;
    this.status = data.status;
    this.moderationReason = data.moderationReason;
    this.moderatedBy = data.moderatedBy;
    this.moderatedAt = data.moderatedAt ? new Date(data.moderatedAt) : null;
    this.createdAt = new Date(data.createdAt);
    this.updatedAt = new Date(data.updatedAt);
  }

  // Static methods that use the repository
  static async findByPk(id: string): Promise<Post | null> {
    const post = await postRepository.findById(id);
    return post ? new Post(post) : null;
  }

  static async findByUserId(userId: string, limit?: number, offset?: number): Promise<Post[]> {
    const posts = await postRepository.findByUserId(userId, limit, offset);
    return posts.map(post => new Post(post));
  }

  static async findPublic(limit?: number, offset?: number): Promise<Post[]> {
    const posts = await postRepository.findPublic(limit, offset);
    return posts.map(post => new Post(post));
  }

  static async create(data: Omit<PostAttributes, 'id' | 'createdAt' | 'updatedAt'>): Promise<Post> {
    const {
      userId, moderationReason, moderatedBy,
      moderatedAt, ...rest
    } = data;
    const post = await postRepository.create({
      ...rest,
      user_id: userId,
      moderation_reason: moderationReason,
      moderated_by: moderatedBy,
      moderated_at: moderatedAt
    } as Partial<PostAttributes>);
    return new Post(post);
  }

  // Instance methods
  async update(data: Partial<PostAttributes>): Promise<Post> {
    const {
      userId, moderationReason, moderatedBy,
      moderatedAt, ...rest
    } = data;
    const updateData = {
      ...rest,
      ...(userId !== undefined && { user_id: userId }),
      ...(moderationReason !== undefined && { moderation_reason: moderationReason }),
      ...(moderatedBy !== undefined && { moderated_by: moderatedBy }),
      ...(moderatedAt !== undefined && { moderated_at: moderatedAt })
    };
    const updated = await postRepository.update(this.id, updateData as Partial<PostAttributes>);
    Object.assign(this, updated);
    return this;
  }

  async delete(): Promise<boolean> {
    return postRepository.delete(this.id);
  }

  async incrementLikes(): Promise<void> {
    await postRepository.incrementLikes(this.id);
    this.likesCount++;
  }

  async decrementLikes(): Promise<void> {
    await postRepository.decrementLikes(this.id);
    this.likesCount = Math.max(0, this.likesCount - 1);
  }

  async incrementComments(): Promise<void> {
    await postRepository.incrementComments(this.id);
    this.commentsCount++;
  }

  async decrementComments(): Promise<void> {
    await postRepository.decrementComments(this.id);
    this.commentsCount = Math.max(0, this.commentsCount - 1);
  }

  async incrementShares(): Promise<void> {
    await postRepository.incrementShares(this.id);
    this.sharesCount++;
  }

  toJSON(): PostJSON {
    return {
      ...this,
      moderatedAt: this.moderatedAt?.toISOString() || null,
      createdAt: this.createdAt.toISOString(),
      updatedAt: this.updatedAt.toISOString()
    };
  }

  static async findByUserIds(userIds: string[], options: { limit?: number; offset?: number } = {}): Promise<Post[]> {
    const posts = await postRepository.findByUserIds(userIds, options);
    return posts.map(post => new Post(post));
  }
}

export default Post; 
================================================================================
File: models\Track.ts
Lines: 289
--------------------------------------------------------------------------------
import { Pool } from 'pg';

import { BaseModel, BaseRepository } from '../database/BaseRepository';
import { DatabaseConnectionManager } from '../database/config';

import { Album } from './Album';
import { Artist } from './Artist';
import { Playlist } from './Playlist';
import { PlaylistTrack } from './PlaylistTrack';

export interface TrackAttributes extends BaseModel {
  title: string;
  duration: number;
  fileUrl: string;
  fileSize: number;
  fileType: string;
  coverArtUrl: string | null;
  releaseDate: Date | null;
  genre: string | null;
  isPublic: boolean;
  playCount: number;
  artistId: string;
  albumId: string | null;
}

export class TrackRepository extends BaseRepository<TrackAttributes> {
  protected tableName = 'tracks';
  protected columns = [
    'id',
    'title',
    'duration',
    'file_url as fileUrl',
    'file_size as fileSize',
    'file_type as fileType',
    'cover_art_url as coverArtUrl',
    'release_date as releaseDate',
    'genre',
    'is_public as isPublic',
    'play_count as playCount',
    'artist_id as artistId',
    'album_id as albumId',
    'created_at as createdAt',
    'updated_at as updatedAt'
  ];

  /**
   * Find tracks by artist ID
   */
  async findByArtistId(artistId: string, client?: Pool): Promise<TrackAttributes[]> {
    const query = `
      SELECT ${this.columns.join(', ')}
      FROM ${this.tableName}
      WHERE artist_id = $1
      ORDER BY release_date DESC NULLS LAST, title ASC
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [artistId]);
      return result.rows as TrackAttributes[];
    } catch (error) {
      this.logger.error('Error in findByArtistId', { artistId, error });
      throw error;
    }
  }

  /**
   * Find tracks by album ID
   */
  async findByAlbumId(albumId: string, client?: Pool): Promise<TrackAttributes[]> {
    const query = `
      SELECT ${this.columns.join(', ')}
      FROM ${this.tableName}
      WHERE album_id = $1
      ORDER BY title ASC
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [albumId]);
      return result.rows as TrackAttributes[];
    } catch (error) {
      this.logger.error('Error in findByAlbumId', { albumId, error });
      throw error;
    }
  }

  /**
   * Find public tracks by genre
   */
  async findByGenre(genre: string, client?: Pool): Promise<TrackAttributes[]> {
    const query = `
      SELECT ${this.columns.join(', ')}
      FROM ${this.tableName}
      WHERE genre = $1 AND is_public = true
      ORDER BY release_date DESC NULLS LAST, play_count DESC
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [genre]);
      return result.rows as TrackAttributes[];
    } catch (error) {
      this.logger.error('Error in findByGenre', { genre, error });
      throw error;
    }
  }

  /**
   * Find top tracks by play count
   */
  async findTopTracks(limit: number = 10, client?: Pool): Promise<TrackAttributes[]> {
    const query = `
      SELECT ${this.columns.join(', ')}
      FROM ${this.tableName}
      WHERE is_public = true
      ORDER BY play_count DESC
      LIMIT $1
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [limit]);
      return result.rows as TrackAttributes[];
    } catch (error) {
      this.logger.error('Error in findTopTracks', { limit, error });
      throw error;
    }
  }

  /**
   * Increment play count
   */
  async incrementPlayCount(id: string, client?: Pool): Promise<void> {
    const query = `
      UPDATE ${this.tableName}
      SET play_count = play_count + 1
      WHERE id = $1
    `;

    try {
      await (client || DatabaseConnectionManager.getPool()).query(query, [id]);
    } catch (error) {
      this.logger.error('Error in incrementPlayCount', { id, error });
      throw error;
    }
  }
}

// Singleton instance
export const trackRepository = new TrackRepository();

export class Track implements TrackAttributes {
  static belongsTo(_Album: typeof Album, _options: { foreignKey: string; as: string; }) {
      throw new Error('Method not implemented.');
  }
  static belongsToMany(_Playlist: typeof Playlist, _options: { through: typeof PlaylistTrack; foreignKey: string; as: string; }) {
      throw new Error('Method not implemented.');
  }
  id: string;
  title: string;
  duration: number;
  fileUrl: string;
  fileSize: number;
  fileType: string;
  coverArtUrl: string | null;
  releaseDate: Date | null;
  genre: string | null;
  isPublic: boolean;
  playCount: number;
  artistId: string;
  albumId: string | null;
  createdAt: Date;
  updatedAt: Date;

  constructor(data: TrackAttributes) {
    this.id = data.id;
    this.title = data.title;
    this.duration = data.duration;
    this.fileUrl = data.fileUrl;
    this.fileSize = data.fileSize;
    this.fileType = data.fileType;
    this.coverArtUrl = data.coverArtUrl;
    this.releaseDate = data.releaseDate ? new Date(data.releaseDate) : null;
    this.genre = data.genre;
    this.isPublic = data.isPublic;
    this.playCount = data.playCount;
    this.artistId = data.artistId;
    this.albumId = data.albumId;
    this.createdAt = new Date(data.createdAt);
    this.updatedAt = new Date(data.updatedAt);
  }

  // Static methods that use the repository
  static async findByPk(id: string): Promise<Track | null> {
    const track = await trackRepository.findById(id);
    return track ? new Track(track) : null;
  }

  static async findByArtistId(artistId: string): Promise<Track[]> {
    const tracks = await trackRepository.findByArtistId(artistId);
    return tracks.map(track => new Track(track));
  }

  static async findByAlbumId(albumId: string): Promise<Track[]> {
    const tracks = await trackRepository.findByAlbumId(albumId);
    return tracks.map(track => new Track(track));
  }

  static async findByGenre(genre: string): Promise<Track[]> {
    const tracks = await trackRepository.findByGenre(genre);
    return tracks.map(track => new Track(track));
  }

  static async findTopTracks(limit?: number): Promise<Track[]> {
    const tracks = await trackRepository.findTopTracks(limit);
    return tracks.map(track => new Track(track));
  }

  static async create(data: Omit<TrackAttributes, 'id' | 'createdAt' | 'updatedAt'>): Promise<Track> {
    const {
      fileUrl, fileSize, fileType, coverArtUrl, releaseDate,
      isPublic, playCount, artistId, albumId,
      ...rest
    } = data;
    const track = await trackRepository.create({
      ...rest,
      file_url: fileUrl,
      file_size: fileSize,
      file_type: fileType,
      cover_art_url: coverArtUrl,
      release_date: releaseDate,
      is_public: isPublic,
      play_count: playCount,
      artist_id: artistId,
      album_id: albumId
    } as Partial<TrackAttributes>);
    return new Track(track);
  }

  // Instance methods
  async update(data: Partial<TrackAttributes>): Promise<Track> {
    const {
      fileUrl, fileSize, fileType, coverArtUrl, releaseDate,
      isPublic, playCount, artistId, albumId,
      ...rest
    } = data;
    const updateData = {
      ...rest,
      ...(fileUrl !== undefined && { file_url: fileUrl }),
      ...(fileSize !== undefined && { file_size: fileSize }),
      ...(fileType !== undefined && { file_type: fileType }),
      ...(coverArtUrl !== undefined && { cover_art_url: coverArtUrl }),
      ...(releaseDate !== undefined && { release_date: releaseDate }),
      ...(isPublic !== undefined && { is_public: isPublic }),
      ...(playCount !== undefined && { play_count: playCount }),
      ...(artistId !== undefined && { artist_id: artistId }),
      ...(albumId !== undefined && { album_id: albumId })
    };
    const updated = await trackRepository.update(this.id, updateData as Partial<TrackAttributes>);
    Object.assign(this, updated);
    return this;
  }

  async delete(): Promise<boolean> {
    return trackRepository.delete(this.id);
  }

  async incrementPlayCount(): Promise<void> {
    await trackRepository.incrementPlayCount(this.id);
    this.playCount++;
  }

  async getArtist(): Promise<Artist | null> {
    return Artist.findByPk(this.artistId);
  }

  async getAlbum(): Promise<Album | null> {
    if (!this.albumId) return null;
    return Album.findByPk(this.albumId);
  }

  toJSON() {
    return {
      ...this,
      releaseDate: this.releaseDate?.toISOString() || null,
      createdAt: this.createdAt.toISOString(),
      updatedAt: this.updatedAt.toISOString()
    };
  }
}

export default Track; 
================================================================================
File: models\TwoFactorAuth.ts
Lines: 136
--------------------------------------------------------------------------------
import { Pool } from 'pg';

import { BaseModel, BaseRepository } from '../database/BaseRepository';
import { DatabaseConnectionManager } from '../database/config';

// Two-factor authentication status
export enum TwoFactorStatus {
  DISABLED = 'disabled',
  PENDING = 'pending',
  ENABLED = 'enabled'
}

export interface TwoFactorAuthAttributes extends BaseModel {
  userId: string;
  secret: string;
  status: string;
  backupCodes: string[];
  lastUsed: Date | null;
}

export class TwoFactorAuthRepository extends BaseRepository<TwoFactorAuthAttributes> {
  protected tableName = 'two_factor_auth';
  protected columns = [
    'id',
    'user_id as userId',
    'secret',
    'status',
    'backup_codes as backupCodes',
    'last_used as lastUsed',
    'created_at as createdAt',
    'updated_at as updatedAt'
  ];

  /**
   * Find by user ID
   */
  async findByUserId(userId: string, client?: Pool): Promise<TwoFactorAuthAttributes | null> {
    const query = `
      SELECT ${this.columns.join(', ')}
      FROM ${this.tableName}
      WHERE user_id = $1
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [userId]);
      return (result.rows[0] || null) as TwoFactorAuthAttributes | null;
    } catch (error) {
      this.logger.error('Error in findByUserId', { userId, error });
      throw error;
    }
  }
}

// Singleton instance
export const twoFactorAuthRepository = new TwoFactorAuthRepository();

export class TwoFactorAuth implements TwoFactorAuthAttributes {
  static scope(_: undefined): TwoFactorAuth {
    throw new Error('Method not implemented.');
  }

  static belongsTo(_user: typeof TwoFactorAuth, _options: { foreignKey: string; as: string; }) {
    throw new Error('Method not implemented.');
  }

  id: string;
  userId: string;
  secret: string;
  status: string;
  backupCodes: string[];
  lastUsed: Date | null;
  createdAt: Date;
  updatedAt: Date;

  constructor(data: TwoFactorAuthAttributes) {
    this.id = data.id;
    this.userId = data.userId;
    this.secret = data.secret;
    this.status = data.status;
    this.backupCodes = data.backupCodes;
    this.lastUsed = data.lastUsed ? new Date(data.lastUsed) : null;
    this.createdAt = new Date(data.createdAt);
    this.updatedAt = new Date(data.updatedAt);
  }

  // Static methods that use the repository
  static async findByPk(id: string): Promise<TwoFactorAuth | null> {
    const twoFactorAuth = await twoFactorAuthRepository.findById(id);
    return twoFactorAuth ? new TwoFactorAuth(twoFactorAuth) : null;
  }

  static async findByUserId(userId: string): Promise<TwoFactorAuth | null> {
    const twoFactorAuth = await twoFactorAuthRepository.findByUserId(userId);
    return twoFactorAuth ? new TwoFactorAuth(twoFactorAuth) : null;
  }

  static async create(data: Omit<TwoFactorAuthAttributes, 'id' | 'createdAt' | 'updatedAt'>): Promise<TwoFactorAuth> {
    const { userId, backupCodes, lastUsed, ...rest } = data;
    const twoFactorAuth = await twoFactorAuthRepository.create({
      ...rest,
      user_id: userId,
      backup_codes: backupCodes,
      last_used: lastUsed
    } as Partial<TwoFactorAuthAttributes>);
    return new TwoFactorAuth(twoFactorAuth);
  }

  // Instance methods
  async update(data: Partial<TwoFactorAuthAttributes>): Promise<TwoFactorAuth> {
    const { userId, backupCodes, lastUsed, ...rest } = data;
    const updateData = {
      ...rest,
      ...(userId !== undefined && { user_id: userId }),
      ...(backupCodes !== undefined && { backup_codes: backupCodes }),
      ...(lastUsed !== undefined && { last_used: lastUsed })
    };
    const updated = await twoFactorAuthRepository.update(this.id, updateData as Partial<TwoFactorAuthAttributes>);
    Object.assign(this, updated);
    return this;
  }

  async delete(): Promise<boolean> {
    return twoFactorAuthRepository.delete(this.id);
  }

  toJSON() {
    return {
      ...this,
      lastUsed: this.lastUsed?.toISOString() || null,
      createdAt: this.createdAt.toISOString(),
      updatedAt: this.updatedAt.toISOString()
    };
  }
}

export default TwoFactorAuth; 
================================================================================
File: models\User.ts
Lines: 507
--------------------------------------------------------------------------------
// src/server/models/User.ts
import bcrypt from 'bcrypt';
import { Pool } from 'pg';

import { BaseModel, BaseRepository } from '../database/BaseRepository';
import { DatabaseConnectionManager } from '../database/config';

// Mock in-memory storage for development without PostgreSQL
const mockUsers: Map<string, UserAttributes> = new Map();

export interface UserAttributes extends BaseModel {
  username: string;
  email: string;
  password: string;
  displayName: string | null;
  firstName: string | null;
  lastName: string | null;
  bio: string | null;
  profileImage: string | null;
  bannerImage: string | null;
  role: string;
  isVerified: boolean;
  emailConfirmed: boolean;
  emailToken: string | null;
  emailTokenExpire: Date | null;
  lastEmailSent: Date | null;
}

export interface UserJSON extends Omit<User, 'password' | 'update' | 'delete' | 'comparePassword' | 'updatePassword' | 'toJSON' | 'emailToken' | 'emailTokenExpire'> {
  posts?: UserAttributes[];
  isFollowing?: boolean;
}

export class UserRepository extends BaseRepository<UserAttributes> {
  protected tableName = 'users';
  protected columns = [
    'id',
    'username',
    'email',
    'password',
    'display_name as displayName',
    'first_name as firstName',
    'last_name as lastName',
    'bio',
    'profile_image as profileImage',
    'banner_image as bannerImage',
    'role',
    'is_verified as isVerified',
    'email_confirmed as emailConfirmed',
    'email_token as emailToken',
    'email_token_expire as emailTokenExpire',
    'last_email_sent as lastEmailSent',
    'created_at as createdAt',
    'updated_at as updatedAt'
  ];

  /**
   * Find a user by their email
   */
  async findByEmail(email: string, client?: Pool): Promise<UserAttributes | null> {
    const query = `
      SELECT ${this.columns.join(', ')}
      FROM ${this.tableName}
      WHERE email = $1
    `;

    const result = await (client || DatabaseConnectionManager.getPool()).query(query, [email]);
    return (result.rows[0] || null) as UserAttributes | null;
  }

  /**
   * Find a user by their username
   */
  async findByUsername(username: string, client?: Pool): Promise<UserAttributes | null> {
    const query = `
      SELECT ${this.columns.join(', ')}
      FROM ${this.tableName}
      WHERE username = $1
    `;

    const result = await (client || DatabaseConnectionManager.getPool()).query(query, [username]);
    return (result.rows[0] || null) as UserAttributes | null;
  }

  /**
   * Create a new user with a hashed password
   */
  async createWithHashedPassword(data: Omit<UserAttributes, 'id' | 'createdAt' | 'updatedAt'>, client?: Pool): Promise<UserAttributes> {
    const hashedPassword = await bcrypt.hash(data.password, 10);
    const { displayName, firstName, lastName, profileImage, bannerImage, isVerified, ...rest } = data;
    return this.create({
      ...rest,
      password: hashedPassword,
      display_name: displayName,
      first_name: firstName,
      last_name: lastName,
      profile_image: profileImage,
      banner_image: bannerImage,
      is_verified: isVerified
    } as Partial<UserAttributes>, client);
  }

  async countByRole(): Promise<Record<string, number>> {
    const query = `
      SELECT role, COUNT(*) as count
      FROM ${this.tableName}
      GROUP BY role
    `;

    try {
      const result = await DatabaseConnectionManager.getPool().query(query);
      const roleCount: Record<string, number> = {};
      
      for (const row of result.rows as { role: string; count: string }[]) {
        roleCount[row.role] = parseInt(row.count);
      }
      
      return roleCount;
    } catch (error) {
      this.logger.error('Error in countByRole', { error });
      throw error;
    }
  }

  /**
   * Find user with their posts
   */
  async findWithPosts(id: string, limit: number = 20, offset: number = 0, client?: Pool): Promise<(UserAttributes & { posts: UserAttributes[] }) | null> {
    const query = `
      SELECT 
        u.*,
        COALESCE(
          json_agg(
            json_build_object(
              'id', p.id,
              'userId', p.user_id,
              'content', p.content,
              'media', p.media,
              'likesCount', p.likes_count,
              'commentsCount', p.comments_count,
              'sharesCount', p.shares_count,
              'status', p.status,
              'moderationReason', p.moderation_reason,
              'moderatedBy', p.moderated_by,
              'moderatedAt', p.moderated_at,
              'createdAt', p.created_at,
              'updatedAt', p.updated_at
            )
          ) FILTER (WHERE p.id IS NOT NULL), '[]'
        ) as posts
      FROM 
        users u
      LEFT JOIN 
        posts p ON u.id = p.user_id
      WHERE 
        u.id = $1
      GROUP BY 
        u.id
      LIMIT $2 OFFSET $3;
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [id, limit, offset]);
      if (!result.rows[0]) return null;

      const row = result.rows[0] as {
        posts: UserAttributes[];
      } & Omit<UserAttributes, 'posts'>;
      return {
        ...row,
        posts: row.posts || []
      } as (UserAttributes & { posts: UserAttributes[] }) | null;
    } catch (error) {
      console.error('Error in findWithPosts:', error);
      throw error;
    }
  }

  /**
   * Find user with their followers
   */
  async findWithFollowers(id: string, limit: number = 20, offset: number = 0, client?: Pool): Promise<(UserAttributes & { followers: UserAttributes[] }) | null> {
    const query = `
      SELECT 
        u.*,
        COALESCE(
          json_agg(
            json_build_object(
              'id', f.id,
              'followerId', f.follower_id,
              'followingId', f.following_id,
              'createdAt', f.created_at,
              'updatedAt', f.updated_at,
              'follower', json_build_object(
                'id', fu.id,
                'username', fu.username,
                'displayName', fu.display_name,
                'profileImage', fu.profile_image
              )
            )
          ) FILTER (WHERE f.id IS NOT NULL), '[]'
        ) as followers
      FROM 
        users u
      LEFT JOIN 
        follows f ON u.id = f.following_id
      LEFT JOIN
        users fu ON f.follower_id = fu.id
      WHERE 
        u.id = $1
      GROUP BY 
        u.id
      LIMIT $2 OFFSET $3;
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [id, limit, offset]);
      if (!result.rows[0]) return null;

      const row = result.rows[0] as { followers: UserAttributes[] } & Omit<UserAttributes, 'followers'>;
      return {
        ...row,
        followers: row.followers || []
      } as (UserAttributes & { followers: UserAttributes[] });
    } catch (error) {
      console.error('Error in findWithFollowers:', error);
      throw error;
    }
  }

  /**
   * Find user with their following
   */
  async findWithFollowing(id: string, limit: number = 20, offset: number = 0, client?: Pool): Promise<(UserAttributes & { following: UserAttributes[] }) | null> {
    const query = `
      SELECT 
        u.*,
        COALESCE(
          json_agg(
            json_build_object(
              'id', f.id,
              'followerId', f.follower_id,
              'followingId', f.following_id,
              'createdAt', f.created_at,
              'updatedAt', f.updated_at,
              'following', json_build_object(
                'id', fu.id,
                'username', fu.username,
                'displayName', fu.display_name,
                'profileImage', fu.profile_image
              )
            )
          ) FILTER (WHERE f.id IS NOT NULL), '[]'
        ) as following
      FROM 
        users u
      LEFT JOIN 
        follows f ON u.id = f.follower_id
      LEFT JOIN
        users fu ON f.following_id = fu.id
      WHERE 
        u.id = $1
      GROUP BY 
        u.id
      LIMIT $2 OFFSET $3;
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool()).query(query, [id, limit, offset]);
      if (!result.rows[0]) return null;

      const row = result.rows[0] as {
        following: UserAttributes[];
      } & Omit<UserAttributes, 'following'>;
      return {
        ...row,
        following: row.following || []
      } as (UserAttributes & { following: UserAttributes[] });
    } catch (error) {
      console.error('Error in findWithFollowing:', error);
      throw error;
    }
  }

  /**
   * Find complete user profile with all relationships
   */
  async findComplete(id: string, options: {
    postsLimit?: number;
    postsOffset?: number;
    followersLimit?: number;
    followersOffset?: number;
    followingLimit?: number;
    followingOffset?: number;
  } = {}, client?: Pool): Promise<(UserAttributes & { posts: UserAttributes[], followers: UserAttributes[], following: UserAttributes[] }) | null> {
    const {
      postsLimit = 20,
      postsOffset = 0,
      followersLimit = 20,
      followersOffset = 0,
      followingLimit = 20,
      followingOffset = 0
    } = options;

    const query = `
      WITH user_data AS (
        SELECT ${this.columns.join(', ')}
        FROM ${this.tableName}
        WHERE id = $1
      ),
      post_data AS (
        SELECT 
          p.id,
          p.content,
          p.media,
          p.likes_count,
          p.comments_count,
          p.shares_count,
          p.status,
          p.created_at,
          p.updated_at
        FROM posts p
        WHERE p.user_id = $1
        ORDER BY p.created_at DESC
        LIMIT $2 OFFSET $3
      ),
      follower_data AS (
        SELECT 
          u.id,
          u.username,
          u.display_name as displayName,
          u.profile_image as profileImage,
          f.created_at as followedAt
        FROM follows f
        JOIN users u ON f.follower_id = u.id
        WHERE f.followed_id = $1
        ORDER BY f.created_at DESC
        LIMIT $4 OFFSET $5
      ),
      following_data AS (
        SELECT 
          u.id,
          u.username,
          u.display_name as displayName,
          u.profile_image as profileImage,
          f.created_at as followedAt
        FROM follows f
        JOIN users u ON f.followed_id = u.id
        WHERE f.follower_id = $1
        ORDER BY f.created_at DESC
        LIMIT $6 OFFSET $7
      )
      SELECT 
        ud.*,
        json_agg(DISTINCT pd.*) FILTER (WHERE pd.id IS NOT NULL) as posts,
        json_agg(DISTINCT frd.*) FILTER (WHERE frd.id IS NOT NULL) as followers,
        json_agg(DISTINCT fgd.*) FILTER (WHERE fgd.id IS NOT NULL) as following
      FROM user_data ud
      LEFT JOIN post_data pd ON true
      LEFT JOIN follower_data frd ON true
      LEFT JOIN following_data fgd ON true
      GROUP BY ${this.columns.map(c => 'ud.' + c.split(' ')[0]).join(', ')}
    `;

    try {
      const result = await (client || DatabaseConnectionManager.getPool())
        .query(query, [id, postsLimit, postsOffset, followersLimit, followersOffset, followingLimit, followingOffset]);
      
      if (!result.rows[0]) return null;

      const row = result.rows[0] as { posts: UserAttributes[], followers: UserAttributes[], following: UserAttributes[] } & Omit<UserAttributes, 'posts' | 'followers' | 'following'>;
      return {
        ...row,
        posts: row.posts || [],
        followers: row.followers || [],
        following: row.following || []
      } as (UserAttributes & { posts: UserAttributes[], followers: UserAttributes[], following: UserAttributes[] });
    } catch (error) {
      this.logger.error('Error in findComplete', { id, options, error });
      throw error;
    }
  }
}

// Singleton instance
export const userRepository = new UserRepository();

// Mock implementation for development without PostgreSQL
export class User implements UserAttributes {
  id: string;
  username: string;
  email: string;
  password: string;
  displayName: string | null;
  firstName: string | null;
  lastName: string | null;
  bio: string | null;
  profileImage: string | null;
  bannerImage: string | null;
  role: string;
  isVerified: boolean;
  emailConfirmed: boolean;
  emailToken: string | null;
  emailTokenExpire: Date | null;
  lastEmailSent: Date | null;
  createdAt: Date;
  updatedAt: Date;

  constructor(data: Partial<UserAttributes>) {
    this.id = data.id || crypto.randomUUID();
    this.username = data.username || '';
    this.email = data.email || '';
    this.password = data.password || '';
    this.displayName = data.displayName || null;
    this.firstName = data.firstName || null;
    this.lastName = data.lastName || null;
    this.bio = data.bio || null;
    this.profileImage = data.profileImage || null;
    this.bannerImage = data.bannerImage || null;
    this.role = data.role || 'user';
    this.isVerified = data.isVerified || false;
    this.emailConfirmed = data.emailConfirmed || false;
    this.emailToken = data.emailToken || null;
    this.emailTokenExpire = data.emailTokenExpire || null;
    this.lastEmailSent = data.lastEmailSent || null;
    this.createdAt = data.createdAt || new Date();
    this.updatedAt = data.updatedAt || new Date();
  }

  // Static methods for mock database operations
  static async create(data: Partial<UserAttributes>): Promise<User> {
    try {
      // Try to use real database first
      if (DatabaseConnectionManager.isConnected()) {
        // Real database implementation
        const pool = DatabaseConnectionManager.getPool();
        
        // Convert camelCase to snake_case for database columns
        const query = `
          INSERT INTO users (
            username, 
            email, 
            password, 
            display_name, 
            first_name, 
            last_name, 
            bio, 
            profile_image, 
            banner_image, 
            role, 
            is_verified, 
            email_confirmed, 
            email_token, 
            email_token_expire, 
            last_email_sent
          ) VALUES (
            $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15
          ) RETURNING *
        `;
        
        const result = await pool.query(query, [
          data.username,
          data.email,
          data.password,
          data.displayName,
          data.firstName,
          data.lastName,
          data.bio,
          data.profileImage,
          data.bannerImage,
          data.role,
          data.isVerified,
          data.emailConfirmed,
          data.emailToken,
          data.emailTokenExpire,
          data.lastEmailSent
        ]);
        
        return new User(result.rows[0] as UserAttributes);
      } else {
        // Mock implementation
        const user = new User(data);
        mockUsers.set(user.id, user);
        return user;
      }
    } catch (error) {
      console.error('Error in User.create', { error });
      throw error;
    }
  }

  // Static methods that use the repository
  static async findByEmail(email: string): Promise<User | null> {
    const user = await userRepository.findByEmail(email);
    return user ? new User(user) : null;
  }

  static async findByPk(id: string): Promise<User | null> {
    const user = await userRepository.findById(id);
    return user ? new User(user) : null;
  }

  static async findAll(): Promise<User[]> {
    const users = await userRepository.findAll();
    return users.map(user => new User(user));
  }
}
================================================================================
File: routes\admin.ts
Lines: 241
--------------------------------------------------------------------------------
import express from 'express';
import type { Request, Response, NextFunction } from 'express';
import { z } from 'zod';

import { authenticate, authorize } from '../middleware/auth';
import { NotFoundError } from '../middleware/error';
import { validate } from '../middleware/validate';
import { commentRepository } from '../models/Comment';
import { postRepository } from '../models/Post';
import { userRepository } from '../models/User';

// Validation schemas
const userRoleSchema = z.object({
  role: z.enum(['user', 'moderator', 'admin'], {
    errorMap: () => ({ message: 'Role must be one of: user, moderator, admin' })
  })
});

const userIdParamSchema = z.object({
  userId: z.string().uuid('Invalid user ID format')
});

const postIdParamSchema = z.object({
  postId: z.string().uuid('Invalid post ID format')
});

const commentIdParamSchema = z.object({
  commentId: z.string().uuid('Invalid comment ID format')
});

// Create router using our typed router utility
const router: express.Router = express.Router();

// All routes require authentication and admin role
router.use(authenticate, authorize('admin'));

// Get all users
router.get('/users', async (_req: Request, res: Response, next: NextFunction) => {
  try {
    const users = await userRepository.findAll();
    const usersResponse = users.map(user => {
      // Convert to unknown first, then to Record<string, unknown>
      const userData = user as unknown as Record<string, unknown>;
      return {
        ...userData,
        toJSON: () => userData
      };
    });
    
    res.json({
      status: 'success',
      data: { users: usersResponse }
    });
  } catch (error) {
    next(error);
  }
});

// Update user role
router.patch(
  '/users/:userId/role',
  validate(userIdParamSchema, 'params'),
  validate(userRoleSchema),
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const { userId  } = req.params as { userId: string };
      const { role  } = req.body as { role: string };
      
      // Use userRepository instead of User model directly
      const user = await userRepository.findById(userId) as unknown as { 
        id: string; 
        update: (data: Record<string, unknown>) => Promise<unknown>;
        toJSON: () => Record<string, unknown>;
      };
      if (!user) {
        throw new NotFoundError('User not found');
      }
      
      // Prevent changing own role (admin can't demote themselves)
      const reqUserId = (req.user as { id: string } | undefined)?.id;
      if (user.id === reqUserId) {
        throw new Error('Cannot change your own role');
      }
      
      await user.update({ role });
      
      res.json({
        status: 'success',
        data: { user: user.toJSON() }
      });
    } catch (error) {
      next(error);
    }
  }
);

// Delete user
router.delete(
  '/users/:userId',
  validate(userIdParamSchema, 'params'),
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const { userId  } = req.params as { userId: string };
      
      // Use userRepository instead of User model directly
      const user = await userRepository.findById(userId) as unknown as { 
        id: string; 
        delete: () => Promise<unknown>;
      };
      if (!user) {
        throw new NotFoundError('User not found');
      }
      
      // Prevent deleting own account
      const reqUserId = (req.user as { id: string } | undefined)?.id;
      if (user.id === reqUserId) {
        throw new Error('Cannot delete your own account');
      }
      
      await user.delete();
      
      res.json({
        status: 'success',
        message: 'User deleted successfully'
      });
    } catch (error) {
      next(error);
    }
  }
);

// Get all posts (with filtering options)
router.get('/posts', async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { userId, status  } = req.query as { userId: string, status: string };
    
    const posts = await postRepository.find({ 
      limit: 50,
      filters: {
        ...(userId && { userId }),
        ...(status && { status })
      }
    });
    
    res.json({
      status: 'success',
      data: { posts }
    });
  } catch (error) {
    next(error);
  }
});

// Delete post
router.delete(
  '/posts/:postId',
  validate(postIdParamSchema, 'params'),
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const { postId  } = req.params as { postId: string };
      
      // Use postRepository instead of Post model directly
      const post = await postRepository.findById(postId) as unknown as { 
        id: string; 
        delete: () => Promise<unknown>;
      };
      if (!post) {
        throw new NotFoundError('Post not found');
      }
      
      await post.delete();
      
      res.json({
        status: 'success',
        message: 'Post deleted successfully'
      });
    } catch (error) {
      next(error);
    }
  }
);

// Delete comment
router.delete(
  '/comments/:commentId',
  validate(commentIdParamSchema, 'params'),
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const { commentId  } = req.params as { commentId: string };
      
      // Use commentRepository instead of Comment model directly
      const comment = await commentRepository.findById(commentId) as unknown as { 
        id: string; 
        delete: () => Promise<unknown>;
      };
      if (!comment) {
        throw new NotFoundError('Comment not found');
      }
      
      await comment.delete();
      
      res.json({
        status: 'success',
        message: 'Comment deleted successfully'
      });
    } catch (error) {
      next(error);
    }
  }
);

// Get system stats
router.get('/stats', async (_req: Request, res: Response, next: NextFunction) => {
  try {
    const userCount = await userRepository.count();
    const postCount = await postRepository.count();
    const commentCount = await commentRepository.count();
    
    // Get user counts by role
    const usersByRole = await userRepository.countByRole();
    
    // Get posts created in the last 7 days
    const lastWeekPosts = await postRepository.countLastWeek();
    
    res.json({
      status: 'success',
      data: {
        userCount,
        postCount,
        commentCount,
        usersByRole,
        lastWeekPosts
      }
    });
  } catch (error) {
    next(error);
  }
});

// Export the router
export { router as adminRouter };
================================================================================
File: routes\auth.ts
Lines: 352
--------------------------------------------------------------------------------
import express from 'express';
import type { Request, Response, NextFunction } from 'express';

import { NotFoundError, UnauthorizedError } from '../../shared/errors/ApiError';
import { AuthController } from '../controllers/AuthController';
import { authenticate, authorize } from '../middleware/auth';
import { authenticateJWT } from '../middleware/authenticateJWT';
import { customValidate } from '../middleware/customValidate';
import { User, UserAttributes } from '../models/User';
import { AuthService } from '../services/AuthService';
import { AuthTokenService, TokenType } from '../services/AuthTokenService';
import { Logger } from '../services/LoggerService';
import { 
  registerSchema, 
  loginSchema, 
  updateProfileSchema, 
  changePasswordSchema,
  twoFactorVerifySchema,
  twoFactorEnableSchema
} from '../validators/auth.validator';

// Cookie settings
const REFRESH_TOKEN_COOKIE_OPTIONS = {
  httpOnly: true,
  secure: process.env.NODE_ENV === 'production',
  sameSite: process.env.NODE_ENV === 'production' ? 'strict' : 'lax',
  maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
  path: '/api/auth/refresh'
} as const;

// Create router with proper typing
const router: express.Router = express.Router();
const tokenService = AuthTokenService.getInstance();
const authService = AuthService.getInstance();
const logger = new Logger('AuthRoutes');
const authController = new AuthController();

// Define a type for the authenticated request
interface AuthenticatedRequest extends Request {
  user: {
    id: string;
    [key: string]: unknown;
  };
  token?: string;
}

// Register
router.post('/register', customValidate(registerSchema), (req: Request, res: Response, next: NextFunction): void => {
  void authController.register(req, res, next);
});

// Login
router.post('/login', customValidate(loginSchema), (req: Request, res: Response, next: NextFunction): void => {
  void authController.login(req, res, next);
});

// Refresh token
router.post('/refresh-token', (req: Request, res: Response, next: NextFunction): void => {
  void authController.refreshToken(req, res, next);
});

// Get current user
router.get('/me', authenticateJWT, (req: Request, res: Response, next: NextFunction): void => {
  authController.getCurrentUser(req, res, next);
});

// Logout
router.post('/logout', authenticateJWT, (req: Request, res: Response, next: NextFunction): void => {
  authController.logout(req, res, next);
});

// Email verification
router.get('/confirm-email', (req: Request, res: Response, next: NextFunction): void => {
  void authController.confirmEmail(req, res, next);
});

router.post('/resend-confirmation', (req: Request, res: Response, next: NextFunction): void => {
  void authController.resendConfirmationEmail(req, res, next);
});

// Update profile
router.patch('/profile', authenticate, customValidate(updateProfileSchema), async (req: Request, res: Response, next: NextFunction) => {
  try {
    const authenticatedReq = req as AuthenticatedRequest;
    const { displayName, bio, avatar } = req.body as { displayName?: string; bio?: string; avatar?: string };
    
    if (!authenticatedReq.user) {
      throw new UnauthorizedError('User not authenticated');
    }
    
    const user = await User.findByPk(authenticatedReq.user.id) as unknown as {
      id: string;
      update: (data: Record<string, unknown>) => Promise<unknown>;
      toJSON: () => Record<string, unknown>;
      comparePassword?: (password: string) => Promise<boolean>;
      updatePassword?: (password: string) => Promise<void>;
    };
    
    if (!user) {
      throw new NotFoundError('User not found');
    }
    
    // Update fields if provided
    const updates: Record<string, unknown> = {};
    if (displayName) updates.displayName = displayName;
    if (bio !== undefined) updates.bio = bio;
    if (avatar) updates.avatar = avatar;
    
    await user.update(updates);
    
    res.json({
      status: 'success',
      data: { user: user.toJSON() }
    });
  } catch (error) {
    logger.error('Update profile error', { error });
    next(error);
  }
});

// Change password
router.post('/change-password', authenticate, customValidate(changePasswordSchema), async (req: Request, res: Response, next: NextFunction) => {
  try {
    const authenticatedReq = req as AuthenticatedRequest;
    const { currentPassword, newPassword } = req.body as { currentPassword: string; newPassword: string };
    
    if (!authenticatedReq.user) {
      throw new UnauthorizedError('User not authenticated');
    }
    
    const user = await User.findByPk(authenticatedReq.user.id) as unknown as {
      id: string;
      comparePassword: (password: string) => Promise<boolean>;
      updatePassword: (password: string) => Promise<void>;
    };
    
    if (!user) {
      throw new NotFoundError('User not found');
    }
    
    // Verify current password
    const isPasswordValid = await user.comparePassword(currentPassword);
    if (!isPasswordValid) {
      throw new UnauthorizedError('Current password is incorrect');
    }
    
    // Update password
    await user.updatePassword(newPassword);
    
    // Revoke current token to force re-login with new password
    if (req.token) {
      tokenService.blacklistToken(req.token, TokenType.ACCESS);
    }
    
    // Revoke refresh token
    interface CookieObject {
      refreshToken?: string;
    }
    const cookies = req.cookies as CookieObject;
    const refreshToken = cookies.refreshToken;
    if (refreshToken) {
      tokenService.blacklistToken(refreshToken, TokenType.REFRESH);
    }
    
    // Clear refresh token cookie
    res.clearCookie('refreshToken', { path: '/api/auth/refresh' });
    
    res.json({
      status: 'success',
      message: 'Password updated successfully. Please log in again with your new password.'
    });
  } catch (error) {
    logger.error('Change password error', { error });
    next(error);
  }
});

// Admin-only route to get all users
router.get('/users', authenticate, authorize('admin'), async (_req: Request, res: Response, next: NextFunction) => {
  try {
    const users = await User.findAll() as unknown as Array<{
      toJSON: () => Record<string, unknown>;
    }>;
    
    // Remove passwords from response
    const usersResponse = users.map(user => {
      const userData = user.toJSON();
      return userData;
    });
    
    res.json({
      status: 'success',
      data: { users: usersResponse }
    });
  } catch (error) {
    next(error);
  }
});

// Two-factor authentication routes

// Generate 2FA secret
router.post('/2fa/setup', authenticate, async (req: Request, res: Response, next: NextFunction) => {
  try {
    const authenticatedReq = req as AuthenticatedRequest;
    if (!authenticatedReq.user) {
      throw new Error('User not authenticated');
    }
    const { secret, qrCode } = await authService.generate2FASecret(authenticatedReq.user as unknown as UserAttributes);
    
    res.json({
      status: 'success',
      data: {
        secret,
        qrCode
      }
    });
  } catch (error) {
    logger.error('2FA setup error', { error });
    next(error);
  }
});

// Verify and enable 2FA
router.post('/2fa/enable', authenticate, customValidate(twoFactorEnableSchema), async (req: Request, res: Response, next: NextFunction) => {
  try {
    const authenticatedReq = req as AuthenticatedRequest;
    const { token } = req.body as { token: string };
    
    if (!authenticatedReq.user) {
      throw new UnauthorizedError('User not authenticated');
    }
    
    const backupCodes = await authService.enable2FA(authenticatedReq.user.id, token);
    
    res.json({
      status: 'success',
      data: {
        backupCodes,
        message: 'Two-factor authentication enabled successfully'
      }
    });
  } catch (error) {
    logger.error('2FA enable error', { error });
    next(error);
  }
});

// Disable 2FA
router.post('/2fa/disable', authenticate, async (req: Request, res: Response, next: NextFunction) => {
  try {
    const authenticatedReq = req as AuthenticatedRequest;
    if (!authenticatedReq.user) {
      throw new UnauthorizedError('User not authenticated');
    }
    
    await authService.disable2FA(authenticatedReq.user.id);
    
    res.json({
      status: 'success',
      message: 'Two-factor authentication disabled successfully'
    });
  } catch (error) {
    logger.error('2FA disable error', { error });
    next(error);
  }
});

// Regenerate backup codes
router.post('/2fa/backup-codes', authenticate, async (req: Request, res: Response, next: NextFunction) => {
  try {
    const authenticatedReq = req as AuthenticatedRequest;
    if (!authenticatedReq.user) {
      throw new UnauthorizedError('User not authenticated');
    }
    
    const backupCodes = await authService.regenerate2FABackupCodes(authenticatedReq.user.id);
    
    res.json({
      status: 'success',
      data: {
        backupCodes
      }
    });
  } catch (error) {
    logger.error('2FA backup codes regeneration error', { error });
    next(error);
  }
});

// Get 2FA status
router.get('/2fa/status', authenticate, async (req: Request, res: Response, next: NextFunction) => {
  try {
    const authenticatedReq = req as AuthenticatedRequest;
    if (!authenticatedReq.user) {
      throw new UnauthorizedError('User not authenticated');
    }
    
    const status = await authService.getTwoFactorStatus(authenticatedReq.user.id);
    
    res.json({
      status: 'success',
      data: status
    });
  } catch (error) {
    logger.error('2FA status error', { error });
    next(error);
  }
});

// Verify 2FA token during login
router.post('/2fa/verify', customValidate(twoFactorVerifySchema), async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { userId, token } = req.body as { userId: string; token: string };
    
    // Verify token
    const isValid = await authService.verify2FAToken(userId, token);
    
    if (!isValid) {
      throw new UnauthorizedError('Invalid verification code');
    }
    
    // Get user
    const user = await User.findByPk(userId) as unknown as { 
      toJSON: () => Record<string, unknown>;
    };
    if (!user) {
      throw new NotFoundError('User not found');
    }
    
    // Generate tokens
    const { accessToken, refreshToken, expiresIn } = tokenService.generateTokens(user as unknown as UserAttributes);
    
    // Set refresh token as HTTP-only cookie
    res.cookie('refreshToken', refreshToken, REFRESH_TOKEN_COOKIE_OPTIONS);
    
    res.json({
      status: 'success',
      data: {
        user: user.toJSON(),
        accessToken,
        expiresIn
      }
    });
  } catch (error) {
    logger.error('2FA verification error', { error });
    next(error);
  }
});

// Export the router
export { router as authRouter }; 
================================================================================
File: routes\comments.ts
Lines: 262
--------------------------------------------------------------------------------
import express from 'express';
import type { Request, Response, NextFunction } from 'express';

import { authenticate } from '../middleware/auth';
import { AppError } from '../middleware/error';
import { Comment, CommentLike, Post } from '../models';

interface AuthenticatedRequest extends Request {
  user?: {
    id: string;
  };
  params: {
    postId?: string;
    commentId?: string;
  };
}

const router: express.Router = express.Router();

// Get comments for a post
router.get('/post/:postId', authenticate, async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
  try {
    const { offset = 0, limit = 10 } = req.query as { offset?: number; limit?: number };
    const postId = req.params.postId as string;

    const comments = await Comment.findByPostId({
      postId,
      parentId: null, // Only get top-level comments
      limit: Number(limit),
      offset: Number(offset)
    });

    // Check if current user liked each comment
    if (!req.user) {
      // If user is not authenticated, return comments without like status
      res.json({
        status: 'success',
        data: { comments }
      });
      return;
    }

    const userId = req.user.id;
    const likedComments = await Promise.all(
      comments.map(c => CommentLike.findByUserAndComment(userId, c.id))
    );

    const likedCommentIds = new Set(
      likedComments.filter((like: CommentLike | null) => like !== null).map((like: CommentLike) => like.commentId)
    );

    const commentsWithLikes = comments.map(comment => {
      const commentData = comment.toJSON();
      commentData.isLiked = likedCommentIds.has(comment.id);
      return commentData;
    });

    res.json({
      status: 'success',
      data: { comments: commentsWithLikes }
    });
  } catch (error) {
    next(error);
  }
});

// Create comment
router.post('/', authenticate, async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
  try {
    const { postId, content, parentId } = req.body as { postId: string; content: string; parentId?: string };

    // Check if post exists
    const post = await Post.findByPk(postId);
    if (!post) {
      throw new AppError('Post not found', 404);
    }

    // If this is a reply, check if parent comment exists
    if (parentId) {
      const parentComment = await Comment.findByPk(parentId);
      if (!parentComment) {
        throw new AppError('Parent comment not found', 404);
      }
    }

    if (!req.user || !req.user.id) {
      throw new AppError('User not authenticated', 401);
    }

    const comment = await Comment.create({
      userId: req.user.id,
      postId,
      content,
      parentId: parentId || null,
      likesCount: 0,
      status: 'active',
      moderationReason: null,
      moderatedBy: null,
      moderatedAt: null
    });

    // Increment comments count on post
    await post.incrementComments();

    const commentWithUser = await Comment.findByPk(comment.id);

    res.status(201).json({
      status: 'success',
      data: { comment: commentWithUser }
    });
  } catch (error) {
    next(error);
  }
});

// Delete comment
router.delete('/:commentId', authenticate, async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
  try {
    const commentId = req.params.commentId as string;
    const comment = await Comment.findByPk(commentId);

    if (!comment) {
      throw new AppError('Comment not found', 404);
    }

    if (!req.user || !req.user.id) {
      throw new AppError('User not authenticated', 401);
    }

    if (comment.userId !== req.user.id) {
      throw new AppError('Not authorized to delete this comment', 403);
    }

    // Get post to decrement comments count
    const post = await Post.findByPk(comment.postId);
    if (post) {
      await post.decrementComments();
    }

    await comment.delete();

    res.json({
      status: 'success',
      message: 'Comment deleted successfully'
    });
  } catch (error) {
    next(error);
  }
});

// Like comment
router.post('/:commentId/like', authenticate, async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
  try {
    const commentId = req.params.commentId as string;
    const comment = await Comment.findByPk(commentId);
    if (!comment) {
      throw new AppError('Comment not found', 404);
    }

    // Check if already liked
    if (!req.user || !req.user.id) {
      throw new AppError('User not authenticated', 401);
    }
    const existingLike = await CommentLike.findByUserAndComment(req.user.id, comment.id);

    if (existingLike) {
      throw new AppError('Already liked this comment', 400);
    }

    // Create like
    await CommentLike.create({
      userId: req.user.id,
      commentId: comment.id,
      updatedAt: new Date()
    });

    // Increment likes count
    await comment.incrementLikes();

    res.json({
      status: 'success',
      message: 'Comment liked successfully'
    });
  } catch (error) {
    next(error);
  }
});

// Unlike comment
router.delete('/:commentId/like', authenticate, async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
  try {
    const commentId = req.params.commentId as string;
    const comment = await Comment.findByPk(commentId);
    if (!comment) {
      throw new AppError('Comment not found', 404);
    }

    // Check if liked
    if (!req.user || !req.user.id) {
      throw new AppError('User not authenticated', 401);
    }
    const like = await CommentLike.findByUserAndComment(req.user.id, comment.id);

    if (!like) {
      throw new AppError('Not liked this comment', 400);
    }

    // Remove like
    await like.delete();

    // Decrement likes count
    await comment.decrementLikes();

    res.json({
      status: 'success',
      message: 'Comment unliked successfully'
    });
  } catch (error) {
    next(error);
  }
});

// Get replies for a comment
router.get('/:commentId/replies', authenticate, async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
  try {
    const commentId = req.params.commentId as string;
    const replies = await Comment.findReplies(commentId);

    // Check if current user liked each reply
    if (!req.user || !req.user.id) {
      // If user is not authenticated, return replies without like status
      res.json({
        status: 'success',
        data: { replies }
      });
      return;
    }

    const likedReplies = await Promise.all(
      replies.map(r => CommentLike.findByUserAndComment(req.user?.id as string, r.id))
    );

    const likedReplyIds = new Set(
      likedReplies.filter(like => like !== null).map(like => like.commentId)
    );

    const repliesWithLikes = replies.map(reply => {
      const replyData = reply.toJSON();
      replyData.isLiked = likedReplyIds.has(reply.id);
      return replyData;
    });

    res.json({
      status: 'success',
      data: { replies: repliesWithLikes }
    });
  } catch (error) {
    next(error);
  }
});

export const commentRouter = router; 
================================================================================
File: routes\index.ts
Lines: 31
--------------------------------------------------------------------------------
import express from 'express';

import { errorHandler } from '../middleware/errorHandler';
import { apiLimiter } from '../middleware/rateLimiter';

import { adminRouter } from './admin';
import { authRouter } from './auth';
import { mediaRouter } from './media';
import { moderatorRouter } from './moderator';
import { socialRouter } from './social';
import { userRouter } from './users';

const router: express.Router = express.Router();

// Apply rate limiter to all API routes
router.use(apiLimiter);

// Public routes
router.use('/auth', authRouter);

// Protected routes (authentication is handled within each router)
router.use('/users', userRouter);
router.use('/social', socialRouter);
router.use('/admin', adminRouter);
router.use('/moderator', moderatorRouter);
router.use('/media', mediaRouter);

// Error handler middleware (must be last)
router.use(errorHandler);

export default router;
================================================================================
File: routes\media.ts
Lines: 230
--------------------------------------------------------------------------------
import path from 'path';

import express from 'express';
import type { Request, Response } from 'express';
import multer from 'multer';
import { z } from 'zod';

import { MediaController } from '../controllers/media.controller';
import { authenticate } from '../middleware/auth';
import { validate } from '../middleware/validate';
import { Media, ProcessingStatus } from '../models/Media';
import { Logger } from '../services/LoggerService';
import { MediaProcessingService } from '../services/media/MediaProcessingService';


// Extend Request type to include multer's file
interface MulterRequest extends Request {
  file?: Express.Multer.File;
  user?: { id: string };
}

interface MediaRequest extends Request {
  params: {
    mediaId: string;
  };
}

const router: express.Router = express.Router();
const logger = new Logger('MediaRoutes');
const mediaController = new MediaController();
const mediaService = MediaProcessingService.getInstance();

// Configure multer for file uploads
const storage = multer.diskStorage({
  destination: (_req, _file, cb) => {
    cb(null, path.join(process.cwd(), 'uploads', 'temp'));
  },
  filename: (_req, file, cb) => {
    const uniqueSuffix = `${Date.now()}-${Math.round(Math.random() * 1E9)}`;
    cb(null, `${uniqueSuffix}-${file.originalname}`);
  }
});

const allowedMimes = {
  'image/jpeg': true,
  'image/png': true,
  'image/gif': true,
  'image/webp': true,
  'video/mp4': true,
  'video/quicktime': true,
  'audio/mpeg': true,
  'audio/wav': true,
  'audio/mp4': true
} as const;

const upload = multer({
  storage,
  limits: {
    fileSize: 100 * 1024 * 1024, // 100MB limit
  },
  fileFilter: (_req, file, cb) => {
    if (file.mimetype in allowedMimes) {
      cb(null, true);
    } else {
      cb(new Error('Invalid file type'));
    }
  }
});

// Validation schemas
const uploadOptionsSchema = z.object({
  generateHLS: z.boolean().optional(),
  generateDASH: z.boolean().optional(),
  generateWaveform: z.boolean().optional(),
  quality: z.enum(['low', 'medium', 'high']).optional(),
  isPublic: z.boolean().optional()
});

// Upload endpoints
router.post('/upload/image', 
  authenticate,
  upload.single('file'),
  validate(uploadOptionsSchema),
  async (req: MulterRequest, res: Response) => {
    try {
      if (!req.file) {
        return res.status(400).json({ error: 'No file provided' });
      }

      if (!req.user) {
        return res.status(400).json({ error: 'User not authenticated' });
      }

      const result = await mediaService.processImage(req.file.path);

      res.status(202).json({
        message: 'Image upload accepted',
        mediaId: result.mediaId,
        status: 'processing'
      });
    } catch (error) {
      logger.error('Image upload failed:', error);
      res.status(500).json({ error: 'Failed to process image upload' });
    }
  }
);

router.post('/upload/video',
  authenticate,
  upload.single('file'),
  validate(uploadOptionsSchema),
  async (req: MulterRequest, res: Response) => {
    try {
      if (!req.file) {
        return res.status(400).json({ error: 'No file provided' });
      }

      if (!req.user) {
        return res.status(400).json({ error: 'User not authenticated' });
      }

      const options = req.body as z.infer<typeof uploadOptionsSchema>;
      const result = await mediaService.processVideo(req.file.path, {
        generateHLS: options.generateHLS,
        generateDASH: options.generateDASH,
        quality: options.quality
      });

      res.status(202).json({
        message: 'Video upload accepted',
        mediaId: result.mediaId,
        status: 'processing'
      });
    } catch (error) {
      logger.error('Video upload failed:', error);
      res.status(500).json({ error: 'Failed to process video upload' });
    }
  }
);

router.post('/upload/audio',
  authenticate,
  upload.single('file'),
  validate(uploadOptionsSchema),
  async (req: MulterRequest, res: Response) => {
    try {
      if (!req.file) {
        return res.status(400).json({ error: 'No file provided' });
      }

      if (!req.user) {
        return res.status(400).json({ error: 'User not authenticated' });
      }

      const options = req.body as z.infer<typeof uploadOptionsSchema>;
      const result = await mediaService.processAudio(req.file.path, {
        generateWaveform: options.generateWaveform
      });

      res.status(202).json({
        message: 'Audio upload accepted',
        mediaId: result.mediaId,
        status: 'processing'
      });
    } catch (error) {
      logger.error('Audio upload failed:', error);
      res.status(500).json({ error: 'Failed to process audio upload' });
    }
  }
);

// Streaming endpoints
router.get('/stream/video/:mediaId',
  mediaController.streamVideo.bind(mediaController)
);

router.get('/stream/video/:mediaId/hls/:file',
  mediaController.streamVideo.bind(mediaController)
);

router.get('/stream/video/:mediaId/dash/:file',
  mediaController.streamVideo.bind(mediaController)
);

router.get('/stream/audio/:mediaId',
  mediaController.streamAudio.bind(mediaController)
);

router.get('/stream/audio/:mediaId/waveform',
  mediaController.getWaveform.bind(mediaController)
);

// Media info endpoints
router.get('/:mediaId/status',
  authenticate,
  async (req: MediaRequest, res: Response) => {
    try {
      const mediaId = req.params.mediaId;
      const media = await Media.findByPk(mediaId);
      if (!media) {
        return res.status(404).json({ error: 'Media not found' });
      }
      res.json({
        status: media.processingStatus as ProcessingStatus,
        metadata: media.metadata
      });
    } catch (error) {
      logger.error('Failed to get media status:', error);
      res.status(500).json({ error: 'Failed to get media status' });
    }
  }
);

router.get('/:mediaId/info',
  async (req: MediaRequest, res: Response) => {
    try {
      const mediaId = req.params.mediaId;
      const media = await Media.findByPk(mediaId);
      if (!media) {
        return res.status(404).json({ error: 'Media not found' });
      }
      res.json(media);
    } catch (error) {
      logger.error('Failed to get media info:', error);
      res.status(500).json({ error: 'Failed to get media info' });
    }
  }
);

export { router as mediaRouter }; 
================================================================================
File: routes\moderator.ts
Lines: 150
--------------------------------------------------------------------------------
import express from 'express';
import type { Request, Response, NextFunction, RequestHandler } from 'express';
import { z } from 'zod';

import { authenticate, authorize } from '../middleware/auth';
import { NotFoundError } from '../middleware/error';
import { validate } from '../middleware/validate';
import { Post, Comment } from '../models';
import { commentRepository } from '../models/Comment';
import { postRepository } from '../models/Post';


// Validation schemas
const postIdParamSchema = z.object({
  postId: z.string().uuid('Invalid post ID format')
});

const commentIdParamSchema = z.object({
  commentId: z.string().uuid('Invalid comment ID format')
});

const contentStatusSchema = z.object({
  status: z.enum(['active', 'hidden', 'flagged'], {
    errorMap: () => ({ message: 'Status must be one of: active, hidden, flagged' })
  }),
  reason: z.string().min(1, 'Reason is required').max(500, 'Reason cannot exceed 500 characters')
});

const router: express.Router = express.Router();

// All routes require authentication and moderator or admin role
router.use(authenticate, authorize('moderator', 'admin'));

// Get reported content
router.get('/reports', async (_req: Request, res: Response, next: NextFunction) => {
  try {
    // Get reported posts
    const posts = await postRepository.findAll({
      status: 'flagged'
    });
    
    // Get reported comments
    const comments = await commentRepository.findAll({
      status: 'flagged'
    });
    
    res.json({
      status: 'success',
      data: {
        posts,
        comments
      }
    });
  } catch (error) {
    next(error);
  }
});

// Update post status (hide/show/flag)
router.patch(
  '/posts/:postId/status',
  validate(postIdParamSchema, 'params') as RequestHandler,
  validate(contentStatusSchema) as RequestHandler,
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const { postId  } = req.params as { postId: string };
      const { status, reason  } = req.body as { status: string, reason: string };
      
      const post = await Post.findByPk(postId);
      if (!post) {
        throw new NotFoundError('Post not found');
      }
      
      // Update post status
      const updatedPost = await postRepository.update(postId, {
        status,
        moderationReason: reason,
        moderatedBy: (req.user as { id: string })?.id,
        moderatedAt: new Date()
      });
      
      res.json({
        status: 'success',
        data: { post: updatedPost }
      });
    } catch (error) {
      next(error);
    }
  }
);

// Update comment status (hide/show/flag)
router.patch(
  '/comments/:commentId/status',
  validate(commentIdParamSchema, 'params') as RequestHandler,
  validate(contentStatusSchema) as RequestHandler,
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const { commentId  } = req.params as { commentId: string };
      const { status, reason  } = req.body as { status: string, reason: string };
      
      const comment = await Comment.findByPk(commentId);
      if (!comment) {
        throw new NotFoundError('Comment not found');
      }
      
      // Update comment status
      const updatedComment = await commentRepository.update(commentId, {
        status,
        moderationReason: reason,
        moderatedBy: (req.user as { id: string })?.id,
        moderatedAt: new Date()
      });
      
      res.json({
        status: 'success',
        data: { comment: updatedComment }
      });
    } catch (error) {
      next(error);
    }
  }
);

// Get moderation history
router.get('/history', async (_req: Request, res: Response, next: NextFunction) => {
  try {
    // Get moderated posts
    const posts = await postRepository.findAll({
      status: 'hidden'
    });
    
    // Get moderated comments
    const comments = await commentRepository.findAll({
      status: 'hidden'
    });
    
    res.json({
      status: 'success',
      data: {
        posts,
        comments
      }
    });
  } catch (error) {
    next(error);
  }
});

export const moderatorRouter = router; 
================================================================================
File: routes\social.ts
Lines: 69
--------------------------------------------------------------------------------
import express from 'express';

import { getPostById, deletePost } from '../controllers/post.controller';
import {
  getFeed,
  createPost,
  likePost,
  unlikePost,
  sharePost,
  getComments,
  createComment,
  likeComment,
  unlikeComment,
  replyToComment
} from '../controllers/social.controller';
import { authenticate } from '../middleware/auth';
import { customValidate } from '../middleware/customValidate';
import {
  createPostSchema,
  postIdParamSchema,
  createCommentSchema,
  commentIdParamSchema,
  replyToCommentSchema,
  feedQuerySchema,
  getCommentsQuerySchema
} from '../validators/custom-social.validator';

const router: express.Router = express.Router();

// All routes require authentication
router.use(authenticate);

// Feed routes
router.get('/feed', customValidate(feedQuerySchema, 'query'), getFeed);

// Post routes
router.post('/posts', customValidate(createPostSchema), createPost);
router.get('/posts/:postId', customValidate(postIdParamSchema, 'params'), getPostById);
router.delete('/posts/:postId', customValidate(postIdParamSchema, 'params'), deletePost);
router.post('/posts/:postId/like', customValidate(postIdParamSchema, 'params'), likePost);
router.delete('/posts/:postId/like', customValidate(postIdParamSchema, 'params'), unlikePost);
router.post('/posts/:postId/share', customValidate(postIdParamSchema, 'params'), sharePost);

// Comment routes
router.get('/posts/:postId/comments', 
  customValidate(postIdParamSchema, 'params'),
  customValidate(getCommentsQuerySchema, 'query'),
  getComments
);
router.post('/posts/:postId/comments', 
  customValidate(postIdParamSchema, 'params'),
  customValidate(createCommentSchema),
  createComment
);
router.post('/comments/:commentId/like', 
  customValidate(commentIdParamSchema, 'params'),
  likeComment
);
router.delete('/comments/:commentId/like', 
  customValidate(commentIdParamSchema, 'params'),
  unlikeComment
);
router.post('/comments/:commentId/reply', 
  customValidate(commentIdParamSchema, 'params'),
  customValidate(replyToCommentSchema),
  replyToComment
);

export const socialRouter: express.Router = router; 
================================================================================
File: routes\users.ts
Lines: 146
--------------------------------------------------------------------------------
import express from 'express';
import type { Response, NextFunction } from 'express';

import { followUser, unfollowUser } from '../controllers/social.controller';
import { authenticate } from '../middleware/auth';
import { AppError } from '../middleware/error';
import { User, Post, Follow } from '../models';
import { AuthenticatedRequest, UserParamRequest } from '../types/request.types';

interface UserResponse {
  id: string;
  username: string;
  email: string;
  displayName: string | null;
  bio: string | null;
  profileImage: string | null;
  posts?: Post[];
  isFollowing?: boolean;
}

const router: express.Router = express.Router();

// All routes require authentication
router.use(authenticate);

// Get user profile
router.get('/:userId', async (req: UserParamRequest, res: Response, next: NextFunction) => {
  try {
    const { userId } = req.params;
    if (!userId) {
      throw new AppError('User ID is required', 400);
    }
    
    const user = await User.findById(userId);

    if (!user) {
      throw new AppError('User not found', 404);
    }

    // Get user's posts
    const posts = await Post.findByUserId(user.id);

    // Check if current user is following this user
    const currentUserId = req.user?.id;
    const isFollowing = currentUserId ? await Follow.findByFollowerAndFollowing(currentUserId, user.id) : null;

    const userResponse: UserResponse = {
      ...user,
      posts,
      isFollowing: !!isFollowing
    };

    res.json({
      status: 'success',
      data: { user: userResponse }
    });
  } catch (error) {
    next(error);
  }
});

// Follow a user
router.post('/:userId/follow', async (req: UserParamRequest, res: Response) => {
  await followUser(req, res);
});

// Unfollow a user
router.delete('/:userId/follow', async (req: UserParamRequest, res: Response) => {
  await unfollowUser(req, res);
});

// Update user profile
router.patch('/me', async (req: AuthenticatedRequest, res: Response, next: NextFunction) => {
  try {
    const { displayName, bio, avatar } = req.body as { displayName: string, bio: string, avatar: string };
    const currentUserId = req.user?.id;
    
    if (!currentUserId) {
      throw new AppError('Authentication required', 401);
    }

    const user = await User.findById(currentUserId);
    if (!user) {
      throw new AppError('User not found', 404);
    }

    // Update user
    await User.update(currentUserId, {
      displayName,
      bio,
      profileImage: avatar
    });

    const updatedUser = await User.findById(currentUserId);
    if (!updatedUser) {
      throw new AppError('User not found', 404);
    }

    res.json({
      status: 'success',
      data: { user: updatedUser }
    });
  } catch (error) {
    next(error);
  }
});

// Get user's followers
router.get('/:userId/followers', async (req: UserParamRequest, res: Response, next: NextFunction) => {
  try {
    const { userId } = req.params;
    if (!userId) {
      throw new AppError('User ID is required', 400);
    }
    
    const followers = await Follow.findFollowers(userId);

    res.json({
      status: 'success',
      data: { followers }
    });
  } catch (error) {
    next(error);
  }
});

// Get user's following
router.get('/:userId/following', async (req: UserParamRequest, res: Response, next: NextFunction) => {
  try {
    const { userId } = req.params;
    if (!userId) {
      throw new AppError('User ID is required', 400);
    }
    
    const following = await Follow.findFollowing(userId);

    res.json({
      status: 'success',
      data: { following }
    });
  } catch (error) {
    next(error);
  }
});

export const userRouter: express.Router = router; 
================================================================================
File: scripts\checkUsers.ts
Lines: 69
--------------------------------------------------------------------------------
import { Database } from '../services/Database';

interface UserRow {
  id: string;
  username: string;
  email: string;
  email_confirmed: boolean;
  created_at: Date;
  updated_at: Date;
}

async function checkUsers() {
  console.log('Checking users in the database...');
  
  // Initialize database connection
  const db = new Database('./db');
  await db.initialize();
  
  try {
    const pool = db.getPool();
    if (!pool) {
      console.error('Database connection not available');
      return;
    }
    
    // Query all users
    const result = await pool.query<UserRow>(`
      SELECT id, username, email, email_confirmed, created_at, updated_at 
      FROM users 
      ORDER BY created_at DESC
    `);
    
    if (result.rows.length === 0) {
      console.log('No users found in the database.');
      return;
    }
    
    console.log(`Found ${result.rows.length} users:`);
    console.log('-----------------------------------');
    
    // Display user information
    (result.rows as UserRow[]).forEach((user: UserRow, index: number) => {
      console.log(`User #${index + 1}:`);
      console.log(`ID: ${user.id}`);
      console.log(`Username: ${user.username}`);
      console.log(`Email: ${user.email}`);
      console.log(`Email Confirmed: ${user.email_confirmed ? 'Yes' : 'No'}`);
      console.log(`Created At: ${user.created_at.toISOString()}`);
      console.log(`Updated At: ${user.updated_at.toISOString()}`);
      console.log('-----------------------------------');
    });
    
    // Check if in-memory mode
    if (db.isInMemoryMode && db.isInMemoryMode()) {
      console.log('NOTE: Running in in-memory database mode. Data will be lost when the server restarts.');
    }
    
  } catch (error) {
    console.error('Error querying users:', error);
  } finally {
    // Close the database connection
    if (db.isConnected()) {
      await db.close();
    }
  }
}

// Run the function
checkUsers().catch(console.error); 
================================================================================
File: scripts\createMigration.ts
Lines: 31
--------------------------------------------------------------------------------
// src/server/scripts/createMigration.ts
import { promises as fsPromises } from 'fs';
import path from 'path';

import { migrationConfig, createMigrationTemplate } from '../database/migrationConfig';

async function createMigration() {
  // Get migration name from command line argument
  const migrationName = process.argv[2];

  if (!migrationName) {
    console.error('Please provide a migration name');
    process.exit(1);
  }

  // Ensure migrations directory exists
  const migrationsDir = migrationConfig.migrations_path;
  await fsPromises.mkdir(migrationsDir, { recursive: true });

  // Generate timestamp for migration filename
  const timestamp = new Date().toISOString().replace(/[-:.]/g, '').slice(0, 14);
  const migrationFilename = `${timestamp}-${migrationName}.ts`;
  const migrationPath = path.join(migrationsDir, migrationFilename);

  // Write migration template
  await fsPromises.writeFile(migrationPath, createMigrationTemplate(migrationName), 'utf8');

  console.log(`Migration created: ${migrationFilename}`);
}

createMigration().catch(console.error);
================================================================================
File: scripts\resetMigration.ts
Lines: 25
--------------------------------------------------------------------------------
// src/server/scripts/resetMigration.ts
import { MigrationManager } from '../database/migrationManager';
import { Logger } from '../services/LoggerService';

async function resetMigrations() {
  const logger = new Logger('ResetMigrations');
  
  try {
    logger.info('Resetting all migrations...');
    
    const migrationManager = new MigrationManager();
    await migrationManager.resetMigrations();
    
    logger.info('All migrations have been reset successfully');
    process.exit(0);
  } catch (error) {
    logger.error('Failed to reset migrations', error);
    process.exit(1);
  }
}

resetMigrations().catch(error => {
  console.error('Failed to reset migrations:', error);
  process.exit(1);
});
================================================================================
File: scripts\runMigration.ts
Lines: 19
--------------------------------------------------------------------------------
// src/server/scripts/runMigrations.ts
import { MigrationManager } from '../database/migrationManager';

async function runMigrations() {
  try {
    const migrationManager = new MigrationManager();
    await migrationManager.migrate();
    console.log('Migrations completed successfully');
    process.exit(0);
  } catch (error) {
    console.error('Migration failed:', error);
    process.exit(1);
  }
}

runMigrations().catch(error => {
  console.error('Migration failed:', error);
  process.exit(1);
});
================================================================================
File: scripts\seedDemoDatabase.ts
Lines: 451
--------------------------------------------------------------------------------
import { randomUUID } from 'crypto';
import { readdir, readFile } from 'fs/promises';
import { join } from 'path';

import * as bcrypt from 'bcrypt';
import { Pool } from 'pg';


// Configuration
const config = {
  host: process.env.DB_HOST || 'localhost',
  port: parseInt(process.env.DB_PORT || '5432'),
  user: process.env.DB_USER || 'postgres',
  password: process.env.DB_PASSWORD || 'postgres',
  database: 'abe_stack',
  migrationsPath: join(__dirname, '../database/migrations')
};

console.log('Database connection configuration:');
console.log(`- Host: ${config.host}`);
console.log(`- Port: ${config.port}`);
console.log(`- User: ${config.user}`);
console.log(`- Password: ${config.password ? '********' : 'not set'}`);
console.log(`- Target database: ${config.database}`);
console.log('');
console.log('If these settings are incorrect, you can set them using environment variables:');
console.log('DB_HOST, DB_PORT, DB_USER, DB_PASSWORD');
console.log('');
console.log('For example:');
console.log('  Windows PowerShell: $env:DB_USER="your_username"; $env:DB_PASSWORD="your_password"; npm run seed:demo');
console.log('  Windows CMD: set DB_USER=your_username && set DB_PASSWORD=your_password && npm run seed:demo');
console.log('  Linux/macOS: DB_USER=your_username DB_PASSWORD=your_password npm run seed:demo');
console.log('');

// Demo users data
const demoUsers = [
  {
    username: 'johndoe',
    email: 'john@example.com',
    password: 'password123',
    displayName: 'John Doe',
    firstName: 'John',
    lastName: 'Doe',
    bio: 'Software developer and tech enthusiast',
    profileImage: 'https://randomuser.me/api/portraits/men/1.jpg',
    role: 'user'
  },
  {
    username: 'janedoe',
    email: 'jane@example.com',
    password: 'password123',
    displayName: 'Jane Doe',
    firstName: 'Jane',
    lastName: 'Doe',
    bio: 'UX Designer | Coffee lover',
    profileImage: 'https://randomuser.me/api/portraits/women/1.jpg',
    role: 'user'
  },
  {
    username: 'alexsmith',
    email: 'alex@example.com',
    password: 'password123',
    displayName: 'Alex Smith',
    firstName: 'Alex',
    lastName: 'Smith',
    bio: 'Photographer and traveler',
    profileImage: 'https://randomuser.me/api/portraits/men/2.jpg',
    role: 'user'
  },
  {
    username: 'sarahwilson',
    email: 'sarah@example.com',
    password: 'password123',
    displayName: 'Sarah Wilson',
    firstName: 'Sarah',
    lastName: 'Wilson',
    bio: 'Digital marketer and content creator',
    profileImage: 'https://randomuser.me/api/portraits/women/2.jpg',
    role: 'user'
  },
  {
    username: 'admin',
    email: 'admin@example.com',
    password: 'admin123',
    displayName: 'Admin User',
    firstName: 'Admin',
    lastName: 'User',
    bio: 'System administrator',
    profileImage: 'https://randomuser.me/api/portraits/men/3.jpg',
    role: 'admin'
  }
];

// Sample posts data (will be populated with user IDs after user creation)
const demoPosts = [
  {
    content: 'Just finished working on a new project with React and TypeScript. Loving the type safety!',
    media: null
  },
  {
    content: 'Check out this amazing sunset I captured yesterday!',
    media: {
      type: 'image',
      url: 'https://images.unsplash.com/photo-1566045638022-8e4465a89acc',
      thumbnail: 'https://images.unsplash.com/photo-1566045638022-8e4465a89acc?w=300'
    }
  },
  {
    content: 'Learning about PostgreSQL and database optimization today. Any good resources to recommend?',
    media: null
  },
  {
    content: 'Just released my new portfolio website. Would love some feedback!',
    media: {
      type: 'image',
      url: 'https://images.unsplash.com/photo-1498050108023-c5249f4df085',
      thumbnail: 'https://images.unsplash.com/photo-1498050108023-c5249f4df085?w=300'
    }
  },
  {
    content: 'Excited to announce that I\'ll be speaking at the upcoming tech conference next month!',
    media: null
  }
];

// Main function to seed the database
async function seedDatabase() {
  console.log('Starting database seeding process...');
  
  // Connect to PostgreSQL server (without specifying a database)
  const serverPool = new Pool({
    host: config.host,
    port: config.port,
    user: config.user,
    password: config.password,
    database: 'postgres' // Connect to default postgres database first
  });
  
  try {
    console.log('Connecting to PostgreSQL server...');
    
    // Test connection
    await serverPool.query('SELECT 1');
    console.log('Successfully connected to PostgreSQL server.');
    
    // Check if demo database exists
    const dbCheckResult = await serverPool.query(
      "SELECT 1 FROM pg_database WHERE datname = $1",
      [config.database]
    );
    
    // Create database if it doesn't exist
    if (dbCheckResult.rows.length === 0) {
      console.log(`Creating database: ${config.database}`);
      await serverPool.query(`CREATE DATABASE ${config.database}`);
    } else {
      console.log(`Database ${config.database} already exists`);
    }
  } catch (error: unknown) {
    console.error('Error connecting to PostgreSQL server:');
    const pgError = error as { code?: string };
    if (pgError.code === '28P01') {
      console.error('Authentication failed. Please check your PostgreSQL username and password.');
      console.error('You can set them using environment variables DB_USER and DB_PASSWORD.');
      console.error('\nFor example:');
      console.error('  Windows PowerShell: $env:DB_USER="your_username"; $env:DB_PASSWORD="your_password"; npm run seed:demo');
      console.error('  Windows CMD: set DB_USER=your_username && set DB_PASSWORD=your_password && npm run seed:demo');
      console.error('  Linux/macOS: DB_USER=your_username DB_PASSWORD=your_password npm run seed:demo');
    } else if (pgError.code === 'ECONNREFUSED') {
      console.error('Connection refused. Please check if PostgreSQL is running and accessible.');
      console.error('You can set the host and port using environment variables DB_HOST and DB_PORT.');
    } else {
      console.error('Unexpected error:', error);
    }
    throw error;
  } finally {
    // Close server connection
    await serverPool.end();
  }
  
  // Connect to the demo database
  const dbPool = new Pool({
    host: config.host,
    port: config.port,
    user: config.user,
    password: config.password,
    database: config.database
  });
  
  try {
    // Create migrations table if it doesn't exist
    await dbPool.query(`
      CREATE TABLE IF NOT EXISTS migrations (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);
    
    // Get list of executed migrations
    const migrationsResult = await dbPool.query<{ name: string }>(
      'SELECT name FROM migrations ORDER BY id ASC'
    );
    const executedMigrations = migrationsResult.rows.map(row => row.name);
    
    // Get list of migration files
    const files = await readdir(config.migrationsPath);
    const sqlFiles = files
      .filter(file => file.endsWith('.sql'))
      .sort(); // Ensure migrations run in order
    
    // Run pending migrations
    for (const file of sqlFiles) {
      if (!executedMigrations.includes(file)) {
        console.log(`Running migration: ${file}`);
        const filePath = join(config.migrationsPath, file);
        const sql = await readFile(filePath, 'utf8');
        
        const client = await dbPool.connect();
        try {
          await client.query('BEGIN');
          await client.query(sql);
          await client.query(
            'INSERT INTO migrations (name) VALUES ($1)',
            [file]
          );
          await client.query('COMMIT');
          console.log(`Migration completed: ${file}`);
        } catch (error) {
          await client.query('ROLLBACK');
          console.error(`Error executing migration ${file}:`, error);
          throw error;
        } finally {
          client.release();
        }
      } else {
        console.log(`Migration already executed: ${file}`);
      }
    }
    
    // Check if users already exist
    const usersResult = await dbPool.query<{ count: string }>('SELECT COUNT(*) FROM users');
    const userCount = parseInt(usersResult.rows[0].count);
    
    if (userCount > 0) {
      console.log(`Database already has ${userCount} users. Skipping demo data insertion.`);
      console.log('If you want to reset the demo data, drop the database and run this script again.');
      return;
    }
    
    // Insert demo users
    console.log('Inserting demo users...');
    const userIds = [];
    
    for (const user of demoUsers) {
      const hashedPassword = await bcrypt.hash(user.password, 10);
      const userId = randomUUID();
      
      await dbPool.query(
        `INSERT INTO users (
          id, username, email, password, display_name, first_name, last_name, bio, profile_image, role
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)`,
        [
          userId,
          user.username,
          user.email,
          hashedPassword,
          user.displayName,
          user.firstName,
          user.lastName,
          user.bio,
          user.profileImage,
          user.role
        ]
      );
      
      userIds.push(userId);
      console.log(`Created user: ${user.username} (${userId})`);
    }
    
    // Check if follows table exists
    try {
      await dbPool.query('SELECT 1 FROM follows LIMIT 1');
      
      // Create follow relationships
      console.log('Creating follow relationships...');
      
      // Each user follows some other users
      for (let i = 0; i < userIds.length; i++) {
        for (let j = 0; j < userIds.length; j++) {
          // Don't follow self and don't have everyone follow everyone
          if (i !== j && Math.random() > 0.3) {
            await dbPool.query(
              'INSERT INTO follows (follower_id, following_id) VALUES ($1, $2)',
              [userIds[i], userIds[j]]
            );
          }
        }
      }
    } catch (error: unknown) {
      const pgError = error as { code?: string };
      if (pgError.code === '42P01') { // relation does not exist
        console.log('Follows table does not exist. Skipping follow relationships.');
        console.log('Please run the migration to create social tables first.');
      } else {
        throw error;
      }
    }
    
    // Check if posts table exists
    try {
      await dbPool.query('SELECT 1 FROM posts LIMIT 1');
      
      // Insert demo posts
      console.log('Inserting demo posts...');
      const postIds = [];
      
      for (let i = 0; i < demoPosts.length; i++) {
        // Assign posts to random users
        const userIndex = Math.floor(Math.random() * userIds.length);
        const userId = userIds[userIndex];
        const post = demoPosts[i];
        const postId = randomUUID();
        
        await dbPool.query(
          `INSERT INTO posts (
            id, user_id, content, media_type, media_url, media_thumbnail
          ) VALUES ($1, $2, $3, $4, $5, $6)`,
          [
            postId,
            userId,
            post.content,
            post.media?.type || null,
            post.media?.url || null,
            post.media?.thumbnail || null
          ]
        );
        
        postIds.push(postId);
        console.log(`Created post by user ${userIds[userIndex]}`);
      }
      
      // Check if likes table exists
      try {
        await dbPool.query('SELECT 1 FROM likes LIMIT 1');
        
        // Create likes on posts
        console.log('Creating likes on posts...');
        
        for (const userId of userIds) {
          for (const postId of postIds) {
            // Not everyone likes every post
            if (Math.random() > 0.4) {
              await dbPool.query(
                'INSERT INTO likes (user_id, post_id) VALUES ($1, $2)',
                [userId, postId]
              );
            }
          }
        }
      } catch (error: unknown) {
        const pgError = error as { code?: string };
        if (pgError.code === '42P01') { // relation does not exist
          console.log('Likes table does not exist. Skipping likes creation.');
          console.log('Please run the migration to create social tables first.');
        } else {
          throw error;
        }
      }
      
      // Check if comments table exists
      try {
        await dbPool.query('SELECT 1 FROM comments LIMIT 1');
        
        // Create comments on posts
        console.log('Creating comments on posts...');
        const comments = [
          'Great post!',
          'Thanks for sharing this.',
          'I completely agree with you.',
          'Interesting perspective!',
          'This is really helpful.',
          'Looking forward to more content like this.',
          'I had a similar experience recently.',
          'What tools did you use for this?',
          'Awesome work!',
          'This is exactly what I needed to see today.'
        ];
        
        for (const postId of postIds) {
          // Add 1-3 comments per post
          const commentCount = Math.floor(Math.random() * 3) + 1;
          
          for (let i = 0; i < commentCount; i++) {
            const userIndex = Math.floor(Math.random() * userIds.length);
            const userId = userIds[userIndex];
            const commentIndex = Math.floor(Math.random() * comments.length);
            const content = comments[commentIndex];
            const commentId = randomUUID();
            
            await dbPool.query(
              `INSERT INTO comments (
                id, post_id, user_id, content
              ) VALUES ($1, $2, $3, $4)`,
              [commentId, postId, userId, content]
            );
          }
        }
      } catch (error: unknown) {
        const pgError = error as { code?: string };
        if (pgError.code === '42P01') { // relation does not exist
          console.log('Comments table does not exist. Skipping comments creation.');
          console.log('Please run the migration to create social tables first.');
        } else {
          throw error;
        }
      }
    } catch (error: unknown) {
      const pgError = error as { code?: string };
      if (pgError.code === '42P01') { // relation does not exist
        console.log('Posts table does not exist. Skipping posts, likes, and comments creation.');
        console.log('Please run the migration to create social tables first.');
      } else {
        throw error;
      }
    }
    
    console.log('Database seeding completed successfully!');
    console.log('\nDemo accounts:');
    demoUsers.forEach(user => {
      console.log(`- Username: ${user.username}, Password: ${user.password}, Role: ${user.role}`);
    });
    
  } catch (error: unknown) {
    console.error('Error seeding database:', error);
    throw error;
  } finally {
    await dbPool.end();
  }
}

// Run the seed function
seedDatabase()
  .then(() => {
    console.log('Seed script completed successfully');
    process.exit(0);
  })
  .catch(error => {
    console.error('Seed script failed:', error);
    process.exit(1);
  }); 
================================================================================
File: scripts\testRegistration.ts
Lines: 87
--------------------------------------------------------------------------------
import { DatabaseConnectionManager } from '../database/config';
import { AuthService } from '../services/AuthService';
import { Database } from '../services/Database';

interface RegistrationResult {
  user: {
    id: string;
    username: string;
    email: string;
  };
}

interface UserRow {
  id: string;
  username: string;
  email: string;
  email_confirmed: boolean;
}

async function testRegistration() {
  console.log('Testing user registration...');
  
  try {
    // Initialize DatabaseConnectionManager
    await DatabaseConnectionManager.initialize();
    console.log('DatabaseConnectionManager initialized successfully');
    
    // Initialize database connection
    const db = new Database('./db');
    await db.initialize();
    
    // Create AuthService instance
    const authService = AuthService.getInstance();
    
    // Test user data
    const testUser = {
      username: 'testuser' + Date.now(),
      email: `testuser${Date.now()}@example.com`,
      password: 'password123',
      displayName: 'Test User',
      firstName: 'Test',
      lastName: 'User'
    };
    
    console.log('Registering test user:', testUser.username, testUser.email);
    
    // Register the user
    const result = await authService.register(testUser) as RegistrationResult;
    
    console.log('Registration successful!');
    console.log('User ID:', result.user.id);
    console.log('Username:', result.user.username);
    console.log('Email:', result.user.email);
    
    // Check if the user exists in the database
    console.log('\nVerifying user in database...');
    
    // Query the database directly
    const pool = db.getPool();
    if (pool) {
      const queryResult = await pool.query<UserRow>(
        'SELECT id, username, email, email_confirmed FROM users WHERE email = $1',
        [testUser.email]
      );
      
      if (queryResult.rows.length > 0) {
        console.log('User found in database:');
        console.log('ID:', queryResult.rows[0].id);
        console.log('Username:', queryResult.rows[0].username);
        console.log('Email:', queryResult.rows[0].email);
        console.log('Email Confirmed:', queryResult.rows[0].email_confirmed);
      } else {
        console.log('User NOT found in database!');
      }
    }
    
    // Close database connection
    await db.close();
    await DatabaseConnectionManager.closePool();
    
  } catch (error) {
    console.error('Error testing registration:', error);
  }
}

// Run the test
testRegistration().catch(console.error); 
================================================================================
File: scripts\undoMigration.ts
Lines: 19
--------------------------------------------------------------------------------
// src/server/scripts/undoMigration.ts
import { MigrationManager } from '../database/migrationManager';

async function undoMigration() {
  try {
    const migrationManager = new MigrationManager();
    await migrationManager.rollbackMigration();
    console.log('Last migration rolled back successfully');
    process.exit(0);
  } catch (error) {
    console.error('Migration rollback failed:', error);
    process.exit(1);
  }
}

undoMigration().catch(error => {
  console.error('Migration rollback failed:', error);
  process.exit(1);
});
================================================================================
File: services\AuthService.ts
Lines: 581
--------------------------------------------------------------------------------
import crypto from 'crypto';

import bcrypt from 'bcrypt';
import * as QRCode from 'qrcode';
import * as speakeasy from 'speakeasy';

import { UnauthorizedError } from '../errors/UnauthorizedError';
import { NotFoundError } from '../middleware/error';
import { TwoFactorAuthRepository, twoFactorAuthRepository, TwoFactorStatus } from '../models/TwoFactorAuth';
import { User, UserAttributes } from '../models/User';

import { AuthTokenService, TokenType } from './AuthTokenService';
import { Database } from './Database';
import { EmailService } from './EmailService';
import { Logger } from './LoggerService';

// Auth interfaces
interface RegisterArgs {
  username: string;
  email: string;
  password: string;
  displayName: string;
  firstName: string;
  lastName: string;
}

interface LoginArgs {
  email: string;
  password: string;
}

interface AuthResult {
  token: string;
  refreshToken: string;
  user: UserAttributes;
  requires2FA?: boolean;
}

/**
 * Consolidated authentication service that handles:
 * - User registration and login
 * - Password management
 * - Email verification
 * - Two-factor authentication (2FA)
 * - Token management (via AuthTokenService)
 */
export class AuthService {
  private emailService: EmailService;
  private logger: Logger;
  private tokenService: AuthTokenService;
  private db: Database;
  private twoFactorAuthRepo: TwoFactorAuthRepository;
  private static instance: AuthService;

  private constructor() {
    this.db = new Database(process.env.DB_PATH || './db');
    void this.initializeDatabase();
    this.emailService = new EmailService(this.db);
    this.logger = new Logger('AuthService');
    this.tokenService = AuthTokenService.getInstance();
    this.twoFactorAuthRepo = twoFactorAuthRepository;
  }

  public static getInstance(): AuthService {
    if (!AuthService.instance) {
      AuthService.instance = new AuthService();
    }
    return AuthService.instance;
  }

  // Initialize the database connection if not already connected
  private async initializeDatabase() {
    try {
      await this.db.initialize();
      console.log('Database initialized successfully in AuthService');
    } catch (error) {
      console.error('Failed to initialize database in AuthService:', error);
      throw new Error('Database connection not initialized');
    }
  }

  /**
   * Register a new user
   */
  async register(args: RegisterArgs): Promise<AuthResult> {
    this.logger.info('Attempting to register new user', { email: args.email });
    
    // Check if user already exists
    const existingUser = await User.findByEmail(args.email);
    if (existingUser) {
      this.logger.warn('Registration attempt with existing email', { email: args.email });
      // If user exists but email is not confirmed, resend confirmation email
      if (existingUser && !existingUser.emailConfirmed) {
        await this.resendConfirmationEmail(existingUser.email);
        return this.generateAuthResult(existingUser);
      }
      throw new Error('User already exists');
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(args.password, 10);

    // Generate confirmation token
    const confirmationToken = crypto.randomBytes(32).toString('hex');
    const tokenExpiry = new Date();
    tokenExpiry.setHours(tokenExpiry.getHours() + 24); // Token expires in 24 hours

    // Create user
    const user = await this.createUser(args, hashedPassword, confirmationToken, tokenExpiry);

    // Send confirmation email
    await this.emailService.sendConfirmationEmail(user.email, confirmationToken);

    return this.generateAuthResult(user);
  }

  /**
   * Login a user
   */
  async login(args: LoginArgs): Promise<AuthResult> {
    this.logger.info('Login attempt', { email: args.email });
    
    const user = await User.findByEmail(args.email) as User;
    if (!user) {
      this.logger.warn('Login failed - user not found', { email: args.email });
      throw new UnauthorizedError('Invalid credentials');
    }

    const validPassword = await bcrypt.compare(args.password, user.password);
    if (!validPassword) {
      this.logger.warn('Login failed - invalid password', { email: args.email });
      throw new UnauthorizedError('Invalid credentials');
    }

    // Check if email is confirmed
    if (!user.emailConfirmed) {
      await this.resendConfirmationEmail(user.email);
      throw new UnauthorizedError('Please confirm your email address. A new confirmation email has been sent.');
    }

    // Check if 2FA is enabled
    const twoFactorStatus = await this.getTwoFactorStatus(user.id);
    if (twoFactorStatus.enabled) {
      return {
        ...this.generateAuthResult(user),
        requires2FA: true
      };
    }

    return this.generateAuthResult(user);
  }

  /**
   * Confirm a user's email
   */
  async confirmEmail(token: string): Promise<boolean> {
    const pool = this.db.getPool();
    if (!pool) {
      throw new Error('Database connection not available');
    }
    
    const result = await pool.query<{ id: string }>(
      'SELECT id FROM users WHERE email_token = $1 AND email_token_expire > NOW()',
      [token]
    );

    if (result.rows.length === 0) {
      throw new Error('Invalid or expired token');
    }

    const userId = result.rows[0].id;
    await pool.query(
      'UPDATE users SET email_confirmed = TRUE, email_token = NULL, email_token_expire = NULL WHERE id = $1',
      [userId]
    );

    return true;
  }

  /**
   * Resend confirmation email
   */
  async resendConfirmationEmail(email: string): Promise<boolean> {
    const user = await User.findByEmail(email);
    if (!user) {
      throw new Error('User not found');
    }

    if (user.emailConfirmed) {
      throw new Error('Email already confirmed');
    }

    // Check if last email was sent less than 1 minute ago
    if (user.lastEmailSent) {
      const lastSent = new Date(user.lastEmailSent);
      const now = new Date();
      const diffInMinutes = (now.getTime() - lastSent.getTime()) / (1000 * 60);
      
      if (diffInMinutes < 1) {
        throw new Error('Please wait before requesting another email');
      }
    }

    // Generate new confirmation token
    const confirmationToken = crypto.randomBytes(32).toString('hex');
    const tokenExpiry = new Date();
    tokenExpiry.setHours(tokenExpiry.getHours() + 24);

    const pool = this.db.getPool();
    if (!pool) {
      throw new Error('Database connection not available');
    }
    
    await pool.query(
      'UPDATE users SET email_token = $1, email_token_expire = $2 WHERE id = $3',
      [confirmationToken, tokenExpiry, user.id]
    );

    await this.emailService.sendConfirmationEmail(user.email, confirmationToken);
    return true;
  }

  /**
   * Get the current user from a token
   */
  async getCurrentUser(token: string): Promise<User> {
    try {
      const decoded = this.tokenService.verifyAccessToken(token);
      const user = await User.findByPk(decoded.userId) as User;
      
      if (!user) {
        throw new UnauthorizedError('User not found');
      }

      return user;
    } catch (error) {
      throw new UnauthorizedError('Invalid token');
    }
  }

  /**
   * Refresh an access token using a refresh token
   */
  async refreshToken(refreshTokenStr: string): Promise<{ token: string; refreshToken: string }> {
    try {
      const decoded = this.tokenService.verifyRefreshToken(refreshTokenStr);
      const user = await User.findByPk(decoded.userId) as User;

      if (!user) {
        throw new UnauthorizedError('User not found');
      }

      const { accessToken, refreshToken } = this.generateTokens(user);
      return { token: accessToken, refreshToken };
    } catch (error) {
      throw new UnauthorizedError('Invalid or expired refresh token');
    }
  }

  /**
   * Logout a user by blacklisting their tokens
   */
  logout(token: string): boolean {
    try {
      const decoded = this.tokenService.verifyAccessToken(token);
      if (decoded.exp) {
        const remainingTime = decoded.exp - Math.floor(Date.now() / 1000);
        if (remainingTime > 0) {
          this.tokenService.blacklistToken(token, TokenType.ACCESS);
        }
      }
      return true;
    } catch (error) {
      console.error('Error during logout:', error);
      return false;
    }
  }

  // Two-Factor Authentication Methods

  /**
   * Generate a new 2FA secret for a user
   */
  async generate2FASecret(user: UserAttributes): Promise<{ secret: string; qrCode: string }> {
    try {
      const secret = speakeasy.generateSecret({
        name: `ABE Stack:${user.email}`,
        length: 20
      });

      const qrCode = await QRCode.toDataURL(secret.otpauth_url || '');
      const existingAuth = await this.twoFactorAuthRepo.findByUserId(user.id);

      if (existingAuth) {
        await this.twoFactorAuthRepo.update(existingAuth.id, {
          secret: secret.base32,
          status: TwoFactorStatus.PENDING
        });
      } else {
        await this.twoFactorAuthRepo.create({
          userId: user.id,
          secret: secret.base32,
          status: TwoFactorStatus.PENDING,
          backupCodes: [],
          lastUsed: null
        });
      }

      return { secret: secret.base32, qrCode };
    } catch (error) {
      this.logger.error('Failed to generate 2FA secret', { error });
      throw new Error('Failed to generate 2FA secret');
    }
  }

  /**
   * Verify a 2FA token
   */
  async verify2FAToken(userId: string, token: string): Promise<boolean> {
    try {
      const twoFactorAuth = await this.twoFactorAuthRepo.findByUserId(userId);

      if (!twoFactorAuth) {
        throw new NotFoundError('Two-factor authentication not set up');
      }

      if (twoFactorAuth.backupCodes.includes(token)) {
        const updatedCodes = twoFactorAuth.backupCodes.filter(code => code !== token);
        await this.twoFactorAuthRepo.update(twoFactorAuth.id, {
          backupCodes: updatedCodes,
          lastUsed: new Date()
        });
        return true;
      }

      const verified = speakeasy.totp.verify({
        secret: twoFactorAuth.secret,
        encoding: 'base32',
        token,
        window: 1
      });

      if (verified) {
        await this.twoFactorAuthRepo.update(twoFactorAuth.id, {
          lastUsed: new Date()
        });
      }

      return verified;
    } catch (error) {
      if (error instanceof NotFoundError) throw error;
      this.logger.error('Failed to verify 2FA token', { error });
      throw new Error('Failed to verify 2FA token');
    }
  }

  /**
   * Enable 2FA for a user
   */
  async enable2FA(userId: string, token: string): Promise<string[]> {
    try {
      const twoFactorAuth = await this.twoFactorAuthRepo.findByUserId(userId);

      if (!twoFactorAuth) {
        throw new NotFoundError('Two-factor authentication not set up');
      }

      const verified = speakeasy.totp.verify({
        secret: twoFactorAuth.secret,
        encoding: 'base32',
        token,
        window: 1
      });

      if (!verified) {
        throw new UnauthorizedError('Invalid verification code');
      }

      const backupCodes = this.generateBackupCodes();

      await this.twoFactorAuthRepo.update(twoFactorAuth.id, {
        status: TwoFactorStatus.ENABLED,
        backupCodes,
        lastUsed: new Date()
      });

      return backupCodes;
    } catch (error) {
      if (error instanceof NotFoundError || error instanceof UnauthorizedError) throw error;
      this.logger.error('Failed to enable 2FA', { error });
      throw new Error('Failed to enable two-factor authentication');
    }
  }

  /**
   * Disable 2FA for a user
   */
  async disable2FA(userId: string): Promise<void> {
    try {
      const twoFactorAuth = await this.twoFactorAuthRepo.findByUserId(userId);

      if (!twoFactorAuth) {
        throw new NotFoundError('Two-factor authentication not set up');
      }

      await this.twoFactorAuthRepo.update(twoFactorAuth.id, {
        status: TwoFactorStatus.DISABLED,
        backupCodes: []
      });
    } catch (error) {
      if (error instanceof NotFoundError) throw error;
      this.logger.error('Failed to disable 2FA', { error });
      throw new Error('Failed to disable two-factor authentication');
    }
  }

  /**
   * Regenerate backup codes for 2FA
   */
  async regenerate2FABackupCodes(userId: string): Promise<string[]> {
    try {
      const twoFactorAuth = await this.twoFactorAuthRepo.findByUserId(userId);

      if (!twoFactorAuth) {
        throw new NotFoundError('Two-factor authentication not set up');
      }

      if ((twoFactorAuth.status as TwoFactorStatus) !== TwoFactorStatus.ENABLED) {
        throw new Error('Two-factor authentication is not enabled');
      }

      const backupCodes = this.generateBackupCodes();

      await this.twoFactorAuthRepo.update(twoFactorAuth.id, {
        backupCodes
      });

      return backupCodes;
    } catch (error) {
      if (error instanceof NotFoundError) throw error;
      this.logger.error('Failed to regenerate backup codes', { error });
      throw new Error('Failed to regenerate backup codes');
    }
  }

  /**
   * Get 2FA status for a user
   */
  async getTwoFactorStatus(userId: string): Promise<{ enabled: boolean; status: TwoFactorStatus }> {
    try {
      const twoFactorAuth = await this.twoFactorAuthRepo.findByUserId(userId);

      if (!twoFactorAuth) {
        return { enabled: false, status: TwoFactorStatus.DISABLED };
      }

      return {
        enabled: (twoFactorAuth.status as TwoFactorStatus) === TwoFactorStatus.ENABLED,
        status: twoFactorAuth.status as TwoFactorStatus
      };
    } catch (error) {
      this.logger.error('Failed to get 2FA status', { error });
      throw new Error('Failed to get two-factor authentication status');
    }
  }

  // Private helper methods

  private async createUser(
    args: RegisterArgs,
    hashedPassword: string,
    confirmationToken: string,
    tokenExpiry: Date
  ): Promise<User> {
    if (this.db.isInMemoryMode && this.db.isInMemoryMode()) {
      return this.createUserInMemory(args, hashedPassword, confirmationToken, tokenExpiry);
    }
    return this.createUserInDatabase(args, hashedPassword, confirmationToken, tokenExpiry);
  }

  private async createUserInMemory(
    args: RegisterArgs,
    hashedPassword: string,
    confirmationToken: string,
    tokenExpiry: Date
  ): Promise<User> {
    const userId = crypto.randomUUID();
    const userData = {
      id: userId,
      username: args.username,
      email: args.email,
      password: hashedPassword,
      displayName: args.displayName,
      firstName: args.firstName,
      lastName: args.lastName,
      bio: '',
      profileImage: '',
      bannerImage: '',
      role: 'user',
      isVerified: false,
      emailConfirmed: false,
      emailToken: confirmationToken,
      emailTokenExpire: tokenExpiry,
      lastEmailSent: new Date(),
      createdAt: new Date(),
      updatedAt: new Date()
    };
    
    const pool = this.db.getPool();
    if (pool) {
      await pool.query(
        'INSERT INTO users (id, username, email, password, display_name, first_name, last_name, bio, profile_image, banner_image, role, is_verified, email_confirmed, email_token, email_token_expire, last_email_sent) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)',
        [userId, args.username, args.email, hashedPassword, args.displayName, args.firstName, args.lastName, '', '', '', 'user', false, false, confirmationToken, tokenExpiry, new Date()]
      );
    }
    
    const user = await User.findByPk(userId) as User;
    return user || new User(userData);
  }

  private async createUserInDatabase(
    args: RegisterArgs,
    hashedPassword: string,
    confirmationToken: string,
    tokenExpiry: Date
  ): Promise<User> {
    return await User.create({
      username: args.username,
      email: args.email,
      password: hashedPassword,
      displayName: args.displayName,
      firstName: args.firstName,
      lastName: args.lastName,
      bio: '',
      profileImage: '',
      bannerImage: '',
      role: 'user',
      isVerified: false,
      emailConfirmed: false,
      emailToken: confirmationToken,
      emailTokenExpire: tokenExpiry,
      lastEmailSent: new Date()
    });
  }

  private generateAuthResult(user: User): AuthResult {
    const { accessToken, refreshToken } = this.generateTokens(user);
    return {
      token: accessToken,
      refreshToken,
      user
    };
  }

  private generateTokens(user: User): { accessToken: string; refreshToken: string } {
    const tokens = this.tokenService.generateTokens(user);
    return {
      accessToken: tokens.accessToken,
      refreshToken: tokens.refreshToken
    };
  }

  private generateBackupCodes(): string[] {
    const codes: string[] = [];
    for (let i = 0; i < 10; i++) {
      const code = `${this.generateRandomCode(4)}-${this.generateRandomCode(4)}-${this.generateRandomCode(4)}`;
      codes.push(code);
    }
    return codes;
  }

  private generateRandomCode(length: number): string {
    const chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    let result = '';
    const randomBytes = crypto.randomBytes(length);
    for (let i = 0; i < length; i++) {
      result += chars[randomBytes[i] % chars.length];
    }
    return result;
  }
}
================================================================================
File: services\AuthTokenService.ts
Lines: 320
--------------------------------------------------------------------------------
import crypto, { createHash } from 'crypto';

import jwt from 'jsonwebtoken';

import { UnauthorizedError } from '../../shared/errors/ApiError';
import { env } from '../config/environment';

import { Logger } from './LoggerService';

// Token types
export enum TokenType {
  ACCESS = 'access',
  REFRESH = 'refresh'
}

// Token payload interface
export interface TokenPayload {
  id: string;
  userId: string;
  type: TokenType;
  role?: string;
  iat?: number;
  exp?: number;
}

// Token response interface
export interface TokenResponse {
  accessToken: string;
  refreshToken: string;
  expiresIn: number;
}

// User attributes interface
export interface UserAttributes {
  id: string;
  email: string;
  role?: string;
}

/**
 * Consolidated service for handling JWT token generation, verification, and blacklisting
 */
export class AuthTokenService {
  private static instance: AuthTokenService;
  private logger: Logger;
  private blacklistedTokens: Map<string, number>; // token hash -> expiry timestamp
  private readonly PREFIX = 'blacklist:token:';
  private cleanupInterval: NodeJS.Timeout;
  
  // Token configuration
  private readonly ACCESS_TOKEN_SECRET: string;
  private readonly REFRESH_TOKEN_SECRET: string;
  private readonly ACCESS_TOKEN_EXPIRY: number;
  private readonly REFRESH_TOKEN_EXPIRY: number;

  private constructor() {
    this.logger = new Logger('AuthTokenService');
    this.blacklistedTokens = new Map();
    
    // Initialize token configuration
    this.ACCESS_TOKEN_SECRET = env.ACCESS_TOKEN_SECRET || env.JWT_SECRET || 'access-token-secret';
    this.REFRESH_TOKEN_SECRET = env.REFRESH_TOKEN_SECRET || env.JWT_REFRESH_SECRET || 'refresh-token-secret';
    this.ACCESS_TOKEN_EXPIRY = parseInt(env.ACCESS_TOKEN_EXPIRY || '15') * 60; // 15 minutes in seconds
    this.REFRESH_TOKEN_EXPIRY = parseInt(env.REFRESH_TOKEN_EXPIRY || '7') * 24 * 60 * 60; // 7 days in seconds
    
    // Start cleanup interval for blacklisted tokens
    this.cleanupInterval = setInterval(() => this.cleanupExpiredTokens(), 60000); // Clean up every minute
  }

  /**
   * Get the singleton instance
   */
  public static getInstance(): AuthTokenService {
    if (!AuthTokenService.instance) {
      AuthTokenService.instance = new AuthTokenService();
    }
    return AuthTokenService.instance;
  }

  /**
   * Generate tokens for a user
   * @param user User to generate tokens for
   * @returns Access token, refresh token, and expiry
   */
  public generateTokens(user: UserAttributes): TokenResponse {
    try {
      const accessToken = this.generateAccessToken(user.id);
      const refreshToken = this.generateRefreshToken(user.id);
      
      return {
        accessToken,
        refreshToken,
        expiresIn: this.ACCESS_TOKEN_EXPIRY
      };
    } catch (error) {
      this.logger.error('Failed to generate tokens', { error });
      throw new Error('Failed to generate authentication tokens');
    }
  }

  /**
   * Generate an access token
   * @param userId User ID to include in the token
   * @returns JWT access token
   */
  private generateAccessToken(userId: string): string {
    return jwt.sign(
      { 
        userId, 
        type: TokenType.ACCESS,
        id: crypto.randomUUID()
      }, 
      this.ACCESS_TOKEN_SECRET, 
      { expiresIn: this.ACCESS_TOKEN_EXPIRY }
    );
  }

  /**
   * Generate a refresh token
   * @param userId User ID to include in the token
   * @returns JWT refresh token
   */
  private generateRefreshToken(userId: string): string {
    return jwt.sign(
      { 
        userId, 
        type: TokenType.REFRESH,
        id: crypto.randomUUID()
      }, 
      this.REFRESH_TOKEN_SECRET, 
      { expiresIn: this.REFRESH_TOKEN_EXPIRY }
    );
  }

  /**
   * Verify an access token
   * @param token JWT access token
   * @returns Decoded token payload
   */
  public verifyAccessToken(token: string): TokenPayload {
    try {
      // Check if token is blacklisted
      if (this.isBlacklisted(token)) {
        throw new UnauthorizedError('Token has been revoked');
      }
      
      // Verify token
      const decoded = jwt.verify(token, this.ACCESS_TOKEN_SECRET) as TokenPayload;
      
      // Ensure it's an access token
      if (decoded.type !== TokenType.ACCESS) {
        throw new UnauthorizedError('Invalid token type');
      }
      
      return decoded;
    } catch (error) {
      if (error instanceof UnauthorizedError) {
        throw error;
      }
      
      if (error instanceof jwt.JsonWebTokenError) {
        throw new UnauthorizedError('Invalid token');
      }
      
      if (error instanceof jwt.TokenExpiredError) {
        throw new UnauthorizedError('Token expired');
      }
      
      this.logger.error('Failed to verify access token', { error });
      throw new UnauthorizedError('Authentication failed');
    }
  }

  /**
   * Verify a refresh token
   * @param token JWT refresh token
   * @returns Decoded token payload
   */
  public verifyRefreshToken(token: string): TokenPayload {
    try {
      // Check if token is blacklisted
      if (this.isBlacklisted(token)) {
        throw new UnauthorizedError('Token has been revoked');
      }
      
      // Verify token
      const decoded = jwt.verify(token, this.REFRESH_TOKEN_SECRET) as TokenPayload;
      
      // Ensure it's a refresh token
      if (decoded.type !== TokenType.REFRESH) {
        throw new UnauthorizedError('Invalid token type');
      }
      
      return decoded;
    } catch (error) {
      if (error instanceof UnauthorizedError) {
        throw error;
      }
      
      if (error instanceof jwt.JsonWebTokenError) {
        throw new UnauthorizedError('Invalid token');
      }
      
      if (error instanceof jwt.TokenExpiredError) {
        throw new UnauthorizedError('Token expired');
      }
      
      this.logger.error('Failed to verify refresh token', { error });
      throw new UnauthorizedError('Authentication failed');
    }
  }

  /**
   * Decode a token without verification
   * @param token JWT token
   * @returns Decoded token payload or null if invalid
   */
  public decodeToken(token: string): TokenPayload | null {
    return jwt.decode(token) as TokenPayload | null;
  }

  /**
   * Revoke a token by adding it to the blacklist
   * @param token The JWT token to blacklist
   * @param type The type of token (access or refresh)
   */
  public blacklistToken(token: string, type: TokenType): void {
    try {
      const expirySeconds = type === TokenType.ACCESS ? this.ACCESS_TOKEN_EXPIRY : this.REFRESH_TOKEN_EXPIRY;
      const key = this.getBlacklistKey(token);
      const expiryTime = Date.now() + (expirySeconds * 1000);
      
      this.blacklistedTokens.set(key, expiryTime);
      this.logger.debug('Token blacklisted', { type, expirySeconds });
    } catch (error) {
      this.logger.error('Failed to blacklist token', { error });
      throw new Error('Failed to revoke token');
    }
  }

  /**
   * Check if a token is blacklisted
   * @param token The JWT token to check
   * @returns True if the token is blacklisted, false otherwise
   */
  private isBlacklisted(token: string): boolean {
    try {
      const key = this.getBlacklistKey(token);
      const expiryTime = this.blacklistedTokens.get(key);
      
      // If token is not in the map or has expired, it's not blacklisted
      if (!expiryTime || expiryTime < Date.now()) {
        if (expiryTime) {
          // Token has expired, remove it from the map
          this.blacklistedTokens.delete(key);
        }
        return false;
      }
      
      return true;
    } catch (error) {
      this.logger.error('Failed to check token blacklist status', { error });
      // Default to treating the token as blacklisted in case of errors
      return true;
    }
  }

  /**
   * Remove a token from the blacklist (rarely needed)
   * @param token The JWT token to remove from the blacklist
   */
  public removeFromBlacklist(token: string): void {
    try {
      const key = this.getBlacklistKey(token);
      this.blacklistedTokens.delete(key);
      this.logger.debug('Token removed from blacklist');
    } catch (error) {
      this.logger.error('Failed to remove token from blacklist', { error });
      throw new Error('Failed to remove token from blacklist');
    }
  }

  /**
   * Get the blacklist key for a token
   * @param token The JWT token
   * @returns The key
   */
  private getBlacklistKey(token: string): string {
    // Use a hash of the token as the key to avoid storing the actual token
    const hash = createHash('sha256').update(token).digest('hex');
    return `${this.PREFIX}${hash}`;
  }

  /**
   * Clean up expired tokens from the blacklist
   */
  private cleanupExpiredTokens(): void {
    const now = Date.now();
    let expiredCount = 0;
    
    for (const [key, expiryTime] of this.blacklistedTokens.entries()) {
      if (expiryTime < now) {
        this.blacklistedTokens.delete(key);
        expiredCount++;
      }
    }
    
    if (expiredCount > 0) {
      this.logger.debug(`Cleaned up ${expiredCount} expired tokens`);
    }
  }

  /**
   * Close the service (cleanup)
   */
  public close(): void {
    clearInterval(this.cleanupInterval);
    this.blacklistedTokens.clear();
  }
} 
================================================================================
File: services\Database.ts
Lines: 173
--------------------------------------------------------------------------------
import { Pool } from 'pg';

import { Simplify } from '../../shared/typeHelpers';

import { Logger } from './LoggerService';

const logger = new Logger('Database');

// Simple in-memory database for fallback mode
class InMemoryDatabase {
  private data: Map<string, Record<string, unknown>[]> = new Map();
  
  query(text: string, params: unknown[] = []): Promise<{ rows: Record<string, unknown>[] }> {
    logger.debug('In-memory DB query:', { text, params });
    
    // Very basic query parser for development fallback
    if (text.toLowerCase().startsWith('select')) {
      const tableName = this.extractTableName(text);
      return Promise.resolve({ rows: this.data.get(tableName) || [] });
    } else if (text.toLowerCase().startsWith('insert')) {
      const tableName = this.extractTableName(text);
      if (!this.data.has(tableName)) {
        this.data.set(tableName, []);
      }
      
      // Create a mock record with an ID
      const mockRecord: Record<string, unknown> = {
        id: crypto.randomUUID(),
        ...this.createMockRecord(params)
      };
      
      const tableData = this.data.get(tableName);
      if (tableData) {
        tableData.push(mockRecord);
      }
      return Promise.resolve({ rows: [mockRecord] });
    } else if (text.toLowerCase().startsWith('update')) {
      // Extract table name but we don't need to use it for this mock implementation
      this.extractTableName(text);
      // For simplicity, just return success
      return Promise.resolve({ rows: [] });
    }
    
    // Default fallback
    return Promise.resolve({ rows: [] });
  }
  
  private extractTableName(query: string): string {
    // Very basic extraction - just for development
    const fromMatch = query.match(/from\s+([^\s,;]+)/i);
    const intoMatch = query.match(/into\s+([^\s,;(]+)/i);
    const updateMatch = query.match(/update\s+([^\s,;]+)/i);
    
    return (fromMatch?.[1] || intoMatch?.[1] || updateMatch?.[1] || 'unknown').replace(/['"]/g, '');
  }
  
  private createMockRecord(params: unknown[]): Record<string, unknown> {
    // Create a simple object with sequential keys
    return params.reduce<Record<string, unknown>>((obj, value, index) => {
      obj[`field${index}`] = value;
      return obj;
    }, {});
  }
}

export class Database {
  private pool: Pool | InMemoryDatabase | null = null;
  private connected = false;
  private inMemoryMode = false;

  constructor(_dbPath: string) {
    // dbPath is ignored when using PostgreSQL
  }

  async initialize() {
    try {
      // Try to connect to PostgreSQL
      this.pool = new Pool({
        host: process.env.DB_HOST || 'localhost',
        port: parseInt(process.env.DB_PORT || '5432'),
        user: process.env.DB_USER || 'postgres',
        password: process.env.DB_PASSWORD || 'postgres',
        database: process.env.DB_NAME || 'abe_stack',
        ssl: process.env.NODE_ENV === 'production' ? {
          rejectUnauthorized: false
        } : undefined,
        max: 20,
        idleTimeoutMillis: 30000,
        connectionTimeoutMillis: 2000
      });

      // Test the connection
      const client = await this.pool.connect();
      try {
        await client.query('SELECT NOW()');
        logger.info('PostgreSQL connection established successfully.');
        this.connected = true;
      } finally {
        client.release();
      }
      
      return this;
    } catch (error) {
      logger.error('Unable to connect to PostgreSQL:', error);
      logger.info('Continuing with in-memory database fallback mode...');
      
      // Set up in-memory database for development
      this.pool = new InMemoryDatabase();
      this.connected = true;
      this.inMemoryMode = true;
      
      return this;
    }
  }

  async reset() {
    if (this.inMemoryMode) {
      // Reset in-memory database
      this.pool = new InMemoryDatabase();
      logger.info('In-memory database reset complete.');
      return;
    }
    
    if (this.connected && this.pool instanceof Pool) {
      // In development, we can reset tables
      if (process.env.NODE_ENV !== 'production') {
        try {
          // Drop all tables and recreate them using migrations
          await this.pool.query(`
            DO $$ DECLARE
              r RECORD;
            BEGIN
              FOR r IN (SELECT tablename FROM pg_tables WHERE schemaname = current_schema()) LOOP
                EXECUTE 'DROP TABLE IF EXISTS ' || quote_ident(r.tablename) || ' CASCADE';
              END LOOP;
            END $$;
          `);
          logger.info('Database reset complete.');
        } catch (error) {
          logger.error('Database reset failed:', error);
        }
      } else {
        logger.warn('Database reset attempted in production mode - operation skipped.');
      }
    }
  }

  // Get the pool instance or in-memory database
  getPool() {
    return this.pool;
  }

  // Check if database is connected
  isConnected() {
    return this.connected;
  }

  // Check if using in-memory mode
  isInMemoryMode() {
    return this.inMemoryMode;
  }

  // Close the database connection
  async close() {
    if (this.pool instanceof Pool) {
      await this.pool.end();
      this.connected = false;
      logger.info('Database connection closed.');
    }
  }
}

export type DatabaseApi = Simplify<Database>;
================================================================================
File: services\EmailService.ts
Lines: 177
--------------------------------------------------------------------------------
// Remove the custom type declaration
import nodemailer from 'nodemailer';

import { emailConfig } from '../config/email';

import { Database } from './Database';

export class EmailService {
  private transporter: nodemailer.Transporter;
  private db: Database;

  constructor(db: Database) {
    this.db = db;
    
    // Create email transporter
    this.transporter = nodemailer.createTransport({
      host: emailConfig.host,
      port: emailConfig.port,
      secure: emailConfig.secure,
      auth: {
        user: emailConfig.user,
        pass: emailConfig.password,
      },
    });
  }

  /**
   * Sends a confirmation email for user registration
   * 
   * @param userEmail - The recipient's email address
   * @param confirmationToken - Unique token for email verification
   * @returns Result of email sending process
   */
  async sendConfirmationEmail(
    userEmail: string,
    confirmationToken: string
  ): Promise<{ success: boolean; message: string }> {
    console.log("Sending confirmation email to:", userEmail);

    // Determine website domain based on environment
    const websiteDomain = emailConfig.isDevelopment
      ? `http://localhost:${emailConfig.port}`
      : emailConfig.appUrl;

    // Generate confirmation URL
    const confirmationUrl = `${websiteDomain}/auth/confirm-email?token=${confirmationToken}`;

    // Email content
    const emailContent = `
      <h2>Welcome to ${emailConfig.appName}!</h2>
      <p>Thank you for registering. Please confirm your email address by clicking the link below:</p>
      <p><a href="${confirmationUrl}">Confirm Email</a></p>
      <p>This link will expire in 24 hours.</p>
      <p>If you did not register for an account, please ignore this email.</p>
    `;

    // Prepare email options
    const mailOptions: nodemailer.SendMailOptions = {
      from: `"${emailConfig.appName}" <${emailConfig.user}>`,
      to: userEmail,
      subject: 'Email Confirmation',
      html: emailContent,
    };

    // In development mode, just log the email and auto-confirm the user
    if (emailConfig.isDevelopment) {
      console.log('=== DEVELOPMENT MODE: Email not actually sent ===');
      console.log('To:', userEmail);
      console.log('Subject:', 'Email Confirmation');
      console.log('Confirmation URL:', confirmationUrl);
      console.log('Email Content:', emailContent);
      console.log('=== END OF EMAIL PREVIEW ===');
      
      // Auto-confirm the user in development mode
      try {
        const pool = this.db.getPool();
        if (pool) {
          // Update the user to mark email as confirmed
          await pool.query(
            'UPDATE users SET email_confirmed = TRUE, last_email_sent = NOW() WHERE email = $1',
            [userEmail]
          );
          console.log(`DEVELOPMENT MODE: Auto-confirmed email for user: ${userEmail}`);
        } else {
          console.warn('Database pool is not available, skipping auto-confirmation');
        }
      } catch (error) {
        console.error('Error auto-confirming user:', error);
      }
      
      return { success: true, message: 'Email logged in development mode and user auto-confirmed.' };
    }

    try {
      // Send email
      const info = await Promise.resolve(this.transporter.sendMail(mailOptions)) as Promise<nodemailer.SentMessageInfo>;
      console.log('Email sent:', String(info));

      // Update last email sent timestamp in the database
      const pool = this.db.getPool();
      if (pool) {
        await pool.query(
          'UPDATE users SET last_email_sent = NOW() WHERE email = $1',
          [userEmail]
        );
      } else {
        console.warn('Database pool is not available, skipping update of last_email_sent');
      }

      return { success: true, message: 'Email sent successfully.' };
    } catch (error) {
      console.error('Error sending confirmation email:', error);
      return { success: false, message: 'Error sending confirmation email.' };
    }
  }

  /**
   * Sends a password reset email
   * 
   * @param userEmail - The recipient's email address
   * @param resetToken - Unique token for password reset
   * @returns Result of email sending process
   */
  async sendPasswordResetEmail(
    userEmail: string,
    resetToken: string
  ): Promise<{ success: boolean; message: string }> {
    console.log("Sending password reset email to:", userEmail);

    // Determine website domain based on environment
    const websiteDomain = emailConfig.isDevelopment
      ? `http://localhost:${emailConfig.port}`
      : emailConfig.appUrl;

    // Generate reset URL
    const resetUrl = `${websiteDomain}/auth/reset-password?token=${resetToken}`;

    // Email content
    const emailContent = `
      <h2>Password Reset Request</h2>
      <p>You requested a password reset. Please click the link below to reset your password:</p>
      <p><a href="${resetUrl}">Reset Password</a></p>
      <p>This link will expire in 1 hour.</p>
      <p>If you did not request a password reset, please ignore this email.</p>
    `;

    // Prepare email options
    const mailOptions: nodemailer.SendMailOptions = {
      from: `"${emailConfig.appName}" <${emailConfig.user}>`,
      to: userEmail,
      subject: 'Password Reset',
      html: emailContent,
    };

    // In development mode, just log the email
    if (emailConfig.isDevelopment) {
      console.log('=== DEVELOPMENT MODE: Email not actually sent ===');
      console.log('To:', userEmail);
      console.log('Subject:', 'Password Reset');
      console.log('Reset URL:', resetUrl);
      console.log('Email Content:', emailContent);
      console.log('=== END OF EMAIL PREVIEW ===');
      
      return { success: true, message: 'Email logged in development mode.' };
    }

    try {
      // Send email
      const info = await Promise.resolve(this.transporter.sendMail(mailOptions)) as Promise<nodemailer.SentMessageInfo>;
      console.log('Email sent:', String(info));
      return { success: true, message: 'Email sent successfully.' };
    } catch (error) {
      console.error('Error sending password reset email:', error);
      return { success: false, message: 'Error sending password reset email.' };
    }
  }
} 
================================================================================
File: services\InMemoryQueue.ts
Lines: 243
--------------------------------------------------------------------------------
import crypto from 'crypto';
import { EventEmitter } from 'events';

// Job status enum
export enum JobStatus {
  WAITING = 'waiting',
  ACTIVE = 'active',
  COMPLETED = 'completed',
  FAILED = 'failed'
}

// Job processor type
export type JobProcessor<T> = (job: Job<T>) => Promise<unknown>;

// Job interface
export interface Job<T> {
  id: string;
  data: T;
  status: JobStatus;
  timestamp: number;
  result?: unknown;
  error?: Error;
  progress: number;
  opts: JobOptions;
  
  // Methods
  update(progress: number): Promise<void>;
  remove(): Promise<void>;
}

// Job options interface
export interface JobOptions {
  delay?: number;
  attempts?: number;
  priority?: number;
  removeOnComplete?: boolean;
  removeOnFail?: boolean;
}

// Queue class
export class InMemoryQueue<T> extends EventEmitter {
  private queue: Job<T>[] = [];
  private isProcessing = false;
  private processor: JobProcessor<T>;
  private timers: Map<string, NodeJS.Timeout>;

  constructor(processor: JobProcessor<T>) {
    super();
    this.processor = processor;
    this.timers = new Map();
  }

  /**
   * Add a job to the queue
   */
  add(data: T, opts: JobOptions = {}): Job<T> {
    const id = crypto.randomUUID();
    const job: Job<T> = {
      id,
      data,
      status: JobStatus.WAITING,
      timestamp: Date.now(),
      progress: 0,
      opts,
      
      update: async (progress: number) => {
        job.progress = progress;
        this.emit('progress', job, progress);
        return Promise.resolve();
      },
      remove: async () => {
        this.queue = this.queue.filter(j => j.id !== id);
        if (this.timers.has(id)) {
          const timer = this.timers.get(id);
          clearTimeout(timer);
          this.timers.delete(id);
        }
        return Promise.resolve();
      }
    };
    
    if (opts.delay && opts.delay > 0) {
      // Schedule delayed job
      const timer = setTimeout(() => {
        this.queue.push(job);
        this.timers.delete(id);
        void this.processNextJob();
      }, opts.delay);
      
      this.timers.set(id, timer);
    } else {
      this.queue.push(job);
      void this.processNextJob();
    }
    
    this.emit('added', job);
    return job;
  }

  /**
   * Process jobs with the given processor function
   */
  process(processor: JobProcessor<T>): void {
    this.processor = processor;
    this.isProcessing = true;
    void this.processNextJob();
  }

  /**
   * Process the next job in the queue
   */
  private async processNextJob(): Promise<void> {
    if (!this.isProcessing || !this.processor || this.queue.length === 0) {
      return;
    }
    
    const job = this.queue.shift() as Job<T>;
    
    if (!job) {
      return this.processNextJob();
    }
    
    job.status = JobStatus.ACTIVE;
    
    try {
      const result = await this.processor(job);
      job.status = JobStatus.COMPLETED;
      job.result = result;
      
      if (job.opts.removeOnComplete) {
        this.queue = this.queue.filter(j => j.id !== job.id);
      }
      
      this.emit('completed', job, result);
    } catch (error) {
      job.status = JobStatus.FAILED;
      job.error = error as Error;
      
      // Handle retries
      if (job.opts.attempts && job.opts.attempts > 1) {
        job.opts.attempts--;
        job.status = JobStatus.WAITING;
        this.queue.push(job);
      } else if (job.opts.removeOnFail) {
        this.queue = this.queue.filter(j => j.id !== job.id);
      }
      
      this.emit('failed', job, error);
    }
    
    // Process next job
    void this.processNextJob();
  }

  /**
   * Get a job by ID
   */
  getJob(jobId: string): Job<T> | null {
    return this.queue.find(job => job.id === jobId) || null;
  }

  /**
   * Get all jobs in the queue
   */
  getJobs(status?: JobStatus): Job<T>[] {
    if (!status) {
      return this.queue;
    }
    
    return this.queue.filter(job => job.status === status);
  }

  /**
   * Pause the queue
   */
  pause(): void {
    this.isProcessing = false;
    this.emit('paused');
  }

  /**
   * Resume the queue
   */
  resume(): void {
    this.isProcessing = true;
    void this.processNextJob();
    this.emit('resumed');
  }

  /**
   * Empty the queue
   */
  empty(): void {
    // Clear all timers
    for (const timer of this.timers.values()) {
      clearTimeout(timer);
    }
    
    this.queue = [];
    this.timers.clear();
    this.emit('emptied');
  }

  /**
   * Close the queue
   */
  close(): void {
    this.pause();
    this.emit('closed');
  }

  /**
   * Get the count of jobs by status
   */
  getJobCounts(): Record<string, number> {
    const counts = {
      waiting: 0,
      active: 0,
      completed: 0,
      failed: 0,
      delayed: 0,
      total: this.queue.length
    };
    
    for (const job of this.queue) {
      if (job.status === JobStatus.WAITING) {
        if (job.opts.delay && job.opts.delay > 0) {
          counts.delayed++;
        } else {
          counts.waiting++;
        }
      } else if (job.status === JobStatus.ACTIVE) {
        counts.active++;
      } else if (job.status === JobStatus.COMPLETED) {
        counts.completed++;
      } else if (job.status === JobStatus.FAILED) {
        counts.failed++;
      }
    }
    
    return counts;
  }
} 
================================================================================
File: services\LoggerService.ts
Lines: 199
--------------------------------------------------------------------------------
import path from 'path';

import { Request, Response } from 'express';
import winston from 'winston';
// Environment variables with defaults
const {
  LOG_LEVEL = 'info',
  NODE_ENV = 'development'
} = process.env;

/**
 * Helper function to format objects for better readability
 */
const formatObject = (obj: unknown): string => {
  if (!obj) return '';
  
  try {
    // For strings that look like JSON, parse and then stringify with indentation
    if (typeof obj === 'string' && (obj.startsWith('{') || obj.startsWith('['))) {
      try {
        const parsed = JSON.parse(obj) as Record<string, unknown>;
        return '\n' + JSON.stringify(parsed, null, 2);
      } catch {
        // If parsing fails, treat as regular string
        return obj;
      }
    }
    
    // For objects, stringify with indentation
    if (typeof obj === 'object') {
      return '\n' + JSON.stringify(obj, null, 2);
    }
    
    // For other types, convert to string
    return String(obj);
  } catch (error) {
    return `[Unformattable object: ${String(error)}]`;
  }
};

/**
 * Sanitize sensitive data from objects
 */
const sanitizeData = (data: Record<string, unknown>): Record<string, unknown> => {
  if (!data) return data;
  const sanitized = { ...data };
  
  // Remove sensitive fields
  if (sanitized.password) sanitized.password = '***';
  if (sanitized.passwordConfirmation) sanitized.passwordConfirmation = '***';
  if (sanitized.token) sanitized.token = '***';
  if (sanitized.refreshToken) sanitized.refreshToken = '***';
  
  return sanitized;
};

/**
 * Unified Logger service for consistent logging across the application
 */
export class Logger {
  private logger: winston.Logger;

  constructor(serviceName?: string) {
    // Ensure logs directory exists
    const logsDir = path.resolve(process.cwd(), 'logs');
    
    // Create Winston logger
    this.logger = winston.createLogger({
      level: LOG_LEVEL,
      format: winston.format.combine(
        winston.format.timestamp({
          format: 'YYYY-MM-DD HH:mm:ss'
        }),
        winston.format.errors({ stack: true }),
        winston.format.splat(),
        winston.format.json()
      ),
      defaultMeta: { service: serviceName },
      transports: [
        // Write logs to console with colorization
        new winston.transports.Console({
          format: winston.format.combine(
            winston.format.colorize(),
            winston.format.printf((info) => {
              const { timestamp, level, message, service, ...meta } = info;
              const messageStr = String(message);
              // Format metadata for better readability
              let metaOutput = '';
              
              if (Object.keys(meta).length) {
                // Handle body property specially for HTTP requests
                if (meta.body) {
                  meta.body = sanitizeData(meta.body as Record<string, unknown>);
                  metaOutput += `\nBody: ${formatObject(meta.body)}`;
                  delete meta.body;
                }
                
                // Format remaining metadata
                if (Object.keys(meta).length) {
                  metaOutput += `\nMeta: ${formatObject(meta)}`;
                }
              }
              
              // Add visual separator for debug level
              const separator = level.includes('debug') ? 
                '\n----------------------------------------' : '';
              
              const servicePart = service ? `[${String(service)}]` : '';
              return `${String(timestamp)} ${String(level)} ${servicePart}: ${messageStr}${metaOutput}${String(separator)}`;
            })
          )
        })
      ]
    });
    
    // Add file transports in production
    if (NODE_ENV === 'production') {
      this.logger.add(
        new winston.transports.File({ 
          filename: path.join(logsDir, 'error.log'), 
          level: 'error' 
        })
      );
      this.logger.add(
        new winston.transports.File({ 
          filename: path.join(logsDir, 'combined.log') 
        })
      );
    }
  }

  /**
   * Log an info message
   */
  public info(message: string, ...meta: unknown[]): void {
    this.logger.info(message, ...meta);
  }

  /**
   * Log a warning message
   */
  public warn(message: string, ...meta: unknown[]): void {
    this.logger.warn(message, ...meta);
  }

  /**
   * Log an error message
   */
  public error(message: string, ...meta: unknown[]): void {
    this.logger.error(message, ...meta);
  }

  /**
   * Log a debug message
   */
  public debug(message: string, ...meta: unknown[]): void {
    this.logger.debug(message, ...meta);
  }

  /**
   * Log HTTP request details
   */
  public logRequest(req: Request): void {
    const logData = {
      method: String(req.method),
      url: String(req.url),
      body: sanitizeData(req.body as Record<string, unknown>),
      query: sanitizeData(req.query as Record<string, unknown>),
      ip: String(req.ip ?? ''),
      userAgent: String((req.get as (name: string) => string | null)('user-agent') ?? '')
    };

    if (NODE_ENV === 'development') {
      this.debug('Incoming request', logData);
    }
  }

  /**
   * Log HTTP response details
   */
  public logResponse(req: Request, res: Response, duration: number): void {
    const responseData = {
      method: String(req.method),
      url: String(req.url),
      status: Number(res.statusCode),
      duration: `${duration}ms`,
      timestamp: new Date().toISOString()
    };

    if (NODE_ENV === 'production' && res.statusCode >= 400) {
      this.error('Request error', responseData);
    } else if (NODE_ENV === 'development') {
      this.info('Request completed', responseData);
    }
  }
}

// Export a default logger instance
export const logger = new Logger('DefaultLogger'); 
================================================================================
File: services\MediaService.ts
Lines: 95
--------------------------------------------------------------------------------
// src/server/services/MediaService.ts
import * as crypto from 'crypto';
import { createReadStream, existsSync, mkdirSync, statSync, Stats } from 'fs';
import { join, parse } from 'path';

import { Request, Response } from 'express';
import * as mime from 'mime-types';

import { Simplify } from '../../shared/typeHelpers';
import { path } from '../helpers/path';

export class MediaService {
  private mediaPath: string;
  
  constructor() {
    this.mediaPath = path('uploads/media');
    
    // Ensure media directory exists
    if (!existsSync(this.mediaPath)) {
      mkdirSync(this.mediaPath, { recursive: true });
    }
  }

  /**
   * Generate a unique filename
   */
  generateFilename(originalname: string): string {
    const { name, ext } = parse(originalname);
    const hash = crypto.createHash('md5').update(`${name}-${Date.now()}`).digest('hex').substring(0, 8);
    return `${name}-${hash}${ext}`;
  }

  /**
   * Stream media file
   */
  streamMedia(req: Request, res: Response & { 
    writeHead: (statusCode: number, headers?: Record<string, string>) => void;
    status: (code: number) => Response;
    send: (body: string) => Response;
  }, filename: string): void {
    const filepath = join(this.mediaPath, filename);
    
    if (!existsSync(filepath)) {
      res.status(404).send('File not found');
      return;
    }
    
    const stat: Stats = statSync(filepath);
    const fileSize = stat.size;
    const mimeType = mime.lookup(filepath) || 'application/octet-stream';
    
    // Handle range requests (important for video/audio seeking)
    const rangeHeader = (req.headers as { range?: string }).range;
    
    if (rangeHeader) {
      const parts = rangeHeader.replace(/bytes=/, '').split('-');
      const start = parseInt(parts[0], 10);
      const end = parts[1] ? parseInt(parts[1], 10) : fileSize - 1;
      const chunkSize = (end - start) + 1;
      
      res.writeHead(206, {
        'Content-Range': `bytes ${start}-${end}/${fileSize}`,
        'Accept-Ranges': 'bytes',
        'Content-Length': chunkSize,
        'Content-Type': mimeType
      });
      
      const stream = createReadStream(filepath, { start, end });
      stream.pipe(res);
    } else {
      res.writeHead(200, {
        'Content-Length': fileSize,
        'Content-Type': mimeType
      });
      createReadStream(filepath).pipe(res);
    }
  }

  /**
   * Get media type
   */
  getMediaType(filename: string): 'audio' | 'video' | 'image' | 'unknown' {
    const mimeType = mime.lookup(filename);
    
    if (!mimeType) return 'unknown';
    
    if (mimeType.startsWith('audio/')) return 'audio';
    if (mimeType.startsWith('video/')) return 'video';
    if (mimeType.startsWith('image/')) return 'image';
    
    return 'unknown';
  }
}

export type MediaServiceApi = Simplify<MediaService>;
================================================================================
File: services\QueueDatabase.ts
Lines: 221
--------------------------------------------------------------------------------
import fs from 'fs';

import { randomId } from "../../shared/randomId"
import { Simplify } from "../../shared/typeHelpers"
import { TaskName, Tasks } from "../tasks"

import { Logger } from "./LoggerService"

type QueueTaskArgs = {
	[K in keyof Tasks]: Parameters<Tasks[K]>[1]
}

export type TaskError = {
	name: string
	message: string
	stack: string
}

type Task<T extends TaskName = TaskName> = {
	id: string
	name: T
	args: QueueTaskArgs[T]
	run_at: string // ISO date string.
	started_at?: string
	error?: TaskError
}

// Simple in-memory database structure
interface TaskStore {
	tasks: Record<string, Task>;
	waiting: Record<string, string[]>; // run_at -> task ids
	running: Record<string, string[]>; // started_at -> task ids
	failed: Record<string, Task>; // task id -> task
}

const debug = (...args: unknown[]) => console.log("queue:", ...args)

export class QueueDatabase {
	private store: TaskStore = {
		tasks: {},
		waiting: {},
		running: {},
		failed: {}
	}
	private tasksPath: string
	private logger: Logger
	enqueue!: EnqueueApi

	constructor(tasksPath: string = '') {
		this.logger = new Logger('QueueDatabase');
		this.tasksPath = tasksPath;
		
		// Load existing tasks if available
		void this.loadTasks()
		
		// Create the enqueue proxy
		this.createEnqueueProxy()
	}

	private async loadTasks() {
		try {
			if (fs.existsSync(this.tasksPath)) {
				const data = await fs.promises.readFile(this.tasksPath, 'utf8')
				this.store = JSON.parse(data) as TaskStore
				this.logger.info('Tasks loaded successfully');
			}
		} catch (error) {
			this.logger.error('Error loading tasks:', error)
			// Initialize with empty store if there's an error
			this.store = {
				tasks: {},
				waiting: {},
				running: {},
				failed: {}
			}
		}
	}

	private async saveTasks() {
		try {
			await fs.promises.writeFile(this.tasksPath, JSON.stringify(this.store, null, 2), 'utf8')
		} catch (error) {
			console.error('Error saving tasks:', error)
		}
	}

	private async enqueueTask(task: Task) {
		debug(`> enqueue.${task.name}`)
		
		// Add task to tasks store
		this.store.tasks[task.id] = task
		
		// Add task to waiting queue
		if (!this.store.waiting[task.run_at]) {
			this.store.waiting[task.run_at] = []
		}
		this.store.waiting[task.run_at].push(task.id)
		
		// Save changes
		await this.saveTasks()
		
		return task.id
	}

	async dequeueTask(now: string) {
		// Find the earliest waiting task that should run now
		const runAtTimes = Object.keys(this.store.waiting).sort()
		let taskToRun: Task | null = null
		let runAtTime: string | null = null
		
		for (const time of runAtTimes) {
			if (time <= now && this.store.waiting[time].length > 0) {
				runAtTime = time
				const taskId = this.store.waiting[time][0]
				taskToRun = this.store.tasks[taskId]
				break
			}
		}
		
		if (!taskToRun || !runAtTime) return null
		
		// Remove task from waiting queue
		this.store.waiting[runAtTime] = this.store.waiting[runAtTime].filter(id => id !== taskToRun.id)
		if (this.store.waiting[runAtTime].length === 0) {
			delete this.store.waiting[runAtTime]
		}
		
		// Update task with started_at time
		taskToRun.started_at = now
		this.store.tasks[taskToRun.id] = taskToRun
		
		// Add task to running queue
		if (!this.store.running[now]) {
			this.store.running[now] = []
		}
		this.store.running[now].push(taskToRun.id)
		
		// Save changes
		await this.saveTasks()
		
		if (taskToRun) debug(`< dequeue.${taskToRun.name}`)
		return taskToRun
	}

	async finishTask(task: Task, error?: TaskError) {
		if (error) {
			console.error(error)
			debug(`. error.${task.name}`)
		} else {
			debug(`. finish.${task.name}`)
		}
		
		const { started_at, id } = task
		if (!started_at) throw new Error(`Cannot finish a task that was never started: ${id}`)
		
		// Remove task from running queue
		if (this.store.running[started_at]) {
			this.store.running[started_at] = this.store.running[started_at].filter(taskId => taskId !== id)
			if (this.store.running[started_at].length === 0) {
				delete this.store.running[started_at]
			}
		}
		
		// If there's an error, add to failed queue
		if (error) {
			this.store.failed[id] = { ...task, error }
		}
		
		// Remove task from tasks store
		delete this.store.tasks[id]
		
		// Save changes
		await this.saveTasks()
	}

	private createEnqueueProxy() {
		this.enqueue = new Proxy(
			{},
			{
				get: (_, key: string) => {
					return async (args: unknown, options?: { runAt: string }) => {
						let runAt: string
						if (options?.runAt) {
							runAt = options.runAt
						} else {
							runAt = new Date().toISOString()
						}

						const task: Task = {
							id: randomId(),
							name: key as TaskName,
							args: args as QueueTaskArgs[TaskName],
							run_at: runAt,
						}
						await this.enqueueTask(task)
						return task.id
					}
				},
			}
		) as EnqueueApi
	}

	async reset() {
		this.store = {
			tasks: {},
			waiting: {},
			running: {},
			failed: {}
		}
		await this.saveTasks()
	}
}

type EnqueueApi = {
	[K in keyof QueueTaskArgs]: (
		args: QueueTaskArgs[K],
		options?: { runAt: string }
	) => Promise<string>
}

export type QueueDatabaseApi = Simplify<QueueDatabase>

================================================================================
File: services\QueueService.ts
Lines: 204
--------------------------------------------------------------------------------
import { InMemoryQueue, Job, JobOptions, JobProcessor } from './InMemoryQueue';
import { Logger } from './LoggerService';

// Queue types
export const QueueTypes = {
  IMAGE_PROCESSING: 'image-processing',
  VIDEO_PROCESSING: 'video-processing',
  AUDIO_PROCESSING: 'audio-processing',
  NOTIFICATION: 'notification'
} as const;

export type QueueTypeKey = keyof typeof QueueTypes;
export type QueueTypeValue = typeof QueueTypes[QueueTypeKey];

// Job data interfaces
export interface ImageProcessingJob {
  mediaId: string;
  filePath: string;
  userId: string;
  metadata?: Record<string, string | number | boolean>;
}

export interface VideoProcessingJob {
  mediaId: string;
  filePath: string;
  userId: string;
  options?: {
    generateHLS?: boolean;
    generateDASH?: boolean;
    quality?: ('1080p' | '720p' | '480p' | '360p' | '240p')[];
  };
  metadata?: Record<string, string | number | boolean>;
}

export interface AudioProcessingJob {
  mediaId: string;
  filePath: string;
  userId: string;
  generateWaveform?: boolean;
  metadata?: Record<string, string | number | boolean>;
}

export interface NotificationJob {
  userId: string;
  type: string;
  message: string;
  data?: Record<string, string | number | boolean>;
}

type QueueJobType = {
  [QueueTypes.IMAGE_PROCESSING]: ImageProcessingJob;
  [QueueTypes.VIDEO_PROCESSING]: VideoProcessingJob;
  [QueueTypes.AUDIO_PROCESSING]: AudioProcessingJob;
  [QueueTypes.NOTIFICATION]: NotificationJob;
};

type AllJobTypes = ImageProcessingJob | VideoProcessingJob | AudioProcessingJob | NotificationJob;

/**
 * Service for managing background job queues
 */
export class QueueService {
  private static instance: QueueService;
  private queues: Map<QueueTypeValue, InMemoryQueue<AllJobTypes>> = new Map();
  private logger: Logger;

  private constructor() {
    this.logger = new Logger('QueueService');
    
    // Initialize queues
    this.initializeQueue(QueueTypes.IMAGE_PROCESSING);
    this.initializeQueue(QueueTypes.VIDEO_PROCESSING);
    this.initializeQueue(QueueTypes.AUDIO_PROCESSING);
    this.initializeQueue(QueueTypes.NOTIFICATION);
    
    // Handle process events
    process.on('SIGTERM', () => void this.closeQueues());
    process.on('SIGINT', () => void this.closeQueues());
  }

  /**
   * Get the singleton instance
   */
  public static getInstance(): QueueService {
    if (!QueueService.instance) {
      QueueService.instance = new QueueService();
    }
    return QueueService.instance;
  }

  /**
   * Initialize a queue with the given name
   */
  private initializeQueue<K extends QueueTypeValue>(queueType: K) {
    const queue = new InMemoryQueue<QueueJobType[K]>((job) => Promise.resolve(job));
    
    // Set up event handlers
    queue.on('error', (error) => {
      this.logger.error(`Error in ${queueType} queue:`, error);
    });
    
    queue.on('failed', (job: Job<QueueJobType[K]>, error) => {
      this.logger.error(`Job ${job.id} in ${queueType} queue failed:`, error);
    });
    
    queue.on('completed', (job: Job<QueueJobType[K]>) => {
      this.logger.debug(`Job ${job.id} in ${queueType} queue completed`);
    });
    
    this.queues.set(queueType, queue as unknown as InMemoryQueue<AllJobTypes>);
    return queue;
  }

  /**
   * Get a queue by type
   */
  public getQueue<K extends QueueTypeValue>(queueType: K): InMemoryQueue<QueueJobType[K]> | undefined {
    return this.queues.get(queueType) as InMemoryQueue<QueueJobType[K]> | undefined;
  }

  /**
   * Add an image processing job to the queue
   */
  public addImageProcessingJob(
    data: ImageProcessingJob,
    options?: JobOptions
  ): Job<ImageProcessingJob> {
    const queue = this.getQueue(QueueTypes.IMAGE_PROCESSING);
    if (!queue) {
      throw new Error(`Queue ${QueueTypes.IMAGE_PROCESSING} not found`);
    }
    return queue.add(data, options);
  }

  /**
   * Add a video processing job to the queue
   */
  public addVideoProcessingJob(
    data: VideoProcessingJob,
    options?: JobOptions
  ): Job<VideoProcessingJob> {
    const queue = this.getQueue(QueueTypes.VIDEO_PROCESSING);
    if (!queue) {
      throw new Error(`Queue ${QueueTypes.VIDEO_PROCESSING} not found`);
    }
    return queue.add(data, options);
  }

  /**
   * Add an audio processing job to the queue
   */
  public addAudioProcessingJob(
    data: AudioProcessingJob,
    options?: JobOptions
  ): Job<AudioProcessingJob> {
    const queue = this.getQueue(QueueTypes.AUDIO_PROCESSING);
    if (!queue) {
      throw new Error(`Queue ${QueueTypes.AUDIO_PROCESSING} not found`);
    }
    return queue.add(data, options);
  }

  /**
   * Add a notification job to the queue
   */
  public addNotificationJob(
    data: NotificationJob,
    options?: JobOptions
  ): Job<NotificationJob> {
    const queue = this.getQueue(QueueTypes.NOTIFICATION);
    if (!queue) {
      throw new Error(`Queue ${QueueTypes.NOTIFICATION} not found`);
    }
    return queue.add(data, options);
  }

  /**
   * Register a processor for a queue
   */
  public registerProcessor<K extends QueueTypeValue>(
    queueType: K,
    processor: JobProcessor<QueueJobType[K]>
  ): void {
    const queue = this.getQueue(queueType);
    if (!queue) {
      throw new Error(`Queue ${queueType} not found`);
    }
    
    queue.process(processor);
    this.logger.info(`Processor registered for ${queueType} queue`);
  }

  /**
   * Close all queues
   */
  private async closeQueues(): Promise<void> {
    this.logger.info('Closing all queues');
    
    const closePromises = Array.from(this.queues.values()).map(queue => queue.close());
    await Promise.all(closePromises);
    
    this.logger.info('All queues closed');
  }
} 
================================================================================
File: services\ServerConfig.ts
Lines: 58
--------------------------------------------------------------------------------
// src/server/services/ServerConfig.ts
import path from 'path';

import { env } from '../config/environment';

export type ServerConfig = {
  production: boolean;
  port: number;
  domain: string;
  baseUrl: string;
  jwtSecret: string;
  corsOrigins: string[];
  queuePath: string;
  signatureSecret: Buffer;
  passwordSalt: Buffer;
  dbPath: string;
  db: {
    host: string;
    port: number;
    database: string;
    username: string;
    password: string;
  };
}

// Default fallback secrets
const DEFAULT_SIGNATURE_SECRET = "4BwkW2TpsYjWt5i6pg8jDt6AA6iz+UAFjSmIeCboLXfln81sud1aLu3jA3vCVdUyTsXFoHijg1RgZ2NNHMMpdO+Fvmsill+2dh8QFgvzhqqm8txmsmC9rkg9FnbIrYG9g7Nom17g/afg/bk7JHGBpEDgWsLZQ3537w81b7dP2HI=";
const DEFAULT_PASSWORD_SALT = "8hrqUP5KLtWI8BmSOe9dSHti2Iz2QA2cCo0Pe3YFGhE=";

// Load signature secret from env or use default
const signatureSecretString = env.NODE_ENV === 'production' 
  ? (process.env.SIGNATURE_SECRET || DEFAULT_SIGNATURE_SECRET)
  : DEFAULT_SIGNATURE_SECRET;

// Password salt for hashing
const passwordSaltString = env.NODE_ENV === 'production'
  ? (process.env.PASSWORD_SALT || DEFAULT_PASSWORD_SALT)
  : DEFAULT_PASSWORD_SALT;

export const config: ServerConfig = {
  production: env.NODE_ENV === 'production',
  port: env.PORT,
  domain: env.HOST,
  baseUrl: env.BASE_URL,
  jwtSecret: env.JWT_SECRET,
  corsOrigins: env.CORS_ORIGINS,
  queuePath: process.env.QUEUE_PATH || path.resolve(process.cwd(), "db/queue.json"),
  dbPath: process.env.DB_PATH || path.resolve(process.cwd(), "db/data.json"),
  signatureSecret: Buffer.from(signatureSecretString, "base64"),
  passwordSalt: Buffer.from(passwordSaltString, "base64"),
  db: {
    host: env.DB_HOST,
    port: env.DB_PORT,
    database: env.DB_NAME,
    username: env.DB_USER,
    password: env.DB_PASSWORD
  }
};
================================================================================
File: services\ServerEnvironment.ts
Lines: 44
--------------------------------------------------------------------------------
import { WebSocketServer } from 'ws';

import { QueueDatabase } from './QueueDatabase';

export type ServerConfig = {
	port: number;
	dbConnectionString: string;
	production: boolean;
	domain: string;
	baseUrl: string;
	corsOrigin: string | string[];
	corsOrigins: string[];
	jwtSecret: string;
	uploadDir: string;
	queuePath: string;
	signatureSecret: Buffer;
	passwordSalt: Buffer;
	dbPath: string;
	db: {
		host: string;
		port: number;
		database: string;
		username: string;
		password: string;
	};
};

export type DatabaseApi = {
	query: <T>(text: string, params?: T[]) => Promise<{ rows: T[] }>;
	getClient: () => Promise<unknown>;
};

export type PubsubApi = {
	broadcast: (key: string, value: unknown) => void;
	subscribe: (key: string, callback: (value: unknown) => void) => () => void;
};

export type ServerEnvironment = {
	config: ServerConfig;
	db: DatabaseApi;
	pubsub: PubsubApi;
	wss?: WebSocketServer;
	queue: QueueDatabase; // Add the queue property
};
================================================================================
File: services\WebsocketPubsubServer.ts
Lines: 74
--------------------------------------------------------------------------------
import type { Server } from "http"

import { WebSocketServer } from "ws"

import { ClientPubsubMessage, ServerPubsubMessage } from "../../shared/PubSubTypes"

const debug = (...args: unknown[]) => console.log("pubsub:", ...args)

export type PubsubApi = {
	publish(items: { key: string; value: unknown }[]): Promise<void>
}

// Define a type for WebSocket to avoid type errors
type SafeWebSocket = {
	on(event: string, listener: (data?: unknown) => void): void;
	send(data: string): void;
};

// TODO: sticky sessions.
export class WebsocketPubsubServer implements PubsubApi {
	private wss: WebSocketServer
	private connections = new Map<SafeWebSocket, Set<string>>()

	constructor(server: Server, onSubscribe: (this: PubsubApi, key: string) => void) {
		this.wss = new WebSocketServer({ server })

		this.wss.on("connection", (connection) => {
			const safeConnection = connection as SafeWebSocket;
			const subscriptions = new Set<string>()
			this.connections.set(safeConnection, subscriptions)

			safeConnection.on("close", () => {
				this.connections.delete(safeConnection)
			})

			safeConnection.on("message", (data) => {
				// Convert data to string safely
				const dataString: string = Buffer.isBuffer(data) 
					? data.toString('utf-8') 
					: String(data);
				const message = JSON.parse(dataString) as ClientPubsubMessage

				debug("<", message.type, message.key)

				// TODO: validate incoming data.
				if (message.type === "subscribe") {
					subscriptions.add(message.key)
					onSubscribe.call(this, message.key)
					return
				}
				if (message.type === "unsubscribe") {
					subscriptions.delete(message.key)
					return
				}
			})
		})
	}

	async publish(items: { key: string; value: unknown }[]): Promise<void> {
		return Promise.resolve().then(() => {
			for (const { key, value } of items) {
				const message: ServerPubsubMessage = { type: "update", key, value }
				debug(">", message.type, message.key, message.value)
				const data = JSON.stringify(message)

				for (const [connection, subscriptions] of this.connections.entries()) {
					if (subscriptions.has(key)) {
						connection.send(data)
					}
				}
			}
		});
	}
}

================================================================================
File: services\media\AudioProcessor.ts
Lines: 218
--------------------------------------------------------------------------------
import { promises as fsPromises } from 'fs';
import path from 'path';

import ffmpeg from 'fluent-ffmpeg';
import * as mm from 'music-metadata';

import { MediaType, ProcessingStatus, AudioMetadata } from '../../types/media.types';

import { BaseMediaProcessor, BaseProcessingResult } from './BaseMediaProcessor';

/**
 * Audio processing result interface
 */
export interface AudioProcessingResult extends BaseProcessingResult {
  waveformPath?: string;
  metadata: AudioMetadata;
}

/**
 * Audio processing options
 */
export interface AudioProcessingOptions {
  generateWaveform?: boolean;
  normalize?: boolean;
  format?: 'mp3' | 'aac' | 'ogg' | 'wav';
  bitrate?: string;
}

/**
 * Audio processor class for handling audio processing operations
 */
export class AudioProcessor extends BaseMediaProcessor {
  constructor(uploadDir: string) {
    super(path.join(uploadDir, 'audio'), 'AudioProcessor');
  }
  
  /**
   * Process an audio file
   */
  public async process(filePath: string, options?: AudioProcessingOptions): Promise<AudioProcessingResult> {
    const mediaId = this.generateFileId();
    const opts = this.getProcessingOptions(options);
    
    try {
      // Get audio metadata
      const metadata = await this.getAudioMetadata(filePath);
      
      // Create output directory
      const outputDir = path.join(this.uploadDir, mediaId);
      await this.ensureDirectoryExists(outputDir);
      
      // Process audio
      const paths: Record<string, string> = {
        original: filePath
      };
      
      // Convert to desired format if needed
      const processedPath = await this.processAudio(
        filePath,
        outputDir,
        opts
      );
      paths.processed = processedPath;
      
      // Generate waveform if requested
      let waveformPath = '';
      if (opts.generateWaveform) {
        waveformPath = await this.generateWaveform(
          processedPath,
          outputDir
        );
        paths.waveform = waveformPath;
      }
      
      return {
        mediaId,
        paths,
        waveformPath,
        metadata,
        status: ProcessingStatus.COMPLETED
      };
    } catch (error) {
      this.logger.error(`Failed to process audio: ${filePath}`, { error });
      return {
        mediaId,
        paths: { original: filePath },
        metadata: {
          duration: 0,
          format: '',
          fileSize: 0,
          mimeType: '',
          bitrate: 0
        },
        status: ProcessingStatus.FAILED
      };
    }
  }
  
  /**
   * Get the media type
   */
  public getMediaType(): MediaType {
    return MediaType.AUDIO;
  }
  
  /**
   * Get audio metadata
   */
  private async getAudioMetadata(filePath: string): Promise<AudioMetadata> {
    try {
      const metadata = await mm.parseFile(filePath);
      const fileSize = await this.getFileSize(filePath);
      
      return {
        duration: metadata.format.duration || 0,
        format: metadata.format.container || '',
        fileSize,
        mimeType: `audio/${metadata.format.container || 'mpeg'}`,
        bitrate: metadata.format.bitrate || 0,
        sampleRate: metadata.format.sampleRate,
        channels: metadata.format.numberOfChannels,
        codec: metadata.format.codec,
        title: metadata.common.title,
        artist: metadata.common.artist,
        album: metadata.common.album,
        genre: metadata.common.genre ? metadata.common.genre[0] : undefined,
        year: metadata.common.year
      };
    } catch (error) {
      this.logger.error(`Failed to get audio metadata: ${filePath}`, { error });
      throw error;
    }
  }
  
  /**
   * Process audio file (convert, normalize, etc.)
   */
  private processAudio(
    inputPath: string,
    outputDir: string,
    options: Required<AudioProcessingOptions>
  ): Promise<string> {
    return new Promise((resolve, reject) => {
      const outputFilename = `processed.${options.format}`;
      const outputPath = path.join(outputDir, outputFilename);
      
      let command = ffmpeg(inputPath);
      
      // Apply normalization if requested
      if (options.normalize) {
        command = command.audioFilters('loudnorm');
      }
      
      // Set output format and bitrate
      command = command
        .audioBitrate(options.bitrate)
        .format(options.format);
      
      command
        .output(outputPath)
        .on('error', reject)
        .on('end', () => resolve(outputPath))
        .run();
    });
  }
  
  /**
   * Generate a waveform visualization
   */
  private generateWaveform(
    inputPath: string,
    outputDir: string
  ): Promise<string> {
    return new Promise((resolve, reject) => {
      const outputPath = path.join(outputDir, 'waveform.json');
      
      ffmpeg(inputPath)
        .outputOptions([
          '-filter_complex',
          'showwavespic=s=1000x200:colors=#3498db',
          '-frames:v', '1'
        ])
        .output(path.join(outputDir, 'waveform.png'))
        .on('error', reject)
        .on('end', () => {
          // Generate a simplified JSON representation of the waveform
          // This would typically involve analyzing the waveform image
          // For simplicity, we're just creating a placeholder
          const waveformData = {
            samples: 1000,
            channels: 1,
            data: Array(100).fill(0).map(() => Math.random())
          };
          
          fsPromises.writeFile(
            outputPath,
            JSON.stringify(waveformData),
            'utf8'
          )
            .then(() => resolve(outputPath))
            .catch(error => reject(error));
        })
        .run();
    });
  }
  
  /**
   * Get processing options with defaults
   */
  private getProcessingOptions(options?: AudioProcessingOptions): Required<AudioProcessingOptions> {
    return {
      generateWaveform: options?.generateWaveform ?? true,
      normalize: options?.normalize ?? true,
      format: options?.format ?? 'mp3',
      bitrate: options?.bitrate ?? '192k'
    };
  }
} 
================================================================================
File: services\media\BaseMediaProcessor.ts
Lines: 109
--------------------------------------------------------------------------------
import crypto from 'crypto';
import { promises as fsPromises } from 'fs';
import path from 'path';

import { MediaType, ProcessingStatus } from '../../types/media.types';
import { Logger } from '../LoggerService';

/**
 * Common metadata interface for all media types
 */
export interface BaseMediaMetadata {
  fileSize: number;
  mimeType: string;
  format: string;
  duration?: number;
}

/**
 * Base result interface for all media processing operations
 */
export interface BaseProcessingResult {
  mediaId: string;
  paths: Record<string, string>;
  metadata: BaseMediaMetadata;
  status: ProcessingStatus;
}

/**
 * Base abstract class for all media processors
 */
export abstract class BaseMediaProcessor {
  protected logger: Logger;
  protected uploadDir: string;
  
  constructor(uploadDir: string, loggerName: string) {
    this.uploadDir = uploadDir;
    this.logger = new Logger(loggerName);
    
    // Ensure upload directory exists
    void this.ensureDirectoryExists(uploadDir);
  }
  
  /**
   * Generate a unique file ID
   */
  protected generateFileId(): string {
    return crypto.randomUUID();
  }
  
  /**
   * Generate a unique filename with a specific extension
   */
  protected generateFilename(originalName: string, extension?: string): string {
    const fileId = this.generateFileId();
    const ext = extension || path.extname(originalName);
    return `${fileId}${ext}`;
  }
  
  /**
   * Ensure a directory exists
   */
  protected async ensureDirectoryExists(dirPath: string): Promise<void> {
    try {
      await fsPromises.mkdir(dirPath, { recursive: true });
    } catch (error) {
      this.logger.error(`Failed to create directory: ${dirPath}`, { error });
      throw new Error(`Failed to create directory: ${dirPath}`);
    }
  }
  
  /**
   * Get file size in bytes
   */
  protected async getFileSize(filePath: string): Promise<number> {
    try {
      const stats = await fsPromises.stat(filePath);
      return stats.size;
    } catch (error) {
      this.logger.error(`Failed to get file size: ${filePath}`, { error });
      return 0;
    }
  }
  
  /**
   * Delete a file if it exists
   */
  protected async deleteFileIfExists(filePath: string): Promise<void> {
    try {
      await fsPromises.unlink(filePath);
    } catch (error) {
      // Ignore if file doesn't exist
      if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {
        this.logger.error(`Failed to delete file: ${filePath}`, { error });
      }
    }
  }
  
  /**
   * Abstract method to process a media file
   * @param filePath Path to the original file
   * @param options Processing options
   */
  public abstract process(filePath: string, options?: Record<string, unknown>): Promise<BaseProcessingResult>;
  
  /**
   * Abstract method to get the media type
   */
  public abstract getMediaType(): MediaType;
} 
================================================================================
File: services\media\ImageProcessor.ts
Lines: 204
--------------------------------------------------------------------------------
import path from 'path';

import sharp from 'sharp';

import { MediaType, ProcessingStatus, ImageSize, ImageMetadata } from '../../types/media.types';

import { BaseMediaProcessor, BaseProcessingResult } from './BaseMediaProcessor';

/**
 * Image processing result interface
 */
export interface ImageProcessingResult extends BaseProcessingResult {
  dimensions: ImageSize;
  metadata: ImageMetadata;
}

/**
 * Image processing options
 */
export interface ImageProcessingOptions {
  quality?: number;
  format?: 'jpeg' | 'png' | 'webp';
  generateThumbnails?: boolean;
  maxWidth?: number;
  maxHeight?: number;
  preserveAspectRatio?: boolean;
}

/**
 * Default image sizes for different variants
 */
const DEFAULT_IMAGE_SIZES = {
  original: { width: 2048, height: 2048 },
  large: { width: 1024, height: 1024 },
  medium: { width: 512, height: 512 },
  small: { width: 256, height: 256 },
  thumbnail: { width: 128, height: 128 }
};

/**
 * Image processor class for handling image processing operations
 */
export class ImageProcessor extends BaseMediaProcessor {
  private readonly imageSizes: Record<string, ImageSize>;
  
  constructor(uploadDir: string, imageSizes?: Record<string, ImageSize>) {
    super(path.join(uploadDir, 'images'), 'ImageProcessor');
    this.imageSizes = imageSizes || DEFAULT_IMAGE_SIZES;
  }
  
  /**
   * Process an image file
   */
  public async process(filePath: string, options?: ImageProcessingOptions): Promise<ImageProcessingResult> {
    const mediaId = this.generateFileId();
    const opts = this.getProcessingOptions(options);
    
    try {
      // Get image metadata
      const metadata = await this.getImageMetadata(filePath);
      
      // Create output directory
      const outputDir = path.join(this.uploadDir, mediaId);
      await this.ensureDirectoryExists(outputDir);
      
      // Process image variants
      const paths: Record<string, string> = {};
      const sizesToProcess = opts.generateThumbnails 
        ? Object.keys(this.imageSizes) 
        : ['original'];
      
      for (const size of sizesToProcess) {
        const sizeConfig = this.imageSizes[size];
        const outputPath = await this.processImageVariant(
          filePath,
          outputDir,
          size,
          sizeConfig,
          opts
        );
        paths[size] = outputPath;
      }
      
      return {
        mediaId,
        paths,
        dimensions: {
          width: metadata.width,
          height: metadata.height
        },
        metadata,
        status: ProcessingStatus.COMPLETED
      };
    } catch (error) {
      this.logger.error(`Failed to process image: ${filePath}`, { error });
      return {
        mediaId,
        paths: {},
        dimensions: { width: 0, height: 0 },
        metadata: {
          width: 0,
          height: 0,
          format: '',
          fileSize: 0,
          mimeType: ''
        },
        status: ProcessingStatus.FAILED
      };
    }
  }
  
  /**
   * Get the media type
   */
  public getMediaType(): MediaType {
    return MediaType.IMAGE;
  }
  
  /**
   * Get image metadata
   */
  private async getImageMetadata(filePath: string): Promise<ImageMetadata> {
    const image = sharp(filePath);
    const metadata = await image.metadata();
    const fileSize = await this.getFileSize(filePath);
    
    return {
      width: metadata.width || 0,
      height: metadata.height || 0,
      format: metadata.format || '',
      fileSize,
      mimeType: `image/${metadata.format}`,
      hasAlpha: metadata.hasAlpha as boolean | undefined,
      colorSpace: metadata.space as string | undefined
    };
  }
  
  /**
   * Process an image variant
   */
  private async processImageVariant(
    inputPath: string,
    outputDir: string,
    sizeName: string,
    sizeConfig: ImageSize,
    options: ImageProcessingOptions
  ): Promise<string> {
    const { format = 'jpeg', quality = 80 } = options;
    const outputFilename = `${sizeName}.${format}`;
    const outputPath = path.join(outputDir, outputFilename);
    
    let processor = sharp(inputPath);
    
    // Resize if needed
    if (sizeName !== 'original') {
      processor = processor.resize({
        width: sizeConfig.width,
        height: sizeConfig.height,
        fit: options.preserveAspectRatio ? 'inside' : 'cover',
        withoutEnlargement: true
      });
    } else if (options.maxWidth || options.maxHeight) {
      // For original, only resize if it exceeds max dimensions
      processor = processor.resize({
        width: options.maxWidth,
        height: options.maxHeight,
        fit: 'inside',
        withoutEnlargement: true
      });
    }
    
    // Set output format
    switch (format) {
      case 'jpeg':
        processor = processor.jpeg({ quality });
        break;
      case 'png':
        processor = processor.png({ quality });
        break;
      case 'webp':
        processor = processor.webp({ quality });
        break;
    }
    
    // Save the processed image
    await processor.toFile(outputPath);
    
    return outputPath;
  }
  
  /**
   * Get processing options with defaults
   */
  private getProcessingOptions(options?: ImageProcessingOptions): Required<ImageProcessingOptions> {
    return {
      quality: options?.quality ?? 80,
      format: options?.format ?? 'jpeg',
      generateThumbnails: options?.generateThumbnails ?? true,
      maxWidth: options?.maxWidth ?? 2048,
      maxHeight: options?.maxHeight ?? 2048,
      preserveAspectRatio: options?.preserveAspectRatio ?? true
    };
  }
} 
================================================================================
File: services\media\index.ts
Lines: 13
--------------------------------------------------------------------------------
// Base classes and interfaces
export * from './BaseMediaProcessor';

// Specialized processors
export * from './ImageProcessor';
export * from './VideoProcessor';
export * from './AudioProcessor';

// Main service
export * from './MediaProcessingService';

// Re-export types
export * from '../../types/media.types'; 
================================================================================
File: services\media\MediaProcessingService.ts
Lines: 167
--------------------------------------------------------------------------------
import { promises as fsPromises } from 'fs';
import path from 'path';

import { MediaType } from '../../types/media.types';
import { Logger } from '../LoggerService';

import { AudioProcessor, AudioProcessingOptions, AudioProcessingResult } from './AudioProcessor';
import { BaseMediaProcessor } from './BaseMediaProcessor';
import { ImageProcessor, ImageProcessingOptions, ImageProcessingResult } from './ImageProcessor';
import { VideoProcessor, VideoProcessingOptions, VideoProcessingResult } from './VideoProcessor';
/**
 * Media processing options
 */
export type MediaProcessingOptions = 
  | { type: MediaType.IMAGE; options?: ImageProcessingOptions }
  | { type: MediaType.VIDEO; options?: VideoProcessingOptions }
  | { type: MediaType.AUDIO; options?: AudioProcessingOptions };

/**
 * Media processing result
 */
export type MediaProcessingResult = 
  | ImageProcessingResult
  | VideoProcessingResult
  | AudioProcessingResult;

/**
 * Unified media processing service that delegates to specialized processors
 * 
 * @example
 * ```typescript
 * const mediaService = MediaProcessingService.getInstance();
 * const result = await mediaService.processMedia(filePath, MediaType.AUDIO);
 * ```
 */
export class MediaProcessingService {
  private static instance: MediaProcessingService | null = null;
  private readonly logger: Logger;
  private readonly uploadDir: string;
  private readonly processors: Map<MediaType, BaseMediaProcessor>;
  
  private constructor(uploadDir: string) {
    this.logger = new Logger('MediaProcessingService');
    this.uploadDir = uploadDir;
    this.processors = new Map();
    
    // Initialize processors
    this.processors.set(MediaType.IMAGE, new ImageProcessor(uploadDir));
    this.processors.set(MediaType.VIDEO, new VideoProcessor(uploadDir));
    this.processors.set(MediaType.AUDIO, new AudioProcessor(uploadDir));
    
    this.logger.info('MediaProcessingService initialized with processors for all media types');
  }
  
  /**
   * Get the singleton instance of the MediaProcessingService
   * @param uploadDir Directory to store processed media files
   */
  public static getInstance(uploadDir = 'uploads'): MediaProcessingService {
    if (!MediaProcessingService.instance) {
      MediaProcessingService.instance = new MediaProcessingService(uploadDir);
    }
    return MediaProcessingService.instance;
  }
  
  /**
   * Process a media file based on its type
   * @param filePath Path to the media file
   * @param mediaType Type of media (image, video, audio)
   * @param options Processing options
   */
  public async processMedia(
    filePath: string,
    mediaType: MediaType,
    options?: Record<string, unknown>
  ): Promise<MediaProcessingResult> {
    const processor = this.getProcessor(mediaType);
    
    if (!processor) {
      throw new Error(`No processor available for media type: ${mediaType}`);
    }
    
    try {
      await this.ensureUploadDirectory();
      const result = await processor.process(filePath, options);
      return result as MediaProcessingResult;
    } catch (error) {
      this.logger.error(`Failed to process ${mediaType} file: ${filePath}`, { error });
      throw error;
    }
  }
  
  /**
   * Process an image file
   * @param filePath Path to the image file
   * @param options Image processing options
   */
  public async processImage(
    filePath: string,
    options?: ImageProcessingOptions
  ): Promise<ImageProcessingResult> {
    return this.processMedia(filePath, MediaType.IMAGE, options as Record<string, unknown>) as Promise<ImageProcessingResult>;
  }
  
  /**
   * Process a video file
   * @param filePath Path to the video file
   * @param options Video processing options
   */
  public async processVideo(
    filePath: string,
    options?: VideoProcessingOptions
  ): Promise<VideoProcessingResult> {
    return this.processMedia(filePath, MediaType.VIDEO, options as Record<string, unknown>) as Promise<VideoProcessingResult>;
  }
  
  /**
   * Process an audio file
   * @param filePath Path to the audio file
   * @param options Audio processing options
   */
  public async processAudio(
    filePath: string,
    options?: AudioProcessingOptions
  ): Promise<AudioProcessingResult> {
    return this.processMedia(filePath, MediaType.AUDIO, options as Record<string, unknown>) as Promise<AudioProcessingResult>;
  }
  
  /**
   * Detect the media type based on file extension
   * @param filePath Path to the media file
   */
  public detectMediaType(filePath: string): MediaType {
    const ext = path.extname(filePath).toLowerCase();
    
    // Image extensions
    if (['.jpg', '.jpeg', '.png', '.gif', '.webp', '.svg', '.bmp'].includes(ext)) {
      return MediaType.IMAGE;
    }
    
    // Video extensions
    if (['.mp4', '.webm', '.mov', '.avi', '.mkv', '.flv', '.wmv'].includes(ext)) {
      return MediaType.VIDEO;
    }
    
    // Audio extensions
    if (['.mp3', '.wav', '.ogg', '.flac', '.aac', '.m4a'].includes(ext)) {
      return MediaType.AUDIO;
    }
    
    throw new Error(`Unsupported file type: ${ext}`);
  }
  
  /**
   * Get the appropriate processor for a media type
   */
  private getProcessor(mediaType: MediaType): BaseMediaProcessor | undefined {
    return this.processors.get(mediaType);
  }
  
  /**
   * Ensure the upload directory exists
   */
  private async ensureUploadDirectory(): Promise<void> {
    await fsPromises.mkdir(this.uploadDir, { recursive: true });
  }
} 
================================================================================
File: services\media\VideoProcessor.ts
Lines: 303
--------------------------------------------------------------------------------
import path from 'path';

import ffmpeg from 'fluent-ffmpeg';

import { MediaType, ProcessingStatus, VideoMetadata } from '../../types/media.types';

import { BaseMediaProcessor, BaseProcessingResult } from './BaseMediaProcessor';

/**
 * Video processing result interface
 */
export interface VideoProcessingResult extends BaseProcessingResult {
  thumbnailPath: string;
  hlsPath?: string;
  dashPath?: string;
  metadata: VideoMetadata;
}

/**
 * Video processing options
 */
export interface VideoProcessingOptions {
  generateHLS?: boolean;
  generateDASH?: boolean;
  generateThumbnail?: boolean;
  thumbnailTime?: number;
  quality?: 'low' | 'medium' | 'high';
  maxWidth?: number;
  maxHeight?: number;
}

/**
 * Video quality presets
 */
const QUALITY_PRESETS = {
  low: {
    videoBitrate: '800k',
    audioBitrate: '96k',
    maxWidth: 640,
    maxHeight: 360
  },
  medium: {
    videoBitrate: '1500k',
    audioBitrate: '128k',
    maxWidth: 1280,
    maxHeight: 720
  },
  high: {
    videoBitrate: '3000k',
    audioBitrate: '192k',
    maxWidth: 1920,
    maxHeight: 1080
  }
};

/**
 * Video processor class for handling video processing operations
 */
export class VideoProcessor extends BaseMediaProcessor {
  constructor(uploadDir: string) {
    super(path.join(uploadDir, 'videos'), 'VideoProcessor');
  }
  
  /**
   * Process a video file
   */
  public async process(filePath: string, options?: VideoProcessingOptions): Promise<VideoProcessingResult> {
    const mediaId = this.generateFileId();
    const opts = this.getProcessingOptions(options);
    
    try {
      // Get video metadata
      const metadata = await this.getVideoMetadata(filePath);
      
      // Create output directory
      const outputDir = path.join(this.uploadDir, mediaId);
      await this.ensureDirectoryExists(outputDir);
      
      // Process video
      const paths: Record<string, string> = {
        original: filePath
      };
      
      // Generate thumbnail
      let thumbnailPath = '';
      if (opts.generateThumbnail) {
        thumbnailPath = await this.generateThumbnail(
          filePath,
          outputDir,
          opts.thumbnailTime
        );
        paths.thumbnail = thumbnailPath;
      }
      
      // Generate HLS
      if (opts.generateHLS) {
        const hlsPath = await this.generateHLS(
          filePath,
          outputDir,
          opts
        );
        paths.hls = hlsPath;
      }
      
      // Generate DASH
      if (opts.generateDASH) {
        const dashPath = await this.generateDASH(
          filePath,
          outputDir,
          opts
        );
        paths.dash = dashPath;
      }
      
      return {
        mediaId,
        paths,
        thumbnailPath,
        hlsPath: paths.hls,
        dashPath: paths.dash,
        metadata,
        status: ProcessingStatus.COMPLETED
      };
    } catch (error) {
      this.logger.error(`Failed to process video: ${filePath}`, { error });
      return {
        mediaId,
        paths: { original: filePath },
        thumbnailPath: '',
        metadata: {
          width: 0,
          height: 0,
          duration: 0,
          format: '',
          fileSize: 0,
          mimeType: '',
          bitrate: 0
        },
        status: ProcessingStatus.FAILED
      };
    }
  }
  
  /**
   * Get the media type
   */
  public getMediaType(): MediaType {
    return MediaType.VIDEO;
  }
  
  /**
   * Get video metadata
   */
  private getVideoMetadata(filePath: string): Promise<VideoMetadata> {
    return new Promise((resolve, reject) => {
      ffmpeg.ffprobe(filePath, (err, metadata) => {
        if (err) {
          return reject(err);
        }
        
        const videoStream = metadata.streams.find(stream => stream.codec_type === 'video');
        if (!videoStream) {
          return reject(new Error('No video stream found'));
        }
        
        this.getFileSize(filePath)
          .then(fileSize => {
            resolve({
              width: videoStream.width || 0,
              height: videoStream.height || 0,
              duration: metadata.format.duration || 0,
              format: metadata.format.format_name || '',
              fileSize,
              mimeType: `video/${metadata.format.format_name}`,
              bitrate: parseInt(metadata.format.bit_rate?.toString() || '0', 10),
              fps: videoStream.r_frame_rate && typeof videoStream.r_frame_rate === 'string'
                ? Number((videoStream.r_frame_rate.split('/').map(Number).reduce((a, b) => a / b)).toFixed(2))
                : undefined,
              codec: videoStream.codec_name
            });
          })
          .catch(reject);
      });
    });
  }
  
  /**
   * Generate a thumbnail from a video
   */
  private generateThumbnail(
    inputPath: string,
    outputDir: string,
    thumbnailTime?: number
  ): Promise<string> {
    return new Promise((resolve, reject) => {
      const outputPath = path.join(outputDir, 'thumbnail.jpg');
      
      ffmpeg(inputPath)
        .on('error', reject)
        .screenshots({
          timestamps: [thumbnailTime || 1],
          filename: 'thumbnail.jpg',
          folder: outputDir,
          size: '320x240'
        })
        .on('end', () => resolve(outputPath));
    });
  }
  
  /**
   * Generate HLS (HTTP Live Streaming) files
   */
  private generateHLS(
    inputPath: string,
    outputDir: string,
    options: Required<VideoProcessingOptions>
  ): Promise<string> {
    return new Promise((resolve, reject) => {
      const hlsDir = path.join(outputDir, 'hls');
      const playlistPath = path.join(hlsDir, 'playlist.m3u8');
      
      // Ensure HLS directory exists
      this.ensureDirectoryExists(hlsDir)
        .then(() => {
          const qualityPreset = QUALITY_PRESETS[options.quality];
          
          ffmpeg(inputPath)
            .outputOptions([
              '-profile:v main',
              '-c:v h264',
              '-c:a aac',
              `-b:v ${qualityPreset.videoBitrate}`,
              `-b:a ${qualityPreset.audioBitrate}`,
              '-f hls',
              '-hls_time 10',
              '-hls_playlist_type vod',
              '-hls_segment_filename',
              path.join(hlsDir, 'segment_%03d.ts')
            ])
            .output(playlistPath)
            .on('error', reject)
            .on('end', () => resolve(playlistPath))
            .run();
        })
        .catch(reject);
    });
  }
  
  /**
   * Generate DASH (Dynamic Adaptive Streaming over HTTP) files
   */
  private generateDASH(
    inputPath: string,
    outputDir: string,
    options: Required<VideoProcessingOptions>
  ): Promise<string> {
    return new Promise((resolve, reject) => {
      const dashDir = path.join(outputDir, 'dash');
      const manifestPath = path.join(dashDir, 'manifest.mpd');
      
      // Ensure DASH directory exists
      this.ensureDirectoryExists(dashDir)
        .then(() => {
          const qualityPreset = QUALITY_PRESETS[options.quality];
          
          ffmpeg(inputPath)
            .outputOptions([
              '-profile:v main',
              '-c:v libx264',
              '-c:a aac',
              `-b:v ${qualityPreset.videoBitrate}`,
              `-b:a ${qualityPreset.audioBitrate}`,
              '-f dash',
              '-use_timeline 1',
              '-use_template 1',
              '-seg_duration 4',
              '-init_seg_name init-stream$RepresentationID$.m4s',
              '-media_seg_name chunk-stream$RepresentationID$-$Number%05d$.m4s'
            ])
            .output(manifestPath)
            .on('error', reject)
            .on('end', () => resolve(manifestPath))
            .run();
        })
        .catch(reject);
    });
  }
  
  /**
   * Get processing options with defaults
   */
  private getProcessingOptions(options?: VideoProcessingOptions): Required<VideoProcessingOptions> {
    return {
      generateHLS: options?.generateHLS ?? true,
      generateDASH: options?.generateDASH ?? false,
      generateThumbnail: options?.generateThumbnail ?? true,
      thumbnailTime: options?.thumbnailTime ?? 1,
      quality: options?.quality ?? 'medium',
      maxWidth: options?.maxWidth ?? 1920,
      maxHeight: options?.maxHeight ?? 1080
    };
  }
} 
================================================================================
File: tasks\autoindex.ts
Lines: 7
--------------------------------------------------------------------------------
/* WARNING: this file is generated! */

import * as followup from "./followup"

export {
	followup,
}

================================================================================
File: tasks\followup.ts
Lines: 17
--------------------------------------------------------------------------------
/*

This Task is a template.

*/

// This task can be enqueued and run in the background by enqueuing on the QueueDatabase.
//
// environment.queue.enqueue({
// 	id: randomId(),
// 	name: "followup",
// 	args: {message: "Hey!"},
// 	run_at: new Date().toISOString()
// })
export function followup(args: { message: string }) {
	console.log("Running followup task: " + args.message)
}

================================================================================
File: types\express.d.ts
Lines: 14
--------------------------------------------------------------------------------
import { User } from '../models';

declare module 'express' {
  interface Request {
    user?: User;
    token?: string;
    cookies?: {
      refreshToken?: string;
      [key: string]: string | undefined;
    };
  }
}

export {};
================================================================================
File: types\index.ts
Lines: 5
--------------------------------------------------------------------------------
// Re-export all media types to ensure consistent usage
export * from './media.types';

// Add any other shared types here
export * from './request.types'; 
================================================================================
File: types\media.types.ts
Lines: 88
--------------------------------------------------------------------------------
/**
 * Media types supported by the application
 */
export enum MediaType {
  IMAGE = 'image',
  VIDEO = 'video',
  AUDIO = 'audio',
  DOCUMENT = 'document'
}

/**
 * Processing status for media files
 */
export enum ProcessingStatus {
  PENDING = 'pending',
  PROCESSING = 'processing',
  COMPLETED = 'completed',
  FAILED = 'failed'
}

/**
 * Image size interface
 */
export interface ImageSize {
  width: number;
  height: number;
}

/**
 * Image metadata interface
 */
export interface ImageMetadata {
  width: number;
  height: number;
  format: string;
  fileSize: number;
  mimeType: string;
  hasAlpha?: boolean;
  colorSpace?: string;
}

/**
 * Video metadata interface
 */
export interface VideoMetadata {
  width: number;
  height: number;
  duration: number;
  format: string;
  fileSize: number;
  mimeType: string;
  bitrate: number;
  fps?: number;
  codec?: string;
}

/**
 * Audio metadata interface
 */
export interface AudioMetadata {
  duration: number;
  format: string;
  fileSize: number;
  mimeType: string;
  bitrate: number;
  sampleRate?: number;
  channels?: number;
  codec?: string;
  title?: string;
  artist?: string;
  album?: string;
  genre?: string;
  year?: number;
}

/**
 * Document metadata interface
 */
export interface DocumentMetadata {
  format: string;
  fileSize: number;
  mimeType: string;
  pageCount?: number;
  title?: string;
  author?: string;
  createdAt?: Date;
  modifiedAt?: Date;
} 
================================================================================
File: types\request.types.ts
Lines: 53
--------------------------------------------------------------------------------
import { Request } from 'express';

/**
 * Interface for authenticated requests with user information
 */
export interface AuthenticatedRequest extends Request {
  user?: {
    id: string;
    role?: string;
    [key: string]: unknown;
  };
  token?: string;
}

/**
 * Interface for authenticated requests with user ID param
 */
export interface UserParamRequest extends AuthenticatedRequest {
  params: {
    userId: string;
    [key: string]: string;
  };
}

/**
 * Interface for authenticated requests with post ID param
 */
export interface PostParamRequest extends AuthenticatedRequest {
  params: {
    postId: string;
    [key: string]: string;
  };
}

/**
 * Interface for authenticated requests with comment ID param
 */
export interface CommentParamRequest extends AuthenticatedRequest {
  params: {
    commentId: string;
    [key: string]: string;
  };
}

/**
 * Interface for requests with file uploads
 */
export interface FileUploadRequest extends AuthenticatedRequest {
  file?: Express.Multer.File;
  files?: {
    [fieldname: string]: Express.Multer.File[];
  };
} 
================================================================================
File: utils\validation.ts
Lines: 4
--------------------------------------------------------------------------------
export const isEmail = (value: string): boolean => {
  const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
  return emailRegex.test(value);
}; 
================================================================================
File: validators\auth.validator.ts
Lines: 77
--------------------------------------------------------------------------------
// src/server/validators/auth.validator.ts
import { z } from 'zod';

// Register validation schema
export const registerSchema = z.object({
  username: z.string()
    .min(3, 'Username must be at least 3 characters')
    .max(30, 'Username cannot exceed 30 characters')
    .regex(/^[a-zA-Z0-9_-]+$/, 'Username can only contain letters, numbers, underscores, and hyphens'),
  email: z.string()
    .email('Invalid email address'),
  password: z.string()
    .min(8, 'Password must be at least 8 characters'),
  firstName: z.string()
    .min(1, 'First name is required')
    .max(100, 'First name cannot exceed 100 characters'),
  lastName: z.string()
    .min(1, 'Last name is required')
    .max(100, 'Last name cannot exceed 100 characters'),
  displayName: z.string()
    .optional()
});

// Login validation schema
export const loginSchema = z.object({
  email: z.string()
    .email('Invalid email format'),
  password: z.string()
    .min(8, 'Password must be at least 8 characters'),
});

// Refresh token validation schema
export const refreshTokenSchema = z.object({
  refreshToken: z.string()
    .min(1, 'Refresh token is required'),
});

// Email validation schema for resend confirmation
export const emailSchema = z.object({
  email: z.string()
    .email('Invalid email format')
});

// Update profile validation schema
export const updateProfileSchema = z.object({
  username: z.string()
    .min(3, 'Username must be at least 3 characters')
    .regex(/^[a-zA-Z0-9_-]+$/, 'Username can only contain letters, numbers, underscores, and hyphens'),
  bio: z.string()
    .max(500, 'Bio must not exceed 500 characters')
    .optional(),
  avatar: z.string()
    .url('Avatar must be a valid URL')
    .optional(),
});

// Change password validation schema
export const changePasswordSchema = z.object({
  currentPassword: z.string()
    .min(1, 'Current password is required'),
  newPassword: z.string()
    .min(8, 'New password must be at least 8 characters'),
});

// Two-factor authentication verification schema
export const twoFactorVerifySchema = z.object({
  code: z.string()
    .length(6, 'Code must be exactly 6 characters'),
});

// Two-factor authentication enable schema
export const twoFactorEnableSchema = z.object({
  secret: z.string()
    .min(1, 'Secret is required'),
  code: z.string()
    .length(6, 'Code must be exactly 6 characters'),
});
================================================================================
File: validators\custom-social.validator.ts
Lines: 134
--------------------------------------------------------------------------------
import * as t from '../../shared/dataTypes';

// Helper for string validation with min/max length and regex
const createStringValidator = (
  minLength?: number,
  maxLength?: number,
  pattern?: RegExp,
  patternMessage?: string,
  isEmail?: boolean,
  isUrl?: boolean
) => {
  // Create a custom validator with all the constraints
  return t.custom<string>((value) => {
    if (typeof value !== 'string') {
      throw new Error('Value must be a string');
    }
    
    if (minLength !== undefined && value.length < minLength) {
      throw new Error(`Must be at least ${minLength} characters`);
    }
    
    if (maxLength !== undefined && value.length > maxLength) {
      throw new Error(`Cannot exceed ${maxLength} characters`);
    }
    
    if (pattern !== undefined && !pattern.test(value)) {
      throw new Error(patternMessage || 'Invalid format');
    }
    
    if (isEmail) {
      const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
      if (!emailRegex.test(value)) {
        throw new Error('Invalid email address');
      }
    }
    
    if (isUrl) {
      try {
        new URL(value);
      } catch {
        throw new Error('Invalid URL');
      }
    }
    
    return true;
  });
};

// UUID validator helper
const uuidValidator = t.custom<string>((value) => {
  if (typeof value !== 'string') {
    throw new Error('Value must be a string');
  }
  
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
  if (!uuidRegex.test(value)) {
    throw new Error('Invalid UUID format');
  }
  
  return true;
});

// Enum validator helper
const createEnumValidator = <T extends string>(allowedValues: T[]) => {
  return t.custom<T>((value) => {
    if (typeof value !== 'string') {
      throw new Error('Value must be a string');
    }
    
    if (!allowedValues.includes(value as T)) {
      throw new Error(`Value must be one of: ${allowedValues.join(', ')}`);
    }
    
    return true;
  });
};

// Media type validator
const mediaTypeValidator = createEnumValidator(['image', 'video', 'audio']);

// Post creation schema
export const createPostSchema = t.object({
  content: createStringValidator(1, 2000, undefined, 'Post content is required'),
  media: t.optional(t.object({
    type: mediaTypeValidator,
    url: createStringValidator(undefined, undefined, undefined, undefined, false, true),
    thumbnail: t.optional(createStringValidator(undefined, undefined, undefined, undefined, false, true))
  }))
});

// Post ID param schema
export const postIdParamSchema = t.object({
  postId: uuidValidator
});

// Comment creation schema
export const createCommentSchema = t.object({
  content: createStringValidator(1, 1000, undefined, 'Comment content is required')
});

// Comment ID param schema
export const commentIdParamSchema = t.object({
  commentId: uuidValidator
});

// Reply to comment schema
export const replyToCommentSchema = t.object({
  content: createStringValidator(1, 1000, undefined, 'Reply content is required')
});

// User ID param schema
export const userIdParamSchema = t.object({
  userId: uuidValidator
});

// Number string validator
const numberStringValidator = createStringValidator(
  undefined, 
  undefined, 
  /^\d+$/, 
  'Must be a number'
);

// Feed query schema
export const feedQuerySchema = t.object({
  offset: t.optional(numberStringValidator),
  limit: t.optional(numberStringValidator)
});

// Get comments query schema
export const getCommentsQuerySchema = t.object({
  offset: t.optional(numberStringValidator),
  limit: t.optional(numberStringValidator)
}); 
================================================================================
File: validators\social.validator.ts
Lines: 54
--------------------------------------------------------------------------------
import { z } from 'zod';

// Post creation schema
export const createPostSchema = z.object({
  content: z.string()
    .min(1, 'Post content is required')
    .max(2000, 'Post content cannot exceed 2000 characters'),
  media: z.object({
    type: z.enum(['image', 'video', 'audio']),
    url: z.string().url('Media URL must be a valid URL'),
    thumbnail: z.string().url('Thumbnail URL must be a valid URL').optional(),
  }).optional(),
});

// Post ID param schema
export const postIdParamSchema = z.object({
  postId: z.string().uuid('Invalid post ID format'),
});

// Comment creation schema
export const createCommentSchema = z.object({
  content: z.string()
    .min(1, 'Comment content is required')
    .max(1000, 'Comment content cannot exceed 1000 characters'),
});

// Comment ID param schema
export const commentIdParamSchema = z.object({
  commentId: z.string().uuid('Invalid comment ID format'),
});

// Reply to comment schema
export const replyToCommentSchema = z.object({
  content: z.string()
    .min(1, 'Reply content is required')
    .max(1000, 'Reply content cannot exceed 1000 characters'),
});

// User ID param schema
export const userIdParamSchema = z.object({
  userId: z.string().uuid('Invalid user ID format'),
});

// Feed query schema
export const feedQuerySchema = z.object({
  offset: z.string().regex(/^\d+$/, 'Offset must be a number').optional(),
  limit: z.string().regex(/^\d+$/, 'Limit must be a number').optional(),
});

// Get comments query schema
export const getCommentsQuerySchema = z.object({
  offset: z.string().regex(/^\d+$/, 'Offset must be a number').optional(),
  limit: z.string().regex(/^\d+$/, 'Limit must be a number').optional(),
}); 