// SUMMARY FOR: infrastructure
// Total files: 82
// Total lines of code: 15421
// File extensions included: .ts, .js, .tsx, .jsx

// DIRECTORY STRUCTURE:
// └── infrastructure
//     ├── cache
//     │   ├── CacheService.ts
//     │   ├── ICacheService.ts
//     │   ├── index.ts
//     │   └── startupHooks.ts
//     ├── config
//     │   ├── .env
//     │   │   ├── .env.development
//     │   │   ├── .env.production
//     │   │   └── .env.test
//     │   ├── ConfigSchema.ts
//     │   ├── ConfigService.ts
//     │   ├── Env.ts
//     │   ├── IConfigService.ts
//     │   ├── domain
//     │   │   ├── DatabaseConfig.ts
//     │   │   ├── EmailConfig.ts
//     │   │   ├── SecurityConfig.ts
//     │   │   ├── ServerConfig.ts
//     │   │   ├── StorageConfig.ts
//     │   │   └── index.ts
//     │   ├── environments.ts
//     │   ├── index.ts
//     │   └── secrets
//     │       ├── EnvSecretProvider.ts
//     │       ├── FileSecretProvider.ts
//     │       ├── InMemorySecretProvider.ts
//     │       ├── SecretProvider.ts
//     │       └── index.ts
//     ├── database
//     │   ├── DatabaseConfigProvider.ts
//     │   ├── DatabaseServer.ts
//     │   ├── IDatabaseServer.ts
//     │   ├── TransactionService.ts
//     │   ├── index.ts
//     │   ├── migrationAuth.ts
//     │   ├── migrationConfig.ts
//     │   └── migrationManager.ts
//     ├── di
//     │   ├── container.ts
//     │   ├── index.ts
//     │   └── types.ts
//     ├── errors
//     │   ├── AppError.ts
//     │   ├── ErrorHandler.ts
//     │   ├── IErrorHandler.ts
//     │   ├── ServiceError.ts
//     │   ├── base
//     │   │   ├── BaseError.ts
//     │   │   └── index.ts
//     │   ├── index.ts
//     │   ├── infrastructure
//     │   │   ├── ConfigValidationError.ts
//     │   │   ├── DatabaseError.ts
//     │   │   ├── InfrastructureError.ts
//     │   │   └── ValidationError.ts
//     │   └── technical
//     │       └── TechnicalError.ts
//     ├── index.ts
//     ├── jobs
//     │   ├── IJobService.ts
//     │   ├── JobService.ts
//     │   ├── JobTypes.ts
//     │   ├── index.ts
//     │   └── storage
//     │       ├── FileJobStorage.ts
//     │       ├── IJobStorage.ts
//     │       └── index.ts
//     ├── lifecycle
//     │   ├── ApplicationLifecycle.ts
//     │   ├── IApplicationLifecycle.ts
//     │   └── index.ts
//     ├── logging
//     │   ├── ILogger.ts
//     │   ├── Logger.ts
//     │   ├── LoggerService.ts
//     │   ├── LoggingConfig.ts
//     │   ├── ServerLogger.ts
//     │   ├── index.ts
//     │   └── transports
//     │       └── ConsoleTransport.ts
//     ├── middleware
//     │   ├── rateLimitMiddleware.ts
//     │   └── validationMiddleware.ts
//     ├── processor
//     │   ├── ImageProcessor.ts
//     │   ├── MediaProcessor.ts
//     │   ├── StreamProcessor.ts
//     │   └── index.ts
//     ├── pubsub
//     │   ├── IWebSocketService.ts
//     │   ├── WebSocketService.ts
//     │   ├── WebSocketTypes.ts
//     │   └── index.ts
//     ├── server
//     │   ├── ServerManager.ts
//     │   └── index.ts
//     └── storage
//         ├── ContentTypes.ts
//         ├── FileUtils.ts
//         ├── IStorageProvider.ts
//         ├── LocalStorageProvider.ts
//         ├── StorageService.ts
//         ├── StorageTypes.ts
//         ├── index.ts
//         └── processor
//             └── MediaProcessor.ts
// 

// ====================== FILE CONTENTS ======================


// ---------------------- infrastructure\cache\CacheService.ts (322 lines) ----------------------

import { performance } from "perf_hooks";

import { injectable, inject } from "inversify";

import { ICacheService } from "@/server/infrastructure/cache";
import { TYPES } from "@/server/infrastructure/di/types";
import type { ILoggerService } from "@/server/infrastructure/logging";

/**
 * Options for memoization
 */
export interface MemoizeOptions<T = unknown> {
  /**
   * Time to live in seconds, or a function that calculates TTL
   */
  ttl?: number | ((result: T, executionTime: number) => number);

  /**
   * Function to generate cache key from arguments
   */
  keyFn?: (...args: unknown[]) => string;
}

/**
 * Cache entry with value and expiration
 */
interface CacheEntry<T> {
  value: T;
  expiresAt: number | null;
}

/**
 * In-memory cache service implementation
 */
@injectable()
export class CacheService implements ICacheService {
  private cache: Map<string, CacheEntry<unknown>> = new Map();
  private stats = {
    hits: 0,
    misses: 0,
    size: 0,
  };

  constructor(
    @inject(TYPES.LoggerService) private readonly logger: ILoggerService,
  ) {}

  /**
   * Initialize the cache service
   */
  public async initialize(): Promise<void> {
    this.logger.info("Cache service initialized");
  }

  /**
   * Shutdown the cache service
   */
  public async shutdown(): Promise<void> {
    await this.clear();
    this.logger.info("Cache service shut down");
  }

  /**
   * Get a value from cache
   * @param key Cache key
   * @returns Value or null if not found
   */
  public async get<T>(key: string): Promise<T | null> {
    const entry = this.cache.get(key);

    if (!entry) {
      this.stats.misses++;
      return null;
    }

    // Check if expired
    if (entry.expiresAt !== null && entry.expiresAt < Date.now()) {
      this.cache.delete(key);
      this.stats.misses++;
      return null;
    }

    this.stats.hits++;
    return entry.value as T;
  }

  /**
   * Set a value in cache
   * @param key Cache key
   * @param value Value to cache
   * @param ttl Time to live in seconds (optional)
   */
  public async set<T>(key: string, value: T, ttl?: number): Promise<boolean> {
    const expiresAt = ttl ? Date.now() + ttl * 1000 : null;

    this.cache.set(key, {
      value,
      expiresAt,
    });

    this.updateSize();
    return true;
  }

  /**
   * Delete a value from cache
   * @param key Cache key
   */
  public async delete(key: string): Promise<boolean> {
    const result = this.cache.delete(key);
    if (result) {
      this.updateSize();
    }
    return result;
  }

  /**
   * Get multiple values from cache
   * @param keys Array of cache keys
   * @returns Object with key-value pairs
   */
  public async getMultiple<T>(keys: string[]): Promise<Record<string, T>> {
    const result: Record<string, T> = {};

    for (const key of keys) {
      const value = await this.get<T>(key);
      if (value !== null) {
        result[key] = value;
      }
    }

    return result;
  }

  /**
   * Set multiple values in cache
   * @param entries Object with key-value pairs
   * @param ttl Time to live in seconds (optional)
   */
  public async setMultiple<T>(
    entries: Record<string, T>,
    ttl?: number,
  ): Promise<boolean> {
    for (const key in entries) {
      await this.set(key, entries[key], ttl);
    }

    return true;
  }

  /**
   * Delete multiple values from cache
   * @param keys Array of cache keys
   */
  public async deleteMultiple(keys: string[]): Promise<boolean> {
    for (const key of keys) {
      await this.delete(key);
    }

    return true;
  }

  /**
   * Clear all values from cache
   * Alias for flush() to maintain compatibility with ICacheService
   */
  public async clear(): Promise<boolean> {
    return this.flush();
  }

  /**
   * Clear all values from cache
   */
  public async flush(): Promise<boolean> {
    this.cache.clear();
    this.updateSize();
    this.resetStats();
    return true;
  }

  /**
   * Check if key exists in cache
   * @param key Cache key
   */
  public async has(key: string): Promise<boolean> {
    const entry = this.cache.get(key);

    if (!entry) {
      return false;
    }

    // Check if expired
    if (entry.expiresAt !== null && entry.expiresAt < Date.now()) {
      this.cache.delete(key);
      return false;
    }

    return true;
  }

  /**
   * Get all cache keys
   */
  public keys(): string[] {
    // Clean expired entries
    this.cleanExpired();

    return Array.from(this.cache.keys());
  }

  /**
   * Get cache size
   */
  public size(): number {
    // Clean expired entries
    this.cleanExpired();

    return this.cache.size;
  }

  /**
   * Create a memoized version of a function
   * Results will be cached based on the arguments
   *
   * @param fn Function to memoize
   * @param options Memoization options
   * @returns Memoized function
   */
  public memoize<T extends (...args: unknown[]) => Promise<unknown>>(
    fn: T,
    options: MemoizeOptions<Awaited<ReturnType<T>>> = {},
  ): T {
    return (async (...args: Parameters<T>): Promise<ReturnType<T>> => {
      // Generate cache key
      const key = options.keyFn
        ? options.keyFn(...args)
        : `memoize:${JSON.stringify(args)}`;

      // Try to get from cache
      const cached = await this.get<ReturnType<T>>(key);
      if (cached !== null) {
        return cached;
      }

      // Execute the function
      const start = performance.now();
      const result = await fn(...args);
      const executionTime = performance.now() - start;

      // Determine TTL and cache the result
      let ttl: number | undefined;
      if (typeof options.ttl === "function") {
        ttl = options.ttl(result as Awaited<ReturnType<T>>, executionTime);
      } else {
        ttl = options.ttl;
      }

      await this.set(key, result, ttl);
      return result as ReturnType<T>;
    }) as T;
  }

  /**
   * Update cache size stat
   */
  private updateSize(): void {
    this.cleanExpired();
    this.stats.size = this.cache.size;
  }

  /**
   * Clean expired entries
   */
  private cleanExpired(): void {
    const now = Date.now();
    let expired = 0;

    for (const [key, entry] of this.cache.entries()) {
      if (entry.expiresAt !== null && entry.expiresAt < now) {
        this.cache.delete(key);
        expired++;
      }
    }

    if (expired > 0) {
      this.logger.debug(`Removed ${expired} expired cache entries`);
    }
  }

  /**
   * Get cache statistics
   * @returns Cache statistics
   */
  public getStats(): {
    hits: number;
    misses: number;
    size: number;
    hitRatio: number;
  } {
    this.updateSize();
    return {
      hits: this.stats.hits,
      misses: this.stats.misses,
      size: this.stats.size,
      hitRatio:
        this.stats.hits + this.stats.misses > 0
          ? Math.round(
              (this.stats.hits / (this.stats.hits + this.stats.misses)) * 100,
            ) / 100
          : 0,
    };
  }

  /**
   * Reset cache statistics
   */
  public resetStats(): void {
    this.stats.hits = 0;
    this.stats.misses = 0;
    this.updateSize();
  }
}


// ---------------------- infrastructure\cache\ICacheService.ts (102 lines) ----------------------

/**
 * Interface for cache service
 * Provides methods for interacting with application cache
 */
export interface ICacheService {
  /**
   * Initialize the cache service
   */
  initialize(): Promise<void>;

  /**
   * Shutdown the cache service
   */
  shutdown(): Promise<void>;

  /**
   * Get an item from the cache
   * @param key The key to fetch
   * @returns The cached value or null if not found
   */
  get<T>(key: string): Promise<T | null>;

  /**
   * Set an item in the cache
   * @param key The key to store
   * @param value The value to store
   * @param ttl Time to live in seconds (optional)
   * @returns True if successful
   */
  set<T>(key: string, value: T, ttl?: number): Promise<boolean>;

  /**
   * Delete an item from the cache
   * @param key The key to delete
   * @returns True if successful
   */
  delete(key: string): Promise<boolean>;

  /**
   * Get multiple values from cache
   * @param keys Array of cache keys
   * @returns Object with key-value pairs
   */
  getMultiple<T>(keys: string[]): Promise<Record<string, T>>;

  /**
   * Set multiple values in cache
   * @param entries Object with key-value pairs
   * @param ttl Time to live in seconds (optional)
   */
  setMultiple<T>(entries: Record<string, T>, ttl?: number): Promise<boolean>;

  /**
   * Delete multiple values from cache
   * @param keys Array of cache keys
   */
  deleteMultiple(keys: string[]): Promise<boolean>;

  /**
   * Clear the entire cache
   * @returns True if successful
   */
  flush(): Promise<boolean>;

  /**
   * Alias for flush
   */
  clear(): Promise<boolean>;

  /**
   * Check if key exists in cache
   * @param key Cache key
   */
  has(key: string): Promise<boolean>;

  /**
   * Get all keys in the cache
   */
  keys(): string[];

  /**
   * Memoize a function by caching its results
   * @param fn Function to memoize
   * @param options Memoization options
   * @returns Memoized function that caches results
   */
  memoize<T extends (...args: unknown[]) => Promise<unknown>>(
    fn: T,
    options?: {
      ttl?:
        | number
        | ((result: Awaited<ReturnType<T>>, executionTime: number) => number);
      keyFn?: (...args: unknown[]) => string;
    },
  ): T;

  /**
   * Get statistics about the cache
   * @returns Statistics object with hits, misses and size
   */
  getStats(): { hits: number; misses: number; size: number };
}


// ---------------------- infrastructure\cache\index.ts (4 lines) ----------------------

// Export Files
export * from "./ICacheService";
export { CacheService } from "./CacheService";
export * from "./startupHooks";


// ---------------------- infrastructure\cache\startupHooks.ts (32 lines) ----------------------

import { container } from "@/server/infrastructure/di";
import { TYPES } from "@/server/infrastructure/di/types";

import { ICacheService } from "./ICacheService";

/**
 * Initialize cache service on startup
 * @throws Error if initialization fails
 */
export async function initializeCache(): Promise<void> {
  try {
    const cacheService = container.get<ICacheService>(TYPES.CacheService);
    await cacheService.initialize();
  } catch (error) {
    console.error("Failed to initialize cache service:", error);
    throw error;
  }
}

/**
 * Shutdown cache service on application exit
 * @throws Error if shutdown fails
 */
export async function shutdownCache(): Promise<void> {
  try {
    const cacheService = container.get<ICacheService>(TYPES.CacheService);
    await cacheService.shutdown();
  } catch (error) {
    console.error("Failed to shutdown cache service:", error);
    throw error;
  }
}


// ---------------------- infrastructure\config\ConfigSchema.ts (299 lines) ----------------------

/**
 * Configuration schema field definition
 */
export interface ConfigSchemaField {
  type: "string" | "number" | "boolean" | "array" | "object";
  required?: boolean;
  default?: unknown;
  secret?: boolean;
  description?: string;

  // Validation rules
  pattern?: RegExp;
  enum?: readonly (string | number)[];
  minLength?: number;
  maxLength?: number;
  min?: number;
  max?: number;
  arrayType?: "string" | "number" | "boolean";
  validator?: (value: unknown) => boolean;
}

/**
 * Configuration schema
 */
export interface ConfigSchema {
  properties: Record<string, ConfigSchemaField>;
}

/**
 * Validated configuration result
 */
export interface ValidatedConfig {
  valid: boolean;
  errors: string[];
  values: Record<string, unknown>;
}

/**
 * Validates a configuration against a schema
 *
 * @param config Configuration to validate
 * @param schema Schema to validate against
 * @returns Validation result
 */
export function validateConfig(
  config: Record<string, string>,
  schema: ConfigSchema,
): ValidatedConfig {
  const result: ValidatedConfig = {
    valid: true,
    errors: [],
    values: {},
  };

  if (!config || typeof config !== "object") {
    result.valid = false;
    result.errors.push("Configuration is not a valid object");
    return result;
  }

  if (!schema || typeof schema !== "object" || !schema.properties) {
    result.valid = false;
    result.errors.push("Schema is not a valid object with properties");
    return result;
  }

  // Validate each field in schema
  for (const [key, field] of Object.entries(schema.properties)) {
    let value: unknown = config[key];

    // Apply default if value is undefined
    if (value === undefined && field.default !== undefined) {
      value = field.default;
    }

    // Convert value based on type
    if (value !== undefined) {
      try {
        value = convertValue(value, field);
      } catch (error) {
        result.errors.push(
          `Error converting ${key}: ${error instanceof Error ? error.message : String(error)}`,
        );
        result.valid = false;
        continue;
      }
    }

    // Check if required
    if (field.required && value === undefined) {
      result.errors.push(`Required configuration key missing: ${key}`);
      result.valid = false;
      continue;
    }

    // Skip further validation if no value
    if (value === undefined) {
      result.values[key] = undefined;
      continue;
    }

    // Type-specific validations
    if (!validateFieldValue(key, value, field, result)) {
      continue;
    }

    // Store validated value
    result.values[key] = value;
  }

  return result;
}

/**
 * Converts a string value to the appropriate type
 *
 * @param value Value to convert
 * @param field Schema field
 * @returns Converted value
 */
function convertValue(value: unknown, field: ConfigSchemaField): unknown {
  // If value is already converted (not a string), return as is
  if (typeof value !== "string") {
    return value;
  }

  switch (field.type) {
    case "string":
      return value;

    case "number": {
      const num = Number(value);
      if (isNaN(num)) {
        throw new Error(`Invalid number: ${value}`);
      }
      return num;
    }

    case "boolean":
      if (value.toLowerCase() === "true" || value === "1" || value === "yes") {
        return true;
      }
      if (value.toLowerCase() === "false" || value === "0" || value === "no") {
        return false;
      }
      throw new Error(`Invalid boolean: ${value}`);

    case "array":
      return value.split(",").map((item) => {
        const trimmed = item.trim();
        if (field.arrayType === "number") {
          const num = Number(trimmed);
          if (isNaN(num)) {
            throw new Error(`Invalid number in array: ${trimmed}`);
          }
          return num;
        }
        if (field.arrayType === "boolean") {
          const lower = trimmed.toLowerCase();
          if (lower === "true" || lower === "1" || lower === "yes") {
            return true;
          }
          if (lower === "false" || lower === "0" || lower === "no") {
            return false;
          }
          throw new Error(`Invalid boolean in array: ${trimmed}`);
        }
        return trimmed;
      });

    case "object":
      try {
        return JSON.parse(value);
      } catch (_error) {
        throw new Error(`Invalid JSON: ${value}`);
      }

    default:
      return value;
  }
}

/**
 * Validates a field value against validation rules
 *
 * @param key Field key
 * @param value Field value
 * @param field Schema field
 * @param result Validation result
 * @returns True if valid, false otherwise
 */
function validateFieldValue(
  key: string,
  value: unknown,
  field: ConfigSchemaField,
  result: ValidatedConfig,
): boolean {
  // String validations
  if (field.type === "string" && typeof value === "string") {
    // Pattern check
    if (field.pattern && !field.pattern.test(value)) {
      result.errors.push(
        `Value for ${key} does not match pattern ${field.pattern}`,
      );
      result.valid = false;
      return false;
    }

    // Enum check
    if (field.enum && !field.enum.includes(value)) {
      result.errors.push(
        `Value for ${key} must be one of: ${field.enum.join(", ")}`,
      );
      result.valid = false;
      return false;
    }

    // Length checks
    if (field.minLength !== undefined && value.length < field.minLength) {
      result.errors.push(
        `Value for ${key} is too short (min ${field.minLength} characters)`,
      );
      result.valid = false;
      return false;
    }

    if (field.maxLength !== undefined && value.length > field.maxLength) {
      result.errors.push(
        `Value for ${key} is too long (max ${field.maxLength} characters)`,
      );
      result.valid = false;
      return false;
    }
  }

  // Number validations
  if (field.type === "number" && typeof value === "number") {
    // Range checks
    if (field.min !== undefined && value < field.min) {
      result.errors.push(`Value for ${key} is too small (min ${field.min})`);
      result.valid = false;
      return false;
    }

    if (field.max !== undefined && value > field.max) {
      result.errors.push(`Value for ${key} is too large (max ${field.max})`);
      result.valid = false;
      return false;
    }

    // Enum check
    if (field.enum && !field.enum.includes(value)) {
      result.errors.push(
        `Value for ${key} must be one of: ${field.enum.join(", ")}`,
      );
      result.valid = false;
      return false;
    }
  }

  // Custom validator
  if (field.validator && !field.validator(value)) {
    result.errors.push(`Invalid value for configuration key: ${key}`);
    result.valid = false;
    return false;
  }

  return true;
}

export type ConfigValueType =
  | "string"
  | "number"
  | "boolean"
  | "array"
  | "object";

export interface ConfigSchemaEntry {
  type: ConfigValueType;
  description: string;
  required?: boolean;
  default?: unknown;
  validate?: (value: unknown) => boolean;
  transform?: (value: unknown) => unknown;
}

export type ConfigSchemaDefinition = Record<string, ConfigSchemaEntry>;

export interface ConfigValidationError {
  key: string;
  message: string;
  value?: unknown;
  expected?: unknown;
}

export interface ConfigValidationResult {
  isValid: boolean;
  errors: ConfigValidationError[];
}


// ---------------------- infrastructure\config\ConfigService.ts (669 lines) ----------------------

import * as fs from "fs";
import * as path from "path";

import dotenv from "dotenv";
import { injectable, inject, optional, unmanaged } from "inversify";

import { TYPES } from "@/server/infrastructure/di/types";

import { ConfigSchema, ValidatedConfig, validateConfig } from "./ConfigSchema";
import { SecretProvider } from "./secrets/SecretProvider";

import type { ILoggerService } from "../logging";
import type { IConfigService } from "./IConfigService";

/**
 * Core configuration service that provides access to application configuration
 * with support for environment variables, .env files, and validation.
 */
@injectable()
export class ConfigService implements IConfigService {
  private values = new Map<string, string>();
  private namespaces = new Map<string, ConfigService>();
  private secretProviders: SecretProvider[] = [];
  private logger: ILoggerService;
  private namespace?: string;
  private parent?: ConfigService;
  private errors: string[] = [];

  /**
   * Creates a new ConfigService instance
   *
   * @param loggerService Optional logger service
   * @param parent Parent configuration service (for namespaced configs)
   * @param namespace Optional namespace for this configuration
   */
  constructor(
    @inject(TYPES.LoggerService) @optional() loggerService?: ILoggerService,
    @unmanaged() parent?: ConfigService,
    @unmanaged() namespace?: string,
  ) {
    this.logger = loggerService?.createLogger("ConfigService") || {
      debug: console.debug,
      info: console.info,
      warn: console.warn,
      error: console.error,
      // Minimal implementation for other required methods
      createLogger: () => this.logger,
      withContext: () => this.logger,
      debugObj: () => {},
      infoObj: () => {},
      warnObj: () => {},
      errorObj: () => {},
      addTransport: () => {},
      setTransports: () => {},
      setMinLevel: () => {},
      initialize: async () => {},
      shutdown: async () => {},
    };

    this.parent = parent;
    this.namespace = namespace;

    // Only load environment in the root instance
    if (!parent) {
      this.loadFromEnvironment();
      this.loadEnvFiles();
    }
  }

  /**
   * Initialize the configuration service
   */
  async initialize(): Promise<void> {
    if (this.parent) {
      return Promise.resolve();
    }

    // For root service, ensure environment is loaded
    this.loadEnvFiles();
    this.loadFromEnvironment();
    this.logger.info("ConfigService initialized");

    return Promise.resolve();
  }

  /**
   * Loads configuration from environment variables
   */
  private loadFromEnvironment(): void {
    for (const [key, value] of Object.entries(process.env)) {
      if (value !== undefined) {
        this.set(key, value);
      }
    }
    this.logger.debug("Loaded configuration from environment variables");
  }

  /**
   * Loads configuration from .env files with priority
   */
  private loadEnvFiles(): void {
    const NODE_ENV = process.env.NODE_ENV || "development";
    const configDir = path.resolve(__dirname);
    const envDir = path.join(configDir, ".env");
    const envFiles = [
      path.join(envDir, `.env.${NODE_ENV}.local`), // highest priority
      path.join(envDir, `.env.${NODE_ENV}`),
      path.join(envDir, ".env.local"),
      path.join(envDir, ".env"), // lowest priority
    ];

    // Load files in reverse order (lowest priority first)
    const loadedFiles = [];
    for (const file of envFiles.reverse()) {
      if (fs.existsSync(file)) {
        this.loadFromFile(file);
        loadedFiles.push(path.basename(file));
      }
    }

    if (loadedFiles.length > 0) {
      this.logger.info(`Loaded environment files: ${loadedFiles.join(", ")}`);
    } else {
      this.logger.debug("No environment files found");
    }
  }

  /**
   * Loads configuration from a file
   *
   * @param filePath Path to the configuration file
   */
  loadFromFile(filePath: string): void {
    try {
      if (!fs.existsSync(filePath)) {
        this.logger.warn(`Config file not found: ${filePath}`);
        return;
      }

      const fullPath = path.resolve(filePath);
      const config = dotenv.parse(fs.readFileSync(fullPath));

      for (const [key, value] of Object.entries(config)) {
        this.set(key, value);
      }

      // Get relative path from src directory
      const relativePath = path.relative(
        path.join(process.cwd(), "src"),
        fullPath,
      );
      this.logger.info(`Loaded config from ${relativePath}`);
    } catch (error) {
      this.logger.error(
        `Failed to load config from ${filePath}: ${
          error instanceof Error ? error.message : String(error)
        }`,
      );
    }
  }

  /**
   * Sets a configuration value
   *
   * @param key Configuration key
   * @param value Configuration value
   */
  set(key: string, value: string): void {
    if (this.parent) {
      // If this is a namespaced config, delegate to parent
      this.parent.set(this.getNamespacedKey(key), value);
      return;
    }

    this.values.set(key, value);
  }

  /**
   * Gets a configuration value
   *
   * @param key Configuration key
   * @param defaultValue Optional default value if key is not found
   * @returns The configuration value
   */
  get<T>(key: string, defaultValue?: T): T {
    if (this.parent) {
      return this.parent.get(this.getNamespacedKey(key), defaultValue);
    }

    const value = this.values.get(key);
    if (value === undefined) {
      return defaultValue as T;
    }
    return value as T;
  }

  /**
   * Gets a required configuration value
   *
   * @param key Configuration key
   * @returns The configuration value
   * @throws Error if the configuration value is not found
   */
  getRequired(key: string): string {
    const value = this.get<string>(key);
    if (value === undefined || value === null) {
      const fullKey = this.getNamespacedKey(key);
      const error = `Required configuration key not found: ${fullKey}`;
      this.logger.error(error);
      throw new Error(error);
    }
    return value;
  }

  /**
   * Gets a configuration value as a number
   *
   * @param key Configuration key
   * @param defaultValue Optional default value
   * @returns The configuration value as a number or default
   */
  getNumber(key: string, defaultValue?: number): number {
    const value = this.get<string>(key);
    if (value === undefined || value === null || value === "") {
      return defaultValue ?? 0;
    }
    const num = Number(value);
    if (isNaN(num)) {
      return defaultValue ?? NaN;
    }
    return num;
  }

  /**
   * Gets a configuration value as a boolean
   *
   * @param key Configuration key
   * @param defaultValue Optional default value
   * @returns The configuration value as a boolean or default
   */
  getBoolean(key: string, defaultValue: boolean = false): boolean {
    const value = this.get<string>(key);
    if (value === undefined) {
      return defaultValue;
    }
    const lowered = value.toLowerCase();
    if (
      lowered === "true" ||
      value === "1" ||
      lowered === "yes" ||
      lowered === "y"
    ) {
      return true;
    }
    if (
      lowered === "false" ||
      value === "0" ||
      lowered === "no" ||
      lowered === "n"
    ) {
      return false;
    }
    return defaultValue;
  }

  /**
   * Gets a configuration value as an array
   *
   * @param key Configuration key
   * @param defaultValue Optional default value
   * @param separator Separator character (default: comma)
   * @returns The configuration value as an array or default
   */
  getArray<T>(
    key: string,
    defaultValue: T[] = [] as T[],
    separator = ",",
  ): T[] {
    const value = this.get<string>(key);
    if (!value) {
      return defaultValue;
    }

    return value
      .split(separator)
      .map((item: string) => item.trim())
      .filter(Boolean)
      .map((item) => item as T);
  }

  /**
   * Gets a namespaced configuration service
   *
   * @param namespace Namespace name
   * @returns A namespaced configuration service
   */
  getNamespace(namespace: string): ConfigService {
    if (!this.namespaces.has(namespace)) {
      // Create a new namespaced config and initialize it with existing values
      const namespacedConfig = new ConfigService(this.logger, this, namespace);
      this.namespaces.set(namespace, namespacedConfig);

      // Copy any existing namespaced values
      const prefix = `${namespace}_`;
      for (const [key, value] of this.values.entries()) {
        if (key.startsWith(prefix)) {
          namespacedConfig.set(key.substring(prefix.length), value);
        }
      }

      // Also copy any environment variables with the namespace prefix
      for (const [key, value] of Object.entries(process.env)) {
        if (key.startsWith(prefix) && value !== undefined) {
          namespacedConfig.set(key.substring(prefix.length), value);
        }
      }
    }
    return this.namespaces.get(namespace)!;
  }

  /**
   * Gets all configuration values
   *
   * @returns All configuration values
   */
  getAll(): Record<string, string> {
    if (this.parent) {
      // If this is a namespaced config, filter values from parent
      const prefix = `${this.namespace}_`;
      const result: Record<string, string> = {};

      for (const [key, value] of this.parent.values.entries()) {
        if (key.startsWith(prefix)) {
          result[key.substring(prefix.length)] = value;
        }
      }

      return result;
    }

    // For root config, return all values
    const result: Record<string, string> = {};
    for (const [key, value] of this.values.entries()) {
      result[key] = value;
    }

    return result;
  }

  /**
   * Validates the configuration against a schema
   *
   * @param schema Schema to validate against
   * @returns Whether the configuration is valid
   */
  validate(schema: ConfigSchema): ValidatedConfig {
    this.errors = [];
    const config = this.getAll();
    if (!config || typeof config !== "object") {
      return {
        valid: false,
        errors: ["Configuration is not a valid object"],
        values: {},
      };
    }
    const result = validateConfig(config, schema);
    this.errors = result.errors;
    return result;
  }

  /**
   * Check if validation succeeded and throw an error if not
   *
   * @param schema Schema to validate against
   * @throws ConfigValidationError if validation failed
   */
  public ensureValid(schema: ConfigSchema): void {
    const result = this.validate(schema);
    if (!result.valid) {
      throw new Error(`Invalid configuration:\n${result.errors.join("\n")}`);
    }
  }

  /**
   * Registers a secret provider
   *
   * @param provider Secret provider
   */
  registerSecretProvider(provider: SecretProvider): void {
    if (this.parent) {
      this.parent.registerSecretProvider(provider);
      return;
    }

    this.secretProviders.push(provider);
    this.logger.info("Registered secret provider");
  }

  /**
   * Gets a secret value
   *
   * @param key Secret key
   * @returns Secret value or undefined
   */
  async getSecret(key: string): Promise<string | undefined> {
    if (this.parent) {
      return this.parent.getSecret(key);
    }

    // First check if in environment
    const envValue = process.env[key];
    if (envValue !== undefined) {
      return envValue;
    }

    // Then check secret providers
    for (const provider of this.secretProviders) {
      try {
        // First check if the provider supports this secret
        let supportsKey = false;
        try {
          supportsKey = await provider.supportsSecret(key);
        } catch (supportError) {
          this.logger.error(
            `Error checking if provider supports secret ${key}: ${
              supportError instanceof Error
                ? supportError.message
                : String(supportError)
            }`,
          );
          continue; // Skip this provider on error
        }

        if (supportsKey) {
          try {
            const value = await provider.getSecret(key);
            if (value !== undefined) {
              return value;
            }
          } catch (secretError) {
            this.logger.error(
              `Error getting secret ${key} from provider: ${
                secretError instanceof Error
                  ? secretError.message
                  : String(secretError)
              }`,
            );
          }
        }
      } catch (error) {
        this.logger.error(
          `Unexpected error with secret provider: ${
            error instanceof Error ? error.message : String(error)
          }`,
        );
      }
    }

    return undefined;
  }

  /**
   * Checks if the application is running in development mode
   *
   * @returns True if in development mode
   */
  isDevelopment(): boolean {
    return (process.env.NODE_ENV || "development") === "development";
  }

  /**
   * Checks if the application is running in production mode
   *
   * @returns True if in production mode
   */
  isProduction(): boolean {
    return process.env.NODE_ENV === "production";
  }

  /**
   * Checks if the application is running in test mode
   *
   * @returns True if in test mode
   */
  isTest(): boolean {
    return process.env.NODE_ENV === "test";
  }

  /**
   * Gets the full key with namespace prefix
   *
   * @param key Configuration key
   * @returns Namespaced key
   */
  private getNamespacedKey(key: string): string {
    return this.namespace ? `${this.namespace}_${key}` : key;
  }

  getString(key: string, defaultValue?: string): string {
    try {
      return this.get<string>(key);
    } catch {
      return defaultValue || "";
    }
  }

  getObject<T>(key: string, defaultValue?: T): T {
    try {
      const value = this.get<string>(key);
      return value ? JSON.parse(value) : (defaultValue as T);
    } catch {
      return defaultValue as T;
    }
  }

  getErrors(): string[] {
    return [...this.errors];
  }

  clearErrors(): void {
    // Implement error clearing if needed
  }

  hasErrors(): boolean {
    return false; // Implement error checking if needed
  }

  getConfig(): Record<string, unknown> {
    return this.getAll();
  }

  setMultiple(entries: Record<string, unknown>): void {
    Object.entries(entries).forEach(([key, value]) => {
      this.set(key, String(value));
    });
  }

  delete(key: string): void {
    this.values.delete(key);
  }

  deleteMultiple(keys: string[]): void {
    keys.forEach((key) => this.delete(key));
  }

  clear(): void {
    this.values.clear();
  }

  /**
   * Checks if a configuration key exists
   *
   * @param key Configuration key
   * @returns True if the key exists
   */
  has(key: string): boolean {
    if (this.parent) {
      return this.parent.has(this.getNamespacedKey(key));
    }
    return this.values.has(key);
  }

  getKeys(): string[] {
    return Array.from(this.values.keys());
  }

  getValues(): unknown[] {
    return Array.from(this.values.values());
  }

  getEntries(): [string, unknown][] {
    return Array.from(this.values.entries());
  }

  getSize(): number {
    return this.values.size;
  }

  isEmpty(): boolean {
    return this.values.size === 0;
  }

  clone(): Record<string, unknown> {
    return { ...this.getAll() };
  }

  merge(other: Record<string, unknown>): void {
    Object.entries(other).forEach(([key, value]) => {
      this.set(key, String(value));
    });
  }

  diff(other: Record<string, unknown>): Record<string, unknown> {
    const result: Record<string, unknown> = {};
    const current = this.getAll();
    Object.keys(other).forEach((key) => {
      if (current[key] !== other[key]) {
        result[key] = other[key];
      }
    });
    return result;
  }

  equals(other: Record<string, unknown>): boolean {
    const current = this.getAll();
    return Object.keys(other).every((key) => current[key] === other[key]);
  }

  toString(): string {
    return JSON.stringify(this.getAll());
  }

  toJSON(): string {
    return this.toString();
  }

  fromJSON(json: string): void {
    const data = JSON.parse(json);
    this.fromObject(data);
  }

  fromObject(obj: Record<string, unknown>): void {
    this.clear();
    this.setMultiple(obj);
  }

  reset(): void {
    this.clear();
    this.loadFromEnvironment();
    this.loadEnvFiles();
  }

  reload(): Promise<void> {
    return this.initialize();
  }

  watch(key: string, callback: (value: unknown) => void): () => void {
    // Store initial value
    const initialValue = this.get(key);
    callback(initialValue);

    // Return cleanup function
    return () => {
      // Cleanup if needed
    };
  }

  unwatch(key: string, callback: (value: unknown) => void): void {
    // Get current value before unwatching
    const currentValue = this.get(key);
    callback(currentValue);
  }

  unwatchAll(): void {
    // Implement unwatchAll if needed
  }

  getWithDefault<T>(key: string, defaultValue: T): T {
    try {
      return this.get<T>(key);
    } catch {
      return defaultValue;
    }
  }

  toObject(): Record<string, unknown> {
    return this.getAll();
  }
}


// ---------------------- infrastructure\config\Env.ts (31 lines) ----------------------

/**
 * Types for server environment and configuration
 */

/**
 * Server environment configuration
 */
export interface ServerEnvironment {
  nodeEnv: string;
  isProduction: boolean;
  isDevelopment: boolean;
  isTest: boolean;
  config: ServerConfig;
}

/**
 * Server configuration settings
 */
export interface ServerConfig {
  production: boolean;
  baseUrl: string;
  corsOrigin: string | string[];
  signatureSecret: Buffer;
  passwordSalt: string;
  port: number;
  host: string;
  uploadPath: string;
  tempPath: string;
  storagePath: string;
  storageUrl: string;
}


// ---------------------- infrastructure\config\IConfigService.ts (46 lines) ----------------------

import { ConfigSchema, ValidatedConfig } from "./ConfigSchema";

export interface IConfigService {
  initialize(): Promise<void>;
  get<T>(key: string): T;
  getWithDefault<T>(key: string, defaultValue: T): T;
  getNumber(key: string, defaultValue?: number): number;
  getBoolean(key: string, defaultValue?: boolean): boolean;
  getString(key: string, defaultValue?: string): string;
  getArray<T>(key: string, defaultValue?: T[]): T[];
  getObject<T>(key: string, defaultValue?: T): T;
  isProduction(): boolean;
  isDevelopment(): boolean;
  isTest(): boolean;
  ensureValid(schema: ConfigSchema): void;
  validate(schema: ConfigSchema): ValidatedConfig;
  getErrors(): string[];
  clearErrors(): void;
  hasErrors(): boolean;
  getConfig(): Record<string, unknown>;
  set(key: string, value: unknown): void;
  setMultiple(entries: Record<string, unknown>): void;
  delete(key: string): void;
  deleteMultiple(keys: string[]): void;
  clear(): void;
  has(key: string): boolean;
  getKeys(): string[];
  getValues(): unknown[];
  getEntries(): [string, unknown][];
  getSize(): number;
  isEmpty(): boolean;
  clone(): Record<string, unknown>;
  merge(other: Record<string, unknown>): void;
  diff(other: Record<string, unknown>): Record<string, unknown>;
  equals(other: Record<string, unknown>): boolean;
  toString(): string;
  toJSON(): string;
  fromJSON(json: string): void;
  toObject(): Record<string, unknown>;
  fromObject(obj: Record<string, unknown>): void;
  reset(): void;
  reload(): Promise<void>;
  watch(key: string, callback: (value: unknown) => void): () => void;
  unwatch(key: string, callback: (value: unknown) => void): void;
  unwatchAll(): void;
}


// ---------------------- infrastructure\config\domain\DatabaseConfig.ts (206 lines) ----------------------

import { injectable, inject } from "inversify";

import { ConfigService, ConfigSchema } from "@/server/infrastructure/config";
import { TYPES } from "@/server/infrastructure/di/types";

/**
 * Database configuration interface
 */
export interface DatabaseConfig {
  connectionString: string;
  host: string;
  port: number;
  database: string;
  user: string;
  password: string;
  maxConnections: number;
  idleTimeout: number;
  connectionTimeout: number;
  statementTimeout: number;
  ssl?: boolean | { rejectUnauthorized: boolean };
  metricsMaxSamples: number;
}

/**
 * Database configuration provider
 */
@injectable()
export class DatabaseConfigProvider {
  private config: DatabaseConfig;

  constructor(
    @inject(TYPES.ConfigService) private configService: ConfigService,
  ) {
    // Load config only
    this.config = this.loadConfig();
  }

  /**
   * Gets the database configuration
   *
   * @returns Database configuration
   */
  getConfig(): DatabaseConfig {
    // Validate configuration against schema
    this.configService.ensureValid(this.getConfigSchema());
    return this.config;
  }

  /**
   * Gets the configuration schema for validation
   *
   * @returns Configuration schema
   */
  getConfigSchema(): ConfigSchema {
    return {
      properties: {
        DB_HOST: {
          type: "string",
          required: true,
          default: "localhost",
          description: "Database host",
        },
        DB_PORT: {
          type: "number",
          required: true,
          default: 5432,
          min: 1,
          max: 65535,
          description: "Database port",
        },
        DB_NAME: {
          type: "string",
          required: true,
          default: "abe_stack",
          description: "Database name",
        },
        DB_USER: {
          type: "string",
          required: true,
          default: "postgres",
          description: "Database user",
        },
        DB_PASSWORD: {
          type: "string",
          required: true,
          default: "postgres",
          secret: true,
          description: "Database password",
        },
        DATABASE_URL: {
          type: "string",
          required: true,
          default: "postgresql://postgres:postgres@localhost:5432/abe_stack",
          pattern: /^postgresql:\/\/.+/,
          description: "PostgreSQL connection string",
        },
        DB_MAX_CONNECTIONS: {
          type: "number",
          required: false,
          default: 20,
          min: 1,
          description: "Maximum number of database connections",
        },
        DB_IDLE_TIMEOUT: {
          type: "number",
          required: false,
          default: 30000,
          min: 1000,
          description: "Connection idle timeout in milliseconds",
        },
        DB_CONNECTION_TIMEOUT: {
          type: "number",
          required: false,
          default: 5000,
          min: 100,
          description: "Connection timeout in milliseconds",
        },
        DB_STATEMENT_TIMEOUT: {
          type: "number",
          required: false,
          default: 30000,
          min: 100,
          description: "Statement timeout in milliseconds",
        },
        DB_SSL: {
          type: "boolean",
          required: false,
          default: false,
          description: "Enable SSL for database connection",
        },
        DB_METRICS_MAX_SAMPLES: {
          type: "number",
          required: false,
          default: 1000,
          min: 10,
          description: "Maximum number of metrics samples to keep",
        },
      },
    };
  }

  /**
   * Loads the database configuration from the config service
   *
   * @returns Database configuration
   */
  private loadConfig(): DatabaseConfig {
    // Load the configuration
    const config = {
      connectionString: this.configService.get(
        "DATABASE_URL",
        "postgresql://postgres:postgres@localhost:5432/abe_stack",
      ) as string,
      host: this.configService.get("DB_HOST", "localhost") as string,
      port: this.configService.getNumber("DB_PORT", 5432) as number,
      database: this.configService.get("DB_NAME", "abe_stack") as string,
      user: this.configService.get("DB_USER", "postgres") as string,
      password: this.configService.get("DB_PASSWORD", "postgres") as string,
      maxConnections: this.configService.getNumber(
        "DB_MAX_CONNECTIONS",
        20,
      ) as number,
      idleTimeout: this.configService.getNumber(
        "DB_IDLE_TIMEOUT",
        30000,
      ) as number,
      connectionTimeout: this.configService.getNumber(
        "DB_CONNECTION_TIMEOUT",
        5000,
      ) as number,
      statementTimeout: this.configService.getNumber(
        "DB_STATEMENT_TIMEOUT",
        30000,
      ) as number,
      ssl: this.configService.getBoolean("DB_SSL", false),
      metricsMaxSamples: this.configService.getNumber(
        "DB_METRICS_MAX_SAMPLES",
        1000,
      ) as number,
    };

    // Validate required fields
    const requiredFields = [
      "connectionString",
      "host",
      "port",
      "database",
      "user",
      "password",
    ];

    const missingFields = requiredFields.filter(
      (field) => !config[field as keyof DatabaseConfig],
    );

    if (missingFields.length > 0) {
      throw new Error(
        `Missing required database configuration fields: ${missingFields.join(
          ", ",
        )}`,
      );
    }

    return config;
  }
}


// ---------------------- infrastructure\config\domain\EmailConfig.ts (107 lines) ----------------------

import { injectable, inject } from "inversify";

import { ConfigService, ConfigSchema } from "@/server/infrastructure/config";
import { TYPES } from "@/server/infrastructure/di/types";

/**
 * Email configuration interface
 */
export interface EmailConfig {
  host: string;
  port: number;
  secure: boolean;
  auth: {
    user: string;
    pass: string;
  };
  from: string;
}

/**
 * Email configuration provider
 */
@injectable()
export class EmailConfigProvider {
  private config: EmailConfig;

  constructor(
    @inject(TYPES.ConfigService) private configService: ConfigService,
  ) {
    this.config = this.loadConfig();

    // Validate configuration
    this.configService.ensureValid(this.getConfigSchema());
  }

  /**
   * Gets the email configuration
   *
   * @returns Email configuration
   */
  getConfig(): EmailConfig {
    return this.config;
  }

  /**
   * Gets the configuration schema for validation
   *
   * @returns Configuration schema
   */
  getConfigSchema(): ConfigSchema {
    return {
      properties: {
        EMAIL_HOST: {
          type: "string",
          default: "smtp.example.com",
          description: "SMTP server host",
        },
        EMAIL_PORT: {
          type: "number",
          default: 465,
          min: 1,
          max: 65535,
          description: "SMTP server port",
        },
        EMAIL_USER: {
          type: "string",
          default: "user@example.com",
          description: "SMTP server username",
        },
        EMAIL_PASSWORD: {
          type: "string",
          default: "password123",
          secret: true,
          description: "SMTP server password",
        },
        EMAIL_FROM: {
          type: "string",
          default: "noreply@example.com",
          description: "Default sender email address",
        },
        EMAIL_SECURE: {
          type: "boolean",
          default: true,
          description: "Use secure connection (TLS)",
        },
      },
    };
  }

  /**
   * Loads the email configuration from the config service
   *
   * @returns Email configuration
   */
  private loadConfig(): EmailConfig {
    return {
      host: this.configService.get("EMAIL_HOST") || "smtp.example.com",
      port: this.configService.getNumber("EMAIL_PORT") || 465,
      secure: this.configService.getBoolean("EMAIL_SECURE") || true,
      auth: {
        user: this.configService.get("EMAIL_USER") || "user@example.com",
        pass: this.configService.get("EMAIL_PASSWORD") || "password123",
      },
      from: this.configService.get("EMAIL_FROM") || "noreply@example.com",
    };
  }
}


// ---------------------- infrastructure\config\domain\SecurityConfig.ts (127 lines) ----------------------

import { injectable, inject } from "inversify";

import { ConfigService, ConfigSchema } from "@/server/infrastructure/config";
import { TYPES } from "@/server/infrastructure/di/types";

/**
 * Security configuration interface
 */
export interface SecurityConfig {
  jwtSecret: string;
  jwtRefreshSecret: string;
  signatureSecret: Buffer;
  passwordSalt: Buffer;
}

/**
 * Security configuration provider
 */
@injectable()
export class SecurityConfigProvider {
  private config: SecurityConfig;

  constructor(
    @inject(TYPES.ConfigService) private configService: ConfigService,
  ) {
    this.config = this.loadConfig();

    // Validate configuration
    this.configService.ensureValid(this.getConfigSchema());
  }

  /**
   * Gets the security configuration
   *
   * @returns Security configuration
   */
  getConfig(): SecurityConfig {
    return this.config;
  }

  /**
   * Gets the configuration schema for validation
   *
   * @returns Configuration schema
   */
  getConfigSchema(): ConfigSchema {
    return {
      properties: {
        JWT_SECRET: {
          type: "string",
          required: true,
          secret: true,
          description: "Secret key for JWT signing",
        },
        JWT_EXPIRES_IN: {
          type: "string",
          default: "1d",
          description: "JWT token expiration time",
        },
        JWT_REFRESH_EXPIRES_IN: {
          type: "string",
          default: "7d",
          description: "JWT refresh token expiration time",
        },
        PASSWORD_SALT_ROUNDS: {
          type: "number",
          default: 10,
          min: 1,
          max: 20,
          description: "Number of salt rounds for password hashing",
        },
        RATE_LIMIT_WINDOW: {
          type: "number",
          default: 15,
          min: 1,
          description: "Rate limit window in minutes",
        },
        RATE_LIMIT_MAX_REQUESTS: {
          type: "number",
          default: 100,
          min: 1,
          description: "Maximum number of requests per window",
        },
        CORS_ORIGIN: {
          type: "string",
          default: "*",
          description: "CORS allowed origin",
        },
        CORS_METHODS: {
          type: "string",
          default: "GET,POST,PUT,DELETE,OPTIONS",
          description: "CORS allowed methods",
        },
        CORS_HEADERS: {
          type: "string",
          default: "Content-Type,Authorization",
          description: "CORS allowed headers",
        },
        CORS_CREDENTIALS: {
          type: "boolean",
          default: true,
          description: "Whether to allow credentials in CORS",
        },
      },
    };
  }

  /**
   * Loads the security configuration from the config service
   *
   * @returns Security configuration
   */
  private loadConfig(): SecurityConfig {
    return {
      jwtSecret: this.configService.getRequired("JWT_SECRET"),
      jwtRefreshSecret: this.configService.getRequired("JWT_REFRESH_SECRET"),
      signatureSecret: Buffer.from(
        this.configService.getRequired("SIGNATURE_SECRET"),
        "utf8",
      ),
      passwordSalt: Buffer.from(
        this.configService.getRequired("PASSWORD_SALT"),
        "utf8",
      ),
    };
  }
}


// ---------------------- infrastructure\config\domain\ServerConfig.ts (146 lines) ----------------------

import { injectable, inject } from "inversify";

import { ConfigService, ConfigSchema } from "@/server/infrastructure/config";
import { TYPES } from "@/server/infrastructure/di/types";

/**
 * Server configuration interface
 */
export interface ServerConfig {
  port: number;
  host: string;
  baseUrl: string;
  environment: string;
  isDevelopment: boolean;
  isProduction: boolean;
  isTest: boolean;
  cors: {
    origin: string;
    origins: string[];
  };
  storagePath: string;
  tempPath: string;
}

/**
 * Server configuration provider
 */
@injectable()
export class ServerConfigProvider {
  private config: ServerConfig;

  constructor(
    @inject(TYPES.ConfigService) private configService: ConfigService,
  ) {
    this.config = this.loadConfig();

    // Validate configuration
    this.configService.ensureValid(this.getConfigSchema());
  }

  /**
   * Gets the server configuration
   *
   * @returns Server configuration
   */
  getConfig(): ServerConfig {
    return this.config;
  }

  /**
   * Gets the configuration schema for validation
   *
   * @returns Configuration schema
   */
  getConfigSchema(): ConfigSchema {
    return {
      properties: {
        PORT: {
          type: "number",
          default: 3000,
          min: 1,
          max: 65535,
          description: "Server port",
        },
        HOST: {
          type: "string",
          default: "0.0.0.0",
          description: "Server host",
        },
        NODE_ENV: {
          type: "string",
          default: "development",
          enum: ["development", "test", "production"],
          description: "Node environment",
        },
        LOG_LEVEL: {
          type: "string",
          default: "info",
          enum: ["error", "warn", "info", "debug", "trace"],
          description: "Logging level",
        },
        REQUEST_TIMEOUT: {
          type: "number",
          default: 30000,
          min: 1000,
          description: "Request timeout in milliseconds",
        },
        MAX_REQUEST_SIZE: {
          type: "string",
          default: "10mb",
          description: "Maximum request body size",
        },
        COMPRESSION_ENABLED: {
          type: "boolean",
          default: true,
          description: "Whether to enable response compression",
        },
        COMPRESSION_LEVEL: {
          type: "number",
          default: 6,
          min: 0,
          max: 9,
          description: "Compression level (0-9)",
        },
        KEEP_ALIVE_TIMEOUT: {
          type: "number",
          default: 120000,
          min: 1000,
          description: "Keep-alive timeout in milliseconds",
        },
        MAX_CONNECTIONS: {
          type: "number",
          default: 1000,
          min: 1,
          description: "Maximum number of concurrent connections",
        },
      },
    };
  }

  /**
   * Loads the server configuration from the config service
   *
   * @returns Server configuration
   */
  private loadConfig(): ServerConfig {
    return {
      port: this.configService.getNumber("PORT", 3003) as number,
      host: this.configService.get("HOST", "localhost") as string,
      baseUrl: this.configService.get(
        "BASE_URL",
        "http://localhost:3003",
      ) as string,
      environment: this.configService.get("NODE_ENV", "development") as string,
      isDevelopment: this.configService.isDevelopment(),
      isProduction: this.configService.isProduction(),
      isTest: this.configService.isTest(),
      cors: {
        origin: this.configService.get("CORS_ORIGIN", "*") as string,
        origins: this.configService.getArray("CORS_ORIGINS"),
      },
      storagePath: this.configService.get("STORAGE_PATH", "") as string,
      tempPath: this.configService.get("TEMP_PATH", "") as string,
    };
  }
}


// ---------------------- infrastructure\config\domain\StorageConfig.ts (219 lines) ----------------------

import * as path from "path";

import { injectable, inject } from "inversify";

import { ConfigService, ConfigSchema } from "@/server/infrastructure/config";
import { TYPES } from "@/server/infrastructure/di/types";

/**
 * Content detection configuration
 */
export interface ContentDetectionConfig {
  analyzeContent: boolean;
  maxBytesToAnalyze: number;
}

/**
 * Image optimization configuration
 */
export interface ImageOptimizationConfig {
  enabled: boolean;
  defaultQuality: number;
  maxDimensions?: {
    width: number;
    height: number;
  };
  defaultFormat?: "jpeg" | "png" | "webp" | "avif" | "original";
  stripMetadata: boolean;
}

/**
 * Stream processing configuration
 */
export interface StreamConfig {
  defaultChunkSize: number;
  defaultHighWaterMark: number;
}

/**
 * Storage configuration interface
 */
export interface StorageConfig {
  uploadDir: string;
  queuePath: string;
  tempDir: string;
  basePath: string;
  baseUrl?: string;
  contentDetection: ContentDetectionConfig;
  imageOptimization: ImageOptimizationConfig;
  streaming: StreamConfig;
}

/**
 * Storage configuration provider
 */
@injectable()
export class StorageConfigProvider {
  private config: StorageConfig;

  constructor(
    @inject(TYPES.ConfigService) private configService: ConfigService,
  ) {
    this.config = this.loadConfig();

    // Validate configuration
    this.configService.ensureValid(this.getConfigSchema());
  }

  /**
   * Gets the storage configuration
   *
   * @returns Storage configuration
   */
  getConfig(): StorageConfig {
    return this.config;
  }

  /**
   * Gets the configuration schema for validation
   *
   * @returns Configuration schema
   */
  getConfigSchema(): ConfigSchema {
    return {
      properties: {
        STORAGE_ANALYZE_CONTENT: {
          type: "boolean",
          default: false,
          description: "Whether to analyze file content",
        },
        STORAGE_MAX_BYTES_TO_ANALYZE: {
          type: "number",
          default: 4096,
          min: 1024,
          description:
            "Maximum number of bytes to analyze for content detection",
        },
        STORAGE_IMAGE_OPTIMIZATION_ENABLED: {
          type: "boolean",
          default: true,
          description: "Whether to optimize images",
        },
        STORAGE_IMAGE_DEFAULT_QUALITY: {
          type: "number",
          default: 80,
          min: 1,
          max: 100,
          description: "Default image quality (1-100)",
        },
        STORAGE_IMAGE_MAX_WIDTH: {
          type: "number",
          description: "Maximum image width",
          required: false,
        },
        STORAGE_IMAGE_MAX_HEIGHT: {
          type: "number",
          description: "Maximum image height",
          required: false,
        },
        STORAGE_IMAGE_DEFAULT_FORMAT: {
          type: "string",
          default: "webp",
          description: "Default image format for optimization",
        },
        STORAGE_IMAGE_STRIP_METADATA: {
          type: "boolean",
          default: true,
          description: "Whether to strip image metadata",
        },
        STORAGE_PATH: {
          type: "string",
          default: "./storage",
          description: "Storage root path",
        },
        STORAGE_URL: {
          type: "string",
          default: "https://storage.example.com",
          description: "Storage base URL",
        },
        UPLOAD_DIR: {
          type: "string",
          default: "./uploads",
          description: "Upload directory path",
        },
        QUEUE_PATH: {
          type: "string",
          default: "./queue",
          description: "Queue directory path",
        },
        TEMP_DIR: {
          type: "string",
          default: "./temp",
          description: "Temporary directory path",
        },
      },
    };
  }

  /**
   * Loads the storage configuration from the config service
   *
   * @returns Storage configuration
   */
  private loadConfig(): StorageConfig {
    this.configService.ensureValid(this.getConfigSchema());

    const maxWidth = this.configService.getNumber("STORAGE_IMAGE_MAX_WIDTH");
    const maxHeight = this.configService.getNumber("STORAGE_IMAGE_MAX_HEIGHT");

    const maxDimensions =
      maxWidth || maxHeight
        ? {
            width: maxWidth || 0,
            height: maxHeight || 0,
          }
        : undefined;

    const cwd = process.cwd();
    const uploadDir = this.configService.getString("UPLOAD_DIR") || "./uploads";
    const queuePath = this.configService.getString("QUEUE_PATH") || "./queue";
    const tempDir = this.configService.getString("TEMP_DIR") || "./temp";
    const basePath =
      this.configService.getString("STORAGE_PATH") || "./storage";

    // Don't join with cwd if path is absolute
    const resolvePath = (pathStr: string): string =>
      path.isAbsolute(pathStr) ? pathStr : path.join(cwd, pathStr);

    return {
      uploadDir: resolvePath(uploadDir),
      queuePath: resolvePath(queuePath),
      tempDir: resolvePath(tempDir),
      basePath: resolvePath(basePath),
      baseUrl: this.configService.getString("STORAGE_URL"),
      contentDetection: {
        analyzeContent:
          this.configService.getBoolean("STORAGE_ANALYZE_CONTENT") || false,
        maxBytesToAnalyze:
          this.configService.getNumber("STORAGE_MAX_BYTES_TO_ANALYZE") || 4096,
      },
      imageOptimization: {
        enabled:
          this.configService.getBoolean("STORAGE_IMAGE_OPTIMIZATION_ENABLED") ||
          true,
        defaultQuality:
          this.configService.getNumber("STORAGE_IMAGE_DEFAULT_QUALITY") || 80,
        maxDimensions,
        defaultFormat: (this.configService.getString(
          "STORAGE_IMAGE_DEFAULT_FORMAT",
        ) || "webp") as "jpeg" | "png" | "webp" | "avif" | "original",
        stripMetadata:
          this.configService.getBoolean("STORAGE_IMAGE_STRIP_METADATA") || true,
      },
      streaming: {
        defaultChunkSize: 65536,
        defaultHighWaterMark: 16384,
      },
    };
  }
}


// ---------------------- infrastructure\config\domain\index.ts (5 lines) ----------------------

export * from "./DatabaseConfig";
export * from "./EmailConfig";
export * from "./SecurityConfig";
export * from "./ServerConfig";
export * from "./StorageConfig";


// ---------------------- infrastructure\config\environments.ts (78 lines) ----------------------

import fs from "fs";
import path from "path";

import dotenv from "dotenv";

/**
 * Load environment files in order of priority
 */
export function loadEnvFiles(): void {
  const nodeEnv = process.env.NODE_ENV || "development";
  const envFiles = [
    `.env.${nodeEnv}.local`,
    `.env.${nodeEnv}`,
    ".env.local",
    ".env",
  ];

  const rootDir = process.cwd();
  const configDir = path.join(
    rootDir,
    "src",
    "server",
    "infrastructure",
    "config",
  );
  const loadedFiles: string[] = [];

  // Check both the root directory and the config directory
  for (const file of envFiles) {
    // Try in config directory first
    const configFilePath = path.join(configDir, file);
    if (fs.existsSync(configFilePath)) {
      dotenv.config({ path: configFilePath });
      loadedFiles.push(`config/${file}`);
      continue;
    }

    // Then try in root directory
    const rootFilePath = path.join(rootDir, file);
    if (fs.existsSync(rootFilePath)) {
      dotenv.config({ path: rootFilePath });
      loadedFiles.push(file);
    }
  }

  if (loadedFiles.length > 0) {
    console.log(`Loaded environment files: ${loadedFiles.join(", ")}`);
  } else {
    console.log(`No environment files found in ${rootDir} or ${configDir}`);
  }
}

// Load environment files on module import
loadEnvFiles();

/**
 * Check if the application is running in development mode
 */
export function isDevelopment(): boolean {
  return (process.env.NODE_ENV || "development") === "development";
}

/**
 * Check if the application is running in production mode
 */
export function isProduction(): boolean {
  return process.env.NODE_ENV === "production";
}

/**
 * Check if the application is running in test mode
 */
export function isTest(): boolean {
  return process.env.NODE_ENV === "test";
}

// Re-export process.env for convenience and type safety
export const env = process.env;


// ---------------------- infrastructure\config\index.ts (32 lines) ----------------------

// Core configuration
export type { IConfigService } from "./IConfigService";
export { ConfigService } from "./ConfigService";
export type {
  ConfigSchema,
  ConfigSchemaField,
  ValidatedConfig,
} from "./ConfigSchema";
export { ConfigValidationError } from "@/server/infrastructure/errors/infrastructure/ConfigValidationError";

// Environment utilities
export { isDevelopment, isProduction, isTest } from "./environments";

// Secret management
export type { SecretProvider } from "./secrets/SecretProvider";
export { FileSecretProvider } from "./secrets/FileSecretProvider";
export { EnvSecretProvider } from "./secrets/EnvSecretProvider";
export { InMemorySecretProvider } from "./secrets/InMemorySecretProvider";

// Domain-specific configuration
export type {
  DatabaseConfig,
  DatabaseConfigProvider,
} from "./domain/DatabaseConfig";
export type { ServerConfig, ServerConfigProvider } from "./domain/ServerConfig";
export type { StorageConfig } from "./domain/StorageConfig";
export { StorageConfigProvider } from "./domain/StorageConfig";
export type {
  SecurityConfig,
  SecurityConfigProvider,
} from "./domain/SecurityConfig";
export type { EmailConfig, EmailConfigProvider } from "./domain/EmailConfig";


// ---------------------- infrastructure\config\secrets\EnvSecretProvider.ts (86 lines) ----------------------

import { injectable, inject, optional } from "inversify";

import { TYPES } from "@/server/infrastructure/di/types";

import { SecretProvider } from "./SecretProvider";

import type { ILoggerService } from "../../logging";

/**
 * Environment variable-based secret provider
 *
 * This provider retrieves secrets from environment variables,
 * optionally with a prefix to distinguish them from regular config values.
 */
@injectable()
export class EnvSecretProvider implements SecretProvider {
  private logger: ILoggerService;

  /**
   * Creates a new EnvSecretProvider instance
   *
   * @param prefix Optional prefix for secret environment variables
   * @param loggerService Optional logger service
   */
  constructor(
    private prefix: string = "",
    @inject(TYPES.LoggerService) @optional() loggerService?: ILoggerService,
  ) {
    this.logger = loggerService?.createLogger("EnvSecretProvider") || {
      debug: console.debug,
      info: console.info,
      warn: console.warn,
      error: console.error,
      // Minimal implementation for other required methods
      createLogger: () => this.logger,
      withContext: () => this.logger,
      debugObj: () => {},
      infoObj: () => {},
      warnObj: () => {},
      errorObj: () => {},
      addTransport: () => {},
      setTransports: () => {},
      setMinLevel: () => {},
      initialize: async () => {},
      shutdown: async () => {},
    };
  }

  /**
   * Checks if this provider supports a specific secret
   *
   * @param key Secret key
   * @returns True if the provider supports the secret
   */
  async supportsSecret(key: string): Promise<boolean> {
    const envKey = this.getEnvKey(key);
    return envKey in process.env;
  }

  /**
   * Gets a secret value
   *
   * @param key Secret key
   * @returns Secret value or undefined if not found
   */
  async getSecret(key: string): Promise<string | undefined> {
    const envKey = this.getEnvKey(key);
    const value = process.env[envKey];

    if (value !== undefined) {
      this.logger.debug(`Retrieved secret from environment: ${envKey}`);
    }

    return value;
  }

  /**
   * Gets the environment variable key for a secret
   *
   * @param key Secret key
   * @returns Environment variable key
   */
  private getEnvKey(key: string): string {
    return this.prefix ? `${this.prefix}_${key}` : key;
  }
}


// ---------------------- infrastructure\config\secrets\FileSecretProvider.ts (116 lines) ----------------------

import * as fs from "fs";
import * as path from "path";

import { injectable, inject, optional } from "inversify";

import { TYPES } from "@/server/infrastructure/di/types";

import { SecretProvider } from "./SecretProvider";

import type { ILoggerService } from "../../logging";

/**
 * File-based secret provider that reads secrets from a JSON file
 */
@injectable()
export class FileSecretProvider implements SecretProvider {
  private secrets: Record<string, string> = {};
  private loaded = false;
  private logger: ILoggerService;

  /**
   * Creates a new FileSecretProvider instance
   *
   * @param secretsFilePath Path to the secrets file
   * @param loggerService Optional logger service
   */
  constructor(
    private secretsFilePath: string,
    @inject(TYPES.LoggerService) @optional() loggerService?: ILoggerService,
  ) {
    this.logger = loggerService?.createLogger("FileSecretProvider") || {
      debug: console.debug,
      info: console.info,
      warn: console.warn,
      error: console.error,
      // Minimal implementation for other required methods
      createLogger: () => this.logger,
      withContext: () => this.logger,
      debugObj: () => {},
      infoObj: () => {},
      warnObj: () => {},
      errorObj: () => {},
      addTransport: () => {},
      setTransports: () => {},
      setMinLevel: () => {},
      initialize: async () => {},
      shutdown: async () => {},
    };
  }

  /**
   * Initializes the provider by loading secrets from file
   */
  async initialize(): Promise<void> {
    if (this.loaded) {
      return;
    }

    try {
      // Check both absolute path and relative to current working directory
      const filePath = path.isAbsolute(this.secretsFilePath)
        ? this.secretsFilePath
        : path.resolve(process.cwd(), this.secretsFilePath);

      if (!fs.existsSync(filePath)) {
        this.logger.warn(`Secrets file not found: ${filePath}`);
        return;
      }

      const content = fs.readFileSync(filePath, "utf8");
      try {
        this.secrets = JSON.parse(content);
        this.loaded = true;
        this.logger.info(`Loaded secrets from: ${filePath}`);
      } catch (parseError) {
        this.logger.error(
          `Failed to parse secrets file ${filePath}: ${
            parseError instanceof Error
              ? parseError.message
              : String(parseError)
          }`,
        );
      }
    } catch (error) {
      this.logger.error(
        `Failed to load secrets: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Checks if this provider supports a specific secret
   *
   * @param key Secret key
   * @returns True if the provider supports the secret
   */
  async supportsSecret(key: string): Promise<boolean> {
    if (!this.loaded) {
      await this.initialize();
    }
    return key in this.secrets;
  }

  /**
   * Gets a secret value
   *
   * @param key Secret key
   * @returns Secret value or undefined if not found
   */
  async getSecret(key: string): Promise<string | undefined> {
    if (!this.loaded) {
      await this.initialize();
    }
    return this.secrets[key];
  }
}


// ---------------------- infrastructure\config\secrets\InMemorySecretProvider.ts (74 lines) ----------------------

import { injectable } from "inversify";

import { SecretProvider } from "./SecretProvider";

/**
 * In-memory secret provider for testing and development
 */
@injectable()
export class InMemorySecretProvider implements SecretProvider {
  private secrets: Map<string, string> = new Map();

  /**
   * Creates a new InMemorySecretProvider instance
   *
   * @param initialSecrets Optional initial secrets
   */
  constructor(initialSecrets?: Record<string, string>) {
    if (initialSecrets) {
      for (const [key, value] of Object.entries(initialSecrets)) {
        this.secrets.set(key, value);
      }
    }
  }

  /**
   * Sets a secret value
   *
   * @param key Secret key
   * @param value Secret value
   */
  setSecret(key: string, value: string): void {
    this.secrets.set(key, value);
  }

  /**
   * Checks if this provider supports a specific secret
   *
   * @param key Secret key
   * @returns True if the provider supports the secret
   */
  async supportsSecret(key: string): Promise<boolean> {
    return this.secrets.has(key);
  }

  /**
   * Gets a secret value
   *
   * @param key Secret key
   * @returns Secret value or undefined if not found
   */
  async getSecret(key: string): Promise<string | undefined> {
    return this.secrets.get(key);
  }

  /**
   * Clears all secrets
   */
  clear(): void {
    this.secrets.clear();
  }

  /**
   * Gets all secrets
   *
   * @returns All secrets
   */
  getAllSecrets(): Record<string, string> {
    const result: Record<string, string> = {};
    for (const [key, value] of this.secrets.entries()) {
      result[key] = value;
    }
    return result;
  }
}


// ---------------------- infrastructure\config\secrets\SecretProvider.ts (34 lines) ----------------------

/**
 * Base interface for secret providers
 *
 * Secret providers are responsible for retrieving sensitive configuration values
 * from external sources such as environment variables, key vaults, or files.
 */
export interface SecretProvider {
  /**
   * Initializes the secret provider
   *
   * This method is called before any secrets are retrieved, and should
   * perform any necessary setup, like loading secrets from a file or
   * connecting to a key vault.
   *
   * @returns A promise that resolves when initialization is complete
   */
  initialize?(): Promise<void>;

  /**
   * Checks if this provider supports a specific secret
   *
   * @param key Secret key
   * @returns True if the provider supports the secret
   */
  supportsSecret(key: string): Promise<boolean>;

  /**
   * Gets a secret value
   *
   * @param key Secret key
   * @returns Secret value or undefined if not found
   */
  getSecret(key: string): Promise<string | undefined>;
}


// ---------------------- infrastructure\config\secrets\index.ts (4 lines) ----------------------

export * from "./EnvSecretProvider";
export * from "./FileSecretProvider";
export * from "./InMemorySecretProvider";
export * from "./SecretProvider";


// ---------------------- infrastructure\database\DatabaseConfigProvider.ts (91 lines) ----------------------

import { injectable, inject } from "inversify";

import { ConfigService } from "@/server/infrastructure/config";
import { TYPES } from "@/server/infrastructure/di/types";

/**
 * Database configuration interface
 */
export interface DatabaseConfig {
  connectionString: string;
  host: string;
  port: number;
  database: string;
  user: string;
  password: string;
  maxConnections: number;
  idleTimeout: number;
  connectionTimeout: number;
  statementTimeout: number;
  ssl?: boolean | { rejectUnauthorized: boolean };
  metricsMaxSamples: number;
}

/**
 * Database configuration provider
 */
@injectable()
export class DatabaseConfigProvider {
  private config: DatabaseConfig;

  constructor(
    @inject(TYPES.ConfigService) private configService: ConfigService,
  ) {
    this.config = this.loadConfig();
    // No validation needed here
  }

  /**
   * Gets the database configuration
   *
   * @returns Database configuration
   */
  public getConfig(): DatabaseConfig {
    // No validation needed here either
    return this.config;
  }

  /**
   * Loads the database configuration from the config service
   *
   * @returns Database configuration
   */
  private loadConfig(): DatabaseConfig {
    // Get values from environment or use defaults
    const host = this.configService.getString("DB_HOST", "localhost");
    const port = this.configService.getNumber("DB_PORT", 5432);
    const database = this.configService.getString("DB_NAME", "abe_stack");
    const user = this.configService.getString("DB_USER", "postgres");
    const password = this.configService.getString("DB_PASSWORD", "postgres");

    // Fall back to connection string if individual values are not set
    const connectionString = this.configService.getString(
      "DATABASE_URL",
      `postgresql://${user}:${password}@${host}:${port}/${database}`,
    );

    return {
      connectionString,
      host,
      port,
      database,
      user,
      password,
      maxConnections: this.configService.getNumber("DB_MAX_CONNECTIONS", 20),
      idleTimeout: this.configService.getNumber("DB_IDLE_TIMEOUT", 30000),
      connectionTimeout: this.configService.getNumber(
        "DB_CONNECTION_TIMEOUT",
        5000,
      ),
      statementTimeout: this.configService.getNumber(
        "DB_STATEMENT_TIMEOUT",
        30000,
      ),
      ssl: this.configService.getBoolean("DB_SSL", false),
      metricsMaxSamples: this.configService.getNumber(
        "DB_METRICS_MAX_SAMPLES",
        1000,
      ),
    };
  }
}


// ---------------------- infrastructure\database\DatabaseServer.ts (938 lines) ----------------------

import { injectable, inject } from "inversify";
import { Pool, PoolClient, QueryResult, QueryResultRow } from "pg";

import { DatabaseConfigProvider } from "@/server/infrastructure/config/domain/DatabaseConfig";
import { TYPES } from "@/server/infrastructure/di/types";
import type { ILoggerService } from "@/server/infrastructure/logging";

import {
  IDatabaseServer,
  ConnectionStats,
  QueryOptions,
  TransactionOptions,
  QueryBuilder,
} from "./IDatabaseServer";

/**
 * Default transaction retry options
 */
const DEFAULT_TRANSACTION_OPTIONS: Required<TransactionOptions> = {
  maxRetries: 0,
  retryDelay: 100,
  retryDelayMultiplier: 1.5,
  maxRetryDelay: 5000,
  isolationLevel: "READ COMMITTED",
  timeout: 0,
  shouldRetry: (error: unknown): boolean => {
    if (error instanceof Error) {
      // Retry on serialization failure (23000) and deadlock (40P01)
      const errorCode = (error as { code?: string }).code;
      return (
        errorCode === "40001" || // serialization_failure
        errorCode === "40P01" || // deadlock_detected
        errorCode === "55P03" || // lock_not_available
        /deadlock|serialize|timeout|connection/i.test(error.message)
      );
    }
    return false;
  },
};

/**
 * Database service that focuses on core database operations
 * Provides connection management, query execution, and transaction support with retries
 */
@injectable()
export class DatabaseServer implements IDatabaseServer {
  private pool: Pool | null = null;
  private connected = false;
  private logger: ReturnType<ILoggerService["createLogger"]>;
  private databaseConfig: ReturnType<DatabaseConfigProvider["getConfig"]>;

  // Metrics tracking
  private metrics = {
    acquireCount: 0,
    acquireFailCount: 0,
    acquireTimes: [] as number[],
    queryCount: 0,
    queryFailCount: 0,
    queryTimes: [] as { time: number; tag?: string }[],
    taggedQueryTimes: new Map<string, number[]>(),
  };

  constructor(
    @inject(TYPES.LoggerService) loggerService: ILoggerService,
    @inject(TYPES.DatabaseConfig) configProvider: DatabaseConfigProvider,
  ) {
    this.logger = loggerService.createLogger("DatabaseServer");
    this.databaseConfig = configProvider.getConfig();
  }

  /**
   * Initialize the database connection
   */
  async initialize(skipConnectionTest = false): Promise<void> {
    if (this.pool) {
      return;
    }

    try {
      try {
        this.logger.info("Initializing database connection", {
          host: this.databaseConfig.host,
          port: this.databaseConfig.port,
          database: this.databaseConfig.database,
          user: this.databaseConfig.user,
        });
      } catch (error) {
        // Silently ignore any logger errors
        console.warn("Logger error:", error);
      }

      // Create connection pool
      this.pool = new Pool({
        host: this.databaseConfig.host,
        port: this.databaseConfig.port,
        database: this.databaseConfig.database,
        user: this.databaseConfig.user,
        password: this.databaseConfig.password,
        max: this.databaseConfig.maxConnections,
        idleTimeoutMillis: this.databaseConfig.idleTimeout,
        connectionTimeoutMillis: this.databaseConfig.connectionTimeout,
        statement_timeout: this.databaseConfig.statementTimeout,
        ssl: this.databaseConfig.ssl,
      });

      // Skip the connection test during testing to avoid actual database connections
      if (!skipConnectionTest && typeof this.pool.connect === "function") {
        // Test the connection
        const client = await this.pool.connect();
        await client.query("SELECT NOW()");
        try {
          this.logger.info("Database connection successful");
        } catch (error) {
          // Silently ignore any logger errors
          console.warn("Logger error:", error);
        }
        client.release();
      }

      // Track acquire times
      if (typeof this.pool.connect === "function") {
        const originalConnect = this.pool.connect.bind(this.pool);
        this.pool.connect = async () => {
          const startTime = Date.now();
          try {
            this.metrics.acquireCount++;
            const client = await originalConnect();
            const acquireTime = Date.now() - startTime;
            this.metrics.acquireTimes.push(acquireTime);
            return client;
          } catch (error) {
            this.metrics.acquireFailCount++;
            try {
              this.logger.error("Failed to acquire database connection", {
                error,
              });
            } catch (error) {
              // Silently ignore any logger errors
              console.warn("Logger error:", error);
            }
            throw error;
          }
        };
      }

      this.connected = true;
    } catch (error) {
      try {
        this.logger.error("Failed to initialize database connection", {
          error,
        });
      } catch (error) {
        // Silently ignore any logger errors
        console.warn("Logger error:", error);
      }
      throw error;
    }
  }

  /**
   * Check if the database is connected
   */
  isConnected(): boolean {
    return this.connected;
  }

  /**
   * Close the database connection
   */
  async close(): Promise<void> {
    if (!this.pool) {
      return;
    }

    try {
      try {
        this.logger.info("Closing database connection");
      } catch (error) {
        // Silently ignore any logger errors
        console.warn("Logger error:", error);
      }

      if (this.pool && typeof this.pool.end === "function") {
        await this.pool.end();
      }

      this.pool = null;
      this.connected = false;
      try {
        this.logger.info("Database connection closed");
      } catch (error) {
        // Silently ignore any logger errors
        console.warn("Logger error:", error);
      }
    } catch (error) {
      try {
        this.logger.error("Error closing database connection", {
          error: error instanceof Error ? error.message : String(error),
        });
      } catch (error) {
        // Silently ignore any logger errors
        console.warn("Logger error:", error);
      }
      throw error;
    }
  }

  /**
   * Get a client from the connection pool
   * @returns A promise that resolves with a database client
   */
  async connect(): Promise<PoolClient> {
    await this.ensureInitialized(true);

    if (!this.pool) {
      throw new Error("Database pool is not initialized");
    }

    try {
      return await this.pool.connect();
    } catch (error) {
      return this.handleError(error, "Failed to acquire client from pool");
    }
  }

  /**
   * Execute a SQL query
   */
  async query<T extends QueryResultRow = QueryResultRow>(
    text: string,
    params: unknown[] = [],
    options: QueryOptions = {},
  ): Promise<QueryResult<T>> {
    await this.ensureInitialized(true);

    const startTime = Date.now();
    const tag = options.tag || this.extractQueryTag(text);
    const maxRetries = options.maxRetries || 2;
    let lastError: Error | unknown;
    let attemptCount = 0;

    while (attemptCount <= maxRetries) {
      try {
        // Set statement timeout if provided
        if (options.timeout || this.databaseConfig.statementTimeout) {
          if (this.pool && typeof this.pool.query === "function") {
            await this.pool!.query(
              `SET statement_timeout = ${options.timeout || this.databaseConfig.statementTimeout}`,
            );
          }
        }

        const queryConfig: import("pg").QueryConfig<unknown[]> = {
          text,
          values: params,
        };

        // Skip actual query during testing if the pool doesn't have a query method
        let result: QueryResult<T>;
        if (this.pool && typeof this.pool.query === "function") {
          result = await this.pool!.query<T>(queryConfig);
        } else {
          // During testing, return a mock result
          result = {
            rows: [] as T[],
            rowCount: 0,
            command: "SELECT",
            oid: 0,
            fields: [],
          };
        }

        // Track query metrics
        this.metrics.queryCount++;
        const queryTime = Date.now() - startTime;
        this.metrics.queryTimes.push({ time: queryTime, tag });

        // Track query time by tag if present
        if (tag) {
          if (!this.metrics.taggedQueryTimes.has(tag)) {
            this.metrics.taggedQueryTimes.set(tag, []);
          }
          this.metrics.taggedQueryTimes.get(tag)!.push(queryTime);
        }

        // Cap the number of samples to prevent memory leaks
        if (
          this.metrics.queryTimes.length > this.databaseConfig.metricsMaxSamples
        ) {
          this.metrics.queryTimes = this.metrics.queryTimes.slice(
            -this.databaseConfig.metricsMaxSamples,
          );
        }

        return result;
      } catch (error) {
        lastError = error;
        this.metrics.queryFailCount++;
        try {
          this.logger.error("Query execution failed", {
            error: error instanceof Error ? error.message : String(error),
            query: text,
            params,
            tag,
            attempt: attemptCount + 1,
            maxRetries,
          });
        } catch (error) {
          // Silently ignore any logger errors
          console.warn("Logger error:", error);
        }

        // Check if we should retry
        if (attemptCount < maxRetries && this.shouldRetryQuery(error)) {
          attemptCount++;
          await this.delay(Math.pow(2, attemptCount) * 100); // Exponential backoff
          continue;
        }
        throw error;
      }
    }

    throw lastError;
  }

  private shouldRetryQuery(error: unknown): boolean {
    if (error instanceof Error) {
      // Retry on connection errors and deadlocks
      return /connection|deadlock|timeout/i.test(error.message);
    }
    return false;
  }

  private delay(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  private formatError(error: unknown, context: string): Error {
    if (error instanceof Error) {
      return error;
    }
    return new Error(`${context}: ${String(error)}`);
  }

  private handleError(error: unknown, context: string): never {
    const formattedError = this.formatError(error, context);
    try {
      this.logger.error(context, {
        error: formattedError.message,
      });
    } catch (error) {
      // Silently ignore any logger errors
      console.warn("Logger error:", error);
    }
    throw formattedError;
  }

  /**
   * Execute a function with a database client
   */
  async withClient<T>(
    callback: (client: PoolClient) => Promise<T>,
  ): Promise<T> {
    await this.ensureInitialized(true);

    let client: PoolClient;
    try {
      if (this.pool && typeof this.pool.connect === "function") {
        client = await this.pool!.connect();
      } else {
        // During testing, create a mock client that passes through queries
        const mockClient = {
          query: async (
            _text: string | { text: string; values: unknown[] },
            _values?: unknown[],
          ) => {
            // Support both formats: query(text, values) and query({ text, values })

            // If in a test context where we have access to jest, use a mock implementation
            if (typeof jest !== "undefined") {
              return Promise.resolve({ rows: [], rowCount: 0 });
            }

            // Default mock implementation
            return Promise.resolve({ rows: [], rowCount: 0 });
          },
          release: () => {},
        };
        client = mockClient as unknown as PoolClient;
      }
    } catch (error) {
      return this.handleError(error, "Failed to acquire client from pool");
    }

    try {
      const result = await callback(client);
      return result;
    } finally {
      try {
        client.release();
      } catch (error) {
        this.logger.error("Error releasing client", {
          error: error instanceof Error ? error.message : String(error),
        });
      }
    }
  }

  /**
   * Execute a function within a transaction with optional retries
   */
  async withTransaction<T>(
    callback: (client: PoolClient) => Promise<T>,
    options?: TransactionOptions,
  ): Promise<T> {
    const opts = this.mergeTransactionOptions(options);
    let lastError: Error | unknown;
    let attemptCount = 0;
    let delay = opts.retryDelay;

    while (attemptCount <= opts.maxRetries) {
      attemptCount++;

      try {
        const result = await this.executeTransaction(callback, opts);

        // If successful after retries, log it
        if (attemptCount > 1) {
          try {
            this.logger.info(
              `Transaction succeeded after ${attemptCount} attempts`,
            );
          } catch (error) {
            // Silently ignore any logger errors
            console.warn("Logger error:", error);
          }
        }

        return result;
      } catch (error) {
        lastError = error;

        // Check if we should retry
        const shouldRetry =
          attemptCount <= opts.maxRetries && opts.shouldRetry(error);

        if (shouldRetry) {
          try {
            this.logger.warn(
              `Transaction failed (attempt ${attemptCount}/${opts.maxRetries + 1}), retrying in ${delay}ms`,
              {
                error: error instanceof Error ? error.message : String(error),
              },
            );
          } catch (error) {
            // Silently ignore any logger errors
            console.warn("Logger error:", error);
          }

          // Wait before retrying
          await new Promise((resolve) => setTimeout(resolve, delay));

          // Increase delay with exponential backoff
          delay = Math.min(
            delay * opts.retryDelayMultiplier,
            opts.maxRetryDelay,
          );
        } else {
          // No more retries or non-retryable error
          break;
        }
      }
    }

    // If we get here, all retries failed
    try {
      this.logger.error(`Transaction failed after ${attemptCount} attempt(s)`, {
        error:
          lastError instanceof Error ? lastError.message : String(lastError),
      });
    } catch (error) {
      // Silently ignore any logger errors
      console.warn("Logger error:", error);
    }

    throw lastError;
  }

  /**
   * Execute a single transaction attempt
   */
  private async executeTransaction<T>(
    callback: (client: PoolClient) => Promise<T>,
    options: Required<TransactionOptions>,
  ): Promise<T> {
    return this.withClient(async (client) => {
      // Begin transaction with isolation level if specified
      let beginCommand = "BEGIN";
      if (options.isolationLevel) {
        beginCommand += ` ISOLATION LEVEL ${options.isolationLevel}`;
      }

      // Set statement timeout if specified
      if (options.timeout) {
        await client.query(`SET LOCAL statement_timeout = ${options.timeout}`);
      }

      try {
        await client.query(beginCommand);
        const result = await callback(client);
        await client.query("COMMIT");
        return result;
      } catch (error) {
        await client.query("ROLLBACK");
        throw error;
      }
    });
  }

  /**
   * Get connection statistics and metrics
   */
  getStats(reset: boolean = false): ConnectionStats {
    // Default values for the pool stats
    let poolStats = {
      totalCount: 0,
      idleCount: 0,
      activeCount: 0,
      waitingCount: 0,
    };

    // Try to get real pool stats if available
    if (this.pool) {
      const typedPool = this.pool as Pool & {
        totalCount?: number;
        idleCount?: number;
        activeCount?: number;
        waitingCount?: number;
      };

      poolStats = {
        totalCount: typedPool.totalCount ?? 0,
        idleCount: typedPool.idleCount ?? 0,
        activeCount: typedPool.activeCount ?? 0,
        waitingCount: typedPool.waitingCount ?? 0,
      };
    }

    // Calculate metrics from samples
    const avgAcquireTime = this.calculateAverage(this.metrics.acquireTimes);
    const maxAcquireTime = this.calculateMax(this.metrics.acquireTimes);

    const queryTimes = this.metrics.queryTimes.map((q) => q.time);
    const avgQueryTime = this.calculateAverage(queryTimes);
    const maxQueryTime = this.calculateMax(queryTimes);

    const stats = {
      totalCount: poolStats.totalCount,
      idleCount: poolStats.idleCount,
      activeCount: poolStats.activeCount,
      waitingCount: poolStats.waitingCount,
      maxConnections: this.databaseConfig.maxConnections,
      utilization:
        poolStats.totalCount > 0
          ? poolStats.activeCount / this.databaseConfig.maxConnections
          : 0,
      acquireCount: this.metrics.acquireCount,
      acquireFailCount: this.metrics.acquireFailCount,
      avgAcquireTime,
      maxAcquireTime,
      queryCount: this.metrics.queryCount,
      queryFailCount: this.metrics.queryFailCount,
      avgQueryTime,
      maxQueryTime,
    };

    if (reset) {
      this.resetMetrics();
    }

    return stats;
  }

  /**
   * Reset metrics tracking
   */
  resetMetrics(): void {
    this.metrics = {
      acquireCount: 0,
      acquireFailCount: 0,
      acquireTimes: [],
      queryCount: 0,
      queryFailCount: 0,
      queryTimes: [],
      taggedQueryTimes: new Map(),
    };
  }

  /**
   * Reset the database connection
   * This is primarily used for testing
   */
  async reset(): Promise<void> {
    try {
      try {
        this.logger.info("Resetting database connection");
      } catch (error) {
        // Silently ignore any logger errors
        console.warn("Logger error:", error);
      }
      this.resetMetrics();
      await this.close();
      await this.initialize();
      try {
        this.logger.info("Database connection reset");
      } catch (error) {
        // Silently ignore any logger errors
        console.warn("Logger error:", error);
      }
    } catch (error) {
      try {
        this.logger.error("Error resetting database connection", {
          error: error instanceof Error ? error.message : String(error),
        });
      } catch (error) {
        // Silently ignore any logger errors
        console.warn("Logger error:", error);
      }
      throw error;
    }
  }

  /**
   * Ensure the database is initialized
   */
  private async ensureInitialized(skipConnectionTest = true): Promise<void> {
    if (!this.pool) {
      await this.initialize(skipConnectionTest);
    }
  }

  /**
   * Calculate average from an array of numbers
   */
  private calculateAverage(values: number[]): number {
    if (values.length === 0) return 0;
    const sum = values.reduce((acc, val) => acc + val, 0);
    return Math.round(sum / values.length);
  }

  /**
   * Calculate maximum from an array of numbers
   */
  private calculateMax(values: number[]): number {
    if (values.length === 0) return 0;
    return Math.max(...values);
  }

  /**
   * Merge provided transaction options with defaults
   */
  private mergeTransactionOptions(
    options?: TransactionOptions,
  ): Required<TransactionOptions> {
    if (!options) return DEFAULT_TRANSACTION_OPTIONS;

    return {
      ...DEFAULT_TRANSACTION_OPTIONS,
      ...options,
    };
  }

  /**
   * Extract a meaningful tag from a SQL query if not provided
   */
  private extractQueryTag(sql: string): string | undefined {
    // Extract the first few words to create a tag
    const match = sql
      .trim()
      .match(
        /^(SELECT|INSERT|UPDATE|DELETE|CREATE|ALTER|DROP|TRUNCATE)\s+(?:INTO|FROM|TABLE)?\s+(?:IF\s+EXISTS\s+)?(?:([a-zA-Z0-9_"]+)\.)?([a-zA-Z0-9_"]+)/i,
      );

    if (match) {
      const [, action, schema, table] = match;
      if (table) {
        return `${action.toUpperCase()}-${schema ? `${schema}.` : ""}${table}`;
      }
    }

    return undefined;
  }

  /**
   * Create a query builder for constructing complex SQL queries
   * @param tableName The name of the table to query
   * @returns A QueryBuilder instance
   */
  createQueryBuilder(tableName: string): QueryBuilder {
    return new QueryBuilderImpl(tableName, this);
  }
}

/**
 * Implementation of the QueryBuilder interface for constructing SQL queries
 */
class QueryBuilderImpl implements QueryBuilder {
  private table: string;
  private db: DatabaseServer;
  private selectCols: string[] = ["*"];
  private whereClauses: { condition: string; params: unknown[] }[] = [];
  private joinClauses: string[] = [];
  private groupByCols: string[] = [];
  private orderByClauses: string[] = [];
  private limitValue?: number;
  private offsetValue?: number;

  constructor(tableName: string, db: DatabaseServer) {
    this.table = tableName;
    this.db = db;
  }

  /**
   * Specify columns to select
   * @param columns Columns to select
   */
  select(columns: string | string[]): QueryBuilder {
    this.selectCols = Array.isArray(columns) ? columns : [columns];
    return this;
  }

  /**
   * Add a WHERE condition to the query
   * @param condition The SQL condition
   * @param params Parameters for the condition
   */
  where(condition: string, ...params: unknown[]): QueryBuilder {
    // Replace ? placeholders with $1, $2, etc. to match PostgreSQL parameter format
    const parsedCondition = condition.replace(/\?/g, (_match, index) => {
      return `$${index + 1}`;
    });
    this.whereClauses.push({ condition: parsedCondition, params });
    return this;
  }

  /**
   * Add a JOIN clause to the query
   * @param table The table to join
   * @param condition The join condition
   */
  join(table: string, condition: string): QueryBuilder {
    this.joinClauses.push(`JOIN ${table} ON ${condition}`);
    return this;
  }

  /**
   * Add a LEFT JOIN clause to the query
   * @param table The table to join
   * @param condition The join condition
   */
  leftJoin(table: string, condition: string): QueryBuilder {
    this.joinClauses.push(`LEFT JOIN ${table} ON ${condition}`);
    return this;
  }

  /**
   * Add a GROUP BY clause to the query
   * @param columns Columns to group by
   */
  groupBy(columns: string | string[]): QueryBuilder {
    this.groupByCols = this.groupByCols.concat(
      Array.isArray(columns) ? columns : [columns],
    );
    return this;
  }

  /**
   * Add an ORDER BY clause to the query
   * @param column Column to order by
   * @param direction Sort direction
   */
  orderBy(column: string, direction: "ASC" | "DESC" = "ASC"): QueryBuilder {
    this.orderByClauses.push(`${column} ${direction}`);
    return this;
  }

  /**
   * Set a LIMIT on the query
   * @param limit Maximum number of rows to return
   */
  limit(limit: number): QueryBuilder {
    this.limitValue = limit;
    return this;
  }

  /**
   * Set an OFFSET on the query
   * @param offset Number of rows to skip
   */
  offset(offset: number): QueryBuilder {
    this.offsetValue = offset;
    return this;
  }

  /**
   * Execute the SELECT query
   * @param options Query options
   */
  async execute<T extends QueryResultRow = QueryResultRow>(
    options: QueryOptions = {},
  ): Promise<QueryResult<T>> {
    const { sql, params } = this.buildQuery();
    return this.db.query<T>(sql, params, options);
  }

  /**
   * Execute the query and return the first result
   * @param options Query options
   */
  async getOne<T extends QueryResultRow = QueryResultRow>(
    options: QueryOptions = {},
  ): Promise<T | null> {
    const result = await this.limit(1).execute<T>(options);
    return result.rows.length > 0 ? result.rows[0] : null;
  }

  /**
   * Execute the query and return all results
   * @param options Query options
   */
  async getMany<T extends QueryResultRow = QueryResultRow>(
    options: QueryOptions = {},
  ): Promise<T[]> {
    const result = await this.execute<T>(options);
    return result.rows;
  }

  /**
   * Count the number of rows matching the query
   * @param options Query options
   */
  async count(options: QueryOptions = {}): Promise<number> {
    // Save current select columns and then override
    const originalSelect = [...this.selectCols];
    this.selectCols = ["COUNT(*) as count"];

    // Remove order by, limit and offset for count queries
    const originalOrderBy = [...this.orderByClauses];
    const originalLimit = this.limitValue;
    const originalOffset = this.offsetValue;
    this.orderByClauses = [];
    this.limitValue = undefined;
    this.offsetValue = undefined;

    try {
      const { sql, params } = this.buildQuery();
      const result = await this.db.query<{ count: string }>(
        sql,
        params,
        options,
      );
      return parseInt(result.rows[0]?.count || "0", 10);
    } finally {
      // Restore original query parts
      this.selectCols = originalSelect;
      this.orderByClauses = originalOrderBy;
      this.limitValue = originalLimit;
      this.offsetValue = originalOffset;
    }
  }

  /**
   * Build the SQL query and parameters
   * @returns The SQL query and parameters
   */
  buildQuery(): { sql: string; params: unknown[] } {
    const parts: string[] = [];
    let allParams: unknown[] = [];
    let paramCounter = 1;

    // SELECT clause
    parts.push(`SELECT ${this.selectCols.join(", ")}`);

    // FROM clause
    parts.push(`FROM ${this.table}`);

    // JOIN clauses
    if (this.joinClauses.length > 0) {
      parts.push(this.joinClauses.join(" "));
    }

    // WHERE clauses
    if (this.whereClauses.length > 0) {
      const whereConditions = this.whereClauses.map(({ condition, params }) => {
        // Add params to the all params array
        allParams = allParams.concat(params);

        // Update the condition to use the correct parameter index
        const updatedCondition = condition.replace(
          /\$\d+/g,
          () => `$${paramCounter++}`,
        );
        return updatedCondition;
      });
      parts.push(`WHERE ${whereConditions.join(" AND ")}`);
    }

    // GROUP BY
    if (this.groupByCols.length > 0) {
      parts.push(`GROUP BY ${this.groupByCols.join(", ")}`);
    }

    // ORDER BY
    if (this.orderByClauses.length > 0) {
      parts.push(`ORDER BY ${this.orderByClauses.join(", ")}`);
    }

    // LIMIT
    if (this.limitValue !== undefined) {
      parts.push(`LIMIT ${this.limitValue}`);
    }

    // OFFSET
    if (this.offsetValue !== undefined) {
      parts.push(`OFFSET ${this.offsetValue}`);
    }

    const sql = parts.join(" ");
    return { sql, params: allParams };
  }

  /**
   * Get the SQL for this query
   */
  getSql(): string {
    return this.buildQuery().sql;
  }
}


// ---------------------- infrastructure\database\IDatabaseServer.ts (326 lines) ----------------------

import { PoolClient, QueryResult, QueryResultRow } from "pg";

/**
 * Query options for database operations
 */
export interface QueryOptions {
  /**
   * Query timeout in milliseconds
   */
  timeout?: number;

  /**
   * Tag for query metrics
   */
  tag?: string;

  /**
   * Maximum number of retry attempts for failed queries
   * Default: 2
   */
  maxRetries?: number;
}

/**
 * Transaction options
 */
export interface TransactionOptions {
  /**
   * Maximum number of retry attempts for failed transactions
   * Default: 0 (no retries)
   */
  maxRetries?: number;

  /**
   * Initial delay in milliseconds between retries
   * Default: 100ms
   */
  retryDelay?: number;

  /**
   * Multiplier for delay between retries (for exponential backoff)
   * Default: 1.5
   */
  retryDelayMultiplier?: number;

  /**
   * Maximum delay in milliseconds between retries
   * Default: 5000ms (5 seconds)
   */
  maxRetryDelay?: number;

  /**
   * Function to determine if a transaction should be retried based on the error
   * Default: retry on serialization failures and deadlock errors
   */
  shouldRetry?: (error: unknown) => boolean;

  /**
   * Optional isolation level for the transaction
   */
  isolationLevel?: "READ COMMITTED" | "REPEATABLE READ" | "SERIALIZABLE";

  /**
   * Optional timeout in milliseconds for the transaction
   */
  timeout?: number;
}

/**
 * Connection statistics for monitoring database pool
 */
export interface ConnectionStats {
  /**
   * Total number of clients in the pool
   */
  totalCount: number;

  /**
   * Number of idle clients
   */
  idleCount: number;

  /**
   * Number of active clients
   */
  activeCount: number;

  /**
   * Number of clients waiting for connection
   */
  waitingCount: number;

  /**
   * Maximum number of clients allowed in the pool
   */
  maxConnections: number;

  /**
   * Current connection utilization (activeCount / maxConnections)
   */
  utilization: number;

  /**
   * Number of successful connection acquisitions
   */
  acquireCount: number;

  /**
   * Number of failed connection acquisitions
   */
  acquireFailCount: number;

  /**
   * Average time in milliseconds to acquire a connection
   */
  avgAcquireTime?: number;

  /**
   * Maximum time in milliseconds to acquire a connection
   */
  maxAcquireTime?: number;

  /**
   * Number of database queries executed
   */
  queryCount: number;

  /**
   * Number of failed database queries
   */
  queryFailCount: number;

  /**
   * Average query execution time in milliseconds
   */
  avgQueryTime?: number;

  /**
   * Maximum query execution time in milliseconds
   */
  maxQueryTime?: number;
}

/**
 * Query builder for constructing complex SQL queries
 */
export interface QueryBuilder {
  /**
   * Specify columns to select
   * @param columns Columns to select
   */
  select(columns: string | string[]): QueryBuilder;

  /**
   * Add a WHERE condition to the query
   * @param condition The SQL condition
   * @param params Parameters for the condition
   */
  where(condition: string, ...params: unknown[]): QueryBuilder;

  /**
   * Add a JOIN clause to the query
   * @param table The table to join
   * @param condition The join condition
   */
  join(table: string, condition: string): QueryBuilder;

  /**
   * Add a LEFT JOIN clause to the query
   * @param table The table to join
   * @param condition The join condition
   */
  leftJoin(table: string, condition: string): QueryBuilder;

  /**
   * Add a GROUP BY clause to the query
   * @param columns Columns to group by
   */
  groupBy(columns: string | string[]): QueryBuilder;

  /**
   * Add an ORDER BY clause to the query
   * @param column Column to order by
   * @param direction Sort direction
   */
  orderBy(column: string, direction?: "ASC" | "DESC"): QueryBuilder;

  /**
   * Set a LIMIT on the query
   * @param limit Maximum number of rows to return
   */
  limit(limit: number): QueryBuilder;

  /**
   * Set an OFFSET on the query
   * @param offset Number of rows to skip
   */
  offset(offset: number): QueryBuilder;

  /**
   * Execute the SELECT query
   * @param options Query options
   */
  execute<T extends QueryResultRow = QueryResultRow>(
    options?: QueryOptions,
  ): Promise<QueryResult<T>>;

  /**
   * Execute the query and return the first result
   * @param options Query options
   */
  getOne<T extends QueryResultRow = QueryResultRow>(
    options?: QueryOptions,
  ): Promise<T | null>;

  /**
   * Execute the query and return all results
   * @param options Query options
   */
  getMany<T extends QueryResultRow = QueryResultRow>(
    options?: QueryOptions,
  ): Promise<T[]>;

  /**
   * Count the number of rows matching the query
   * @param options Query options
   */
  count(options?: QueryOptions): Promise<number>;

  /**
   * Get the SQL for this query
   */
  getSql(): string;

  /**
   * Build the SQL query and parameters
   * @returns The SQL query and parameters
   */
  buildQuery(): { sql: string; params: unknown[] };
}

/**
 * Core database service interface
 * Provides database connection management and query execution
 */
export interface IDatabaseServer {
  /**
   * Initialize the database connection
   * @returns A promise that resolves when initialization is complete
   */
  initialize(): Promise<void>;

  /**
   * Check if the database is connected
   * @returns True if connected, false otherwise
   */
  isConnected(): boolean;

  /**
   * Close the database connection
   * @returns A promise that resolves when the connection is closed
   */
  close(): Promise<void>;

  /**
   * Get a client from the connection pool
   * @returns A promise that resolves with a database client
   */
  connect(): Promise<PoolClient>;

  /**
   * Execute a SQL query
   * @param text SQL query text
   * @param params Query parameters
   * @param options Query options
   * @returns Query result
   */
  query<T extends QueryResultRow = QueryResultRow>(
    text: string,
    params?: unknown[],
    options?: QueryOptions,
  ): Promise<QueryResult<T>>;

  /**
   * Execute a function with a database client
   * @param callback Function that takes a client and returns a promise
   * @returns Result of the callback function
   */
  withClient<T>(callback: (client: PoolClient) => Promise<T>): Promise<T>;

  /**
   * Execute a function within a transaction
   * @param callback Function that takes a client and returns a promise
   * @param options Transaction options for retry and isolation level
   * @returns Result of the callback function
   */
  withTransaction<T>(
    callback: (client: PoolClient) => Promise<T>,
    options?: TransactionOptions,
  ): Promise<T>;

  /**
   * Get connection statistics
   * @param reset Whether to reset the metrics after retrieving them
   * @returns Connection statistics
   */
  getStats(reset?: boolean): ConnectionStats;

  /**
   * Reset the connection metrics
   */
  resetMetrics(): void;

  /**
   * Reset the database connection (primarily for testing)
   * @returns A promise that resolves when reset is complete
   */
  reset(): Promise<void>;

  /**
   * Create a query builder for constructing complex SQL queries
   * @param tableName The name of the table to query
   * @returns A QueryBuilder instance
   */
  createQueryBuilder(tableName: string): QueryBuilder;
}


// ---------------------- infrastructure\database\TransactionService.ts (216 lines) ----------------------

import { injectable, inject } from "inversify";
import { PoolClient, QueryResult } from "pg";

import { TYPES } from "@/server/infrastructure/di";
import type { ILoggerService } from "@/server/infrastructure/logging";

import type { IDatabaseServer } from "./IDatabaseServer";

export type TransactionCallback<T> = (client: PoolClient) => Promise<T>;

export enum IsolationLevel {
  READ_UNCOMMITTED = "READ UNCOMMITTED",
  READ_COMMITTED = "READ COMMITTED",
  REPEATABLE_READ = "REPEATABLE READ",
  SERIALIZABLE = "SERIALIZABLE",
}

export interface TransactionOptions {
  isolation?: IsolationLevel;
  readOnly?: boolean;
  deferrable?: boolean;
  timeout?: number; // in milliseconds
}

/**
 * TransactionService provides methods for executing database operations within transactions
 * with proper error handling and connection management.
 */
@injectable()
export class TransactionService {
  constructor(
    @inject(TYPES.LoggerService) private logger: ILoggerService,
    @inject(TYPES.DatabaseService) private databaseServer: IDatabaseServer,
  ) {}

  /**
   * Execute a callback within a transaction with configurable options
   *
   * @param callback Function to execute within the transaction
   * @param options Transaction configuration options
   * @returns Result of the callback
   * @throws Error if transaction fails
   */
  async execute<T>(
    callback: TransactionCallback<T>,
    options: TransactionOptions = {},
  ): Promise<T> {
    return this.databaseServer.withTransaction(async (client) => {
      try {
        // Set statement timeout if specified
        if (options.timeout) {
          await client.query(`SET statement_timeout = ${options.timeout}`);
        }

        // Start transaction with appropriate isolation level
        let beginStatement = "BEGIN";

        if (options.isolation) {
          beginStatement += ` ISOLATION LEVEL ${options.isolation}`;
        }

        if (options.readOnly) {
          beginStatement += " READ ONLY";
        }

        if (
          options.deferrable &&
          options.isolation === IsolationLevel.SERIALIZABLE
        ) {
          beginStatement += " DEFERRABLE";
        }

        await client.query(beginStatement);

        // Execute the callback within the transaction
        const result = await callback(client);
        await client.query("COMMIT");

        return result;
      } catch (error) {
        try {
          await client.query("ROLLBACK");
          this.logger.error("Transaction rolled back due to error", { error });
        } catch (rollbackError) {
          this.logger.error("Failed to rollback transaction", {
            originalError: error,
            rollbackError,
          });
        }

        throw error;
      } finally {
        // Reset statement timeout to default if it was changed
        if (options.timeout) {
          try {
            await client.query("SET statement_timeout TO DEFAULT");
          } catch (error) {
            this.logger.warn("Failed to reset statement timeout", { error });
          }
        }
      }
    });
  }

  /**
   * Execute multiple operations within a single transaction
   *
   * @param operations Array of operations to perform
   * @param options Transaction configuration options
   * @returns Array of results from each operation
   * @throws Error if any operation fails
   */
  async multiOperationTransaction<T>(
    operations: Array<TransactionCallback<T>>,
    options: TransactionOptions = {},
  ): Promise<T[]> {
    return this.execute(async (client) => {
      const results: T[] = [];

      for (const operation of operations) {
        try {
          results.push(await operation(client));
        } catch (error) {
          this.logger.error(
            "Operation failed within multi-operation transaction",
            { error },
          );
          throw error;
        }
      }

      return results;
    }, options);
  }

  /**
   * Execute a read-only transaction
   *
   * @param callback Function to execute within the transaction
   * @param isolation Optional isolation level
   * @returns Result of the callback
   * @throws Error if transaction fails
   */
  async readTransaction<T>(
    callback: TransactionCallback<T>,
    isolation: IsolationLevel = IsolationLevel.READ_COMMITTED,
  ): Promise<T> {
    return this.execute(callback, {
      isolation,
      readOnly: true,
    });
  }

  /**
   * Execute a batch of SQL queries within a transaction
   *
   * @param queries Array of SQL queries to execute
   * @param options Transaction configuration options
   * @returns Array of query results
   * @throws Error if any query fails
   */
  async executeBatch(
    queries: Array<{ text: string; values?: unknown[] }>,
    options: TransactionOptions = {},
  ): Promise<QueryResult[]> {
    return this.execute(async (client) => {
      const results: QueryResult[] = [];

      for (const query of queries) {
        const result = await client.query(query.text, query.values);
        results.push(result);
      }

      return results;
    }, options);
  }

  /**
   * Create a savepoint within a transaction
   *
   * @param client Active transaction client
   * @param name Savepoint name
   */
  async createSavepoint(client: PoolClient, name: string): Promise<void> {
    await client.query(`SAVEPOINT ${name}`);
  }

  /**
   * Rollback to a savepoint within a transaction
   *
   * @param client Active transaction client
   * @param name Savepoint name
   */
  async rollbackToSavepoint(client: PoolClient, name: string): Promise<void> {
    await client.query(`ROLLBACK TO SAVEPOINT ${name}`);
  }

  /**
   * Release a savepoint within a transaction
   *
   * @param client Active transaction client
   * @param name Savepoint name
   */
  async releaseSavepoint(client: PoolClient, name: string): Promise<void> {
    await client.query(`RELEASE SAVEPOINT ${name}`);
  }

  /**
   * Simple wrapper for executing a function within a transaction
   * @param operation Function to execute within transaction
   * @returns Result of the operation
   */
  async withTransaction<T>(operation: () => Promise<T>): Promise<T> {
    return this.databaseServer.withTransaction(operation);
  }
}


// ---------------------- infrastructure\database\index.ts (6 lines) ----------------------

/**
 * Database infrastructure exports
 */
export * from "./IDatabaseServer";
export * from "./DatabaseServer";
export * from "./DatabaseConfigProvider";


// ---------------------- infrastructure\database\migrationAuth.ts (425 lines) ----------------------

import { MigrationBuilder, ColumnDefinitions } from "node-pg-migrate";

export const shorthands: ColumnDefinitions | undefined = undefined;

// Migration: Auth System Tables
// Created: 2025-03-29T00:00:00.000Z

export function up(pgm: MigrationBuilder): void {
  // Enable UUID extension if not already enabled
  pgm.createExtension("uuid-ossp", { ifNotExists: true });

  // Create users table
  pgm.createTable("users", {
    id: {
      type: "uuid",
      primaryKey: true,
      default: pgm.func("uuid_generate_v4()"),
    },
    username: { type: "varchar(100)", notNull: true, unique: true },
    email: { type: "varchar(255)", notNull: true, unique: true },
    password: { type: "text", notNull: true },
    role: { type: "varchar(50)", notNull: true, default: "user" },
    is_verified: { type: "boolean", notNull: true, default: false },
    email_confirmed: { type: "boolean", notNull: true, default: false },
    email_token: { type: "text" },
    email_token_expire: { type: "timestamp" },
    last_email_sent: { type: "timestamp" },
    type: { type: "varchar(20)", notNull: true, default: "standard" },
    last_login_at: { type: "timestamp" },
    account_status: { type: "varchar(20)", notNull: true, default: "pending" },
    failed_login_attempts: { type: "integer", notNull: true, default: 0 },
    password_last_changed: { type: "timestamp" },
    created_at: {
      type: "timestamp",
      notNull: true,
      default: pgm.func("NOW()"),
    },
    updated_at: {
      type: "timestamp",
      notNull: true,
      default: pgm.func("NOW()"),
    },
  });

  // Create roles table
  pgm.createTable("roles", {
    id: {
      type: "uuid",
      primaryKey: true,
      default: pgm.func("uuid_generate_v4()"),
    },
    name: { type: "varchar(50)", notNull: true, unique: true },
    description: { type: "text" },
    inherits_from: { type: "uuid", references: "roles(id)" },
    is_system: { type: "boolean", notNull: true, default: false },
    created_at: {
      type: "timestamp",
      notNull: true,
      default: pgm.func("NOW()"),
    },
    updated_at: {
      type: "timestamp",
      notNull: true,
      default: pgm.func("NOW()"),
    },
  });

  // Create permissions table
  pgm.createTable("permissions", {
    id: {
      type: "uuid",
      primaryKey: true,
      default: pgm.func("uuid_generate_v4()"),
    },
    name: { type: "varchar(100)", notNull: true },
    description: { type: "text" },
    resource: { type: "varchar(100)", notNull: true },
    action: { type: "varchar(100)", notNull: true },
    is_system: { type: "boolean", notNull: true, default: false },
    created_at: {
      type: "timestamp",
      notNull: true,
      default: pgm.func("NOW()"),
    },
    updated_at: {
      type: "timestamp",
      notNull: true,
      default: pgm.func("NOW()"),
    },
  });
  pgm.createConstraint("permissions", "permissions_resource_action_unique", {
    unique: ["resource", "action"],
  });

  // Create user_roles junction table
  pgm.createTable("user_roles", {
    id: {
      type: "uuid",
      primaryKey: true,
      default: pgm.func("uuid_generate_v4()"),
    },
    user_id: {
      type: "uuid",
      notNull: true,
      references: "users(id)",
      onDelete: "CASCADE",
    },
    role_id: {
      type: "uuid",
      notNull: true,
      references: "roles(id)",
      onDelete: "CASCADE",
    },
    created_at: {
      type: "timestamp",
      notNull: true,
      default: pgm.func("NOW()"),
    },
    updated_at: {
      type: "timestamp",
      notNull: true,
      default: pgm.func("NOW()"),
    },
  });
  pgm.createIndex("user_roles", "user_id");
  pgm.createIndex("user_roles", "role_id");
  pgm.createConstraint("user_roles", "user_roles_user_role_unique", {
    unique: ["user_id", "role_id"],
  });

  // Create role_permissions junction table
  pgm.createTable("role_permissions", {
    id: {
      type: "uuid",
      primaryKey: true,
      default: pgm.func("uuid_generate_v4()"),
    },
    role_id: {
      type: "uuid",
      notNull: true,
      references: "roles(id)",
      onDelete: "CASCADE",
    },
    permission_id: {
      type: "uuid",
      notNull: true,
      references: "permissions(id)",
      onDelete: "CASCADE",
    },
    created_at: {
      type: "timestamp",
      notNull: true,
      default: pgm.func("NOW()"),
    },
    updated_at: {
      type: "timestamp",
      notNull: true,
      default: pgm.func("NOW()"),
    },
  });
  pgm.createIndex("role_permissions", "role_id");
  pgm.createIndex("role_permissions", "permission_id");
  pgm.createConstraint(
    "role_permissions",
    "role_permissions_role_permission_unique",
    {
      unique: ["role_id", "permission_id"],
    },
  );

  // Create tokens table
  pgm.createTable("tokens", {
    id: {
      type: "uuid",
      primaryKey: true,
      default: pgm.func("uuid_generate_v4()"),
    },
    user_id: {
      type: "uuid",
      notNull: true,
      references: "users(id)",
      onDelete: "CASCADE",
    },
    token: { type: "text", notNull: true, unique: true },
    type: { type: "varchar(50)", notNull: true },
    device_info: { type: "jsonb" },
    ip_address: { type: "varchar(45)" },
    expires_at: { type: "timestamp", notNull: true },
    last_used_at: { type: "timestamp" },
    revoked: { type: "boolean", notNull: true, default: false },
    created_at: {
      type: "timestamp",
      notNull: true,
      default: pgm.func("NOW()"),
    },
    updated_at: {
      type: "timestamp",
      notNull: true,
      default: pgm.func("NOW()"),
    },
  });
  pgm.createIndex("tokens", "token");
  pgm.createIndex("tokens", "user_id");
  pgm.createIndex("tokens", "type");

  // Create password_reset_tokens table
  pgm.createTable("password_reset_tokens", {
    id: {
      type: "uuid",
      primaryKey: true,
      default: pgm.func("uuid_generate_v4()"),
    },
    user_id: {
      type: "uuid",
      notNull: true,
      references: "users(id)",
      onDelete: "CASCADE",
    },
    token: { type: "text", notNull: true, unique: true },
    expires_at: { type: "timestamp", notNull: true },
    status: { type: "varchar(20)", notNull: true, default: "active" },
    used_at: { type: "timestamp" },
    created_at: {
      type: "timestamp",
      notNull: true,
      default: pgm.func("NOW()"),
    },
    updated_at: {
      type: "timestamp",
      notNull: true,
      default: pgm.func("NOW()"),
    },
  });
  pgm.createIndex("password_reset_tokens", "token");
  pgm.createIndex("password_reset_tokens", "user_id");
  pgm.createIndex("password_reset_tokens", "status");

  // Create user_profiles table
  pgm.createTable("user_profiles", {
    id: {
      type: "uuid",
      primaryKey: true,
      default: pgm.func("uuid_generate_v4()"),
    },
    user_id: {
      type: "uuid",
      notNull: true,
      references: "users(id)",
      onDelete: "CASCADE",
      unique: true,
    },
    display_name: { type: "varchar(100)" },
    first_name: { type: "varchar(100)" },
    last_name: { type: "varchar(100)" },
    bio: { type: "text" },
    profile_image: { type: "text" },
    banner_image: { type: "text" },
    location: { type: "varchar(100)" },
    website: { type: "text" },
    social_links: { type: "jsonb", default: "{}" },
    interests: { type: "text[]", default: "{}" },
    skills: { type: "text[]", default: "{}" },
    occupation: { type: "varchar(100)" },
    education: { type: "text" },
    birthday: { type: "date" },
    phone_number: { type: "varchar(20)" },
    last_profile_update: {
      type: "timestamp",
      notNull: true,
      default: pgm.func("NOW()"),
    },
    profile_completion_percentage: {
      type: "integer",
      notNull: true,
      default: 0,
    },
    is_public: { type: "boolean", notNull: true, default: true },
    created_at: {
      type: "timestamp",
      notNull: true,
      default: pgm.func("NOW()"),
    },
    updated_at: {
      type: "timestamp",
      notNull: true,
      default: pgm.func("NOW()"),
    },
  });
  pgm.createIndex("user_profiles", "user_id");

  // Create user_preferences table
  pgm.createTable("user_preferences", {
    id: {
      type: "uuid",
      primaryKey: true,
      default: pgm.func("uuid_generate_v4()"),
    },
    user_id: {
      type: "uuid",
      notNull: true,
      references: "users(id)",
      onDelete: "CASCADE",
      unique: true,
    },
    notifications: {
      type: "jsonb",
      notNull: true,
      default: '{"emailNotifications":true,"pushNotifications":true}',
    },
    privacy: {
      type: "jsonb",
      notNull: true,
      default: '{"profileVisibility":"public"}',
    },
    theme: { type: "jsonb", notNull: true, default: '{"theme":"system"}' },
    accessibility: { type: "jsonb", notNull: true, default: "{}" },
    language: { type: "varchar(10)", notNull: true, default: "en" },
    timezone: { type: "varchar(50)", notNull: true, default: "UTC" },
    created_at: {
      type: "timestamp",
      notNull: true,
      default: pgm.func("NOW()"),
    },
    updated_at: {
      type: "timestamp",
      notNull: true,
      default: pgm.func("NOW()"),
    },
  });
  pgm.createIndex("user_preferences", "user_id");

  // Create user_connections table
  pgm.createTable("user_connections", {
    id: {
      type: "uuid",
      primaryKey: true,
      default: pgm.func("uuid_generate_v4()"),
    },
    user_id: {
      type: "uuid",
      notNull: true,
      references: "users(id)",
      onDelete: "CASCADE",
    },
    target_user_id: {
      type: "uuid",
      notNull: true,
      references: "users(id)",
      onDelete: "CASCADE",
    },
    type: { type: "varchar(20)", notNull: true },
    created_at: {
      type: "timestamp",
      notNull: true,
      default: pgm.func("NOW()"),
    },
    updated_at: {
      type: "timestamp",
      notNull: true,
      default: pgm.func("NOW()"),
    },
  });
  pgm.addConstraint("user_connections", "user_connections_unique", {
    unique: ["user_id", "target_user_id", "type"],
  });
  pgm.createIndex("user_connections", "user_id");
  pgm.createIndex("user_connections", "target_user_id");
  pgm.createIndex("user_connections", "type");

  // Create default roles and permissions
  pgm.sql(`
    -- Insert default roles
    INSERT INTO roles (name, description, is_system) 
    VALUES ('admin', 'Administrator with full system access', true),
           ('user', 'Regular application user', true),
           ('moderator', 'User with moderation privileges', true);
           
    -- Insert default permissions
    INSERT INTO permissions (name, resource, action, is_system)
    VALUES ('Manage Users', 'user', 'manage', true),
           ('Read Users', 'user', 'read', true),
           ('Create Users', 'user', 'create', true),
           ('Update Users', 'user', 'update', true),
           ('Delete Users', 'user', 'delete', true),
           ('Manage Roles', 'role', 'manage', true),
           ('Read Roles', 'role', 'read', true),
           ('Create Roles', 'role', 'create', true),
           ('Update Roles', 'role', 'update', true),
           ('Delete Roles', 'role', 'delete', true),
           ('Manage Permissions', 'permission', 'manage', true),
           ('Read Permissions', 'permission', 'read', true);
           
    -- Assign permissions to admin role
    INSERT INTO role_permissions (role_id, permission_id)
    SELECT 
      (SELECT id FROM roles WHERE name = 'admin'), 
      id 
    FROM permissions;
    
    -- Assign basic permissions to user role
    INSERT INTO role_permissions (role_id, permission_id)
    SELECT 
      (SELECT id FROM roles WHERE name = 'user'),
      id
    FROM permissions 
    WHERE resource = 'user' AND action = 'read';
  `);
}

export function down(pgm: MigrationBuilder): void {
  // Drop all tables in reverse order (to handle dependencies)
  pgm.dropTable("user_connections");
  pgm.dropTable("user_preferences");
  pgm.dropTable("user_profiles");
  pgm.dropTable("password_reset_tokens");
  pgm.dropTable("tokens");
  pgm.dropTable("role_permissions");
  pgm.dropTable("user_roles");
  pgm.dropTable("permissions");
  pgm.dropTable("roles");
  pgm.dropTable("users");

  // Drop UUID extension if needed
  // pgm.dropExtension('uuid-ossp');
}


// ---------------------- infrastructure\database\migrationConfig.ts (275 lines) ----------------------

import path from "path";

export interface MigrationConfig {
  migrations_path: string;
  migrations_table: string;
  migration_file_extension: string;
  migration_template_path?: string;
}

export const migrationConfig: MigrationConfig = {
  migrations_path: path.join(
    process.cwd(),
    "src/server/database/migrations/migrations",
  ),
  migrations_table: "migrations",
  migration_file_extension: ".ts", // Support for TypeScript migrations
};

export const createMigrationTemplate = (name: string): string => `
import { MigrationBuilder, ColumnDefinitions } from 'node-pg-migrate';

export const shorthands: ColumnDefinitions | undefined = undefined;

// Migration: ${name}
// Created: ${new Date().toISOString()}

export function up(pgm: MigrationBuilder): void {
  // Add migration code here
  // Examples:
  // pgm.createTable('table_name', {
  //   id: 'id',
  //   name: { type: 'varchar(1000)', notNull: true },
  //   created_at: {
  //     type: 'timestamp',
  //     notNull: true,
  //     default: pgm.func('current_timestamp'),
  //   },
  // });
  // pgm.createIndex('table_name', 'name');
}

export function down(pgm: MigrationBuilder): void {
  // Add rollback code here
  // Examples:
  // pgm.dropTable('table_name');
}
`;

// Auth migration template for creating authentication-related tables
export const createAuthMigrationTemplate = (): string => `
import { MigrationBuilder, ColumnDefinitions } from 'node-pg-migrate';

export const shorthands: ColumnDefinitions | undefined = undefined;

// Migration: Auth System Tables
// Created: ${new Date().toISOString()}

export function up(pgm: MigrationBuilder): void {
  // Enable UUID extension if not already enabled
  pgm.createExtension('uuid-ossp', { ifNotExists: true });

  // Create users table
  pgm.createTable('users', {
    id: { type: 'uuid', primaryKey: true, default: pgm.func('uuid_generate_v4()') },
    username: { type: 'varchar(100)', notNull: true, unique: true },
    email: { type: 'varchar(255)', notNull: true, unique: true },
    password: { type: 'text', notNull: true },
    role: { type: 'varchar(50)', notNull: true, default: 'user' },
    is_verified: { type: 'boolean', notNull: true, default: false },
    email_confirmed: { type: 'boolean', notNull: true, default: false },
    email_token: { type: 'text' },
    email_token_expire: { type: 'timestamp' },
    last_email_sent: { type: 'timestamp' },
    type: { type: 'varchar(20)', notNull: true, default: 'standard' },
    last_login_at: { type: 'timestamp' },
    account_status: { type: 'varchar(20)', notNull: true, default: 'pending' },
    failed_login_attempts: { type: 'integer', notNull: true, default: 0 },
    password_last_changed: { type: 'timestamp' },
    created_at: { type: 'timestamp', notNull: true, default: pgm.func('NOW()') },
    updated_at: { type: 'timestamp', notNull: true, default: pgm.func('NOW()') }
  });

  // Create roles table
  pgm.createTable('roles', {
    id: { type: 'uuid', primaryKey: true, default: pgm.func('uuid_generate_v4()') },
    name: { type: 'varchar(50)', notNull: true, unique: true },
    description: { type: 'text' },
    inherits_from: { type: 'uuid', references: 'roles(id)' },
    is_system: { type: 'boolean', notNull: true, default: false },
    created_at: { type: 'timestamp', notNull: true, default: pgm.func('NOW()') },
    updated_at: { type: 'timestamp', notNull: true, default: pgm.func('NOW()') }
  });

  // Create permissions table
  pgm.createTable('permissions', {
    id: { type: 'uuid', primaryKey: true, default: pgm.func('uuid_generate_v4()') },
    name: { type: 'varchar(100)', notNull: true },
    description: { type: 'text' },
    resource: { type: 'varchar(100)', notNull: true },
    action: { type: 'varchar(100)', notNull: true },
    created_at: { type: 'timestamp', notNull: true, default: pgm.func('NOW()') },
    updated_at: { type: 'timestamp', notNull: true, default: pgm.func('NOW()') }
  });
  pgm.createConstraint('permissions', 'permissions_resource_action_unique', {
    unique: ['resource', 'action']
  });

  // Create user_roles junction table
  pgm.createTable('user_roles', {
    user_id: { type: 'uuid', notNull: true, references: 'users(id)', onDelete: 'CASCADE' },
    role_id: { type: 'uuid', notNull: true, references: 'roles(id)', onDelete: 'CASCADE' },
    created_at: { type: 'timestamp', notNull: true, default: pgm.func('NOW()') },
    updated_at: { type: 'timestamp', notNull: true, default: pgm.func('NOW()') }
  });
  pgm.addConstraint('user_roles', 'user_roles_pkey', { 
    primaryKey: ['user_id', 'role_id'] 
  });

  // Create role_permissions junction table
  pgm.createTable('role_permissions', {
    role_id: { type: 'uuid', notNull: true, references: 'roles(id)', onDelete: 'CASCADE' },
    permission_id: { type: 'uuid', notNull: true, references: 'permissions(id)', onDelete: 'CASCADE' },
    created_at: { type: 'timestamp', notNull: true, default: pgm.func('NOW()') },
    updated_at: { type: 'timestamp', notNull: true, default: pgm.func('NOW()') }
  });
  pgm.addConstraint('role_permissions', 'role_permissions_pkey', { 
    primaryKey: ['role_id', 'permission_id'] 
  });

  // Create tokens table
  pgm.createTable('tokens', {
    id: { type: 'uuid', primaryKey: true, default: pgm.func('uuid_generate_v4()') },
    user_id: { type: 'uuid', notNull: true, references: 'users(id)', onDelete: 'CASCADE' },
    token: { type: 'text', notNull: true, unique: true },
    type: { type: 'varchar(50)', notNull: true },
    device_info: { type: 'jsonb' },
    ip_address: { type: 'varchar(45)' },
    expires_at: { type: 'timestamp', notNull: true },
    last_used_at: { type: 'timestamp' },
    revoked: { type: 'boolean', notNull: true, default: false },
    created_at: { type: 'timestamp', notNull: true, default: pgm.func('NOW()') },
    updated_at: { type: 'timestamp', notNull: true, default: pgm.func('NOW()') }
  });
  pgm.createIndex('tokens', 'token');
  pgm.createIndex('tokens', 'user_id');

  // Create password_reset_tokens table
  pgm.createTable('password_reset_tokens', {
    id: { type: 'uuid', primaryKey: true, default: pgm.func('uuid_generate_v4()') },
    user_id: { type: 'uuid', notNull: true, references: 'users(id)', onDelete: 'CASCADE' },
    token: { type: 'text', notNull: true, unique: true },
    expires_at: { type: 'timestamp', notNull: true },
    status: { type: 'varchar(20)', notNull: true, default: 'active' },
    used_at: { type: 'timestamp' },
    created_at: { type: 'timestamp', notNull: true, default: pgm.func('NOW()') },
    updated_at: { type: 'timestamp', notNull: true, default: pgm.func('NOW()') }
  });
  pgm.createIndex('password_reset_tokens', 'token');
  pgm.createIndex('password_reset_tokens', 'user_id');

  // Create user_profiles table
  pgm.createTable('user_profiles', {
    id: { type: 'uuid', primaryKey: true, default: pgm.func('uuid_generate_v4()') },
    user_id: { type: 'uuid', notNull: true, references: 'users(id)', onDelete: 'CASCADE', unique: true },
    display_name: { type: 'varchar(100)' },
    first_name: { type: 'varchar(100)' },
    last_name: { type: 'varchar(100)' },
    bio: { type: 'text' },
    profile_image: { type: 'text' },
    banner_image: { type: 'text' },
    location: { type: 'varchar(100)' },
    website: { type: 'text' },
    social_links: { type: 'jsonb', default: '{}' },
    interests: { type: 'text[]', default: '{}' },
    skills: { type: 'text[]', default: '{}' },
    occupation: { type: 'varchar(100)' },
    education: { type: 'text' },
    birthday: { type: 'date' },
    phone_number: { type: 'varchar(20)' },
    last_profile_update: { type: 'timestamp', notNull: true, default: pgm.func('NOW()') },
    profile_completion_percentage: { type: 'integer', notNull: true, default: 0 },
    is_public: { type: 'boolean', notNull: true, default: true },
    created_at: { type: 'timestamp', notNull: true, default: pgm.func('NOW()') },
    updated_at: { type: 'timestamp', notNull: true, default: pgm.func('NOW()') }
  });
  pgm.createIndex('user_profiles', 'user_id');

  // Create user_preferences table
  pgm.createTable('user_preferences', {
    id: { type: 'uuid', primaryKey: true, default: pgm.func('uuid_generate_v4()') },
    user_id: { type: 'uuid', notNull: true, references: 'users(id)', onDelete: 'CASCADE', unique: true },
    notifications: { type: 'jsonb', notNull: true, default: '{"emailNotifications":true,"pushNotifications":true}' },
    privacy: { type: 'jsonb', notNull: true, default: '{"profileVisibility":"public"}' },
    theme: { type: 'jsonb', notNull: true, default: '{"theme":"system"}' },
    accessibility: { type: 'jsonb', notNull: true, default: '{}' },
    language: { type: 'varchar(10)', notNull: true, default: 'en' },
    timezone: { type: 'varchar(50)', notNull: true, default: 'UTC' },
    created_at: { type: 'timestamp', notNull: true, default: pgm.func('NOW()') },
    updated_at: { type: 'timestamp', notNull: true, default: pgm.func('NOW()') }
  });
  pgm.createIndex('user_preferences', 'user_id');

  // Create user_connections table
  pgm.createTable('user_connections', {
    id: { type: 'uuid', primaryKey: true, default: pgm.func('uuid_generate_v4()') },
    user_id: { type: 'uuid', notNull: true, references: 'users(id)', onDelete: 'CASCADE' },
    target_user_id: { type: 'uuid', notNull: true, references: 'users(id)', onDelete: 'CASCADE' },
    type: { type: 'varchar(20)', notNull: true },
    created_at: { type: 'timestamp', notNull: true, default: pgm.func('NOW()') },
    updated_at: { type: 'timestamp', notNull: true, default: pgm.func('NOW()') }
  });
  pgm.addConstraint('user_connections', 'user_connections_unique', {
    unique: ['user_id', 'target_user_id', 'type']
  });
  pgm.createIndex('user_connections', 'user_id');
  pgm.createIndex('user_connections', 'target_user_id');
  pgm.createIndex('user_connections', 'type');
  
  // Create default roles and permissions
  pgm.sql(\`
    -- Insert default roles
    INSERT INTO roles (name, description, is_system) 
    VALUES ('admin', 'Administrator with full system access', true),
           ('user', 'Regular application user', true),
           ('moderator', 'User with moderation privileges', true);
           
    -- Insert default permissions
    INSERT INTO permissions (name, resource, action, is_system)
    VALUES ('Manage Users', 'user', 'manage', true),
           ('Read Users', 'user', 'read', true),
           ('Create Users', 'user', 'create', true),
           ('Update Users', 'user', 'update', true),
           ('Delete Users', 'user', 'delete', true),
           ('Manage Roles', 'role', 'manage', true),
           ('Read Roles', 'role', 'read', true),
           ('Create Roles', 'role', 'create', true),
           ('Update Roles', 'role', 'update', true),
           ('Delete Roles', 'role', 'delete', true),
           ('Manage Permissions', 'permission', 'manage', true),
           ('Read Permissions', 'permission', 'read', true);
           
    -- Assign permissions to admin role
    INSERT INTO role_permissions (role_id, permission_id)
    SELECT 
      (SELECT id FROM roles WHERE name = 'admin'), 
      id 
    FROM permissions;
    
    -- Assign basic permissions to user role
    INSERT INTO role_permissions (role_id, permission_id)
    SELECT 
      (SELECT id FROM roles WHERE name = 'user'),
      id
    FROM permissions 
    WHERE resource = 'user' AND action = 'read';
  \`);
}

export function down(pgm: MigrationBuilder): void {
  // Drop all tables in reverse order (to handle dependencies)
  pgm.dropTable('user_connections');
  pgm.dropTable('user_preferences');
  pgm.dropTable('user_profiles');
  pgm.dropTable('password_reset_tokens');
  pgm.dropTable('tokens');
  pgm.dropTable('role_permissions');
  pgm.dropTable('user_roles');
  pgm.dropTable('permissions');
  pgm.dropTable('roles');
  pgm.dropTable('users');
  
  // Drop UUID extension if needed
  // pgm.dropExtension('uuid-ossp');
}
`;


// ---------------------- infrastructure\database\migrationManager.ts (428 lines) ----------------------

// src/database/migrations/migrationManager.ts
import { existsSync } from "fs";
import { mkdir, readdir, readFile } from "fs/promises";
import { join } from "path";

import { injectable, inject } from "inversify";
import { PoolClient } from "pg";

import type { IDatabaseServer } from "@/server/infrastructure/database/IDatabaseServer";
import { TYPES } from "@/server/infrastructure/di/types";
import type { ILoggerService } from "@/server/infrastructure/logging";

import {
  createMigrationTemplate,
  createAuthMigrationTemplate,
  migrationConfig,
} from "./migrationConfig";

interface MigrationRecord {
  id: number;
  name: string;
  executed_at: Date;
}

@injectable()
export class MigrationManager {
  private readonly migrationsDir: string;
  private migrationsTable: string;
  private migrationExtension: string;

  constructor(
    @inject(TYPES.LoggerService) private logger: ILoggerService,
    @inject(TYPES.DatabaseServer) private databaseService: IDatabaseServer,
  ) {
    this.migrationsDir = migrationConfig.migrations_path;
    this.migrationsTable = migrationConfig.migrations_table;
    this.migrationExtension = migrationConfig.migration_file_extension;

    this.ensureMigrationsDirectory();
  }

  /**
   * Ensure migrations directory exists
   */
  private async ensureMigrationsDirectory(): Promise<void> {
    if (!existsSync(this.migrationsDir)) {
      try {
        await mkdir(this.migrationsDir, { recursive: true });
        this.logger.info(`Created migrations directory: ${this.migrationsDir}`);
      } catch (error) {
        this.logger.error("Failed to create migrations directory", { error });
        throw error;
      }
    }
  }

  /**
   * Create migrations table if it doesn't exist
   */
  async createMigrationsTable(): Promise<void> {
    const query = `
      CREATE TABLE IF NOT EXISTS ${this.migrationsTable} (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `;

    try {
      await this.databaseService.query(query);
      this.logger.info(
        `Ensured migrations table exists: ${this.migrationsTable}`,
      );
    } catch (error) {
      this.logger.error("Failed to create migrations table", { error });
      throw error;
    }
  }

  /**
   * Get list of executed migrations
   */
  async getExecutedMigrations(): Promise<string[]> {
    const query = `SELECT name FROM ${this.migrationsTable} ORDER BY id ASC`;

    try {
      const result = await this.databaseService.query<{ name: string }>(query);
      return result.rows.map((row: { name: string }) => row.name);
    } catch (error) {
      this.logger.error("Failed to get executed migrations", { error });
      throw error;
    }
  }

  /**
   * Create a new migration file
   */
  async createMigration(name: string): Promise<string> {
    const timestamp = new Date()
      .toISOString()
      .replace(/[-:]/g, "")
      .replace("T", "_")
      .split(".")[0];
    const fileName = `${timestamp}_${name}${this.migrationExtension}`;
    const filePath = join(this.migrationsDir, fileName);

    const template = createMigrationTemplate(name);

    try {
      const { writeFile } = await import("fs/promises");
      await writeFile(filePath, template, "utf8");
      this.logger.info(`Created migration: ${fileName}`);
      return fileName;
    } catch (error) {
      this.logger.error("Failed to create migration file", { error });
      throw error;
    }
  }

  /**
   * Create a new auth migration file with all auth tables
   */
  async createAuthMigration(): Promise<string> {
    const timestamp = new Date()
      .toISOString()
      .replace(/[-:]/g, "")
      .replace("T", "_")
      .split(".")[0];
    const fileName = `${timestamp}_auth_system${this.migrationExtension}`;
    const filePath = join(this.migrationsDir, fileName);

    const template = createAuthMigrationTemplate();

    try {
      const { writeFile } = await import("fs/promises");
      await writeFile(filePath, template, "utf8");
      this.logger.info(`Created auth migration: ${fileName}`);
      return fileName;
    } catch (error) {
      this.logger.error("Failed to create auth migration file", { error });
      throw error;
    }
  }

  /**
   * Get list of all migration files
   */
  private async getMigrationFiles(): Promise<string[]> {
    try {
      const files = await readdir(this.migrationsDir);
      // Support both .sql and .ts/.js files based on config
      return files.filter(
        (file) =>
          (file.endsWith(".sql") || file.endsWith(this.migrationExtension)) &&
          !file.includes(".down."),
      );
    } catch (error) {
      this.logger.error("Failed to read migrations directory", { error });
      throw error;
    }
  }

  /**
   * Get list of pending migrations
   */
  private async getPendingMigrations(): Promise<string[]> {
    const files = await this.getMigrationFiles();
    const executedMigrations = await this.getExecutedMigrations();

    // Filter out migrations that have already been executed
    return files.filter((file) => !executedMigrations.includes(file));
  }

  /**
   * Execute a SQL migration
   */
  private async executeSqlMigration(
    client: PoolClient,
    filename: string,
  ): Promise<void> {
    const filePath = join(this.migrationsDir, filename);
    const sql = await readFile(filePath, "utf8");

    // Execute the migration SQL
    await client.query(sql);
  }

  /**
   * Execute a TypeScript/JavaScript migration
   */
  private async executeJsMigration(
    _client: PoolClient,
    filename: string,
  ): Promise<void> {
    // For TypeScript migrations we need to compile and run them
    try {
      // When using TypeScript, ensure ts-node is installed
      const migrationModule = await import(join(this.migrationsDir, filename));

      if (typeof migrationModule.up !== "function") {
        throw new Error(
          `Migration ${filename} does not export an 'up' function`,
        );
      }

      // Create a migration builder object
      const pgm = {
        createTable: async (
          tableName: string,
          _columns: unknown,
          _options?: unknown,
        ) => {
          this.logger.info(`Creating table ${tableName}`);
        },
        addColumn: async (tableName: string, columnName: string) => {
          this.logger.info(`Adding column ${columnName} to ${tableName}`);
        },
      };

      // Execute the migration
      await migrationModule.up(pgm);
    } catch (err) {
      this.logger.error(`Error executing JS/TS migration ${filename}:`, {
        error: err,
      });
      throw err;
    }
  }

  /**
   * Execute a single migration
   */
  private async executeMigration(filename: string): Promise<void> {
    const client = await this.databaseService.connect();

    try {
      await client.query("BEGIN");

      if (filename.endsWith(".sql")) {
        await this.executeSqlMigration(client, filename);
      } else if (filename.endsWith(".ts") || filename.endsWith(".js")) {
        await this.executeJsMigration(client, filename);
      } else {
        throw new Error(`Unsupported migration file type: ${filename}`);
      }

      // Record the migration
      await client.query(
        `INSERT INTO ${this.migrationsTable} (name) VALUES ($1)`,
        [filename],
      );

      await client.query("COMMIT");
      this.logger.info(`Executed migration: ${filename}`);
    } catch (err) {
      await client.query("ROLLBACK");
      this.logger.error(`Error executing migration ${filename}:`, {
        error: err,
      });
      throw err;
    } finally {
      client.release();
    }
  }

  /**
   * Run all pending migrations
   */
  async migrate(): Promise<void> {
    await this.createMigrationsTable();
    const pendingMigrations = await this.getPendingMigrations();

    if (pendingMigrations.length === 0) {
      this.logger.info("No pending migrations");
      return;
    }

    this.logger.info(`Found ${pendingMigrations.length} pending migrations`);

    // Sort migrations by filename to ensure correct order
    pendingMigrations.sort();

    for (const migration of pendingMigrations) {
      await this.executeMigration(migration);
    }

    this.logger.info("All migrations completed successfully");
  }

  /**
   * Get migration status
   */
  async status(): Promise<{ executed: string[]; pending: string[] }> {
    await this.createMigrationsTable();
    const executed = await this.getExecutedMigrations();
    const pending = await this.getPendingMigrations();

    return { executed, pending };
  }

  /**
   * Roll back last migration
   */
  async rollbackMigration(): Promise<void> {
    const client = await this.databaseService.connect();
    try {
      await client.query("BEGIN");
      const result = await client.query<MigrationRecord>(
        `DELETE FROM ${this.migrationsTable} WHERE id = (SELECT MAX(id) FROM ${this.migrationsTable}) RETURNING *`,
      );
      if (result.rows.length === 0) {
        this.logger.info("No migrations to roll back");
        await client.query("ROLLBACK");
        return;
      }

      const migration = result.rows[0];
      const { name: migrationName } = migration;

      if (migrationName.endsWith(".sql")) {
        // For SQL migrations, look for a corresponding down file
        const downFileName = migrationName.replace(".sql", ".down.sql");
        const downFilePath = join(this.migrationsDir, downFileName);

        try {
          const downSql = await readFile(downFilePath, "utf8");
          await client.query(downSql);
        } catch (error) {
          this.logger.error(`Rollback file not found: ${downFileName}`, {
            error,
          });
          throw new Error(`Rollback file not found: ${downFileName}`);
        }
      } else if (
        migrationName.endsWith(".ts") ||
        migrationName.endsWith(".js")
      ) {
        // For TypeScript/JavaScript migrations, call the down function
        try {
          const migrationModule = await import(
            join(this.migrationsDir, migrationName)
          );

          if (typeof migrationModule.down !== "function") {
            throw new Error(
              `Migration ${migrationName} does not export a 'down' function`,
            );
          }

          // Similar to up, you'd want a proper migration builder here
          const pgm = {
            dropTable: async (tableName: string, _options?: unknown) => {
              // Implementation would build and execute SQL
              this.logger.info(`Dropping table ${tableName}`);
            },
            dropColumn: async (tableName: string, _columnName: string) => {
              // Implementation would build and execute SQL
              this.logger.info(
                `Dropping column ${_columnName} from ${tableName}`,
              );
            },
            // ... other migration methods
          };

          await migrationModule.down(pgm);
        } catch (error) {
          this.logger.error(
            `Error running down migration for ${migrationName}:`,
            { error },
          );
          throw error;
        }
      }

      await client.query("COMMIT");
      this.logger.info(`Rolled back migration: ${migrationName}`);
    } catch (error) {
      await client.query("ROLLBACK");
      this.logger.error("Failed to rollback migration", { error });
      throw error;
    } finally {
      client.release();
    }
  }

  /**
   * Reset database (dangerous - use with caution!)
   */
  async resetDatabase(): Promise<void> {
    this.logger.warn("RESETTING DATABASE - ALL DATA WILL BE LOST");

    const client = await this.databaseService.connect();
    try {
      await client.query("BEGIN");

      // Get all tables except the migrations table
      const tablesResult = await client.query<{ tablename: string }>(
        `
        SELECT tablename 
        FROM pg_tables 
        WHERE schemaname = 'public' 
          AND tablename != $1
      `,
        [this.migrationsTable],
      );

      // Drop all tables in reverse order of creation (to handle dependencies)
      if (tablesResult.rows.length > 0) {
        const tables = tablesResult.rows.map(
          (row: { tablename: string }) => row.tablename,
        );
        await client.query(`DROP TABLE IF EXISTS ${tables.join(", ")} CASCADE`);
      }

      // Clear migration records
      await client.query(`TRUNCATE ${this.migrationsTable}`);

      await client.query("COMMIT");
      this.logger.info("Database reset completed");
    } catch (error) {
      await client.query("ROLLBACK");
      this.logger.error("Failed to reset database", { error });
      throw error;
    } finally {
      client.release();
    }
  }
}


// ---------------------- infrastructure\di\container.ts (149 lines) ----------------------

import "reflect-metadata";

import path from "path";

import { Container } from "inversify";

import { ICacheService, CacheService } from "@/server/infrastructure/cache";
import {
  ConfigService,
  IConfigService,
  StorageConfigProvider,
} from "@/server/infrastructure/config";
import {
  DatabaseConfigProvider,
  DatabaseServer,
  IDatabaseServer,
} from "@/server/infrastructure/database";
import { TYPES } from "@/server/infrastructure/di/types";
import { ErrorHandler } from "@/server/infrastructure/errors";
import {
  IJobService,
  IJobStorage,
  FileJobStorage,
  FileJobStorageConfig,
  JobServiceConfig,
  JobService,
} from "@/server/infrastructure/jobs";
import {
  ILoggerService,
  LoggerService,
  LoggingConfig,
} from "@/server/infrastructure/logging";
import {
  IStorageProvider,
  LocalStorageProvider,
  StorageService,
  IStorageService,
} from "@/server/infrastructure/storage";

// Cache for container instances
const containerCache = new Map<string, Container>();

/**
 * Create and configure the DI container
 * @param options Optional configuration options
 * @returns The configured container
 */
export function createContainer(
  options: { cacheKey?: string } = {},
): Container {
  // Check cache if cacheKey is provided
  if (options.cacheKey && containerCache.has(options.cacheKey)) {
    return containerCache.get(options.cacheKey)!;
  }

  const container = new Container({ defaultScope: "Singleton" });

  // Register infrastructure services
  registerInfrastructureServices(container);

  // Register database services
  registerDatabaseServices(container);

  // Register job system
  registerJobSystem(container);

  // Cache the container if cacheKey is provided
  if (options.cacheKey) {
    containerCache.set(options.cacheKey, container);
  }

  return container;
}

/**
 * Register infrastructure layer services
 * @param container The DI container
 */
function registerInfrastructureServices(container: Container): void {
  // Register configuration service
  container.bind<IConfigService>(TYPES.ConfigService).to(ConfigService);

  // Register logging services
  container.bind<ILoggerService>(TYPES.LoggerService).to(LoggerService);
  container.bind<LoggingConfig>(TYPES.LoggingConfig).to(LoggingConfig);

  // Register storage service
  container.bind<IStorageService>(TYPES.StorageService).to(StorageService);
  container
    .bind<StorageConfigProvider>(TYPES.StorageConfig)
    .to(StorageConfigProvider);
  container
    .bind<IStorageProvider>(TYPES.StorageProvider)
    .to(LocalStorageProvider);

  // Register simplified cache service
  container.bind<ICacheService>(TYPES.CacheService).to(CacheService);

  // Register error handler
  container.bind<ErrorHandler>(TYPES.ErrorHandler).to(ErrorHandler);
}

/**
 * Register database layer services
 * @param container The DI container
 */
function registerDatabaseServices(container: Container): void {
  // Register database configuration provider
  container
    .bind<DatabaseConfigProvider>(TYPES.DatabaseConfig)
    .to(DatabaseConfigProvider);

  // Register database service
  container.bind<IDatabaseServer>(TYPES.DatabaseService).to(DatabaseServer);
}

/**
 * Register simplified job system
 * @param container The DI container
 */
function registerJobSystem(container: Container): void {
  // Job service and storage
  container.bind<IJobService>(TYPES.JobService).to(JobService);
  container.bind<IJobStorage>(TYPES.JobStorage).to(FileJobStorage);

  // Configuration for job storage
  container.bind<FileJobStorageConfig>(TYPES.JobStorageConfig).toConstantValue({
    basePath: path.join(process.cwd(), "data", "jobs"),
    completedJobRetention: 24 * 60 * 60 * 1000, // 24 hours
    failedJobRetention: 7 * 24 * 60 * 60 * 1000, // 7 days
  });

  // Configuration for job service
  container.bind<JobServiceConfig>(TYPES.JobServiceConfig).toConstantValue({
    maxConcurrentJobs: 10,
    pollingInterval: 1000, // 1 second
    defaultJobOptions: {
      priority: 0,
      attempts: 3,
      backoff: {
        type: "exponential",
        delay: 1000,
      },
    },
  });
}

// Create and export a singleton container instance
export const container = createContainer({ cacheKey: "default" });


// ---------------------- infrastructure\di\index.ts (18 lines) ----------------------

import "reflect-metadata";
import { createContainer } from "./container";
export * from "./types";

// Export core DI functionality
export { createContainer };

// Create and export a singleton container instance
export const container = createContainer();

/**
 * Helper to get a service from the singleton container
 * @param serviceIdentifier The service identifier
 * @returns The requested service
 */
export function inject<T>(serviceIdentifier: symbol): T {
  return container.get<T>(serviceIdentifier);
}


// ---------------------- infrastructure\di\types.ts (173 lines) ----------------------

// Service Types - Identifiers for dependency injection
export const TYPES = {
  // INFRASTRUCTURE LAYER
  // Core infrastructure services
  ConfigService: Symbol.for("ConfigService"),
  AppConfig: Symbol.for("AppConfig"),
  DatabaseConfig: Symbol.for("DatabaseConfig"),
  ApiConfig: Symbol.for("ApiConfig"),
  LoggerService: Symbol.for("LoggerService"),
  LegacyLogger: Symbol.for("LegacyLogger"),
  LoggingConfig: Symbol.for("LoggingConfig"),
  LoggerExample: Symbol.for("LoggerExample"),
  ConfigExample: Symbol.for("ConfigExample"),
  CacheService: Symbol.for("CacheService"),
  CacheAdapter: Symbol.for("CacheAdapter"),
  CacheServiceConfig: Symbol.for("CacheServiceConfig"),
  CachePerformanceReporter: Symbol.for("CachePerformanceReporter"),
  CacheExample: Symbol.for("CacheExample"),
  StorageService: Symbol.for("StorageService"),
  StorageConfig: Symbol.for("StorageConfig"),
  StorageProvider: Symbol.for("StorageProvider"),
  JobService: Symbol.for("JobService"),
  PersistentJobQueue: Symbol.for("PersistentJobQueue"),
  JobQueueManager: Symbol.for("JobQueueManager"),
  JobStorage: Symbol.for("JobStorage"),
  JobStorageConfig: Symbol.for("JobStorageConfig"),
  JobServiceConfig: Symbol.for("JobServiceConfig"),
  WebSocketService: Symbol.for("WebSocketService"),
  EventEmitter: Symbol.for("EventEmitter"),
  MetricsService: Symbol.for("MetricsService"),
  TransactionService: Symbol.for("TransactionService"),
  TransactionManager: Symbol.for("TransactionManager"),
  ValidationService: Symbol.for("ValidationService"),
  EncryptionService: Symbol.for("EncryptionService"),
  TokenService: Symbol.for("TokenService"),
  EmailService: Symbol.for("EmailService"),
  SessionService: Symbol.for("SessionService"),
  AuthService: Symbol.for("AuthService"),
  ErrorHandler: Symbol.for("ErrorHandler"),
  ApplicationLifecycle: Symbol.for("ApplicationLifecycle"),
  DatabaseService: Symbol.for("DatabaseService"),
  SearchProvider: Symbol.for("SearchProvider"),
  GeoProvider: Symbol.for("GeoProvider"),
  MessageBus: Symbol.for("MessageBus"),
  DatabaseServer: Symbol.for("DatabaseServer"),
  FileJobStorageConfig: Symbol.for("FileJobStorageConfig"),

  // DATABASE LAYER
  // Base repository
  BaseRepository: Symbol.for("BaseRepository"),

  // Auth repositories
  UserRepository: Symbol.for("UserRepository"),
  UserRoleRepository: Symbol.for("UserRoleRepository"),
  UserPreferencesRepository: Symbol.for("UserPreferencesRepository"),
  RoleRepository: Symbol.for("RoleRepository"),
  RolePermissionRepository: Symbol.for("RolePermissionRepository"),
  PermissionRepository: Symbol.for("PermissionRepository"),
  TokenRepository: Symbol.for("TokenRepository"),
  PasswordResetTokenRepository: Symbol.for("PasswordResetTokenRepository"),

  // Media repositories
  MediaRepository: Symbol.for("MediaRepository"),
  MediaCollectionRepository: Symbol.for("MediaCollectionRepository"),
  MediaTagRepository: Symbol.for("MediaTagRepository"),
  MediaCommentRepository: Symbol.for("MediaCommentRepository"),

  // Social repositories
  UserProfileRepository: Symbol.for("UserProfileRepository"),
  FollowRepository: Symbol.for("FollowRepository"),
  PostRepository: Symbol.for("PostRepository"),
  CommentRepository: Symbol.for("CommentRepository"),
  LikeRepository: Symbol.for("LikeRepository"),
  NotificationRepository: Symbol.for("NotificationRepository"),

  // Messaging repositories
  ConversationRepository: Symbol.for("ConversationRepository"),
  MessageRepository: Symbol.for("MessageRepository"),

  // Moderation repositories
  ReportRepository: Symbol.for("ReportRepository"),
  ContentModerationRepository: Symbol.for("ContentModerationRepository"),
  BlockRepository: Symbol.for("BlockRepository"),

  // Analytics repositories
  UserAnalyticsRepository: Symbol.for("UserAnalyticsRepository"),
  ContentAnalyticsRepository: Symbol.for("ContentAnalyticsRepository"),
  EngagementAnalyticsRepository: Symbol.for("EngagementAnalyticsRepository"),

  // SERVICE LAYER
  // Core services
  GeoService: Symbol.for("GeoService"),
  GeoMiddleware: Symbol.for("GeoMiddleware"),
  SearchService: Symbol.for("SearchService"),
  MessagingService: Symbol.for("MessagingService"),
  JobProcessorRegistry: Symbol.for("JobProcessorRegistry"),
  JobProcessor: Symbol.for("JobProcessor"),
  JobOrchestrationService: Symbol.for("JobOrchestrationService"),

  // User services
  UserService: Symbol.for("UserService"),
  ProfileService: Symbol.for("ProfileService"),

  // Authentication services
  AuthenticationService: Symbol.for("AuthenticationService"),
  PermissionService: Symbol.for("PermissionService"),
  RolePermissionService: Symbol.for("RolePermissionService"),

  // Social services
  PostService: Symbol.for("PostService"),
  CommentService: Symbol.for("CommentService"),
  LikeService: Symbol.for("LikeService"),
  FollowService: Symbol.for("FollowService"),
  NotificationService: Symbol.for("NotificationService"),
  FeedService: Symbol.for("FeedService"),

  // Media services
  MediaService: Symbol.for("MediaService"),
  MediaProcessingService: Symbol.for("MediaProcessingService"),

  // Messaging services
  MessageService: Symbol.for("MessageService"),
  ChatService: Symbol.for("ChatService"),

  // Moderation services
  ModerationService: Symbol.for("ModerationService"),
  ReportingService: Symbol.for("ReportingService"),
  ContentFilterService: Symbol.for("ContentFilterService"),

  // Analytics services
  AnalyticsService: Symbol.for("AnalyticsService"),
  EngagementAnalyticsService: Symbol.for("EngagementAnalyticsService"),

  // Search services

  // Discovery services
  RecommendationService: Symbol.for("RecommendationService"),
  TrendingService: Symbol.for("TrendingService"),

  // Shared utility services
  MailService: Symbol.for("MailService"),
  SmsService: Symbol.for("SmsService"),
  WebhookService: Symbol.for("WebhookService"),
  PushNotificationService: Symbol.for("PushNotificationService"),

  // API LAYER
  RequestLogger: Symbol.for("RequestLogger"),

  // Job System
  JobExample: Symbol.for("JobExample"),

  // Background task system
  BackgroundTaskQueue: Symbol.for("BackgroundTaskQueue"),
  TaskStorage: Symbol.for("TaskStorage"),

  // Controller Layer
  AuthController: Symbol.for("AuthController"),
  SessionController: Symbol.for("SessionController"),
  UserController: Symbol.for("UserController"),
  RolePermissionController: Symbol.for("RolePermissionController"),

  // Email services
  EmailTemplateService: Symbol.for("EmailTemplateService"),

  // Template services
  TemplateEngine: Symbol.for("TemplateEngine"),

  // Security services
  SecurityAuditLogger: Symbol.for("SecurityAuditLogger"),
  PasswordService: Symbol.for("PasswordService"),
};

export default TYPES;


// ---------------------- infrastructure\errors\AppError.ts (67 lines) ----------------------

/**
 * The base application error class.
 * All custom errors should extend this class.
 */
export class AppError extends Error {
  /**
   * Error code for identifying the error type
   */
  readonly code: string;

  /**
   * HTTP status code for the error (if applicable)
   */
  readonly statusCode: number;

  /**
   * Additional error metadata
   */
  readonly metadata: Record<string, unknown>;

  /**
   * Create a new AppError
   * @param message Error message
   * @param code Error code
   * @param statusCode HTTP status code
   * @param metadata Additional metadata
   */
  constructor(
    message: string,
    code = "INTERNAL_ERROR",
    statusCode = 500,
    metadata: Record<string, unknown> = {},
  ) {
    super(message);
    this.name = this.constructor.name;
    this.code = code;
    this.statusCode = statusCode;
    this.metadata = metadata;

    // Maintain proper stack trace
    Error.captureStackTrace(this, this.constructor);
  }

  /**
   * Convert the error to a JSON-friendly format
   */
  toJSON(): Record<string, unknown> {
    // Handle circular references and ensure proper conversion
    const safeMetadata = JSON.parse(JSON.stringify(this.metadata));

    return {
      name: this.name,
      message: this.message,
      code: this.code,
      statusCode: this.statusCode,
      metadata: safeMetadata,
      stack: this.stack,
    };
  }

  /**
   * Get a string representation of the error
   */
  toString(): string {
    return `${this.name} [${this.code}]: ${this.message}`;
  }
}


// ---------------------- infrastructure\errors\ErrorHandler.ts (142 lines) ----------------------

import { Request, Response } from "express";
import { inject, injectable } from "inversify";

import { TYPES } from "@/server/infrastructure/di/types";

import { AppError } from "./AppError";
import { IErrorHandler } from "./IErrorHandler";
import { NetworkError } from "./infrastructure/InfrastructureError";
import { ServiceError } from "./ServiceError";
import { InitializationError } from "./technical/TechnicalError";

import type { ILoggerService } from "../logging";

/**
 * Middleware for handling errors in API requests
 */
@injectable()
export class ErrorHandler implements IErrorHandler {
  constructor(
    @inject(TYPES.LoggerService) private readonly logger: ILoggerService,
  ) {}

  /**
   * Express error handler middleware
   */
  handleError = (error: Error, req: Request, res: Response): Response => {
    // Default error response
    const errorResponse = {
      success: false,
      error: {
        message: "Internal server error",
        code: "INTERNAL_ERROR",
      },
    };

    // Get request information for logging
    const requestInfo = {
      method: req.method,
      path: req.path,
      ip: req.ip,
    };

    // Handle ServiceError instances
    if (error instanceof ServiceError) {
      // Log the error with appropriate level based on status code
      if (error.statusCode && error.statusCode >= 500) {
        this.logger.error(`API Error: ${error.message}`, {
          error: error.toJSON(),
          request: requestInfo,
        });
      } else {
        this.logger.warn(`API Error: ${error.message}`, {
          error: error.toJSON(),
          request: requestInfo,
        });
      }

      // Set status code from error or default to 500
      const statusCode = error.statusCode || 500;

      // Customize error response based on ServiceError properties
      errorResponse.error = {
        message: error.message,
        code: error.code,
        ...error.metadata,
      };

      return res.status(statusCode).json(errorResponse);
    }

    // Handle NetworkError instances
    if (error instanceof NetworkError) {
      this.logger.error(`Network Error: ${error.message}`, {
        error,
        request: requestInfo,
      });

      errorResponse.error = {
        message: error.message,
        code: "NETWORK_ERROR",
      };

      return res.status(500).json(errorResponse);
    }

    // Handle InitializationError instances
    if (error instanceof InitializationError) {
      this.logger.error(`Initialization Error: ${error.message}`, {
        error,
        request: requestInfo,
      });

      // Type assertion to allow component property
      errorResponse.error = {
        message: error.message,
        code: "INITIALIZATION_ERROR",
        component: error.component,
      } as typeof errorResponse.error & { component: string };

      return res.status(500).json(errorResponse);
    }

    // Handle AppError instances
    if (error instanceof AppError) {
      this.logger.error(`App Error: ${error.message}`, {
        error: error.toJSON(),
        request: requestInfo,
      });

      const statusCode = error.statusCode || 500;

      errorResponse.error = {
        message: error.message,
        code: error.code,
      };

      return res.status(statusCode).json(errorResponse);
    }

    // Handle standard errors
    this.logger.error(`Unhandled error: ${error.message}`, {
      error: error.message,
      stack: error.stack,
      request: requestInfo,
    });

    // For security, don't expose internal error details in production
    if (process.env.NODE_ENV === "production") {
      return res.status(500).json(errorResponse);
    }

    // In development, include more details
    return res.status(500).json({
      ...errorResponse,
      error: {
        ...errorResponse.error,
        message: error.message,
        stack: error.stack,
      },
    });
  };
}


// ---------------------- infrastructure\errors\IErrorHandler.ts (11 lines) ----------------------

import { Request, Response } from "express";

/**
 * Interface for error handling middleware
 */
export interface IErrorHandler {
  /**
   * Handle errors and send appropriate responses
   */
  handleError(error: Error, req: Request, res: Response): Response;
}


// ---------------------- infrastructure\errors\ServiceError.ts (74 lines) ----------------------

import { AppError } from "@/server/infrastructure/errors";

/**
 * Service-specific error class.
 * Used for errors that occur within application services.
 */
export class ServiceError extends AppError {
  /**
   * Create a new ServiceError
   * @param message Error message
   * @param code Error code
   * @param statusCode HTTP status code
   * @param metadata Additional metadata
   */
  constructor(
    message: string,
    code = "SERVICE_ERROR",
    statusCode = 500,
    metadata: Record<string, unknown> = {},
  ) {
    super(message, code, statusCode, metadata);
  }

  /**
   * Create a not found error
   * @param resource Resource type that wasn't found
   * @param id Identifier of the resource
   * @param message Custom message (optional)
   */
  static notFound(
    resource: string,
    id?: string | number,
    message?: string,
  ): ServiceError {
    const defaultMessage = id
      ? `${resource} with ID '${id}' not found`
      : `${resource} not found`;

    return new ServiceError(message || defaultMessage, "NOT_FOUND", 404, {
      resource,
      resourceId: id,
    });
  }

  /**
   * Create a validation error
   * @param message Error message
   * @param validationErrors Validation errors
   */
  static validation(
    message = "Validation error",
    validationErrors: Record<string, string> = {},
  ): ServiceError {
    return new ServiceError(message, "VALIDATION_ERROR", 400, {
      validationErrors,
    });
  }

  /**
   * Create an unauthorized error
   * @param message Error message
   */
  static unauthorized(message = "Unauthorized"): ServiceError {
    return new ServiceError(message, "UNAUTHORIZED", 401);
  }

  /**
   * Create a forbidden error
   * @param message Error message
   */
  static forbidden(message = "Forbidden"): ServiceError {
    return new ServiceError(message, "FORBIDDEN", 403);
  }
}


// ---------------------- infrastructure\errors\base\BaseError.ts (25 lines) ----------------------

/**
 * Base error class that all domain errors should extend
 */
export abstract class BaseError extends Error {
  constructor(
    message: string,
    public code: string,
  ) {
    super(message);
    this.name = this.constructor.name;
    // Maintains proper stack trace for where error was thrown
    Error.captureStackTrace(this, this.constructor);
  }

  /**
   * Convert error to a JSON object suitable for API responses
   */
  toJSON(): { code: string; message: string; name: string } {
    return {
      code: this.code,
      message: this.message,
      name: this.name,
    };
  }
}


// ---------------------- infrastructure\errors\base\index.ts (1 lines) ----------------------

export * from "./BaseError";


// ---------------------- infrastructure\errors\index.ts (360 lines) ----------------------

import { ILoggerService } from "@/server/infrastructure/logging";

import { AppError } from "./AppError";

// Base error classes
export { AppError } from "./AppError";
export { BaseError } from "./base/BaseError";
export { ServiceError } from "./ServiceError";

// Infrastructure errors
export {
  InfrastructureError,
  CacheError,
  NetworkError,
  ExternalServiceError,
} from "./infrastructure/InfrastructureError";
export {
  DatabaseError as InfrastructureDatabaseError,
  EntityNotFoundError,
  UniqueConstraintError,
  ForeignKeyConstraintError,
} from "./infrastructure/DatabaseError";
export {
  ValidationError as InfrastructureValidationError,
  MissingRequiredFieldError,
  InvalidFieldValueError,
} from "./infrastructure/ValidationError";
export type { ValidationErrorDetail } from "./infrastructure/ValidationError";

// Technical errors
export {
  TechnicalError,
  ConfigurationError,
  InitializationError,
  SystemError,
} from "./technical/TechnicalError";

// Error handler
export * from "./ErrorHandler";
export * from "./IErrorHandler";

/**
 * Error codes for the application
 */
export enum ErrorCode {
  // Generic error codes
  INTERNAL_ERROR = "INTERNAL_ERROR",
  NOT_IMPLEMENTED = "NOT_IMPLEMENTED",

  // 400 range client errors
  BAD_REQUEST = "BAD_REQUEST",
  UNAUTHORIZED = "UNAUTHORIZED",
  FORBIDDEN = "FORBIDDEN",
  NOT_FOUND = "NOT_FOUND",
  CONFLICT = "CONFLICT",
  VALIDATION_ERROR = "VALIDATION_ERROR",

  // 500 range server errors
  SERVICE_UNAVAILABLE = "SERVICE_UNAVAILABLE",
  DATABASE_ERROR = "DATABASE_ERROR",
  EXTERNAL_SERVICE_ERROR = "EXTERNAL_SERVICE_ERROR",
}

/**
 * HTTP status codes for common errors
 */
export const HttpStatus = {
  OK: 200,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  CONFLICT: 409,
  UNPROCESSABLE_ENTITY: 422,
  INTERNAL_SERVER_ERROR: 500,
  SERVICE_UNAVAILABLE: 503,
};

/**
 * Predefined error types for common use cases
 */

/**
 * Validation error - for invalid input data (400)
 */
export class ValidationError extends AppError {
  constructor(message: string, metadata: Record<string, unknown> = {}) {
    super(
      message,
      ErrorCode.VALIDATION_ERROR,
      HttpStatus.BAD_REQUEST,
      metadata,
    );
  }
}

/**
 * Authentication error - for missing or invalid authentication (401)
 */
export class AuthenticationError extends AppError {
  constructor(
    message = "Authentication required",
    metadata: Record<string, unknown> = {},
  ) {
    super(message, ErrorCode.UNAUTHORIZED, HttpStatus.UNAUTHORIZED, metadata);
  }
}

/**
 * Permission error - for valid authentication but insufficient permissions (403)
 */
export class PermissionError extends AppError {
  constructor(
    message = "Permission denied",
    metadata: Record<string, unknown> = {},
  ) {
    super(message, ErrorCode.FORBIDDEN, HttpStatus.FORBIDDEN, metadata);
  }
}

/**
 * Not found error - for requests to non-existent resources (404)
 */
export class NotFoundError extends AppError {
  constructor(
    message = "Resource not found",
    metadata: Record<string, unknown> = {},
  ) {
    super(message, ErrorCode.NOT_FOUND, HttpStatus.NOT_FOUND, metadata);
  }
}

/**
 * Conflict error - for requests that would create a conflict (409)
 */
export class ConflictError extends AppError {
  constructor(
    message = "Resource conflict",
    metadata: Record<string, unknown> = {},
  ) {
    super(message, ErrorCode.CONFLICT, HttpStatus.CONFLICT, metadata);
  }
}

/**
 * Service unavailable error - for when a service is temporarily unavailable (503)
 */
export class ServiceUnavailableError extends AppError {
  constructor(
    message = "Service unavailable",
    metadata: Record<string, unknown> = {},
  ) {
    super(
      message,
      ErrorCode.SERVICE_UNAVAILABLE,
      HttpStatus.SERVICE_UNAVAILABLE,
      metadata,
    );
  }
}

/**
 * Database error - for database-related errors (500)
 */
export class DatabaseError extends AppError {
  constructor(
    message = "Database error",
    metadata: Record<string, unknown> = {},
  ) {
    super(
      message,
      ErrorCode.DATABASE_ERROR,
      HttpStatus.INTERNAL_SERVER_ERROR,
      metadata,
    );
  }
}

/**
 * Factory functions for creating errors
 */

/**
 * Create a validation error
 */
export function createValidationError(
  message: string,
  metadata?: Record<string, unknown>,
): ValidationError {
  return new ValidationError(message, metadata);
}

/**
 * Create a not found error
 */
export function createNotFoundError(
  message: string,
  metadata?: Record<string, unknown>,
): NotFoundError {
  return new NotFoundError(message, metadata);
}

/**
 * Create an authentication error
 */
export function createAuthenticationError(
  message: string,
  metadata?: Record<string, unknown>,
): AuthenticationError {
  return new AuthenticationError(message, metadata);
}

/**
 * Create a permission error
 */
export function createPermissionError(
  message: string,
  metadata?: Record<string, unknown>,
): PermissionError {
  return new PermissionError(message, metadata);
}

/**
 * Create a conflict error
 */
export function createConflictError(
  message: string,
  metadata?: Record<string, unknown>,
): ConflictError {
  return new ConflictError(message, metadata);
}

/**
 * Global error handling utilities
 */
export const GlobalErrorHandler = {
  /**
   * Register global handlers for unhandled rejections and exceptions
   * @param logger Logger service to use for logging errors
   */
  register: (logger: ILoggerService): void => {
    // Handle uncaught exceptions
    process.on("uncaughtException", (error: Error) => {
      logger.error("Uncaught Exception", {
        error: error.message,
        stack: error.stack,
      });

      // In test environment, don't exit the process
      if (process.env.NODE_ENV !== "test") {
        // Give logger time to flush, then exit
        setTimeout(() => {
          process.exit(1);
        }, 1000);
      }
    });

    // Handle unhandled promise rejections
    process.on(
      "unhandledRejection",
      (reason: unknown, _promise: Promise<unknown>) => {
        logger.error("Unhandled Promise Rejection", {
          reason: reason instanceof Error ? reason.message : String(reason),
          stack: reason instanceof Error ? reason.stack : undefined,
        });
      },
    );
  },
};

// Base API Error class
export class ApiError extends Error {
  statusCode: number;
  errors?: Record<string, string[]>;

  constructor(
    statusCode: number,
    message: string,
    errors?: Record<string, string[]>,
  ) {
    super(message);
    this.statusCode = statusCode;
    this.errors = errors;
    this.name = this.constructor.name;
    Error.captureStackTrace(this, this.constructor);
  }
}

// 400 Bad Request - Invalid request format or invalid data
export class ApiValidationError extends ApiError {
  constructor(message = "Bad request", errors?: Record<string, string[]>) {
    super(400, message, errors);
  }
}

// 401 Unauthorized - Authentication failure
export class UnauthorizedError extends ApiError {
  constructor(message = "Unauthorized") {
    super(401, message);
  }
}

// 403 Forbidden - Permission denied
export class ForbiddenError extends ApiError {
  constructor(message = "Forbidden") {
    super(403, message);
  }
}

// 404 Not Found - Resource doesn't exist
export class ApiNotFoundError extends ApiError {
  constructor(message = "Resource not found") {
    super(404, message);
  }
}

// 409 Conflict - Resource already exists
export class ApiConflictError extends ApiError {
  constructor(message = "Conflict", errors?: Record<string, string[]>) {
    super(409, message, errors);
  }
}

// 500 Internal Server Error - Unexpected server error
export class InternalServerError extends ApiError {
  constructor(message = "Internal server error") {
    super(500, message);
  }
}

// 429 Too Many Requests - Rate limiting
export class TooManyRequestsError extends ApiError {
  constructor(message = "Too many requests") {
    super(429, message);
  }
}

// Error handler middleware
export const errorHandler = (
  err: Error,
  _req: import("express").Request,
  res: import("express").Response,
  _next: import("express").NextFunction,
): import("express").Response => {
  console.error(err);

  if (err instanceof ApiError) {
    return res.status(err.statusCode).json({
      success: false,
      message: err.message,
      errors: err.errors,
    });
  }

  // Default to 500 server error
  return res.status(500).json({
    success: false,
    message: "Internal server error",
  });
};


// ---------------------- infrastructure\errors\infrastructure\ConfigValidationError.ts (35 lines) ----------------------

/**
 * Error thrown when configuration validation fails
 */
export class ConfigValidationError extends Error {
  /**
   * Validation error messages
   */
  public readonly errors: string[];

  /**
   * Creates a new ConfigValidationError
   *
   * @param message Error message
   * @param errors Validation error messages
   */
  constructor(message: string, errors: string[]) {
    super(message);
    this.name = "ConfigValidationError";
    this.errors = errors;
  }

  /**
   * Gets a formatted error message with all validation errors
   *
   * @returns Formatted error message
   */
  getFormattedMessage(): string {
    return [
      this.message,
      "",
      "Validation errors:",
      ...this.errors.map((error) => `- ${error}`),
    ].join("\n");
  }
}


// ---------------------- infrastructure\errors\infrastructure\DatabaseError.ts (124 lines) ----------------------

/**
 * Base error class for database-related errors
 */
export class DatabaseError extends Error {
  public readonly code: string;
  public readonly operation: string;
  public readonly entity: string;
  public readonly cause?: Error | string;

  constructor(
    operation: string,
    entity: string,
    cause?: Error | string,
    code = "DATABASE_ERROR",
  ) {
    const causeMessage = cause instanceof Error ? cause.message : cause;
    super(
      `Database operation '${operation}' failed for ${entity}${causeMessage ? `: ${causeMessage}` : ""}`,
    );
    this.name = "DatabaseError";
    this.code = code;
    this.operation = operation;
    this.entity = entity;
    this.cause = cause;
  }

  toJSON(): Record<string, unknown> {
    return {
      name: this.name,
      message: this.message,
      code: this.code,
      operation: this.operation,
      entity: this.entity,
      cause: this.cause instanceof Error ? this.cause.message : this.cause,
    };
  }
}

/**
 * Error thrown when an entity is not found in the database
 */
export class EntityNotFoundError extends DatabaseError {
  public readonly identifier: string | number;

  constructor(entity: string, identifier: string | number) {
    super(
      "find",
      entity,
      `Entity with identifier ${identifier} not found`,
      "ENTITY_NOT_FOUND",
    );
    this.identifier = identifier;
    this.message = `Database operation 'find' failed for ${entity} with identifier ${identifier} not found`;
  }

  toJSON(): Record<string, unknown> {
    return {
      ...super.toJSON(),
      identifier: this.identifier,
    };
  }
}

/**
 * Error thrown when a unique constraint is violated
 */
export class UniqueConstraintError extends DatabaseError {
  public readonly field: string;
  public readonly value: string | number;

  constructor(entity: string, field: string, value: string | number) {
    super(
      "create/update",
      entity,
      `Unique constraint violation on field '${field}' with value '${value}'`,
      "UNIQUE_CONSTRAINT_VIOLATION",
    );
    this.field = field;
    this.value = value;
    this.message = `Database operation 'create/update' failed for ${entity} with ${field} '${value}' already exists`;
  }

  toJSON(): Record<string, unknown> {
    return {
      ...super.toJSON(),
      field: this.field,
      value: this.value,
    };
  }
}

/**
 * Error thrown when a foreign key constraint is violated
 */
export class ForeignKeyConstraintError extends DatabaseError {
  public readonly constraint: string;
  public readonly value: string | number;

  constructor(entity: string, constraint: string, value: string | number) {
    super(
      "create/update",
      entity,
      `Foreign key constraint violation on field '${constraint}' with value '${value}'`,
      "FOREIGN_KEY_CONSTRAINT_VIOLATION",
    );
    this.constraint = constraint;
    this.value = value;
    this.message = `Database operation 'create/update' failed for ${entity} violates foreign key constraint '${constraint}' with value '${value}'`;
  }

  toJSON(): Record<string, unknown> {
    return {
      ...super.toJSON(),
      constraint: this.constraint,
      value: this.value,
    };
  }
}

export const DatabaseErrors = {
  EntityNotFound: EntityNotFoundError,
  UniqueConstraint: UniqueConstraintError,
  ForeignKeyConstraint: ForeignKeyConstraintError,
};


// ---------------------- infrastructure\errors\infrastructure\InfrastructureError.ts (94 lines) ----------------------

import { BaseError } from "@/server/infrastructure/errors";

/**
 * Base class for all infrastructure-related errors
 * This includes errors with databases, caches, external services, etc.
 */
export class InfrastructureError extends BaseError {
  /**
   * Create a new infrastructure error
   * @param message Error message
   * @param code Error code
   */
  constructor(message: string, code = "INFRASTRUCTURE_ERROR") {
    super(message, code);
  }
}

/**
 * Error thrown when a cache operation fails
 */
export class CacheError extends InfrastructureError {
  readonly operation: string;
  readonly key?: string;
  readonly cause?: Error | string;

  /**
   * Create a new cache error
   * @param operation Operation that failed (get, set, delete, etc.)
   * @param key Optional cache key that was being accessed
   * @param cause Optional cause of the error
   */
  constructor(operation: string, key?: string, cause?: Error | string) {
    const causeMessage = cause instanceof Error ? cause.message : cause;
    super(
      `Cache operation '${operation}'${key ? ` for key '${key}'` : ""} failed${causeMessage ? `: ${causeMessage}` : ""}`,
      "CACHE_ERROR",
    );
    this.operation = operation;
    this.key = key;
    this.cause = cause;
  }
}

/**
 * Error thrown when a network operation fails
 */
export class NetworkError extends InfrastructureError {
  readonly url?: string;
  readonly statusCode?: number;
  readonly cause?: Error | string;

  /**
   * Create a new network error
   * @param url Optional URL that was being accessed
   * @param statusCode Optional HTTP status code
   * @param cause Optional cause of the error
   */
  constructor(url?: string, statusCode?: number, cause?: Error | string) {
    const causeMessage = cause instanceof Error ? cause.message : cause;
    super(
      `Network request${url ? ` to '${url}'` : ""}${statusCode ? ` failed with status ${statusCode}` : " failed"}${causeMessage ? `: ${causeMessage}` : ""}`,
      "NETWORK_ERROR",
    );
    this.url = url;
    this.statusCode = statusCode;
    this.cause = cause;
  }
}

/**
 * Error thrown when an external service operation fails
 */
export class ExternalServiceError extends InfrastructureError {
  readonly service: string;
  readonly operation: string;
  readonly cause?: Error | string;

  /**
   * Create a new external service error
   * @param service External service name
   * @param operation Operation that failed
   * @param cause Optional cause of the error
   */
  constructor(service: string, operation: string, cause?: Error | string) {
    const causeMessage = cause instanceof Error ? cause.message : cause;
    super(
      `External service '${service}' operation '${operation}' failed${causeMessage ? `: ${causeMessage}` : ""}`,
      "EXTERNAL_SERVICE_ERROR",
    );
    this.service = service;
    this.operation = operation;
    this.cause = cause;
  }
}


// ---------------------- infrastructure\errors\infrastructure\ValidationError.ts (87 lines) ----------------------

/**
 * Interface for validation error details
 */
export interface ValidationErrorDetail {
  field: string;
  message: string;
  code?: string;
}

/**
 * Base error class for validation errors
 */
export class ValidationError extends Error {
  public readonly code: string;
  public readonly details: Array<{
    field: string;
    message: string;
    code?: string;
  }>;
  public readonly entity?: string;

  constructor(
    details: Array<{
      field: string;
      message: string;
      code?: string;
    }>,
    entity?: string,
    code: string = "VALIDATION_ERROR",
  ) {
    super(entity ? `Validation failed for ${entity}` : "Validation failed");
    this.name = "ValidationError";
    this.code = code;
    this.details = details;
    this.entity = entity;
  }

  /**
   * Convert error to a JSON object suitable for API responses
   */
  toJSON(): Record<string, unknown> {
    return {
      name: this.name,
      message: this.message,
      code: this.code,
      details: this.details,
      entity: this.entity,
    };
  }
}

/**
 * Error thrown when required fields are missing
 */
export class MissingRequiredFieldError extends ValidationError {
  constructor(fields: string[], entity?: string) {
    const details = fields.map((field) => ({
      field,
      message: "Field is required",
      code: "REQUIRED_FIELD",
    }));

    super(details, entity, "MISSING_REQUIRED_FIELDS");
  }
}

/**
 * Error thrown when a field has an invalid value
 */
export class InvalidFieldValueError extends ValidationError {
  constructor(field: string, message: string, entity?: string) {
    const details = [
      {
        field,
        message,
        code: "INVALID_VALUE",
      },
    ];

    super(details, entity, "INVALID_FIELD_VALUE");
  }
}

export const ValidationErrors = {
  MissingRequiredFields: MissingRequiredFieldError,
  InvalidFieldValue: InvalidFieldValueError,
};


// ---------------------- infrastructure\errors\technical\TechnicalError.ts (85 lines) ----------------------

import { AppError } from "@/server/infrastructure/errors";

/**
 * Base class for all technical errors
 * These are errors related to the application itself rather than domain or infrastructure
 */
export class TechnicalError extends AppError {
  /**
   * Create a new technical error
   * @param message Error message
   * @param code Error code
   * @param statusCode HTTP status code
   */
  constructor(message: string, code = "TECHNICAL_ERROR", statusCode = 500) {
    super(message, code, statusCode);
  }
}

/**
 * Error thrown when there's an issue with configuration
 */
export class ConfigurationError extends TechnicalError {
  readonly configKey?: string;

  /**
   * Create a new configuration error
   * @param message Error message
   * @param configKey Optional configuration key that caused the error
   */
  constructor(message: string, configKey?: string) {
    super(
      configKey
        ? `Configuration error for '${configKey}': ${message}`
        : message,
      "CONFIGURATION_ERROR",
    );
    this.configKey = configKey;
  }
}

/**
 * Error thrown when there's an issue with initialization
 */
export class InitializationError extends TechnicalError {
  readonly component: string;
  readonly cause?: Error | string;

  /**
   * Create a new initialization error
   * @param component Component that failed to initialize
   * @param cause Optional cause of the error
   */
  constructor(component: string, cause?: Error | string) {
    const causeMessage = cause instanceof Error ? cause.message : cause;
    super(
      `Failed to initialize ${component}${causeMessage ? `: ${causeMessage}` : ""}`,
      "INITIALIZATION_ERROR",
    );
    this.component = component;
    this.cause = cause;
  }
}

/**
 * Error thrown when there's a system-level issue
 */
export class SystemError extends TechnicalError {
  readonly operation: string;
  readonly cause?: Error | string;

  /**
   * Create a new system error
   * @param operation Operation that failed
   * @param cause Optional cause of the error
   */
  constructor(operation: string, cause?: Error | string) {
    const causeMessage = cause instanceof Error ? cause.message : cause;
    super(
      `System operation '${operation}' failed${causeMessage ? `: ${causeMessage}` : ""}`,
      "SYSTEM_ERROR",
    );
    this.operation = operation;
    this.cause = cause;
  }
}


// ---------------------- infrastructure\index.ts (14 lines) ----------------------

// Export core interfaces and types
export * from "./cache";
export { ConfigService } from "./config";
export type { IConfigService } from "./config";
export * from "./di";
export * from "./errors";
export * from "./jobs";
export * from "./logging";
export * from "./storage";
export * from "./pubsub";
export { DatabaseServer } from "./database";
export type { IDatabaseServer } from "./database";
export * from "./server";
export * from "./lifecycle";


// ---------------------- infrastructure\jobs\IJobService.ts (165 lines) ----------------------

import { JobType, JobOptions } from "@/server/infrastructure/jobs";

/**
 * Dependency status result
 */
export interface DependencyStatus {
  /**
   * Whether all dependencies are resolved
   */
  resolved: boolean;

  /**
   * Reason if not resolved
   */
  reason?: string;

  /**
   * Status of each dependency
   */
  dependencies: Array<{
    jobId: string;
    status: string;
    success?: boolean;
  }>;
}

/**
 * Standard job result interface
 */
export interface JobResult {
  success: boolean;
  error?: string;
  data?: unknown;
}

/**
 * Job processor function type
 */
export type JobProcessor<T> = (data: T) => Promise<void>;

/**
 * Enhanced job statistics
 */
export interface JobStats {
  waiting: number;
  active: number;
  completed: number;
  failed: number;
  delayed: number;
  blocked: number; // Jobs waiting on dependencies

  /**
   * Number of jobs by priority level
   */
  priorityBreakdown: Record<string, number>;

  /**
   * Performance metrics for this job type
   */
  performance?: {
    /**
     * Average processing time in milliseconds
     */
    averageProcessingTime: number;

    /**
     * Success rate (percent of jobs that succeeded)
     */
    successRate: number;

    /**
     * Number of jobs that required retries
     */
    jobsWithRetries: number;

    /**
     * Average wait time before processing
     */
    averageWaitTime: number;
  };
}

/**
 * Core job service interface
 */
export interface IJobService {
  /**
   * Add a job to the queue
   * @param type The job type
   * @param data The data required for the job
   * @param options Optional job configuration
   * @returns A unique job ID
   */
  addJob<T>(type: JobType, data: T, options?: JobOptions): Promise<string>;

  /**
   * Register a processor function for a job type
   * @param type The job type
   * @param processor The function that processes jobs of this type
   */
  registerProcessor<T>(type: JobType, processor: JobProcessor<T>): void;

  /**
   * Pause processing for a specific job queue
   * @param type The job type
   */
  pauseQueue(type: JobType): Promise<void>;

  /**
   * Resume processing for a specific job queue
   * @param type The job type
   */
  resumeQueue(type: JobType): Promise<void>;

  /**
   * Get statistics for a specific job type
   * @param type The job type
   * @returns Current job statistics
   */
  getStats(type: JobType): Promise<JobStats>;

  /**
   * Check the status of a job's dependencies
   * @param jobId The job ID
   * @param type The job type
   * @returns Status of the job's dependencies
   */
  checkDependencies(type: JobType, jobId: string): Promise<DependencyStatus>;

  /**
   * Chain a new job to depend on completion of an existing job
   * @param type The job type
   * @param data The data required for the job
   * @param dependsOnJobId The ID of the job this new job depends on
   * @param options Optional job configuration
   * @returns A unique job ID
   */
  chainJob<T>(
    type: JobType,
    data: T,
    dependsOnJobId: string,
    options?: JobOptions,
  ): Promise<string>;

  /**
   * Get the current status of a job
   * @param type The job type
   * @param jobId The job ID
   * @returns The job status and result if available
   */
  getJobStatus<T>(
    type: JobType,
    jobId: string,
  ): Promise<{ status: string; result?: JobResult; data?: T } | null>;

  /**
   * Initialize the job service
   */
  initialize(): Promise<void>;

  /**
   * Gracefully shut down the job service
   */
  shutdown(): Promise<void>;
}


// ---------------------- infrastructure\jobs\JobService.ts (575 lines) ----------------------

// Built-in Node.js modules
import { randomBytes } from "crypto";
import { EventEmitter } from "events";

// External modules
import { injectable, inject } from "inversify";

// Internal modules (with @ aliases)
import { TYPES } from "@/server/infrastructure/di/types";
// Parent/sibling imports
import type { ILoggerService } from "@/server/infrastructure/logging";

import { JobPriority, DependencyResolutionStrategy } from "./JobTypes";

import type {
  IJobService,
  JobProcessor,
  JobResult,
  JobStats,
} from "./IJobService";
import type { JobType, JobOptions } from "./JobTypes";
import type {
  IJobStorage,
  JobData,
  DependencyStatus,
} from "./storage/IJobStorage";

/**
 * Configuration for the job service
 */
export interface JobServiceConfig {
  /**
   * Maximum concurrent jobs
   */
  maxConcurrentJobs?: number;

  /**
   * Polling interval in milliseconds
   */
  pollingInterval?: number;

  /**
   * Default job options
   */
  defaultJobOptions?: JobOptions;
}

/**
 * Job service implementation
 */
@injectable()
export class JobService implements IJobService {
  private processors = new Map<JobType, JobProcessor<unknown>>();
  private pausedQueues = new Set<JobType>();
  private activeJobs = new Map<string, boolean>();
  private isProcessing = false;
  private pollingInterval: number;
  private maxConcurrentJobs: number;
  private defaultJobOptions: JobOptions;
  private events = new EventEmitter();
  private pollingTimer: NodeJS.Timeout | null = null;
  private initialized = false;

  constructor(
    @inject(TYPES.LoggerService) private logger: ILoggerService,
    @inject(TYPES.JobStorage) private storage: IJobStorage,
    @inject(TYPES.JobServiceConfig) config: JobServiceConfig,
  ) {
    this.pollingInterval = config.pollingInterval || 1000;
    this.maxConcurrentJobs = config.maxConcurrentJobs || 10;
    this.defaultJobOptions = config.defaultJobOptions || {
      priority: JobPriority.NORMAL,
      attempts: 3,
      backoff: {
        type: "exponential",
        delay: 1000,
      },
    };
  }

  /**
   * Initialize the job service
   */
  async initialize(): Promise<void> {
    if (this.initialized) return;

    // Initialize storage
    await this.storage.initialize();

    // Start processing jobs
    this.startProcessing();

    this.initialized = true;
    this.logger.info("Job service initialized");
  }

  /**
   * Add a job to the queue
   */
  async addJob<T>(
    type: JobType,
    data: T,
    options?: JobOptions,
  ): Promise<string> {
    await this.ensureInitialized();

    // Merge with default options
    const mergedOptions = {
      ...this.defaultJobOptions,
      ...options,
    };

    // Generate job ID if not provided
    const jobId = mergedOptions.jobId || (await this.generateId());

    // Calculate scheduled time if delay is provided
    const now = new Date();
    const scheduledFor = mergedOptions.delay
      ? new Date(now.getTime() + mergedOptions.delay)
      : now;

    // Create job data
    const job: JobData<T> = {
      id: jobId,
      type,
      data,
      status: mergedOptions.delay ? "delayed" : "waiting",
      priority: mergedOptions.priority || JobPriority.NORMAL,
      attempts: 0,
      maxAttempts:
        mergedOptions.attempts || this.defaultJobOptions.attempts || 3,
      createdAt: now,
      updatedAt: now,
      scheduledFor,
    };

    // Save job to storage
    await this.storage.saveJob(job);

    this.logger.debug("Job added to queue", {
      jobId,
      jobType: type,
      scheduled: scheduledFor.toISOString(),
    });

    return jobId;
  }

  /**
   * Register a job processor
   */
  registerProcessor<T>(type: JobType, processor: JobProcessor<T>): void {
    if (this.processors.has(type)) {
      this.logger.warn("Overwriting existing processor", { jobType: type });
    }

    this.processors.set(type, processor as JobProcessor<unknown>);
    this.logger.info("Registered job processor", { jobType: type });
  }

  /**
   * Pause a job queue
   */
  async pauseQueue(type: JobType): Promise<void> {
    await this.ensureInitialized();

    this.pausedQueues.add(type);
    this.logger.info("Paused job queue", { jobType: type });
  }

  /**
   * Resume a job queue
   */
  async resumeQueue(type: JobType): Promise<void> {
    await this.ensureInitialized();

    this.pausedQueues.delete(type);
    this.logger.info("Resumed job queue", { jobType: type });
  }

  /**
   * Get job statistics
   */
  async getStats(type: JobType): Promise<JobStats> {
    await this.ensureInitialized();

    const counts = await this.storage.getJobCounts(type);

    // Calculate priority breakdown
    const priorityBreakdown: Record<string, number> = {};
    const jobs = await this.storage.getJobsByStatus(type, "waiting", 100);
    for (const job of jobs) {
      const priority = job.priority.toString();
      priorityBreakdown[priority] = (priorityBreakdown[priority] || 0) + 1;
    }

    return {
      waiting: counts.waiting,
      active: counts.active,
      completed: counts.completed,
      failed: counts.failed,
      delayed: counts.delayed,
      blocked: counts.blocked,
      priorityBreakdown,
      performance: {
        averageProcessingTime: 0, // TODO: Implement performance metrics
        successRate: 0,
        jobsWithRetries: 0,
        averageWaitTime: 0,
      },
    };
  }

  /**
   * Shut down job service
   */
  async shutdown(): Promise<void> {
    if (!this.initialized) return;

    // Stop polling
    if (this.pollingTimer) {
      clearInterval(this.pollingTimer);
      this.pollingTimer = null;
    }

    // Stop processing new jobs
    this.isProcessing = false;

    // Wait for all active jobs to complete
    if (this.activeJobs.size > 0) {
      this.logger.info("Waiting for active jobs to complete", {
        count: this.activeJobs.size,
      });

      await new Promise<void>((resolve) => {
        const checkComplete = (): void => {
          if (this.activeJobs.size === 0) {
            resolve();
          } else {
            setTimeout(checkComplete, 100);
          }
        };
        checkComplete();
      });
    }

    // Close the storage
    await this.storage.close();

    this.initialized = false;
    this.logger.info("Job service shutdown complete");
  }

  /**
   * Start job processing
   */
  private startProcessing(): void {
    if (this.pollingTimer) {
      clearInterval(this.pollingTimer);
    }

    this.pollingTimer = setInterval(() => {
      this.processNextBatch().catch((error) => {
        this.logger.error("Job processing error", { error });
      });
    }, this.pollingInterval);

    this.logger.debug("Started job processing", {
      pollingInterval: this.pollingInterval,
      maxConcurrentJobs: this.maxConcurrentJobs,
    });
  }

  /**
   * Process the next batch of jobs
   */
  private async processNextBatch(): Promise<void> {
    if (this.isProcessing) return;

    this.isProcessing = true;

    try {
      // Check how many slots are available
      const availableSlots = this.maxConcurrentJobs - this.activeJobs.size;

      if (availableSlots <= 0) {
        return;
      }

      // Process delayed jobs that are ready
      await this.moveReadyDelayedJobs();

      // Get all job types with registered processors
      const jobTypes = Array.from(this.processors.keys()).filter(
        (type) => !this.pausedQueues.has(type),
      );

      if (jobTypes.length === 0) {
        return;
      }

      // For each job type, get the next jobs
      for (const jobType of jobTypes) {
        // Skip if we have no more slots
        if (this.activeJobs.size >= this.maxConcurrentJobs) {
          break;
        }

        // Get the next waiting jobs
        const availableJobs = await this.storage.getJobsByStatus(
          jobType,
          "waiting",
          availableSlots,
        );

        if (availableJobs.length === 0) {
          continue;
        }

        // Process each job
        for (const job of availableJobs) {
          // Skip if we have no more slots
          if (this.activeJobs.size >= this.maxConcurrentJobs) {
            break;
          }

          // Mark as active
          this.activeJobs.set(job.id, true);

          // Update job status
          await this.storage.updateJobStatus(job.type, job.id, "active");

          // Process the job
          this.processJob(job).catch((error) => {
            this.logger.error("Error processing job", {
              jobId: job.id,
              jobType: job.type,
              error,
            });
          });
        }
      }
    } finally {
      this.isProcessing = false;
    }
  }

  /**
   * Move delayed jobs that are ready to waiting status
   */
  private async moveReadyDelayedJobs(): Promise<void> {
    const now = new Date();

    // For each job type, get delayed jobs
    for (const jobType of this.processors.keys()) {
      const delayedJobs = await this.storage.getJobsByStatus(
        jobType,
        "delayed",
        100,
      );

      for (const job of delayedJobs) {
        if (job.scheduledFor && job.scheduledFor <= now) {
          await this.storage.updateJobStatus(job.type, job.id, "waiting");
        }
      }
    }
  }

  /**
   * Process a single job
   */
  private async processJob(job: JobData): Promise<void> {
    const startTime = Date.now();

    this.logger.debug("Processing job", {
      jobId: job.id,
      jobType: job.type,
      attempt: job.attempts + 1,
    });

    try {
      // Get the processor for this job type
      const processor = this.processors.get(job.type);

      if (!processor) {
        throw new Error(`No processor registered for job type: ${job.type}`);
      }

      // Update attempts count
      job.attempts++;

      // Execute the processor
      await processor(job.data);

      // Job succeeded
      const processingTime = Date.now() - startTime;

      // Mark as completed
      await this.storage.updateJobStatus(job.type, job.id, "completed", {
        success: true,
        data: { processingTime },
      });

      this.logger.debug("Job completed successfully", {
        jobId: job.id,
        jobType: job.type,
        processingTime,
      });

      // Emit completion event
      this.events.emit("job:complete", job.type, job.id);
    } catch (error) {
      // Handle failure
      const processingTime = Date.now() - startTime;

      // Determine if we should retry
      if (job.attempts < job.maxAttempts) {
        // Calculate delay based on backoff
        const delay = this.calculateBackoff(job);

        // Schedule retry
        const scheduledFor = new Date(Date.now() + delay);

        // Update job for retry
        job.scheduledFor = scheduledFor;
        job.status = "delayed";
        job.updatedAt = new Date();
        await this.storage.saveJob(job);

        this.logger.warn("Job failed, scheduled for retry", {
          jobId: job.id,
          jobType: job.type,
          attempt: job.attempts,
          nextAttemptAt: scheduledFor.toISOString(),
          error,
        });
      } else {
        // Mark as failed
        await this.storage.updateJobStatus(job.type, job.id, "failed", {
          success: false,
          error: error instanceof Error ? error.message : String(error),
          data: { processingTime },
        });

        this.logger.error("Job failed permanently", {
          jobId: job.id,
          jobType: job.type,
          attempts: job.attempts,
          error,
        });

        // Emit failure event
        this.events.emit("job:failed", job.type, job.id);
      }
    } finally {
      // Remove from active jobs
      this.activeJobs.delete(job.id);
    }
  }

  /**
   * Calculate backoff delay for a failed job
   */
  private calculateBackoff(job: JobData): number {
    // Default backoff
    const defaultBackoff = {
      type: "exponential",
      delay: 1000,
    };

    // Get backoff config
    const backoff = this.defaultJobOptions.backoff || defaultBackoff;

    // Calculate delay based on type
    if (backoff.type === "fixed") {
      return backoff.delay;
    } else if (backoff.type === "exponential") {
      // Exponential backoff: delay * 2^(attempts-1)
      return backoff.delay * Math.pow(2, job.attempts - 1);
    }

    // Fallback to fixed delay
    return backoff.delay;
  }

  /**
   * Generate a unique ID
   */
  private async generateId(): Promise<string> {
    // For tests that mock uuidv4, try to use that first
    if (process.env.NODE_ENV === "test") {
      try {
        const uuidModule = await import("uuid");
        return uuidModule.v4();
      } catch (_error) {
        // Fallback to random bytes if uuid is not available
      }
    }
    return randomBytes(8).toString("hex");
  }

  /**
   * Ensure service is initialized
   */
  private async ensureInitialized(): Promise<void> {
    if (!this.initialized) {
      await this.initialize();
    }
  }

  /**
   * Check the status of a job's dependencies
   */
  async checkDependencies(
    type: JobType,
    jobId: string,
  ): Promise<DependencyStatus> {
    await this.ensureInitialized();
    return this.storage.checkDependencies(type, jobId);
  }

  /**
   * Chain a new job to depend on completion of an existing job
   */
  async chainJob<T>(
    type: JobType,
    data: T,
    dependsOnJobId: string,
    options?: JobOptions,
  ): Promise<string> {
    await this.ensureInitialized();

    // Create the new job
    const jobId = await this.addJob(type, data, options);

    // Get the job we just created
    const job = await this.storage.getJob(type, jobId);
    if (!job) {
      throw new Error(`Failed to create chained job: ${jobId}`);
    }

    // Add dependency
    job.dependencies = {
      jobIds: [dependsOnJobId],
      strategy: DependencyResolutionStrategy.FAIL_ON_ANY_FAILURE,
    };

    // Save the updated job
    await this.storage.saveJob(job);

    return jobId;
  }

  /**
   * Get the current status of a job
   */
  async getJobStatus<T>(
    type: JobType,
    jobId: string,
  ): Promise<{ status: string; result?: JobResult; data?: T } | null> {
    await this.ensureInitialized();

    const job = await this.storage.getJob<T>(type, jobId);
    if (!job) {
      return null;
    }

    return {
      status: job.status,
      result: job.result,
      data: job.data,
    };
  }
}


// ---------------------- infrastructure\jobs\JobTypes.ts (230 lines) ----------------------

/**
 * Types of background jobs supported by the application
 */
export enum JobType {
  // Media processing jobs
  MEDIA_PROCESSING = "media_processing",
  VIDEO_TRANSCODING = "video_transcoding",
  IMAGE_OPTIMIZATION = "image_optimization",
  THUMBNAIL_GENERATION = "thumbnail_generation",

  // Communication jobs
  EMAIL_NOTIFICATION = "email_notification",
  PUSH_NOTIFICATION = "push_notification",

  // Content jobs
  FEED_GENERATION = "feed_generation",
  CONTENT_INDEXING = "content_indexing",

  // User-related jobs
  USER_ONBOARDING = "user_onboarding",
  ACCOUNT_CLEANUP = "account_cleanup",

  // System jobs
  DATABASE_BACKUP = "database_backup",
  CACHE_MAINTENANCE = "cache_maintenance",
  REPORT_GENERATION = "report_generation",
}

/**
 * Job priority levels
 */
export enum JobPriority {
  LOWEST = 20,
  LOW = 10,
  NORMAL = 0,
  MEDIUM = -5,
  HIGH = -10,
  CRITICAL = -15,
  URGENT = -20,
}

/**
 * Strategy for handling job dependency failures
 */
export enum DependencyResolutionStrategy {
  /**
   * Fail the dependent job if any dependency fails
   */
  FAIL_ON_ANY_FAILURE = "fail_on_any_failure",

  /**
   * Only require that dependencies complete, regardless of their success
   */
  CONTINUE_ON_FAILURE = "continue_on_failure",

  /**
   * Skip the dependent job if any dependency fails
   */
  SKIP_ON_FAILURE = "skip_on_failure",
}

/**
 * Media format type
 */
export type MediaFormatType = "thumbnail" | "preview" | "standard" | "hd";

/**
 * Media processing job data
 */
export interface MediaProcessingJobData {
  /**
   * Unique ID of the media being processed
   */
  mediaId: string;

  /**
   * User ID who owns the media
   */
  userId: string;

  /**
   * Path to the original media file
   */
  originalPath: string;

  /**
   * Target output formats to generate
   */
  targetFormats: Array<{
    /**
     * Type of format to generate
     */
    type: MediaFormatType;

    /**
     * Target width in pixels
     */
    width: number;

    /**
     * Target height in pixels
     */
    height: number;

    /**
     * Quality setting (1-100, for lossy formats)
     */
    quality: number;

    /**
     * Optional target format (defaults to format based on type)
     */
    format?: "jpeg" | "webp" | "png" | "mp4" | "webm";

    /**
     * Optional target path (if not provided, will be auto-generated)
     */
    targetPath?: string;
  }>;

  /**
   * Optional metadata to include with the processed media
   */
  metadata?: Record<string, unknown>;

  /**
   * Optional processing options
   */
  options?: {
    /**
     * Whether to preserve the original aspect ratio
     */
    preserveAspectRatio?: boolean;

    /**
     * Whether to strip metadata from the processed media
     */
    stripMetadata?: boolean;

    /**
     * Custom options for specific media types
     */
    custom?: Record<string, unknown>;
  };
}

/**
 * Job options interface
 */
export interface JobOptions {
  /**
   * Job priority
   */
  priority?: JobPriority;

  /**
   * Number of retry attempts
   */
  attempts?: number;

  /**
   * Retry backoff configuration
   */
  backoff?: {
    /**
     * Type of backoff strategy
     */
    type: "fixed" | "exponential";

    /**
     * Base delay in milliseconds
     */
    delay: number;
  };

  /**
   * Timeout in milliseconds
   */
  timeout?: number;

  /**
   * Delay before the job is processed (in milliseconds)
   */
  delay?: number;

  /**
   * Optional custom job ID
   */
  jobId?: string;

  /**
   * Job dependencies - these jobs must complete before this job can start
   */
  dependsOn?: {
    /**
     * IDs of jobs that must complete before this job can start
     */
    jobIds: string[];

    /**
     * How to handle dependency failures
     * @default DependencyResolutionStrategy.FAIL_ON_ANY_FAILURE
     */
    strategy?: DependencyResolutionStrategy;
  };

  /**
   * Optional metadata for the job
   */
  metadata?: Record<string, unknown>;
}

/**
 * Type to map job types to their data types
 */
export interface JobDataMap {
  [JobType.MEDIA_PROCESSING]: MediaProcessingJobData;
  [JobType.VIDEO_TRANSCODING]: Record<string, unknown>;
  [JobType.IMAGE_OPTIMIZATION]: Record<string, unknown>;
  [JobType.THUMBNAIL_GENERATION]: Record<string, unknown>;
  [JobType.EMAIL_NOTIFICATION]: Record<string, unknown>;
  [JobType.PUSH_NOTIFICATION]: Record<string, unknown>;
  [JobType.FEED_GENERATION]: Record<string, unknown>;
  [JobType.CONTENT_INDEXING]: Record<string, unknown>;
  [JobType.USER_ONBOARDING]: Record<string, unknown>;
  [JobType.ACCOUNT_CLEANUP]: Record<string, unknown>;
  [JobType.DATABASE_BACKUP]: Record<string, unknown>;
  [JobType.CACHE_MAINTENANCE]: Record<string, unknown>;
  [JobType.REPORT_GENERATION]: Record<string, unknown>;
}


// ---------------------- infrastructure\jobs\index.ts (28 lines) ----------------------

/**
 * Infrastructure job queue and service exports
 */

// Core types
export { JobType, DependencyResolutionStrategy } from "./JobTypes";
export type { JobPriority, JobOptions } from "./JobTypes";

// Job service interfaces and implementations
export type {
  IJobService,
  JobProcessor,
  JobResult,
  JobStats,
  DependencyStatus,
} from "./IJobService";
export { JobService } from "./JobService";
export type { JobServiceConfig } from "./JobService";

// Storage
export type { IJobStorage, JobData, JobStatus } from "./storage/IJobStorage";
export { FileJobStorage } from "./storage/FileJobStorage";
export type { FileJobStorageConfig } from "./storage/FileJobStorage";

/* 
Note: Legacy exports have been removed. Import from the specific files 
above if needed for backward compatibility during migration.
*/


// ---------------------- infrastructure\jobs\storage\FileJobStorage.ts (516 lines) ----------------------

import path from "path";

import { injectable, inject } from "inversify";

import { TYPES } from "@/server/infrastructure/di/types";
import {
  IJobStorage,
  JobData,
  JobStatus,
  JobResult,
  JobType,
} from "@/server/infrastructure/jobs";
import type { ILoggerService } from "@/server/infrastructure/logging";
import type { IStorageService } from "@/server/infrastructure/storage";

interface DependencyStatus {
  resolved: boolean;
  reason?: string;
  dependencies: Array<{
    jobId: string;
    status: JobStatus;
    success?: boolean;
  }>;
}

/**
 * Configuration for file job storage
 */
export interface FileJobStorageConfig {
  /**
   * Base path for storing job files
   */
  basePath: string;

  /**
   * Time in ms to retain completed jobs
   */
  completedJobRetention?: number;

  /**
   * Time in ms to retain failed jobs
   */
  failedJobRetention?: number;
}

/**
 * Simple file-based job storage implementation using StorageService
 */
@injectable()
export class FileJobStorage implements IJobStorage {
  private basePath: string;
  private initialized = false;
  private completedJobRetention: number;
  private failedJobRetention: number;
  private cleanupInterval: NodeJS.Timeout | null = null;

  /**
   * Helper method to normalize path for display purposes
   * @param pathToNormalize Path to be normalized with forward slashes
   */
  private normalizePath(pathToNormalize: string): string {
    return pathToNormalize.replace(/\\/g, "/");
  }

  constructor(
    @inject(TYPES.LoggerService) private logger: ILoggerService,
    @inject(TYPES.StorageService) private storageService: IStorageService,
    @inject(TYPES.JobStorageConfig)
    {
      basePath,
      completedJobRetention,
      failedJobRetention,
    }: FileJobStorageConfig,
  ) {
    this.basePath = basePath;
    this.completedJobRetention = completedJobRetention || 24 * 60 * 60 * 1000; // 24 hours
    this.failedJobRetention = failedJobRetention || 7 * 24 * 60 * 60 * 1000; // 7 days
  }

  /**
   * Initialize storage
   */
  async initialize(): Promise<void> {
    if (this.initialized) return;

    try {
      // Ensure base directory exists
      await this.storageService.createDirectory(this.basePath);

      // Create directories for each status
      const statuses: JobStatus[] = [
        "waiting",
        "active",
        "completed",
        "failed",
        "delayed",
      ];
      for (const status of statuses) {
        await this.storageService.createDirectory(
          path.join(this.basePath, status),
        );
      }

      // Start cleanup interval (every hour)
      this.startCleanupInterval();

      this.initialized = true;

      this.logger.info("Job storage initialized", {
        path: this.normalizePath(this.basePath),
      });
    } catch (error) {
      this.logger.error("Failed to initialize job storage", { error });
      throw error;
    }
  }

  /**
   * Get file path for a job
   */
  private getJobFilePath(type: JobType, id: string, status: JobStatus): string {
    return path.join(this.basePath, status, `${type}_${id}.json`);
  }

  /**
   * Save a job
   */
  async saveJob<T>(job: JobData<T>): Promise<void> {
    await this.ensureInitialized();

    const filePath = this.getJobFilePath(job.type, job.id, job.status);

    try {
      const data = Buffer.from(JSON.stringify(job), "utf8");
      await this.storageService.saveFile(filePath, data);
    } catch (error) {
      this.logger.error("Failed to save job", {
        jobId: job.id,
        jobType: job.type,
        error,
      });
      throw error;
    }
  }

  /**
   * Get a job by ID
   */
  async getJob<T>(type: JobType, id: string): Promise<JobData<T> | null> {
    await this.ensureInitialized();

    // Try to find the job in any status directory
    const statuses: JobStatus[] = [
      "waiting",
      "active",
      "completed",
      "failed",
      "delayed",
    ];

    for (const status of statuses) {
      const filePath = this.getJobFilePath(type, id, status);

      try {
        if (await this.storageService.fileExists(filePath)) {
          const data = await this.storageService.getFile(filePath);
          return JSON.parse(data.toString("utf8")) as JobData<T>;
        }
      } catch (_error) {
        // File not found in this status, continue to next
      }
    }

    return null;
  }

  /**
   * Update job status
   */
  async updateJobStatus(
    type: JobType,
    id: string,
    newStatus: JobStatus,
    result?: JobResult,
  ): Promise<void> {
    await this.ensureInitialized();

    // First find the job in any status
    const job = await this.getJob(type, id);

    if (!job) {
      throw new Error(`Job not found: ${type} ${id}`);
    }

    // Delete from old status file
    const oldPath = this.getJobFilePath(type, id, job.status);

    try {
      await this.storageService.deleteFile(oldPath);
    } catch (_error) {
      // Ignore errors if file doesn't exist
    }

    // Update job
    job.status = newStatus;
    job.updatedAt = new Date();

    if (result) {
      job.result = result;
    }

    // Save to new location
    await this.saveJob(job);
  }

  /**
   * Get jobs by status
   */
  async getJobsByStatus<T>(
    type: JobType,
    status: JobStatus,
    limit = 100,
  ): Promise<JobData<T>[]> {
    await this.ensureInitialized();

    const statusDir = path.join(this.basePath, status);
    const prefix = `${type}_`;

    try {
      const files = await this.storageService.listFiles(statusDir, prefix);
      const matchingFiles = files
        .filter((file) => file.endsWith(".json"))
        .slice(0, limit);

      const jobs: JobData<T>[] = [];

      for (const file of matchingFiles) {
        const filePath = path.join(statusDir, file);
        try {
          const data = await this.storageService.getFile(filePath);
          jobs.push(JSON.parse(data.toString("utf8")));
        } catch (error) {
          this.logger.warn("Error reading job file", { file, error });
        }
      }

      return jobs;
    } catch (error) {
      this.logger.error("Failed to get jobs by status", {
        type,
        status,
        error,
      });
      return [];
    }
  }

  /**
   * Delete a job
   */
  async deleteJob(type: JobType, id: string): Promise<boolean> {
    await this.ensureInitialized();

    const job = await this.getJob(type, id);

    if (!job) {
      return false;
    }

    const filePath = path.join(
      this.basePath,
      this.getJobFilePath(type, id, job.status),
    );

    try {
      return await this.storageService.deleteFile(filePath);
    } catch (error) {
      this.logger.error("Failed to delete job", {
        jobId: id,
        jobType: type,
        error,
      });
      return false;
    }
  }

  /**
   * Get job counts
   */
  async getJobCounts(type: JobType): Promise<Record<JobStatus, number>> {
    await this.ensureInitialized();

    const statuses: JobStatus[] = [
      "waiting",
      "active",
      "completed",
      "failed",
      "delayed",
    ];
    const counts: Record<JobStatus, number> = {
      waiting: 0,
      active: 0,
      completed: 0,
      failed: 0,
      delayed: 0,
      blocked: 0,
    };

    for (const status of statuses) {
      const statusDir = path.join(this.basePath, status);
      const prefix = `${type}_`;

      try {
        const files = await this.storageService.listFiles(statusDir, prefix);
        counts[status] = files.filter((file) => file.endsWith(".json")).length;
      } catch (_error) {
        // Ignore errors if directory doesn't exist
      }
    }

    return counts;
  }

  /**
   * Clean up old jobs
   */
  async cleanup(type?: JobType, olderThan?: Date): Promise<number> {
    await this.ensureInitialized();

    let count = 0;

    // Clean completed jobs
    const completedDir = path.join(this.basePath, "completed");
    count += await this.cleanupDirectory(
      completedDir,
      type,
      olderThan || new Date(Date.now() - this.completedJobRetention),
    );

    // Clean failed jobs
    const failedDir = path.join(this.basePath, "failed");
    count += await this.cleanupDirectory(
      failedDir,
      type,
      olderThan || new Date(Date.now() - this.failedJobRetention),
    );

    return count;
  }

  /**
   * Clean a specific directory
   */
  private async cleanupDirectory(
    dir: string,
    type?: JobType,
    olderThan?: Date,
  ): Promise<number> {
    try {
      const prefix = type ? `${type}_` : "";
      const files = await this.storageService.listFiles(dir, prefix);
      let deleteCount = 0;

      for (const file of files) {
        // Skip if not a JSON file
        if (!file.endsWith(".json")) continue;

        const filePath = path.join(dir, file);

        try {
          // Get file data to check the updatedAt date
          const data = await this.storageService.getFile(filePath);
          const job = JSON.parse(data.toString("utf8")) as JobData<unknown>;

          // Delete if older than cutoff date
          if (olderThan && new Date(job.updatedAt) < olderThan) {
            await this.storageService.deleteFile(filePath);
            deleteCount++;
          }
        } catch (_error) {
          // Ignore errors for individual files
        }
      }

      return deleteCount;
    } catch (error) {
      this.logger.warn("Error cleaning up directory", { dir, error });
      return 0;
    }
  }

  /**
   * Start cleanup interval
   */
  private startCleanupInterval(): void {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
    }

    // Run cleanup every hour
    this.cleanupInterval = setInterval(
      () => {
        this.cleanup().catch((error) => {
          this.logger.error("Job cleanup error", { error });
        });
      },
      60 * 60 * 1000,
    );
  }

  /**
   * Ensure storage is initialized
   */
  private async ensureInitialized(): Promise<void> {
    if (!this.initialized) {
      await this.initialize();
    }
  }

  /**
   * Close storage
   */
  async close(): Promise<void> {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
    }
  }

  async getJobsByStatusPrioritized<T>(
    type: JobType,
    status: JobStatus,
    limit = 100,
  ): Promise<JobData<T>[]> {
    const jobs = await this.getJobsByStatus<T>(type, status, limit);
    return jobs.sort((a, b) => b.priority - a.priority);
  }

  async checkDependencies(
    type: JobType,
    jobId: string,
  ): Promise<DependencyStatus> {
    const job = await this.getJob(type, jobId);
    if (!job?.dependencies) {
      return { resolved: true, dependencies: [] };
    }

    const dependencies: DependencyStatus["dependencies"] = [];
    let allResolved = true;

    for (const depId of job.dependencies.jobIds) {
      const depJob = await this.getJob(type, depId);
      if (!depJob) {
        allResolved = false;
        dependencies.push({ jobId: depId, status: "failed" });
        continue;
      }

      const success = depJob.status === "completed" && depJob.result?.success;
      dependencies.push({
        jobId: depId,
        status: depJob.status,
        success,
      });

      if (!success) {
        allResolved = false;
      }
    }

    return {
      resolved: allResolved,
      reason: allResolved
        ? undefined
        : "Some dependencies are not completed or failed",
      dependencies,
    };
  }

  async findDependentJobs<T>(jobId: string): Promise<JobData<T>[]> {
    const allJobs: JobData<T>[] = [];
    const statuses: JobStatus[] = [
      "waiting",
      "active",
      "completed",
      "failed",
      "delayed",
      "blocked",
    ];

    // Get all jobs across all types and statuses
    for (const status of statuses) {
      // Use a wildcard/empty prefix to get all job types in this status
      const statusDir = path.join(this.basePath, status);
      try {
        const files = await this.storageService.listFiles(statusDir, "");
        const matchingFiles = files.filter((file) => file.endsWith(".json"));

        for (const file of matchingFiles) {
          const filePath = path.join(statusDir, file);
          try {
            const data = await this.storageService.getFile(filePath);
            const job = JSON.parse(data.toString("utf8")) as JobData<T>;
            allJobs.push(job);
          } catch (error) {
            this.logger.warn("Error reading job file", { file, error });
          }
        }
      } catch (_error) {
        // Ignore errors if directory doesn't exist
      }
    }

    return allJobs.filter((job) => job.dependencies?.jobIds.includes(jobId));
  }
}


// ---------------------- infrastructure\jobs\storage\IJobStorage.ts (155 lines) ----------------------

import {
  JobResult,
  JobType,
  DependencyResolutionStrategy,
} from "@/server/infrastructure/jobs";

/**
 * Job data structure
 */
export interface JobData<T = unknown> {
  id: string;
  type: JobType;
  data: T;
  status: JobStatus;
  priority: number;
  attempts: number;
  maxAttempts: number;
  createdAt: Date;
  updatedAt: Date;
  scheduledFor?: Date;
  result?: JobResult;

  /**
   * Dependencies configuration
   */
  dependencies?: {
    /**
     * IDs of jobs this job depends on
     */
    jobIds: string[];

    /**
     * How to handle dependency failures
     */
    strategy: DependencyResolutionStrategy;
  };

  /**
   * Optional metadata for tracking and custom logic
   */
  metadata?: Record<string, unknown>;
}

/**
 * Dependency status result
 */
export interface DependencyStatus {
  /**
   * Whether all dependencies are resolved
   */
  resolved: boolean;

  /**
   * Reason if not resolved
   */
  reason?: string;

  /**
   * Status of each dependency
   */
  dependencies: Array<{
    jobId: string;
    status: JobStatus;
    success?: boolean;
  }>;
}

/**
 * Possible job status values
 */
export type JobStatus =
  | "waiting"
  | "active"
  | "completed"
  | "failed"
  | "delayed"
  | "blocked"; // Added for jobs waiting on dependencies

/**
 * Job storage interface
 */
export interface IJobStorage {
  /**
   * Initialize the storage
   */
  initialize(): Promise<void>;

  /**
   * Save a job
   */
  saveJob<T>(job: JobData<T>): Promise<void>;

  /**
   * Get a job by ID
   */
  getJob<T>(type: JobType, id: string): Promise<JobData<T> | null>;

  /**
   * Update a job's status
   */
  updateJobStatus(
    type: JobType,
    id: string,
    status: JobStatus,
    result?: JobResult,
  ): Promise<void>;

  /**
   * Get jobs by status
   */
  getJobsByStatus<T>(
    type: JobType,
    status: JobStatus,
    limit?: number,
  ): Promise<JobData<T>[]>;

  /**
   * Get jobs by status ordered by priority
   */
  getJobsByStatusPrioritized<T>(
    type: JobType,
    status: JobStatus,
    limit?: number,
  ): Promise<JobData<T>[]>;

  /**
   * Check if a job's dependencies are resolved
   */
  checkDependencies(type: JobType, jobId: string): Promise<DependencyStatus>;

  /**
   * Find jobs that depend on the given job
   */
  findDependentJobs<T>(jobId: string): Promise<JobData<T>[]>;

  /**
   * Delete a job
   */
  deleteJob(type: JobType, id: string): Promise<boolean>;

  /**
   * Get job counts by status
   */
  getJobCounts(type: JobType): Promise<Record<JobStatus, number>>;

  /**
   * Clean up old jobs
   */
  cleanup(type?: JobType, olderThan?: Date): Promise<number>;

  /**
   * Close storage
   */
  close(): Promise<void>;
}


// ---------------------- infrastructure\jobs\storage\index.ts (2 lines) ----------------------

export * from "./IJobStorage";
export * from "./FileJobStorage";


// ---------------------- infrastructure\lifecycle\ApplicationLifecycle.ts (429 lines) ----------------------

import { Server } from "http";

import { inject, injectable } from "inversify";
import { v4 as uuidv4 } from "uuid";

import type { IDatabaseServer } from "@/server/infrastructure/database";
import { TYPES } from "@/server/infrastructure/di/types";

import type {
  DependencyOrder,
  IApplicationLifecycle,
} from "@infrastructure/lifecycle";
import type { ILoggerService } from "@infrastructure/logging";
import type { IWebSocketService } from "@infrastructure/pubsub";

// Helper function to generate correlation ID since the import isn't working
function generateCorrelationId(): string {
  return uuidv4();
}

/**
 * Application lifecycle manager handles graceful startup and shutdown
 */
@injectable()
class ApplicationLifecycle implements IApplicationLifecycle {
  private httpServer: Server | null = null;
  private isShuttingDown = false;
  private dependencies: Map<
    string,
    DependencyOrder & {
      startup?: () => Promise<void>;
      shutdown?: () => Promise<void>;
    }
  > = new Map();
  private initialized: Set<string> = new Set();
  private shutdownHandlers: Array<() => Promise<void>> = [];
  private shutdownTimeout = 30000; // 30 seconds default timeout

  /**
   * Create a new application lifecycle manager
   */
  constructor(
    @inject(TYPES.LoggerService) private logger: ILoggerService,
    @inject(TYPES.WebSocketService) private webSocketService: IWebSocketService,
    @inject(TYPES.DatabaseService) private databaseService: IDatabaseServer,
  ) {
    // Register shutdown handlers for process signals
    this.registerProcessHandlers();

    // Register the database as a dependency by default
    this.registerDatabaseDependency();
  }

  /**
   * Set the HTTP server instance
   */
  setHttpServer(server: Server): void {
    this.httpServer = server;
  }

  /**
   * Register process signal handlers
   */
  private registerProcessHandlers(): void {
    // Handle SIGTERM (Docker graceful shutdown)
    process.on("SIGTERM", this.handleShutdownSignal.bind(this, "SIGTERM"));

    // Handle SIGINT (Ctrl+C)
    process.on("SIGINT", this.handleShutdownSignal.bind(this, "SIGINT"));

    // Handle uncaught exceptions (already logged by global error handler)
    process.on(
      "uncaughtException",
      this.handleShutdownSignal.bind(this, "uncaughtException"),
    );

    this.logger.info(
      "Process signal handlers registered for graceful shutdown",
    );
  }

  /**
   * Register the database dependency
   */
  private registerDatabaseDependency(): void {
    this.registerDependency({
      name: "Database",
      dependencies: [],
      startup: async () => {
        await this.databaseService.initialize();
      },
      shutdown: async () => {
        await this.databaseService.close();
      },
    });
  }

  /**
   * Handle shutdown signals
   */
  private handleShutdownSignal(signal: string): void {
    if (this.isShuttingDown) {
      return; // Prevent multiple shutdown attempts
    }

    const correlationId = generateCorrelationId();
    this.logger.info(
      `Received ${signal} signal - initiating graceful shutdown`,
      { correlationId },
    );

    // Begin graceful shutdown
    this.shutdown(signal).catch((error) => {
      this.logger.error("Error during graceful shutdown", {
        error,
        correlationId,
      });
      process.exit(1);
    });
  }

  /**
   * Register a component to be managed in the lifecycle
   * @implements IApplicationLifecycle.register
   */
  register(
    name: string,
    dependencies: string[],
    component: {
      start?: () => Promise<void>;
      stop?: () => Promise<void>;
    },
  ): void {
    this.registerDependency({
      name,
      dependencies,
      startup: component.start ? component.start : async () => {},
      shutdown: component.stop ? component.stop : async () => {},
    });
  }

  /**
   * Start the application and its dependencies
   * @implements IApplicationLifecycle.start
   */
  async start(): Promise<void> {
    return this.initialize();
  }

  /**
   * Stop the application and its dependencies
   * @implements IApplicationLifecycle.stop
   */
  async stop(): Promise<void> {
    return this.shutdown("manual");
  }

  /**
   * Register a dependency
   */
  registerDependency(
    dependency: DependencyOrder & {
      startup?: () => Promise<void>;
      shutdown?: () => Promise<void>;
    },
  ): void {
    this.dependencies.set(dependency.name, dependency);
    this.logger.debug(`Registered dependency: ${dependency.name}`);
  }

  /**
   * Register a shutdown handler
   */
  registerShutdownHandler(handler: () => Promise<void>): void {
    this.shutdownHandlers.push(handler);
  }

  /**
   * Initialize the application
   */
  async initialize(): Promise<void> {
    const correlationId = generateCorrelationId();
    this.logger.info("Starting application initialization", { correlationId });

    const startTime = Date.now();

    try {
      // Initialize database
      await this.databaseService.initialize();
      this.logger.info("Database initialized");

      // Get all dependencies
      const dependencies = Array.from(this.dependencies.values());

      // Create a dependency graph and initialize in order
      const initialized = new Set<string>();
      const remaining = [...dependencies];

      while (remaining.length > 0) {
        const initializedThisPass = await this.initializeDependencyBatch(
          remaining,
          initialized,
          correlationId,
        );

        if (initializedThisPass === 0) {
          // Circular dependency or unresolvable dependencies
          const uninitialized = remaining.map((dep) => dep.name).join(", ");
          throw new Error(
            `Could not initialize dependencies: ${uninitialized}. Possible circular dependency.`,
          );
        }
      }

      this.initialized = initialized;
      const duration = Date.now() - startTime;

      this.logger.info(
        `Application initialization completed successfully in ${duration}ms`,
        { correlationId },
      );
    } catch (error) {
      const duration = Date.now() - startTime;
      this.logger.error(
        `Application initialization failed after ${duration}ms`,
        {
          error,
          correlationId,
        },
      );
      throw error;
    }
  }

  /**
   * Initialize a batch of dependencies whose requirements are satisfied
   */
  private async initializeDependencyBatch(
    remaining: Array<
      DependencyOrder & {
        startup?: () => Promise<void>;
        shutdown?: () => Promise<void>;
      }
    >,
    initialized: Set<string>,
    correlationId: string,
  ): Promise<number> {
    // Find dependencies that can be initialized
    const canInitialize: Array<
      DependencyOrder & {
        startup?: () => Promise<void>;
        shutdown?: () => Promise<void>;
      }
    > = [];
    const stillRemaining: Array<
      DependencyOrder & {
        startup?: () => Promise<void>;
        shutdown?: () => Promise<void>;
      }
    > = [];

    for (const dep of remaining) {
      const dependenciesMet =
        !dep.dependencies ||
        dep.dependencies.every((depName: string) => initialized.has(depName));

      if (dependenciesMet) {
        canInitialize.push(dep);
      } else {
        stillRemaining.push(dep);
      }
    }

    if (canInitialize.length === 0) {
      return 0;
    }

    // Initialize all dependencies that can be initialized in parallel
    await Promise.all(
      canInitialize.map(async (dep) => {
        try {
          this.logger.debug(`Initializing dependency: ${dep.name}`, {
            correlationId,
          });
          const startTime = Date.now();

          if (dep.startup) {
            await dep.startup();
          }

          const duration = Date.now() - startTime;
          initialized.add(dep.name);

          this.logger.info(
            `Initialized dependency: ${dep.name} (${duration}ms)`,
            { correlationId },
          );
        } catch (error) {
          this.logger.error(`Failed to initialize dependency: ${dep.name}`, {
            error,
            correlationId,
          });
          throw error;
        }
      }),
    );

    // Update remaining list
    remaining.splice(0, remaining.length, ...stillRemaining);

    return canInitialize.length;
  }

  /**
   * Perform graceful shutdown
   */
  async shutdown(reason: string = "manual"): Promise<void> {
    if (this.isShuttingDown) {
      return; // Prevent multiple shutdown attempts
    }

    this.isShuttingDown = true;
    const correlationId = generateCorrelationId();
    this.logger.info(`Starting graceful shutdown: ${reason}`, {
      correlationId,
    });

    const startTime = Date.now();

    // Create a timeout promise
    const timeoutPromise = new Promise<void>((_, reject) => {
      setTimeout(() => {
        reject(new Error(`Shutdown timed out after ${this.shutdownTimeout}ms`));
      }, this.shutdownTimeout);
    });

    try {
      // Race the shutdown process against the timeout
      await Promise.race([this.performShutdown(correlationId), timeoutPromise]);

      const duration = Date.now() - startTime;
      this.logger.info(`Graceful shutdown completed in ${duration}ms`);
    } catch (error) {
      const duration = Date.now() - startTime;
      this.logger.error(`Error during graceful shutdown after ${duration}ms`, {
        error,
        correlationId,
      });

      // Force exit if it was a timeout
      if (duration >= this.shutdownTimeout) {
        this.logger.error(`Forcing exit after shutdown timeout`);
        process.exit(1);
      }
    } finally {
      // Give time for logs to flush
      await new Promise((resolve) => setTimeout(resolve, 500));
    }
  }

  /**
   * Internal method to perform the actual shutdown steps
   */
  private async performShutdown(correlationId: string): Promise<void> {
    // Execute custom shutdown handlers first
    if (this.shutdownHandlers.length > 0) {
      this.logger.info(
        `Executing ${this.shutdownHandlers.length} shutdown handlers`,
      );
      await Promise.all(this.shutdownHandlers.map((handler) => handler()));
    }

    // Close WebSocket connections
    this.logger.info("Closing WebSocket connections");
    await this.webSocketService.close();

    // Shut down dependencies in reverse initialization order
    const dependencyNames = Array.from(this.initialized);
    const reverseDependencies = dependencyNames.reverse();

    this.logger.info(
      `Shutting down ${reverseDependencies.length} dependencies`,
    );

    for (const depName of reverseDependencies) {
      const dependency = this.dependencies.get(depName);
      if (!dependency) continue;

      try {
        this.logger.debug(`Shutting down dependency: ${depName}`);
        if (dependency && dependency.shutdown) {
          await dependency.shutdown();
        }
        this.logger.debug(`Dependency shutdown completed: ${depName}`);
      } catch (error) {
        this.logger.error(`Error shutting down dependency: ${depName}`, {
          error,
          correlationId,
        });
        // Continue shutting down other dependencies
      }
    }

    // Close HTTP server if it exists
    if (this.httpServer) {
      this.logger.info("Closing HTTP server");
      await new Promise<void>((resolve, reject) => {
        this.httpServer!.close((err) => {
          if (err) {
            this.logger.error("Error closing HTTP server", {
              error: err,
              correlationId,
            });
            reject(err);
          } else {
            this.logger.info("HTTP server closed successfully");
            resolve();
          }
        });
      });
    }

    // Close database connection
    await this.databaseService.close();
    this.logger.info("Database connection closed");
  }
}

export default ApplicationLifecycle;


// ---------------------- infrastructure\lifecycle\IApplicationLifecycle.ts (52 lines) ----------------------

/**
 * Interface for application lifecycle management
 */

import { Server } from "http";

/**
 * Order of dependencies for initialization and shutdown
 */
export type DependencyOrder = {
  name: string;
  dependencies?: string[];
  startup?: () => Promise<void>;
  shutdown?: () => Promise<void>;
};

/**
 * Application lifecycle interface for managing startup and shutdown
 */
export interface IApplicationLifecycle {
  /**
   * Start the application and its dependencies
   */
  start(): Promise<void>;

  /**
   * Stop the application and its dependencies
   */
  stop(): Promise<void>;

  /**
   * Register a component to be managed in the lifecycle
   */
  register(
    name: string,
    dependencies: string[],
    component: {
      start?: () => Promise<void>;
      stop?: () => Promise<void>;
    },
  ): void;

  /**
   * Set the HTTP server instance
   */
  setHttpServer(server: Server): void;

  /**
   * Register a shutdown handler
   */
  registerShutdownHandler(handler: () => Promise<void>): void;
}


// ---------------------- infrastructure\lifecycle\index.ts (5 lines) ----------------------

export { default as ApplicationLifecycle } from "./ApplicationLifecycle";
export type {
  DependencyOrder,
  IApplicationLifecycle,
} from "./IApplicationLifecycle";


// ---------------------- infrastructure\logging\ILogger.ts (173 lines) ----------------------

/**
 * Log levels for the logger
 */
export enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3,
}

/**
 * Log metadata type
 */
export interface LogMetadata {
  [key: string]: unknown;
}

/**
 * Log context information for structured logging
 */
export interface ILogContext {
  [key: string]: string | number | boolean | null;
}

/**
 * Log entry structure
 */
export interface LogEntry {
  timestamp: string;
  level: LogLevel;
  message: string;
  service?: string;
  correlationId?: string;
  metadata?: LogMetadata;
  context?: ILogContext;
  structuredData?: Record<string, unknown>;
}

/**
 * Log transport interface
 */
export interface ILogTransport {
  log(entry: LogEntry): void;
}

/**
 * Core logger service interface
 */
export interface ILoggerService {
  /**
   * Log a debug message
   * @param message The message to log
   * @param metadata Optional metadata to include with the log
   * @param correlationId Optional correlation ID for request tracking
   */
  debug(message: string, metadata?: LogMetadata, correlationId?: string): void;

  /**
   * Log a debug message with structured data
   * @param obj Structured data object to log
   * @param message Optional message to accompany the structured data
   * @param correlationId Optional correlation ID for request tracking
   */
  debugObj(
    obj: Record<string, unknown>,
    message?: string,
    correlationId?: string,
  ): void;

  /**
   * Log an info message
   * @param message The message to log
   * @param metadata Optional metadata to include with the log
   * @param correlationId Optional correlation ID for request tracking
   */
  info(message: string, metadata?: LogMetadata, correlationId?: string): void;

  /**
   * Log an info message with structured data
   * @param obj Structured data object to log
   * @param message Optional message to accompany the structured data
   * @param correlationId Optional correlation ID for request tracking
   */
  infoObj(
    obj: Record<string, unknown>,
    message?: string,
    correlationId?: string,
  ): void;

  /**
   * Log a warning message
   * @param message The message to log
   * @param metadata Optional metadata to include with the log
   * @param correlationId Optional correlation ID for request tracking
   */
  warn(message: string, metadata?: LogMetadata, correlationId?: string): void;

  /**
   * Log a warning message with structured data
   * @param obj Structured data object to log
   * @param message Optional message to accompany the structured data
   * @param correlationId Optional correlation ID for request tracking
   */
  warnObj(
    obj: Record<string, unknown>,
    message?: string,
    correlationId?: string,
  ): void;

  /**
   * Log an error message
   * @param message The message to log
   * @param metadata Optional metadata to include with the log
   * @param correlationId Optional correlation ID for request tracking
   */
  error(message: string, metadata?: LogMetadata, correlationId?: string): void;

  /**
   * Log an error message with structured data
   * @param obj Structured data object to log
   * @param message Optional message to accompany the structured data
   * @param correlationId Optional correlation ID for request tracking
   */
  errorObj(
    obj: Record<string, unknown>,
    message?: string,
    correlationId?: string,
  ): void;

  /**
   * Create a new child logger with a specific context
   * @param context The context name for the new logger
   * @returns A new logger instance with the specified context
   */
  createLogger(context: string): ILoggerService;

  /**
   * Create a new child logger with context data
   * @param context The context data for the new logger
   * @returns A new logger instance with the specified context
   */
  withContext(context: ILogContext): ILoggerService;

  /**
   * Add a transport to the logger
   * @param transport The transport to add
   */
  addTransport(transport: ILogTransport): void;

  /**
   * Set the transports for the logger, replacing any existing ones
   * @param transports The transports to set
   */
  setTransports(transports: ILogTransport[]): void;

  /**
   * Set the minimum log level that will be output
   * @param level The minimum log level to display
   */
  setMinLevel(level: LogLevel): void;

  /**
   * Initialize the logger
   * @returns A promise that resolves when initialization is complete
   */
  initialize(): Promise<void>;

  /**
   * Shutdown the logger, flushing any pending logs
   * @returns A promise that resolves when shutdown is complete
   */
  shutdown(): Promise<void>;
}


// ---------------------- infrastructure\logging\Logger.ts (329 lines) ----------------------

import { injectable, unmanaged } from "inversify";

import {
  LogLevel,
  LogMetadata,
  type ILogContext,
  type LogEntry,
  type ILogTransport,
  type ILoggerService,
} from "./ILogger";
import { ConsoleTransport } from "./transports/ConsoleTransport";

/**
 * A simple logger service that implements the ILoggerService interface
 * Focuses on core logging functionality with minimal overhead
 */
@injectable()
export class LoggerService implements ILoggerService {
  private minLevel: LogLevel = LogLevel.INFO;
  private transports: ILogTransport[] = [];
  private context: string = "";
  private prettyPrint: boolean = false;
  private contextData: ILogContext = {};

  /**
   * Create a new SimpleLoggerService
   * @param context Optional context name for this logger
   * @param parent Optional parent logger to inherit settings from
   * @param contextData Optional context data for structured logging
   */
  constructor(
    @unmanaged() context: string = "",
    @unmanaged() private parent?: LoggerService,
    @unmanaged() contextData: ILogContext = {},
  ) {
    this.context = context;
    this.contextData = contextData;

    // If this is a root logger (no parent), add default console transport
    if (!parent) {
      this.prettyPrint = process.env.NODE_ENV !== "production";
      this.transports = [new ConsoleTransport(this.prettyPrint)];
    }
  }

  /**
   * Initialize the logger
   */
  public async initialize(): Promise<void> {
    // Nothing special needed for initialization
    return Promise.resolve();
  }

  /**
   * Shutdown the logger
   */
  public async shutdown(): Promise<void> {
    // Nothing special needed for shutdown
    return Promise.resolve();
  }

  /**
   * Set the minimum log level
   * @param level The minimum level to log
   */
  public setMinLevel(level: LogLevel): void {
    this.minLevel = level;
  }

  /**
   * Log a debug message
   * @param message The message to log
   * @param metadata Optional metadata to include
   * @param correlationId Optional correlation ID for request tracking
   */
  public debug(
    message: string,
    metadata?: LogMetadata,
    correlationId?: string,
  ): void {
    this.log(LogLevel.DEBUG, message, metadata, correlationId);
  }

  /**
   * Log a debug message with structured data
   * @param obj Structured data object to log
   * @param message Optional message to accompany the structured data
   * @param correlationId Optional correlation ID for request tracking
   */
  public debugObj(
    obj: Record<string, unknown>,
    message?: string,
    correlationId?: string,
  ): void {
    this.logObj(LogLevel.DEBUG, obj, message, correlationId);
  }

  /**
   * Log an info message
   * @param message The message to log
   * @param metadata Optional metadata to include
   * @param correlationId Optional correlation ID for request tracking
   */
  public info(
    message: string,
    metadata?: LogMetadata,
    correlationId?: string,
  ): void {
    this.log(LogLevel.INFO, message, metadata, correlationId);
  }

  /**
   * Log an info message with structured data
   * @param obj Structured data object to log
   * @param message Optional message to accompany the structured data
   * @param correlationId Optional correlation ID for request tracking
   */
  public infoObj(
    obj: Record<string, unknown>,
    message?: string,
    correlationId?: string,
  ): void {
    this.logObj(LogLevel.INFO, obj, message, correlationId);
  }

  /**
   * Log a warning message
   * @param message The message to log
   * @param metadata Optional metadata to include
   * @param correlationId Optional correlation ID for request tracking
   */
  public warn(
    message: string,
    metadata?: LogMetadata,
    correlationId?: string,
  ): void {
    this.log(LogLevel.WARN, message, metadata, correlationId);
  }

  /**
   * Log a warning message with structured data
   * @param obj Structured data object to log
   * @param message Optional message to accompany the structured data
   * @param correlationId Optional correlation ID for request tracking
   */
  public warnObj(
    obj: Record<string, unknown>,
    message?: string,
    correlationId?: string,
  ): void {
    this.logObj(LogLevel.WARN, obj, message, correlationId);
  }

  /**
   * Log an error message
   * @param message The message to log
   * @param metadata Optional metadata to include
   * @param correlationId Optional correlation ID for request tracking
   */
  public error(
    message: string,
    metadata?: LogMetadata,
    correlationId?: string,
  ): void {
    this.log(LogLevel.ERROR, message, metadata, correlationId);
  }

  /**
   * Log an error message with structured data
   * @param obj Structured data object to log
   * @param message Optional message to accompany the structured data
   * @param correlationId Optional correlation ID for request tracking
   */
  public errorObj(
    obj: Record<string, unknown>,
    message?: string,
    correlationId?: string,
  ): void {
    this.logObj(LogLevel.ERROR, obj, message, correlationId);
  }

  /**
   * Create a new child logger with a specific context
   * @param context The context name for the new logger
   * @returns A new logger instance with the specified context
   */
  public createLogger(context: string): ILoggerService {
    const newContext = this.context ? `${this.context}.${context}` : context;
    return new LoggerService(newContext, this);
  }

  /**
   * Create a new child logger with context data
   * @param context The context data for the new logger
   * @returns A new logger instance with the specified context
   */
  public withContext(context: ILogContext): ILoggerService {
    return new LoggerService(this.context, this, {
      ...this.contextData,
      ...context,
    });
  }

  /**
   * Log a message with the provided level
   * @param level Log level
   * @param message Message to log
   * @param metadata Optional metadata
   * @param correlationId Optional correlation ID
   */
  private log(
    level: LogLevel,
    message: string,
    metadata?: LogMetadata,
    correlationId?: string,
  ): void {
    // Skip if below minimum level
    if (level < this.getMinLevel()) {
      return;
    }

    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      service: this.context,
      correlationId,
      metadata,
      context:
        Object.keys(this.contextData).length > 0 ? this.contextData : undefined,
    };

    // If this is a child logger, use parent's transports
    if (this.parent) {
      this.parent.writeLog(entry);
    } else {
      this.writeLog(entry);
    }
  }

  /**
   * Log a structured data object with the provided level
   * @param level Log level
   * @param obj Structured data object to log
   * @param message Optional message to accompany the structured data
   * @param correlationId Optional correlation ID
   */
  private logObj(
    level: LogLevel,
    obj: Record<string, unknown>,
    message?: string,
    correlationId?: string,
  ): void {
    // Skip if below minimum level
    if (level < this.getMinLevel()) {
      return;
    }

    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level,
      message: message || "Structured log entry",
      service: this.context,
      correlationId,
      structuredData: obj,
      context:
        Object.keys(this.contextData).length > 0 ? this.contextData : undefined,
    };

    // If this is a child logger, use parent's transports
    if (this.parent) {
      this.parent.writeLog(entry);
    } else {
      this.writeLog(entry);
    }
  }

  /**
   * Write a log entry to all transports
   * @param entry The log entry to write
   */
  private writeLog(entry: LogEntry): void {
    for (const transport of this.transports) {
      try {
        transport.log(entry);
      } catch (error) {
        // Log transport errors to console to avoid infinite recursion
        console.error("Error writing to log transport:", error);
      }
    }
  }

  /**
   * Get the minimum log level to display
   */
  private getMinLevel(): LogLevel {
    // If this is a child logger, use parent's min level
    if (this.parent) {
      return this.parent.getMinLevel();
    }
    return this.minLevel;
  }

  /**
   * Add a transport to the logger
   * @param transport The transport to add
   */
  public addTransport(transport: ILogTransport): void {
    // Only add transports to the root logger
    if (this.parent) {
      this.parent.addTransport(transport);
    } else {
      this.transports.push(transport);
    }
  }

  /**
   * Set the transports for the logger, replacing any existing ones
   * @param transports The transports to set
   */
  public setTransports(transports: ILogTransport[]): void {
    // Only set transports on the root logger
    if (this.parent) {
      this.parent.setTransports(transports);
    } else {
      this.transports = transports;
    }
  }
}


// ---------------------- infrastructure\logging\LoggerService.ts (300 lines) ----------------------

import { injectable, unmanaged } from "inversify";

import {
  LogLevel,
  type LogEntry,
  type LogMetadata,
  type ILogTransport,
  type ILogContext,
  type ILoggerService,
} from "./ILogger";
import { ConsoleTransport } from "./transports/ConsoleTransport";

/**
 * A simple logger service implementation
 */
@injectable()
export class LoggerService implements ILoggerService {
  private _transports: ILogTransport[] = [];
  private _minLevel: LogLevel = LogLevel.INFO;
  private _serviceName: string;
  private _contextData: ILogContext;
  private _parent: LoggerService | null = null;

  constructor(
    @unmanaged() serviceName: string = "",
    @unmanaged() parent: LoggerService | null = null,
    @unmanaged() contextData: ILogContext = {},
  ) {
    this._serviceName = serviceName;
    this._contextData = { ...contextData };
    this._parent = parent;

    // Initialize with default transport if this is a root logger
    if (!parent) {
      const prettyPrint = process.env.NODE_ENV !== "production";
      this._transports = [new ConsoleTransport(prettyPrint)];
    }
  }

  public async initialize(): Promise<void> {
    return Promise.resolve();
  }

  public async shutdown(): Promise<void> {
    return Promise.resolve();
  }

  public setMinLevel(level: LogLevel): void {
    this._minLevel = level;
  }

  public setContext(context: string): void {
    this._serviceName = context;
  }

  public setContextData(data: ILogContext): void {
    this._contextData = { ...data };
  }

  public debug(
    message: string,
    metadata?: LogMetadata,
    correlationId?: string,
  ): void {
    this.log(LogLevel.DEBUG, message, metadata, correlationId);
  }

  public debugObj(
    obj: Record<string, unknown>,
    message?: string,
    correlationId?: string,
  ): void {
    this.logObj(LogLevel.DEBUG, obj, message, correlationId);
  }

  public info(
    message: string,
    metadata?: LogMetadata,
    correlationId?: string,
  ): void {
    this.log(LogLevel.INFO, message, metadata, correlationId);
  }

  public infoObj(
    obj: Record<string, unknown>,
    message?: string,
    correlationId?: string,
  ): void {
    this.logObj(LogLevel.INFO, obj, message, correlationId);
  }

  public warn(
    message: string,
    metadata?: LogMetadata,
    correlationId?: string,
  ): void {
    this.log(LogLevel.WARN, message, metadata, correlationId);
  }

  public warnObj(
    obj: Record<string, unknown>,
    message?: string,
    correlationId?: string,
  ): void {
    this.logObj(LogLevel.WARN, obj, message, correlationId);
  }

  public error(
    message: string,
    metadata?: LogMetadata,
    correlationId?: string,
  ): void {
    this.log(LogLevel.ERROR, message, metadata, correlationId);
  }

  public errorObj(
    obj: Record<string, unknown>,
    message?: string,
    correlationId?: string,
  ): void {
    this.logObj(LogLevel.ERROR, obj, message, correlationId);
  }

  public createLogger(context: string): ILoggerService {
    // Create a properly formatted nested context name
    const newContext = this._serviceName
      ? `${this._serviceName}.${context}`
      : context;

    // Create a new logger with this as parent
    return new LoggerService(newContext, this, { ...this._contextData });
  }

  public withContext(context: ILogContext): ILoggerService {
    // Create a new logger with merged context
    const newContextData = {
      ...this._contextData,
      ...context,
    };

    // Use the current service name and either the current parent or self as parent
    return new LoggerService(this._serviceName, this, newContextData);
  }

  public addTransport(transport: ILogTransport): void {
    // If this is a child logger, add transport to root logger
    if (this._parent) {
      // Find the root parent and add transport there
      let rootLogger: LoggerService = this._parent;
      while (rootLogger._parent) {
        rootLogger = rootLogger._parent;
      }
      rootLogger._transports.push(transport);
    } else {
      // This is a root logger, add transport directly
      this._transports.push(transport);
    }
  }

  public setTransports(transports: ILogTransport[]): void {
    // If this is a child logger, set transports on root logger
    if (this._parent) {
      // Find the root parent and set transports there
      let rootLogger: LoggerService = this._parent;
      while (rootLogger._parent) {
        rootLogger = rootLogger._parent;
      }
      rootLogger._transports = [...transports];
    } else {
      // This is a root logger, set transports directly
      this._transports = [...transports];
    }
  }

  private log(
    level: LogLevel,
    message: string,
    metadata?: LogMetadata,
    correlationId?: string,
  ): void {
    // Get the effective min level (from root logger if this is a child)
    const effectiveMinLevel = this.getEffectiveMinLevel();

    // Skip if below minimum level
    if (level < effectiveMinLevel) {
      return;
    }

    // Create log entry
    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      service: this._serviceName,
      correlationId,
      metadata,
    };

    // Add context data if available
    if (Object.keys(this._contextData).length > 0) {
      entry.context = { ...this._contextData };
    }

    // Write to transports (either own or root)
    this.writeToTransports(entry);
  }

  private logObj(
    level: LogLevel,
    obj: Record<string, unknown>,
    message?: string,
    correlationId?: string,
  ): void {
    // Get the effective min level (from root logger if this is a child)
    const effectiveMinLevel = this.getEffectiveMinLevel();

    // Skip if below minimum level
    if (level < effectiveMinLevel) {
      return;
    }

    // Create log entry
    const entry: LogEntry = {
      timestamp: new Date().toISOString(),
      level,
      message: message || "Structured log entry",
      service: this._serviceName,
      correlationId,
      structuredData: obj,
    };

    // Add context data if available
    if (Object.keys(this._contextData).length > 0) {
      entry.context = { ...this._contextData };
    }

    // Write to transports (either own or root)
    this.writeToTransports(entry);
  }

  private getEffectiveMinLevel(): LogLevel {
    // If this is a child logger, use the root logger's min level
    if (this._parent) {
      let rootLogger: LoggerService = this._parent;
      while (rootLogger._parent) {
        rootLogger = rootLogger._parent;
      }
      return rootLogger._minLevel;
    }

    // This is a root logger, use own min level
    return this._minLevel;
  }

  private writeToTransports(entry: LogEntry): void {
    try {
      // If this is a child logger, use the root logger's transports
      if (this._parent) {
        let rootLogger: LoggerService = this._parent;
        while (rootLogger._parent) {
          rootLogger = rootLogger._parent;
        }

        // Ensure the root logger has at least one transport
        if (rootLogger._transports.length === 0) {
          const prettyPrint = process.env.NODE_ENV !== "production";
          rootLogger._transports = [new ConsoleTransport(prettyPrint)];
        }

        // Write to all transports of the root logger
        rootLogger._transports.forEach((transport) => {
          try {
            transport.log(entry);
          } catch (error) {
            console.error("Error in log transport:", error);
          }
        });
      } else {
        // This is a root logger, use own transports

        // Ensure there's at least one transport
        if (this._transports.length === 0) {
          const prettyPrint = process.env.NODE_ENV !== "production";
          this._transports = [new ConsoleTransport(prettyPrint)];
        }

        // Write to all transports
        this._transports.forEach((transport) => {
          try {
            transport.log(entry);
          } catch (error) {
            console.error("Error in log transport:", error);
          }
        });
      }
    } catch (error) {
      console.error("Error in logger:", error);
    }
  }
}


// ---------------------- infrastructure\logging\LoggingConfig.ts (97 lines) ----------------------

import { injectable } from "inversify";

import { LogLevel } from "./ILogger";

/**
 * Configuration options for logging
 */
export interface LoggingOptions {
  /**
   * Minimum log level to display (default: "info")
   */
  minLevel?: LogLevel | string;

  /**
   * Whether to use pretty printing in development (default: true)
   */
  prettyPrint?: boolean;

  /**
   * Console output enabled (default: true)
   */
  console?: boolean;

  /**
   * File logging configuration
   */
  file?: {
    /**
     * Enable file logging (default: false)
     */
    enabled: boolean;

    /**
     * Log directory path (default: "logs")
     */
    dir?: string;

    /**
     * Log filename pattern (default: "app-%DATE%.log")
     */
    filename?: string;

    /**
     * Maximum file size before rotation (default: "10m")
     */
    maxSize?: string;

    /**
     * Maximum number of log files to keep (default: 5)
     */
    maxFiles?: number;
  };
}

/**
 * Logging configuration provider
 */
@injectable()
export class LoggingConfig {
  /**
   * Get logging configuration
   */
  public getConfig(): LoggingOptions {
    // Parse log level string to enum if needed
    let minLevel: LogLevel | string = process.env.LOG_LEVEL || "info";
    if (typeof minLevel === "string") {
      switch (minLevel.toLowerCase()) {
        case "debug":
          minLevel = LogLevel.DEBUG;
          break;
        case "info":
          minLevel = LogLevel.INFO;
          break;
        case "warn":
        case "warning":
          minLevel = LogLevel.WARN;
          break;
        case "error":
          minLevel = LogLevel.ERROR;
          break;
      }
    }

    return {
      minLevel,
      prettyPrint: process.env.NODE_ENV !== "production",
      console: true,
      file: {
        enabled: process.env.LOG_TO_FILE === "true",
        dir: process.env.LOG_DIR || "logs",
        filename: process.env.LOG_FILENAME || "app-%DATE%.log",
        maxSize: process.env.LOG_MAX_SIZE || "10m",
        maxFiles: parseInt(process.env.LOG_MAX_FILES || "5", 10),
      },
    };
  }
}


// ---------------------- infrastructure\logging\ServerLogger.ts (409 lines) ----------------------

import path from "path";

import type { ILoggerService } from "./index";

// Service interfaces
interface DatabaseService {
  isConnected?: () => boolean;
  getStats?: () => { activeCount?: number };
}

interface CacheService {
  isConnected?: () => boolean;
  getStats?: () => { hits?: number };
}

interface WebSocketService {
  clients?: { size: number };
}

interface ConfigObject {
  get: (key: string) => unknown;
  storagePath?: string;
}

// Database connection info interface
interface DBConnectionInfo {
  host?: string;
  port?: number;
  database?: string;
  user?: string;
}

/**
 * Utility class for logging server status and connection information
 */
export class ServerLogger {
  private logger: ILoggerService;

  constructor(logger: ILoggerService) {
    this.logger = logger;
    this.logger.debug("ServerLogger initialized");
  }

  /**
   * Helper method to normalize path for display purposes
   */
  private normalizePath(pathToNormalize: string): string {
    return pathToNormalize.replace(/\\/g, "/");
  }

  /**
   * Helper to create a table row for service status
   */
  private createRow(
    name: string,
    status: boolean,
    details: string = "",
  ): string {
    const statusText = status ? "✓ Active" : "✗ Inactive";
    const statusColor = status ? "\x1b[32m" : "\x1b[31m"; // Green or Red
    return `│ ${name.padEnd(20)} │ ${statusColor}${statusText.padEnd(12)}\x1b[0m │ ${details.padEnd(30)} │`;
  }

  /**
   * Display infrastructure services status
   */
  displayInfrastructureServices(services: {
    logger: ILoggerService;
    databaseService: DatabaseService;
    cacheService: CacheService;
    storageService: unknown;
    jobService: unknown;
    errorHandler: unknown;
    validationService: unknown;
    wss: WebSocketService;
    pubSubService: unknown;
    imageProcessor: unknown;
    mediaProcessor: unknown;
    streamProcessor: unknown;
    storageProvider: unknown;
    config: ConfigObject;
  }): void {
    const {
      logger,
      databaseService,
      cacheService,
      storageService,
      jobService,
      errorHandler,
      validationService,
      wss,
      pubSubService,
      imageProcessor,
      mediaProcessor,
      streamProcessor,
      storageProvider,
      config,
    } = services;

    try {
      // Database connection details - try environment variables or DATABASE object
      // First try the DATABASE object
      const dbConnectionInfo =
        (config.get("DATABASE") as DBConnectionInfo) || {};

      // Fall back to direct environment variables or DB/database connection info
      // Look at process.env if config doesn't have the values
      let dbHost = dbConnectionInfo.host;
      if (!dbHost) {
        dbHost =
          (config.get("DB_HOST") as string) || process.env.DB_HOST || "unknown";
      }

      let dbPort = dbConnectionInfo.port;
      if (!dbPort) {
        dbPort =
          Number(config.get("DB_PORT")) || Number(process.env.DB_PORT) || 5555;
      }

      let dbName = dbConnectionInfo.database;
      if (!dbName) {
        dbName =
          (config.get("DB_NAME") as string) || process.env.DB_NAME || "unknown";
      }

      let dbUser = dbConnectionInfo.user;
      if (!dbUser) {
        dbUser =
          (config.get("DB_USER") as string) || process.env.DB_USER || "unknown";
      }

      // Table borders
      const tableBorder =
        "┌──────────────────────┬──────────────┬────────────────────────────────┐";
      const tableHeader =
        "│ Service              │ Status       │ Details                        │";
      const tableDivider =
        "├──────────────────────┼──────────────┼────────────────────────────────┤";
      const tableBottom =
        "└──────────────────────┴──────────────┴────────────────────────────────┘";

      // Infrastructure Services Table
      console.log("\n\x1b[1mINFRASTRUCTURE SERVICES\x1b[0m");
      console.log(tableBorder);
      console.log(tableHeader);
      console.log(tableDivider);

      // Add rows for infrastructure services
      console.log(this.createRow("Logging", !!logger));

      // Check database connection status
      const dbIsConnected = !!(
        databaseService &&
        databaseService.isConnected &&
        databaseService.isConnected()
      );

      // Show connection status with appropriate details
      console.log(
        this.createRow(
          "Database",
          dbIsConnected,
          dbIsConnected
            ? `${dbHost}:${dbPort} (${dbName})`
            : "Not connected - Check configuration",
        ),
      );

      // Only show detailed DB info if connected
      if (dbIsConnected) {
        console.log(this.createRow("  DB User", true, dbUser));
        console.log(
          this.createRow(
            "  DB Connections",
            true,
            `Active: ${(databaseService && databaseService.getStats && databaseService.getStats()?.activeCount) || 0}`,
          ),
        );
      }

      // Check cache service status
      const cacheIsActive = !!(
        cacheService &&
        (typeof cacheService.isConnected === "function"
          ? cacheService.isConnected()
          : true)
      );

      console.log(
        this.createRow(
          "Cache",
          cacheIsActive,
          cacheIsActive
            ? `Hits: ${(cacheService && cacheService.getStats && cacheService.getStats()?.hits) || 0}`
            : "Not available",
        ),
      );

      // Check storage service
      const storageIsActive = !!storageService;
      console.log(
        this.createRow(
          "Storage",
          storageIsActive,
          storageIsActive
            ? `Path: ${config.storagePath || "uploads"}`
            : "Not available",
        ),
      );

      console.log(this.createRow("Jobs", !!jobService));
      console.log(this.createRow("Error Handler", !!errorHandler));
      console.log(this.createRow("Validation", !!validationService));

      // WebSocket status check
      const wsActive = !!(wss && wss.clients);
      const wsConnectionCount = wsActive && wss.clients ? wss.clients.size : 0;
      console.log(
        this.createRow(
          "WebSocket",
          wsActive,
          wsActive ? `Connections: ${wsConnectionCount}` : "Not available",
        ),
      );

      console.log(this.createRow("PubSub", !!pubSubService));
      console.log(this.createRow("Image Processor", !!imageProcessor));
      console.log(this.createRow("Media Processor", !!mediaProcessor));
      console.log(this.createRow("Stream Processor", !!streamProcessor));
      console.log(this.createRow("Storage Provider", !!storageProvider));

      console.log(tableBottom);
      console.log("\n");
    } catch (error) {
      console.error("Error displaying infrastructure services:", error);
    }
  }

  /**
   * Display business services status
   */
  displayBusinessServices(services: {
    metricsService?: unknown;
    emailService?: unknown;
    tokenService?: unknown;
    encryptionService?: unknown;
    sessionService?: unknown;
    messagingService?: unknown;
  }): void {
    const {
      metricsService,
      emailService,
      tokenService,
      encryptionService,
      sessionService,
      messagingService,
    } = services;

    // Table borders
    const tableBorder =
      "┌──────────────────────┬──────────────┬────────────────────────────────┐";
    const tableHeader =
      "│ Service              │ Status       │ Details                        │";
    const tableDivider =
      "├──────────────────────┼──────────────┼────────────────────────────────┤";
    const tableBottom =
      "└──────────────────────┴──────────────┴────────────────────────────────┘";

    // Business Services Table
    console.log("\n\x1b[1mBUSINESS SERVICES\x1b[0m");
    console.log(tableBorder);
    console.log(tableHeader);
    console.log(tableDivider);

    // Add rows for business services
    console.log(this.createRow("Metrics", !!metricsService));
    console.log(this.createRow("Email", !!emailService));
    console.log(this.createRow("Token", !!tokenService));
    console.log(this.createRow("Encryption", !!encryptionService));
    console.log(this.createRow("Session", !!sessionService));
    console.log(this.createRow("Messaging", !!messagingService));

    console.log(tableBottom);
    console.log("\n");
  }

  /**
   * Display connection information
   */
  displayConnectionInformation(
    port: number,
    configService: ConfigObject,
    infrastructureServices?: {
      databaseService?: DatabaseService;
      storageService?: unknown;
    },
  ): void {
    try {
      // Get database connection info
      const dbConnectionInfo =
        (configService.get("DATABASE") as DBConnectionInfo) || {};

      // Fall back to direct environment variables
      let dbHost = dbConnectionInfo.host;
      if (!dbHost) {
        dbHost =
          (configService.get("DB_HOST") as string) ||
          process.env.DB_HOST ||
          "localhost";
      }

      let dbPort = dbConnectionInfo.port;
      if (!dbPort) {
        dbPort =
          Number(configService.get("DB_PORT")) ||
          Number(process.env.DB_PORT) ||
          5432;
      }

      // Get environment info dynamically with consistent path separators
      const configDir = path.relative(
        process.cwd(),
        path.resolve(path.join(__dirname, "../../infrastructure/config")),
      );
      const envPath = path.join(configDir, ".env");
      const envFile = `.env.${process.env.NODE_ENV || "development"}`;

      console.log("\n\n\x1b[36m=== SERVICE CONNECTION INFORMATION ===\x1b[0m");
      console.log("\n\x1b[1mPORT INFORMATION SUMMARY:\x1b[0m");

      // Check if database is actually connected
      const dbIsConnected = !!(
        infrastructureServices?.databaseService?.isConnected &&
        infrastructureServices.databaseService.isConnected()
      );

      // Show database status with connection indicator
      console.log(
        `Database (PostgreSQL): \x1b[${dbIsConnected ? "32" : "31"}mhttp://${dbHost}:${dbPort}\x1b[0m ${!dbIsConnected ? "\x1b[31m[NOT CONNECTED]\x1b[0m" : ""}`,
      );

      // Show backend server information
      console.log(`Backend (Express): \x1b[32mhttp://localhost:${port}\x1b[0m`);
      console.log(`API URL: \x1b[32mhttp://localhost:${port}/api\x1b[0m`);

      // Check if storage is available
      const storageAvailable = !!infrastructureServices?.storageService;
      console.log(
        `File Server (Local): \x1b[${storageAvailable ? "32" : "31"}mhttp://localhost:${port}/uploads\x1b[0m ${!storageAvailable ? "\x1b[31m[NOT AVAILABLE]\x1b[0m" : ""}`,
      );

      // Show environment information
      console.log(
        `Env Directory: \x1b[32m${this.normalizePath(envPath)}/${envFile}\x1b[0m`,
      );
      console.log("");
    } catch (error) {
      console.error("Error displaying connection information:", error);
    }
  }

  /**
   * Display all service status tables and connection information
   */
  displayServerStatus(
    port: number,
    configService: ConfigObject,
    infrastructureServices: {
      logger: ILoggerService;
      databaseService: DatabaseService;
      cacheService: CacheService;
      storageService: unknown;
      jobService: unknown;
      errorHandler: unknown;
      validationService: unknown;
      wss: WebSocketService;
      pubSubService: unknown;
      imageProcessor: unknown;
      mediaProcessor: unknown;
      streamProcessor: unknown;
      storageProvider: unknown;
      config: ConfigObject;
    },
    businessServices: {
      metricsService?: unknown;
      emailService?: unknown;
      tokenService?: unknown;
      encryptionService?: unknown;
      sessionService?: unknown;
      messagingService?: unknown;
    },
  ): void {
    console.log("\n\x1b[36m=== SERVICE STATUS TABLES ===\x1b[0m");
    console.log("\n");

    // Display infrastructure services
    this.displayInfrastructureServices(infrastructureServices);

    // Display business services
    this.displayBusinessServices(businessServices);

    // Display connection information
    this.displayConnectionInformation(
      port,
      configService,
      infrastructureServices,
    );
  }
}


// ---------------------- infrastructure\logging\index.ts (9 lines) ----------------------

// Export interfaces and types
export * from "./ILogger";

// Export implementations
export { LoggerService } from "./Logger";
export { LoggingConfig } from "./LoggingConfig";

// Export transport
export { ConsoleTransport } from "./transports/ConsoleTransport";


// ---------------------- infrastructure\logging\transports\ConsoleTransport.ts (103 lines) ----------------------

import {
  ILogTransport,
  LogEntry,
  LogLevel,
} from "@/server/infrastructure/logging";

/**
 * Console transport for logging
 * Formats and writes log entries to the console
 */
export class ConsoleTransport implements ILogTransport {
  constructor(private prettyPrint: boolean = false) {}

  log(entry: LogEntry): void {
    const formattedEntry = this.prettyPrint
      ? this.formatPretty(entry)
      : this.formatEntry(entry);

    switch (entry.level) {
      case LogLevel.DEBUG:
        console.debug(formattedEntry);
        break;
      case LogLevel.INFO:
        console.info(formattedEntry);
        break;
      case LogLevel.WARN:
        console.warn(formattedEntry);
        break;
      case LogLevel.ERROR:
        console.error(formattedEntry);
        break;
    }
  }

  private formatEntry(entry: LogEntry): string {
    const service = entry.service ? `[${entry.service}]` : "";
    const correlationId = entry.correlationId ? `(${entry.correlationId})` : "";

    let output = `${entry.timestamp} ${LogLevel[entry.level]} ${service}${correlationId}: ${entry.message}`;

    // Add context if available
    if (entry.context && Object.keys(entry.context).length > 0) {
      output += ` context=${JSON.stringify(entry.context)}`;
    }

    // Add metadata if available
    if (entry.metadata) {
      output += ` ${JSON.stringify(entry.metadata)}`;
    }

    // Add structured data if available
    if (entry.structuredData) {
      output += ` ${JSON.stringify(entry.structuredData)}`;
    }

    return output;
  }

  private formatPretty(entry: LogEntry): string {
    const service = entry.service ? ` \x1b[36m[${entry.service}]\x1b[0m` : "";
    const correlationId = entry.correlationId
      ? ` \x1b[33m(${entry.correlationId})\x1b[0m`
      : "";

    let levelColor = "";
    switch (entry.level) {
      case LogLevel.DEBUG:
        levelColor = "\x1b[34m"; // Blue
        break;
      case LogLevel.INFO:
        levelColor = "\x1b[32m"; // Green
        break;
      case LogLevel.WARN:
        levelColor = "\x1b[33m"; // Yellow
        break;
      case LogLevel.ERROR:
        levelColor = "\x1b[31m"; // Red
        break;
    }

    const levelStr = `${levelColor}${LogLevel[entry.level]}\x1b[0m`;
    const date = new Date(entry.timestamp).toLocaleTimeString();

    let output = `${date}${service}${correlationId} ${levelStr}: ${entry.message}`;

    // Add context with nice formatting if available
    if (entry.context && Object.keys(entry.context).length > 0) {
      output += `\n  \x1b[36mContext:\x1b[0m ${JSON.stringify(entry.context, null, 2)}`;
    }

    // Add metadata with nice formatting if available
    if (entry.metadata) {
      output += `\n  \x1b[35mMetadata:\x1b[0m ${JSON.stringify(entry.metadata, null, 2)}`;
    }

    // Add structured data with nice formatting if available
    if (entry.structuredData) {
      output += `\n  \x1b[32mData:\x1b[0m ${JSON.stringify(entry.structuredData, null, 2)}`;
    }

    return output;
  }
}


// ---------------------- infrastructure\middleware\rateLimitMiddleware.ts (212 lines) ----------------------

import { Request, Response, NextFunction } from "express";
import { RateLimiterMemory } from "rate-limiter-flexible";

import { TooManyRequestsError } from "@/server/infrastructure/errors";

// Extend Express Request type to include user
declare module "express" {
  interface Request {
    user?: {
      id: string;
      [key: string]: unknown;
    };
  }
}

// Rate limiter configurations for different endpoints
const rateLimiters = {
  // Login - 5 attempts per minute
  login: new RateLimiterMemory({
    points: 5, // Number of attempts
    duration: 60, // Per 60 seconds
    blockDuration: 300, // Block for 5 minutes after too many attempts
  }),

  // Register - 3 attempts per 5 minutes
  register: new RateLimiterMemory({
    points: 3,
    duration: 300, // Per 5 minutes
    blockDuration: 600, // Block for 10 minutes after too many attempts
  }),

  // Password reset - 3 attempts per 30 minutes
  passwordReset: new RateLimiterMemory({
    points: 3,
    duration: 1800, // Per 30 minutes
    blockDuration: 3600, // Block for 1 hour after too many attempts
  }),

  // Token refresh - 10 attempts per minute
  tokenRefresh: new RateLimiterMemory({
    points: 10,
    duration: 60,
    blockDuration: 300,
  }),

  // Email verification - 5 attempts per hour
  emailVerification: new RateLimiterMemory({
    points: 5,
    duration: 3600, // Per hour
    blockDuration: 7200, // Block for 2 hours after too many attempts
  }),

  // MFA verification - 3 attempts per 10 minutes
  mfaVerify: new RateLimiterMemory({
    points: 3,
    duration: 600, // Per 10 minutes
    blockDuration: 1800, // Block for 30 minutes after too many attempts
  }),

  // API general limit - 100 requests per minute
  api: new RateLimiterMemory({
    points: 100,
    duration: 60,
  }),
};

/**
 * Get IP address from request
 * Handles various proxy scenarios and header formats
 */
const getIpAddress = (req: Request): string => {
  // Try X-Forwarded-For header first (common in proxy setups)
  const forwardedFor = req.headers["x-forwarded-for"];
  if (forwardedFor) {
    // If it's a comma separated list, get the first IP which is the client's
    const ips = Array.isArray(forwardedFor)
      ? forwardedFor[0]
      : forwardedFor.split(",")[0].trim();
    return ips;
  }

  // Fall back to other headers or the remoteAddress
  return (
    (req.headers["x-real-ip"] as string) ||
    req.connection.remoteAddress ||
    "unknown"
  );
};

/**
 * Rate limiting middleware
 * @param limiterKey Key of the rate limiter to use from the rateLimiters object
 */
export const rateLimitMiddleware = (limiterKey: keyof typeof rateLimiters) => {
  return async (
    req: Request,
    res: Response,
    next: NextFunction,
  ): Promise<void> => {
    const limiter = rateLimiters[limiterKey];

    if (!limiter) {
      // If no limiter configured for this key, just pass through
      return next();
    }

    // Use IP for anonymous users, userId+IP for authenticated users
    const userId = req.user?.id;
    const ip = getIpAddress(req);
    const key = userId ? `${userId}_${ip}` : ip;

    try {
      await limiter.consume(key);
      // If we get here, the request is allowed
      next();
    } catch (error) {
      // Check if this is a rate limit rejection
      if (error instanceof Error && error.name === "RateLimiterRes") {
        const retryAfter =
          Math.round((error.message as unknown as number) / 1000) || 1;

        // Set standard retry-after header
        res.set("Retry-After", String(retryAfter));

        // Return rate limit error
        res.status(429).json({
          success: false,
          message: "Too many requests, please try again later",
          retryAfter: retryAfter,
        });
      } else {
        // For other errors, just continue
        next();
      }
    }
  };
};

/**
 * Create a specialized rate limiter for specific security events
 * This can be used outside the HTTP middleware context
 */
export class SecurityRateLimiter {
  private limiter: RateLimiterMemory;

  constructor(options: {
    points: number;
    duration: number;
    blockDuration?: number;
  }) {
    this.limiter = new RateLimiterMemory(options);
  }

  /**
   * Check if an action is allowed
   * @param key The identifier for this action (userId, IP, etc)
   * @returns True if allowed, false if rate limited
   */
  async isAllowed(key: string): Promise<boolean> {
    try {
      await this.limiter.consume(key);
      return true;
    } catch (_error) {
      return false;
    }
  }

  /**
   * Record a failed attempt and throw error if limited
   * @param key The identifier for this action
   * @throws TooManyRequestsError if rate limit exceeded
   */
  async recordFailedAttempt(key: string): Promise<void> {
    try {
      await this.limiter.consume(key);
    } catch (_error) {
      throw new TooManyRequestsError(
        "Too many failed attempts. Please try again later.",
      );
    }
  }

  /**
   * Get current limit status for a key
   * @param key The identifier to check
   * @returns Points remaining and ms until reset
   */
  async getLimitStatus(
    key: string,
  ): Promise<{ remainingPoints: number; msBeforeNext: number }> {
    try {
      const res = await this.limiter.get(key);
      return {
        remainingPoints: res ? res.remainingPoints : this.limiter.points,
        msBeforeNext: res ? res.msBeforeNext : 0,
      };
    } catch (_error) {
      return {
        remainingPoints: 0,
        msBeforeNext: 300000, // Default 5 minutes
      };
    }
  }

  /**
   * Reset rate limit for a key
   * @param key The identifier to reset
   */
  async resetLimit(key: string): Promise<void> {
    await this.limiter.delete(key);
  }
}


// ---------------------- infrastructure\middleware\validationMiddleware.ts (99 lines) ----------------------

import { Request, Response, NextFunction } from "express";
import { Schema, ValidationErrorItem } from "joi";

/**
 * Middleware for validating request data against provided schema
 * @param schema Joi validation schema
 */
export const validateRequest = (schema: Schema) => {
  return (req: Request, res: Response, next: NextFunction): void => {
    const { error } = schema.validate(req.body, {
      abortEarly: false, // Return all errors, not just the first one
      stripUnknown: true, // Remove unknown keys
      allowUnknown: false, // Don't allow unknown keys
    });

    if (error) {
      // Format validation errors
      const formattedErrors = error.details.map(
        (detail: ValidationErrorItem) => ({
          field: detail.path.join("."),
          message: detail.message,
        }),
      );

      res.status(400).json({
        success: false,
        message: "Validation error",
        errors: formattedErrors,
      });
      return;
    }

    next();
  };
};

/**
 * Middleware for validating query parameters
 * @param schema Joi validation schema
 */
export const validateQuery = (schema: Schema) => {
  return (req: Request, res: Response, next: NextFunction): void => {
    const { error } = schema.validate(req.query, {
      abortEarly: false,
      stripUnknown: true,
      allowUnknown: false,
    });

    if (error) {
      const formattedErrors = error.details.map(
        (detail: ValidationErrorItem) => ({
          field: detail.path.join("."),
          message: detail.message,
        }),
      );

      res.status(400).json({
        success: false,
        message: "Query parameter validation error",
        errors: formattedErrors,
      });
      return;
    }

    next();
  };
};

/**
 * Middleware for validating URL parameters
 * @param schema Joi validation schema
 */
export const validateParams = (schema: Schema) => {
  return (req: Request, res: Response, next: NextFunction): void => {
    const { error } = schema.validate(req.params, {
      abortEarly: false,
      stripUnknown: true,
      allowUnknown: false,
    });

    if (error) {
      const formattedErrors = error.details.map(
        (detail: ValidationErrorItem) => ({
          field: detail.path.join("."),
          message: detail.message,
        }),
      );

      res.status(400).json({
        success: false,
        message: "URL parameter validation error",
        errors: formattedErrors,
      });
      return;
    }

    next();
  };
};


// ---------------------- infrastructure\processor\ImageProcessor.ts (291 lines) ----------------------

// ImageProcessor.ts
import path from "path";

import sharp from "sharp";

import { ILoggerService } from "@/server/infrastructure/logging";
import { ImageFormat, FileUtils } from "@/server/infrastructure/storage";

/**
 * Image processing options
 */
export interface ImageOptions {
  /**
   * Target width
   */
  width?: number;

  /**
   * Target height
   */
  height?: number;

  /**
   * Output quality (1-100)
   */
  quality?: number;

  /**
   * Output format
   */
  format?: ImageFormat | string;

  /**
   * Resize fit
   */
  fit?: "cover" | "contain" | "fill" | "inside";

  /**
   * Prevent image enlargement
   */
  withoutEnlargement?: boolean;

  /**
   * Apply image enhancement
   */
  enhance?: boolean;

  /**
   * Apply sharpening
   */
  sharpen?: boolean;
}

/**
 * Image metadata
 */
export interface ImageMetadata {
  /**
   * Image width in pixels
   */
  width?: number;

  /**
   * Image height in pixels
   */
  height?: number;

  /**
   * Image format
   */
  format?: string;

  /**
   * File size in bytes
   */
  size: number;

  /**
   * Color space
   */
  space?: string;

  /**
   * Whether image has transparency
   */
  hasAlpha?: boolean;

  /**
   * Orientation from EXIF
   */
  orientation?: number;
}

/**
 * Image processor for resizing, optimizing and converting images
 */
export class ImageProcessor {
  private logger: ILoggerService;
  private fileUtils: FileUtils;

  constructor(logger: ILoggerService, fileUtils: FileUtils) {
    this.logger = logger.createLogger("ImageProcessor");
    this.fileUtils = fileUtils;
  }

  /**
   * Check if a content type is an image
   * @param contentType Content type
   */
  isImage(contentType: string): boolean {
    return (
      contentType.startsWith("image/") &&
      !contentType.includes("svg") &&
      !contentType.includes("icon")
    );
  }

  /**
   * Get image metadata
   * @param filePath File path
   */
  async getMetadata(filePath: string): Promise<ImageMetadata | null> {
    try {
      const stats = await this.fileUtils.getFileStats(filePath);
      const metadata = await sharp(filePath).metadata();

      return {
        width: metadata.width,
        height: metadata.height,
        format: metadata.format,
        size: stats.size,
        space: metadata.space,
        hasAlpha: metadata.hasAlpha,
        orientation: metadata.orientation,
      };
    } catch (error) {
      this.logger.error(`Error getting image metadata: ${filePath}`, {
        error: error instanceof Error ? error.message : String(error),
      });
      return null;
    }
  }

  /**
   * Process and optimize an image
   * @param sourcePath Source image path
   * @param targetPath Target image path
   * @param options Processing options
   */
  async process(
    sourcePath: string,
    targetPath: string,
    options: ImageOptions = {},
  ): Promise<ImageMetadata> {
    try {
      // Ensure target directory exists
      const targetDir = path.dirname(targetPath);
      await this.fileUtils.ensureDirectory(targetDir);

      // Get original metadata
      const metadata = await sharp(sourcePath).metadata();

      // Initialize Sharp instance
      let image = sharp(sourcePath);

      // Apply rotation based on EXIF data
      image = image.rotate();

      // Resize if needed
      if (options.width || options.height) {
        image = image.resize({
          width: options.width,
          height: options.height,
          fit: options.fit || "inside",
          withoutEnlargement: options.withoutEnlargement !== false,
        });
      }

      // Apply enhancements if requested
      if (options.enhance) {
        image = image.modulate({
          brightness: 1.05,
          saturation: 1.1,
        });
      }

      // Apply sharpening if requested
      if (options.sharpen) {
        image = image.sharpen();
      }

      // Apply format and quality
      const outputFormat =
        options.format === ImageFormat.ORIGINAL
          ? metadata.format
          : options.format;

      if (
        outputFormat === ImageFormat.JPEG ||
        (!outputFormat && metadata.format === "jpeg")
      ) {
        image = image.jpeg({ quality: options.quality || 80 });
      } else if (
        outputFormat === ImageFormat.PNG ||
        (!outputFormat && metadata.format === "png")
      ) {
        image = image.png({ quality: options.quality || 80 });
      } else if (
        outputFormat === ImageFormat.WEBP ||
        (!outputFormat && metadata.format === "webp")
      ) {
        image = image.webp({ quality: options.quality || 80 });
      } else if (outputFormat === ImageFormat.AVIF) {
        image = image.avif({ quality: options.quality || 80 });
      }

      // Save the processed image
      await image.toFile(targetPath);

      // Get processed file metadata
      const processedMetadata = await this.getMetadata(targetPath);

      return processedMetadata || { size: 0 };
    } catch (error) {
      this.logger.error(
        `Error processing image: ${sourcePath} to ${targetPath}`,
        {
          error: error instanceof Error ? error.message : String(error),
        },
      );
      throw error;
    }
  }

  /**
   * Generate a thumbnail
   * @param sourcePath Source image path
   * @param targetPath Target thumbnail path
   * @param size Thumbnail size
   */
  async generateThumbnail(
    sourcePath: string,
    targetPath: string,
    size: number = 200,
  ): Promise<string> {
    try {
      // Ensure target directory exists
      const targetDir = path.dirname(targetPath);
      await this.fileUtils.ensureDirectory(targetDir);

      // Create a new pipeline for processing to ensure resources are closed
      const image = sharp(sourcePath);

      // Create thumbnail
      await image
        .rotate() // Apply rotation based on EXIF
        .resize(size, size, { fit: "inside", withoutEnlargement: true })
        .webp({ quality: 80 })
        .toFile(targetPath);

      // Force garbage collection without unsafe cast
      if (image && typeof image === "object") {
        // Use optional chaining to safely access and modify properties
        (image as any).options = null;
      }

      return targetPath;
    } catch (error) {
      this.logger.error(`Error generating thumbnail: ${sourcePath}`, {
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Extract EXIF data from an image
   * @param filePath Path to the image file
   */
  async extractExifData(filePath: string): Promise<Buffer | null> {
    try {
      const metadata = await sharp(filePath).metadata();
      return metadata.exif ? metadata.exif : null;
    } catch (error) {
      this.logger.error(`Error extracting EXIF data: ${filePath}`, {
        error: error instanceof Error ? error.message : String(error),
      });
      return null;
    }
  }
}


// ---------------------- infrastructure\processor\MediaProcessor.ts (555 lines) ----------------------

// MediaProcessor.ts
import path from "path";

import ffmpeg from "fluent-ffmpeg";

import { ILoggerService } from "@/server/infrastructure/logging";
import {
  ContentCategory,
  getContentCategory,
  FileUtils,
} from "@/server/infrastructure/storage";

import { ImageProcessor, ImageOptions } from "./ImageProcessor";

/**
 * Media processing options
 */
export interface MediaOptions extends ImageOptions {
  /**
   * Video bitrate
   */
  videoBitrate?: string;

  /**
   * Audio bitrate
   */
  audioBitrate?: string;

  /**
   * Generate streaming variants (HLS)
   */
  generateStreamingVariants?: boolean;

  /**
   * Audio normalization
   */
  normalize?: boolean;

  /**
   * Generate thumbnail
   */
  generateThumbnail?: boolean;

  /**
   * Thumbnail size
   */
  thumbnailSize?: number;
}

/**
 * Media processing result
 */
export interface MediaProcessingResult {
  /**
   * Output path
   */
  path: string;

  /**
   * Public URL
   */
  url: string;

  /**
   * Content type
   */
  contentType: string;

  /**
   * File size in bytes
   */
  size: number;

  /**
   * Media metadata
   */
  metadata: {
    width?: number;
    height?: number;
    duration?: number;
    format?: string;
  };

  /**
   * Thumbnail path (if generated)
   */
  thumbnail?: string;
}

/**
 * Unified media processor for images, videos, and audio
 */
export class MediaProcessor {
  private logger: ILoggerService;
  private fileUtils: FileUtils;
  private imageProcessor: ImageProcessor;
  private baseUrl: string;

  constructor(
    logger: ILoggerService,
    fileUtils: FileUtils,
    tempDir: string,
    baseUrl: string = "",
  ) {
    this.logger = logger.createLogger("MediaProcessor");
    this.fileUtils = fileUtils;
    this.imageProcessor = new ImageProcessor(logger, fileUtils);
    this.baseUrl = baseUrl;

    // Ensure temp directory exists
    this.fileUtils.ensureDirectory(tempDir);
  }

  /**
   * Update the base URL (useful when port changes)
   * @param baseUrl New base URL
   */
  updateBaseUrl(baseUrl: string): void {
    if (baseUrl) {
      this.baseUrl = baseUrl;
      this.logger.info("Updated media processor base URL", {
        baseUrl: this.baseUrl,
      });
    }
  }

  /**
   * Process media file based on its type
   * @param sourcePath Source file path
   * @param targetPath Target file path
   * @param options Processing options
   */
  async processMedia(
    sourcePath: string,
    targetPath: string,
    options: MediaOptions = {},
  ): Promise<MediaProcessingResult> {
    try {
      // Detect content type
      const contentType = this.fileUtils.detectContentType(sourcePath);
      const category = getContentCategory(contentType);

      // Process based on media type
      switch (category) {
        case ContentCategory.IMAGE:
          return await this.processImage(
            sourcePath,
            targetPath,
            contentType,
            options,
          );
        case ContentCategory.VIDEO:
          return await this.processVideo(
            sourcePath,
            targetPath,
            contentType,
            options,
          );
        case ContentCategory.AUDIO:
          return await this.processAudio(
            sourcePath,
            targetPath,
            contentType,
            options,
          );
        default: {
          // For other file types, just copy the file
          await this.fileUtils.copyFile(sourcePath, targetPath);

          // Get file stats
          const stats = await this.fileUtils.getFileStats(targetPath);

          return {
            path: targetPath,
            url: this.getFileUrl(targetPath),
            contentType,
            size: stats.size,
            metadata: { format: path.extname(targetPath).slice(1) },
          };
        }
      }
    } catch (error) {
      this.logger.error(`Error processing media: ${sourcePath}`, {
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Process an image
   * @param sourcePath Source file path
   * @param targetPath Target file path
   * @param contentType Content type
   * @param options Processing options
   */
  private async processImage(
    sourcePath: string,
    targetPath: string,
    contentType: string,
    options: MediaOptions,
  ): Promise<MediaProcessingResult> {
    // Process the image
    const processedMetadata = await this.imageProcessor.process(
      sourcePath,
      targetPath,
      options,
    );

    // Generate thumbnail if requested
    let thumbnail;
    if (options.generateThumbnail) {
      const thumbSize = options.thumbnailSize || 200;
      const thumbPath = this.generateThumbnailPath(targetPath);
      thumbnail = await this.imageProcessor.generateThumbnail(
        sourcePath,
        thumbPath,
        thumbSize,
      );
    }

    return {
      path: targetPath,
      url: this.getFileUrl(targetPath),
      contentType: this.getOutputContentType(contentType, options.format),
      size: processedMetadata.size,
      metadata: {
        width: processedMetadata.width,
        height: processedMetadata.height,
        format: processedMetadata.format,
      },
      thumbnail,
    };
  }

  /**
   * Process a video
   * @param sourcePath Source file path
   * @param targetPath Target file path
   * @param contentType Content type
   * @param options Processing options
   */
  private async processVideo(
    sourcePath: string,
    targetPath: string,
    contentType: string,
    options: MediaOptions,
  ): Promise<MediaProcessingResult> {
    // Create output directory
    const outputDir = path.dirname(targetPath);
    await this.fileUtils.ensureDirectory(outputDir);

    // Get video metadata
    const metadata = await this.getVideoMetadata(sourcePath);

    // Generate thumbnail if requested
    let thumbnail;
    if (options.generateThumbnail) {
      thumbnail = await this.generateVideoThumbnail(
        sourcePath,
        this.generateThumbnailPath(targetPath),
        options.thumbnailSize || 200,
      );
    }

    // If streaming variants are requested
    if (options.generateStreamingVariants) {
      await this.generateStreamingVariants(sourcePath, targetPath, options);
    } else {
      // Basic video processing
      await this.transcodeVideo(sourcePath, targetPath, options);
    }

    // Get processed file stats
    const stats = await this.fileUtils.getFileStats(targetPath);

    return {
      path: targetPath,
      url: this.getFileUrl(targetPath),
      contentType,
      size: stats.size,
      metadata: {
        width: metadata.width,
        height: metadata.height,
        duration: metadata.duration,
        format: path.extname(targetPath).slice(1),
      },
      thumbnail,
    };
  }

  /**
   * Process an audio file
   * @param sourcePath Source file path
   * @param targetPath Target file path
   * @param contentType Content type
   * @param options Processing options
   */
  private async processAudio(
    sourcePath: string,
    targetPath: string,
    contentType: string,
    options: MediaOptions,
  ): Promise<MediaProcessingResult> {
    // Create output directory
    const outputDir = path.dirname(targetPath);
    await this.fileUtils.ensureDirectory(outputDir);

    // Extract audio metadata
    const metadata = await this.getAudioMetadata(sourcePath);

    // Process audio
    await this.transcodeAudio(sourcePath, targetPath, options);

    // Get processed file stats
    const stats = await this.fileUtils.getFileStats(targetPath);

    return {
      path: targetPath,
      url: this.getFileUrl(targetPath),
      contentType,
      size: stats.size,
      metadata: {
        duration: metadata.duration,
        format: path.extname(targetPath).slice(1),
      },
    };
  }

  /**
   * Generate streaming variants for a video
   * @param sourcePath Source video path
   * @param targetPath Base path for output files
   * @param options Processing options
   */
  private async generateStreamingVariants(
    sourcePath: string,
    targetPath: string,
    _options: MediaOptions,
  ): Promise<void> {
    // Get output directory
    const outputDir = path.dirname(targetPath);
    const baseName = path.basename(targetPath, path.extname(targetPath));

    // Create HLS directory
    const hlsDir = path.join(outputDir, `${baseName}_hls`);
    await this.fileUtils.ensureDirectory(hlsDir);

    // Generate HLS playlist
    return new Promise<void>((resolve, reject) => {
      ffmpeg(sourcePath)
        .outputOptions([
          "-hls_time 10",
          "-hls_list_size 0",
          "-hls_segment_filename",
          `${hlsDir}/%03d.ts`,
        ])
        .output(`${hlsDir}/playlist.m3u8`)
        .on("end", () => resolve())
        .on("error", (err) => reject(err))
        .run();
    });
  }

  /**
   * Transcode a video
   * @param sourcePath Source video path
   * @param targetPath Target video path
   * @param options Processing options
   */
  private async transcodeVideo(
    sourcePath: string,
    targetPath: string,
    options: MediaOptions,
  ): Promise<void> {
    return new Promise<void>((resolve, reject) => {
      let command = ffmpeg(sourcePath);

      if (options.videoBitrate) {
        command = command.videoBitrate(options.videoBitrate);
      }

      if (options.audioBitrate) {
        command = command.audioBitrate(options.audioBitrate);
      }

      command
        .output(targetPath)
        .on("end", () => resolve())
        .on("error", (err) => reject(err))
        .run();
    });
  }

  /**
   * Transcode an audio file
   * @param sourcePath Source audio path
   * @param targetPath Target audio path
   * @param options Processing options
   */
  private async transcodeAudio(
    sourcePath: string,
    targetPath: string,
    options: MediaOptions,
  ): Promise<void> {
    return new Promise<void>((resolve, reject) => {
      let command = ffmpeg(sourcePath);

      if (options.audioBitrate) {
        command = command.audioBitrate(options.audioBitrate);
      }

      if (options.normalize) {
        command = command.audioFilters("loudnorm");
      }

      command
        .output(targetPath)
        .on("end", () => resolve())
        .on("error", (err) => reject(err))
        .run();
    });
  }

  /**
   * Generate a thumbnail from a video
   * @param sourcePath Source video path
   * @param targetPath Target thumbnail path
   * @param size Thumbnail size
   */
  private async generateVideoThumbnail(
    sourcePath: string,
    targetPath: string,
    size: number,
  ): Promise<string> {
    // Create output directory
    const outputDir = path.dirname(targetPath);
    await this.fileUtils.ensureDirectory(outputDir);

    return new Promise<string>((resolve, reject) => {
      ffmpeg(sourcePath)
        .screenshots({
          timestamps: ["10%"],
          filename: path.basename(targetPath),
          folder: outputDir,
          size: `${size}x${size}`,
        })
        .on("end", () => resolve(targetPath))
        .on("error", (err) => reject(err));
    });
  }

  /**
   * Get video metadata
   * @param filePath Video file path
   */
  private async getVideoMetadata(
    filePath: string,
  ): Promise<{ width?: number; height?: number; duration?: number }> {
    return new Promise((resolve, reject) => {
      ffmpeg.ffprobe(filePath, (err, metadata) => {
        if (err) {
          reject(err);
          return;
        }

        const videoStream = metadata.streams.find(
          (s) => s.codec_type === "video",
        );

        resolve({
          width: videoStream?.width,
          height: videoStream?.height,
          duration: metadata.format.duration,
        });
      });
    });
  }

  /**
   * Get audio metadata
   * @param filePath Audio file path
   */
  private async getAudioMetadata(
    filePath: string,
  ): Promise<{ duration?: number }> {
    return new Promise((resolve, reject) => {
      ffmpeg.ffprobe(filePath, (err, metadata) => {
        if (err) {
          reject(err);
          return;
        }

        resolve({
          duration: metadata.format.duration,
        });
      });
    });
  }

  /**
   * Generate a thumbnail path
   * @param originalPath Original file path
   */
  private generateThumbnailPath(originalPath: string): string {
    const ext = path.extname(originalPath);
    const basePath = originalPath.substring(
      0,
      originalPath.length - ext.length,
    );
    return `${basePath}_thumb.webp`;
  }

  /**
   * Get file URL
   * @param filePath File path
   */
  private getFileUrl(filePath: string): string {
    // Normalize path for URL
    const normalizedPath = filePath.replace(/\\/g, "/");

    // Remove any leading slash to avoid double slashes
    const cleanPath = normalizedPath.startsWith("/")
      ? normalizedPath.substring(1)
      : normalizedPath;

    return this.baseUrl ? `${this.baseUrl}/${cleanPath}` : cleanPath;
  }

  /**
   * Get output content type based on format
   * @param originalType Original content type
   * @param format Output format
   */
  private getOutputContentType(originalType: string, format?: string): string {
    if (!format || format === "original") {
      return originalType;
    }

    const formatContentTypes: Record<string, string> = {
      jpeg: "image/jpeg",
      png: "image/png",
      webp: "image/webp",
      gif: "image/gif",
      avif: "image/avif",
      mp4: "video/mp4",
      webm: "video/webm",
      mp3: "audio/mpeg",
      wav: "audio/wav",
      ogg: "audio/ogg",
    };

    return formatContentTypes[format] || originalType;
  }
}


// ---------------------- infrastructure\processor\StreamProcessor.ts (258 lines) ----------------------

// StreamProcessor.ts
import fs, { ReadStream, WriteStream } from "fs";
import path from "path";
import { Transform, Readable, Writable, pipeline } from "stream";
import { promisify } from "util";

import { StreamOptions } from "@/server/infrastructure/storage";

// Promisify pipeline
const pipelineAsync = promisify(pipeline);

/**
 * Stream processing statistics
 */
export interface StreamStats {
  /**
   * Bytes processed
   */
  bytesProcessed: number;

  /**
   * Duration in milliseconds
   */
  durationMs: number;

  /**
   * Bytes per second
   */
  bytesPerSecond: number;
}

/**
 * Utility class for stream processing operations
 */
export class StreamProcessor {
  /**
   * Create a read stream
   * @param filePath File path
   * @param options Stream options
   */
  static createReadStream(
    filePath: string,
    options?: StreamOptions,
  ): ReadStream {
    const streamOptions: {
      start?: number;
      end?: number;
      highWaterMark?: number;
    } = {};

    if (options) {
      if (options.start !== undefined) {
        streamOptions.start = options.start;
      }

      if (options.end !== undefined) {
        streamOptions.end = options.end;
      }

      if (options.highWaterMark !== undefined) {
        streamOptions.highWaterMark = options.highWaterMark;
      }
    }

    return fs.createReadStream(filePath, streamOptions);
  }

  /**
   * Create a write stream
   * @param filePath File path
   * @param options Stream options
   */
  static createWriteStream(
    filePath: string,
    options?: StreamOptions,
  ): WriteStream {
    const streamOptions: { highWaterMark?: number } = {};

    if (options) {
      if (options.highWaterMark !== undefined) {
        streamOptions.highWaterMark = options.highWaterMark;
      }
    }

    // Ensure directory exists
    const dirPath = path.dirname(filePath);
    if (!fs.existsSync(dirPath)) {
      fs.mkdirSync(dirPath, { recursive: true });
    }

    return fs.createWriteStream(filePath, streamOptions);
  }

  /**
   * Process a stream with metrics
   * @param source Source stream or file path
   * @param destination Destination stream or file path
   * @param transforms Optional transform streams
   */
  static async processStream(
    source: Readable | string,
    destination: Writable | string,
    transforms: Transform[] = [],
  ): Promise<StreamStats> {
    const startTime = Date.now();

    // Create input stream if string path provided
    const inputStream =
      typeof source === "string" ? this.createReadStream(source) : source;

    // Create output stream if string path provided
    const outputStream =
      typeof destination === "string"
        ? this.createWriteStream(destination)
        : destination;

    // Create metrics tracking transform
    let bytesProcessed = 0;
    const metricsTransform = new Transform({
      transform(chunk, _encoding, callback) {
        bytesProcessed += chunk.length;
        callback(null, chunk);
      },
    });

    // Build pipeline stages
    const stages: [Readable, ...Array<Transform | Writable>] = [inputStream];

    // Add transforms if provided
    if (transforms.length > 0) {
      stages.push(...transforms);
    }

    // Add metrics transform
    stages.push(metricsTransform);

    // Add output stream
    stages.push(outputStream);

    // Run the pipeline
    await (
      pipelineAsync as (
        ...streams: Array<Readable | Transform | Writable>
      ) => Promise<void>
    )(inputStream, ...transforms, metricsTransform, outputStream);

    // Calculate metrics
    const endTime = Date.now();
    const durationMs = endTime - startTime;

    return {
      bytesProcessed,
      durationMs,
      bytesPerSecond:
        durationMs > 0 ? Math.floor(bytesProcessed / (durationMs / 1000)) : 0,
    };
  }

  /**
   * Create a throttled transform stream
   * @param bytesPerSecond Bytes per second limit
   */
  static createThrottleTransform(bytesPerSecond: number): Transform {
    let byteCount = 0;
    let lastTime = Date.now();
    const MAX_DELAY = 2000; // Cap the max delay to prevent test timeouts

    return new Transform({
      transform(chunk, _encoding, callback) {
        const now = Date.now();
        const elapsedMs = now - lastTime;

        byteCount += chunk.length;

        // Calculate allowed bytes for the elapsed time
        const allowedBytes = (bytesPerSecond * elapsedMs) / 1000;

        if (byteCount > allowedBytes) {
          // Calculate delay needed to throttle to target rate
          let delayMs = (1000 * (byteCount - allowedBytes)) / bytesPerSecond;

          // Cap the delay to prevent hanging
          delayMs = Math.min(delayMs, MAX_DELAY);

          setTimeout(() => {
            byteCount = 0;
            lastTime = Date.now();
            callback(null, chunk);
          }, delayMs);
        } else {
          byteCount = 0;
          lastTime = now;
          callback(null, chunk);
        }
      },
    });
  }

  /**
   * Create a progress reporting transform stream
   * @param progressCallback Callback function for progress updates
   * @param totalSize Total expected size (for percentage calculation)
   */
  static createProgressTransform(
    progressCallback: (progress: number, bytes: number) => void,
    totalSize?: number,
  ): Transform {
    let processedBytes = 0;

    return new Transform({
      transform(chunk, _encoding, callback) {
        processedBytes += chunk.length;

        if (totalSize) {
          const progress = Math.min(
            100,
            Math.floor((processedBytes / totalSize) * 100),
          );
          progressCallback(progress, processedBytes);
        } else {
          progressCallback(0, processedBytes);
        }

        callback(null, chunk);
      },
    });
  }

  /**
   * Create a chunking transform stream
   * @param chunkSize Size of each chunk in bytes
   */
  static createChunkingTransform(chunkSize: number): Transform {
    let buffer = Buffer.alloc(0);

    return new Transform({
      transform(chunk, _encoding, callback) {
        // Add new data to the buffer
        buffer = Buffer.concat([buffer, chunk]);

        // Push complete chunks
        while (buffer.length >= chunkSize) {
          this.push(buffer.slice(0, chunkSize));
          buffer = buffer.slice(chunkSize);
        }

        callback();
      },
      flush(callback) {
        // Push any remaining data
        if (buffer.length > 0) {
          this.push(buffer);
        }
        callback();
      },
    });
  }
}


// ---------------------- infrastructure\processor\index.ts (3 lines) ----------------------

export * from "./ImageProcessor";
export * from "./MediaProcessor";
export * from "./StreamProcessor";


// ---------------------- infrastructure\pubsub\IWebSocketService.ts (299 lines) ----------------------

import { Server as HttpServer } from "http";

import { WebSocket } from "ws";

/**
 * Authentication options for WebSocket connections
 */
export interface WebSocketAuthOptions {
  /**
   * Whether authentication is required for connecting
   */
  required: boolean;

  /**
   * Function to validate an authentication token
   */
  validateToken?: (token: string) => Promise<string | null>; // Returns userId if valid

  /**
   * Custom authentication handler
   */
  authHandler?: (request: {
    headers: Record<string, string | string[]>;
    url: string;
  }) => Promise<{
    authenticated: boolean;
    userId?: string;
    metadata?: Record<string, unknown>;
  }>;

  /**
   * Time in milliseconds before unauthenticated connections are closed
   * @default 10000 (10 seconds)
   */
  authTimeout?: number;
}

/**
 * Options for WebSocket messages
 */
export interface WebSocketMessageOptions {
  /**
   * Whether message delivery confirmation is required
   */
  requireAck?: boolean;

  /**
   * Message ID for tracking and acknowledgment
   */
  messageId?: string;

  /**
   * Timeout in milliseconds for acknowledgment
   */
  ackTimeout?: number;

  /**
   * Whether to exclude the sender from receiving the message
   */
  excludeSender?: boolean;
}

/**
 * Client connection state
 */
export enum ClientState {
  /**
   * Initial connection state
   */
  CONNECTING = "connecting",

  /**
   * Connected but not authenticated
   */
  CONNECTED = "connected",

  /**
   * Connection authorized
   */
  AUTHORIZED = "authorized",

  /**
   * Connection closed
   */
  CLOSED = "closed",
}

/**
 * Basic presence information
 * Infrastructure-level presence data, application-specific presence should be in the service layer
 */
export interface PresenceInfo {
  /**
   * User identifier
   */
  userId: string;

  /**
   * Basic presence status
   */
  status: "online" | "offline";

  /**
   * Last activity timestamp
   */
  lastSeen?: Date;

  /**
   * Associated client IDs
   */
  clientIds: string[];
}

/**
 * WebSocket client information
 */
export interface WebSocketClient {
  /**
   * Unique client identifier
   */
  id: string;

  /**
   * WebSocket instance
   */
  ws: WebSocket | import("ws").WebSocket;

  /**
   * Associated user identifier (if authenticated)
   */
  userId?: string;

  /**
   * Whether the client is authenticated
   */
  authenticated: boolean;

  /**
   * Current connection state
   */
  state: ClientState;

  /**
   * Time when the connection was established
   */
  connectedAt: Date;

  /**
   * Time of last activity
   */
  lastActivity: Date;

  /**
   * Client metadata
   */
  metadata?: Record<string, unknown>;
}

/**
 * WebSocket service interface for real-time communication
 * Core infrastructure interface with no application-specific logic
 */
export interface IWebSocketService {
  /**
   * Initialize the WebSocket server
   * @param server HTTP server instance
   * @param options Authentication options
   */
  initialize(server: HttpServer, options?: WebSocketAuthOptions): void;

  /**
   * Close all connections and stop the WebSocket server
   */
  close(): void;

  /**
   * Send a message to a specific client
   * @param clientId Client identifier
   * @param eventType Event type
   * @param data Message data
   * @param options Message options
   * @returns Whether the message was sent successfully
   */
  sendToClient(
    clientId: string,
    eventType: string,
    data: unknown,
    options?: WebSocketMessageOptions,
  ): Promise<boolean>;

  /**
   * Publish a message to a channel
   * @param channel Channel name
   * @param eventType Event type
   * @param data Message data
   * @param options Message options
   * @returns Number of clients the message was sent to
   */
  publish(
    channel: string,
    eventType: string,
    data: unknown,
    options?: WebSocketMessageOptions,
  ): Promise<number>;

  /**
   * Broadcast a message to all connected clients
   * @param eventType Event type
   * @param data Message data
   * @param options Message options
   * @returns Number of clients the message was sent to
   */
  broadcast(
    eventType: string,
    data: unknown,
    options?: WebSocketMessageOptions,
  ): Promise<number>;

  /**
   * Subscribe a client to a channel
   * @param clientId Client identifier
   * @param channel Channel name
   * @returns Whether the subscription was successful
   */
  subscribe(clientId: string, channel: string): boolean;

  /**
   * Unsubscribe a client from a channel
   * @param clientId Client identifier
   * @param channel Channel name
   * @returns Whether the unsubscription was successful
   */
  unsubscribe(clientId: string, channel: string): boolean;

  /**
   * Get the channels a client is subscribed to
   * @param clientId Client identifier
   * @returns Set of channel names
   */
  getClientChannels(clientId: string): Set<string>;

  /**
   * Get all clients subscribed to a channel
   * @param channel Channel name
   * @returns Set of client identifiers
   */
  getChannelClients(channel: string): Set<string>;

  /**
   * Authenticate a client
   * @param clientId Client identifier
   * @param userId User identifier
   * @param metadata Optional metadata about the client
   * @returns Whether authentication was successful
   */
  authenticateClient(
    clientId: string,
    userId: string,
    metadata?: Record<string, unknown>,
  ): Promise<boolean>;

  /**
   * Set basic presence data for a user (infrastructure level)
   * @param userId User identifier
   * @param status Basic presence status
   * @param metadata Optional metadata
   */
  setPresence(
    userId: string,
    status: "online" | "offline",
    metadata?: Record<string, unknown>,
  ): Promise<void>;

  /**
   * Get basic presence data for a user (infrastructure level)
   * @param userId User identifier
   * @returns Basic presence data or null if not found
   */
  getPresence(userId: string): Promise<PresenceInfo | null>;

  /**
   * Disconnect a specific client
   * @param clientId Client identifier
   * @param reason Reason for disconnection
   */
  disconnectClient(clientId: string, reason?: string): void;

  /**
   * Get connection statistics
   * @returns Connection statistics
   */
  getStats(): {
    totalConnections: number;
    authenticatedConnections: number;
    channelCounts: Record<string, number>;
    messagesPerSecond: number;
    peakConnections: number;
  };
}


// ---------------------- infrastructure\pubsub\WebSocketService.ts (948 lines) ----------------------

import { Server as HttpServer, IncomingMessage } from "http";

import { inject, injectable } from "inversify";
import { v4 as uuidv4 } from "uuid";
import WS from "ws";

import { TYPES } from "@/server/infrastructure/di";

import {
  IWebSocketService,
  WebSocketMessageOptions,
  WebSocketAuthOptions,
  PresenceInfo,
  ClientState,
} from "./IWebSocketService";

import type { ILoggerService } from "@infrastructure/logging";

/**
 * User activity types
 */
export interface UserActivity {
  /**
   * Type of activity
   */
  type: "typing" | "viewing" | "reacting";

  /**
   * Target ID (e.g., conversation ID, content ID)
   */
  targetId?: string;

  /**
   * Channel where activity is happening
   */
  channel?: string;

  /**
   * When the activity started
   */
  timestamp: Date;

  /**
   * Additional activity data
   */
  data?: Record<string, unknown>;
}

/**
 * Client connection with user information
 */
interface ClientConnection {
  ws: WS;
  userId?: string;
  subscriptions: Set<string>;
  clientId: string;
  connectedAt: Date;
  lastActivity: Date;
  state: ClientState;
  authenticated: boolean;
  isAlive: boolean;
  metadata?: Record<string, unknown>;
  pendingAcks: Map<
    string,
    {
      timeout: NodeJS.Timeout;
      callback: (success: boolean) => void;
    }
  >;
}

/**
 * WebSocket message format
 */
export interface WebSocketMessage {
  type: string;
  eventType?: string;
  channel?: string;
  data?: unknown;
  messageId?: string;
  error?: string;
}

/**
 * WebSocket service for real-time communication
 */
@injectable()
export class WebSocketService implements IWebSocketService {
  private wss: WS.Server | null = null;
  private clients: Map<string, ClientConnection> = new Map();
  private userConnections: Map<string, Set<string>> = new Map();
  private channels: Map<string, Set<string>> = new Map();
  private userPresence: Map<string, PresenceInfo> = new Map();
  private authOptions: WebSocketAuthOptions | null = null;
  private pingInterval: NodeJS.Timeout | null = null;
  private readonly pingIntervalMs = 30000; // 30 seconds
  private messageCount = 0;
  private messageCountStartTime = Date.now();
  private peakConnections = 0;

  constructor(
    @inject(TYPES.LoggerService) private readonly logger: ILoggerService,
  ) {
    this.logger = logger.createLogger("WebSocketService");
  }

  /**
   * Initialize the WebSocket server
   * @param server HTTP server to attach to
   * @param authOptions Authentication options
   */
  public initialize(
    server: HttpServer,
    authOptions?: WebSocketAuthOptions,
  ): void {
    if (this.wss) {
      this.logger.warn("WebSocket server already initialized");
      return;
    }

    this.logger.info("Initializing WebSocket server");
    this.authOptions = authOptions || null;

    this.wss = new WS.Server({ server });

    this.wss.on("connection", (ws: WS, req: IncomingMessage) => {
      const clientId = uuidv4();
      this.logger.debug(`New client connected: ${clientId}`);

      const client: ClientConnection = {
        ws,
        clientId,
        subscriptions: new Set<string>(),
        connectedAt: new Date(),
        lastActivity: new Date(),
        state: ClientState.CONNECTING,
        authenticated: !this.authOptions?.required,
        isAlive: true,
        pendingAcks: new Map(),
        metadata: {
          ip: req.socket.remoteAddress,
          userAgent: req.headers["user-agent"],
        },
      };

      this.clients.set(clientId, client);
      this.updatePeakConnections();

      // Send welcome message with client ID
      this.sendMessage(ws, {
        type: "system",
        eventType: "connection",
        data: {
          clientId,
          requiresAuth: this.authOptions?.required || false,
        },
      });

      // Set up authentication timeout if required
      if (this.authOptions?.required) {
        const timeout = this.authOptions.authTimeout || 10000;
        setTimeout(() => {
          const currentClient = this.clients.get(clientId);
          if (currentClient && !currentClient.authenticated) {
            this.logger.debug(`Authentication timeout for client: ${clientId}`);
            this.disconnectClient(clientId, "Authentication timeout");
          }
        }, timeout);
      }

      // Set up event listeners
      ws.on("message", (message: WS.Data) => {
        try {
          const parsedMessage: WebSocketMessage = JSON.parse(
            message.toString(),
          );
          this.handleMessage(clientId, parsedMessage);
        } catch (error) {
          this.logger.error("Error parsing WebSocket message", {
            error,
            clientId,
          });
          this.sendMessage(ws, {
            type: "error",
            data: { message: "Invalid message format" },
          });
        }
      });

      ws.on("close", () => {
        this.handleClientDisconnect(clientId);
      });

      ws.on("pong", () => {
        if (client) {
          client.isAlive = true;
        }
      });

      ws.on("error", (error) => {
        this.logger.error("WebSocket error", { error, clientId });
      });
    });

    // Set up ping interval to detect disconnected clients
    this.pingInterval = setInterval(() => {
      this.checkConnections();
    }, this.pingIntervalMs);

    this.logger.info("WebSocket server initialized");
  }

  /**
   * Handles incoming messages from clients
   */
  private handleMessage(clientId: string, message: WebSocketMessage): void {
    const client = this.clients.get(clientId);
    if (!client) {
      this.logger.warn(`Message received for unknown client: ${clientId}`);
      return;
    }

    this.logger.debug(`Received message from client ${clientId}`, {
      type: message.type,
    });

    switch (message.type) {
      case "auth":
        this.handleAuth(clientId, client, message);
        break;
      case "subscribe":
        this.handleSubscribe(clientId, client, message);
        break;
      case "unsubscribe":
        this.handleUnsubscribe(clientId, client, message);
        break;
      case "ack":
        this.handleAcknowledgment(clientId, message);
        break;
      default:
        this.logger.debug(`Unhandled message type: ${message.type}`, {
          clientId,
        });
        this.sendMessage(client.ws, {
          type: "error",
          data: { message: `Unsupported message type: ${message.type}` },
        });
    }
  }

  /**
   * Handle client authentication
   */
  private handleAuth(
    clientId: string,
    client: ClientConnection,
    message: WebSocketMessage,
  ): void {
    const data = message.data as { userId: string };

    if (!data.userId) {
      this.logger.warn("Auth message missing userId", { clientId });
      return;
    }

    const userId = data.userId;

    // Update client with userId
    client.userId = userId;

    // Track user's connections
    if (!this.userConnections.has(userId)) {
      this.userConnections.set(userId, new Set());
    }
    this.userConnections.get(userId)?.add(clientId);

    this.logger.debug("Client authenticated", {
      clientId,
      userId,
    });

    // Send confirmation
    client.ws.send(
      JSON.stringify({
        type: "auth_success",
        data: {
          userId,
          clientId,
        },
      }),
    );
  }

  /**
   * Handle channel subscription
   */
  private handleSubscribe(
    clientId: string,
    client: ClientConnection,
    message: WebSocketMessage,
  ): void {
    const data = message.data as { channel: string };
    const channel = data.channel;

    if (!channel) {
      this.logger.warn("Subscribe message missing channel", { clientId });
      return;
    }

    // Add to client's subscriptions
    client.subscriptions.add(channel);

    // Add client to channel's subscribers
    if (!this.channels.has(channel)) {
      this.channels.set(channel, new Set());
    }
    this.channels.get(channel)?.add(clientId);

    // Send confirmation
    client.ws.send(
      JSON.stringify({
        type: "subscribe_success",
        data: {
          channel,
        },
      }),
    );
  }

  /**
   * Handle channel unsubscription
   */
  private handleUnsubscribe(
    clientId: string,
    client: ClientConnection,
    message: WebSocketMessage,
  ): void {
    const data = message.data as { channel: string };
    const channel = data.channel;

    if (!channel) {
      this.logger.warn("Unsubscribe message missing channel", { clientId });
      return;
    }

    // Remove from client's subscriptions
    client.subscriptions.delete(channel);

    // Remove client from channel's subscribers
    this.channels.get(channel)?.delete(clientId);

    // Remove channel if no subscribers left
    if (this.channels.get(channel)?.size === 0) {
      this.channels.delete(channel);
    }

    // Send confirmation
    client.ws.send(
      JSON.stringify({
        type: "unsubscribe_success",
        data: {
          channel,
        },
      }),
    );
  }

  /**
   * Handle client disconnect
   * @param clientId Client ID
   */
  private handleClientDisconnect(clientId: string): void {
    const client = this.clients.get(clientId);

    if (!client) {
      return;
    }

    // Remove from user connections
    if (client.userId) {
      this.userConnections.get(client.userId)?.delete(clientId);

      // Remove user connections map entry if no connections left
      if (this.userConnections.get(client.userId)?.size === 0) {
        this.userConnections.delete(client.userId);

        // Update user presence to offline if this was the last connection
        this.setPresence(client.userId, "offline");
      }
    }

    // Remove from all subscribed channels
    for (const channel of client.subscriptions) {
      this.channels.get(channel)?.delete(clientId);

      // Remove channel if no subscribers left
      if (this.channels.get(channel)?.size === 0) {
        this.channels.delete(channel);
      }
    }

    // Remove client
    this.clients.delete(clientId);
  }

  /**
   * Publish a message to a specific channel
   */
  public async publish(
    channel: string,
    eventType: string,
    data: unknown,
    options?: WebSocketMessageOptions,
  ): Promise<number> {
    if (!channel || !eventType) {
      this.logger.warn("Cannot publish: missing channel or eventType");
      return 0;
    }

    const subscribers = this.channels.get(channel);
    if (!subscribers || subscribers.size === 0) {
      this.logger.debug(`No subscribers for channel: ${channel}`);
      return 0;
    }

    this.logger.debug(`Publishing to channel ${channel}`, {
      eventType,
      subscriberCount: subscribers.size,
    });

    const messageId = options?.messageId || uuidv4();
    const message: WebSocketMessage = {
      type: "message",
      eventType,
      channel,
      data,
      messageId,
    };

    let sentCount = 0;
    const promises: Promise<boolean>[] = [];

    for (const clientId of subscribers) {
      const client = this.clients.get(clientId);
      if (client) {
        promises.push(
          this.sendMessageWithAck(client, message, options).then((success) => {
            if (success) sentCount++;
            return success;
          }),
        );
      }
    }

    await Promise.all(promises);
    return sentCount;
  }

  /**
   * Close all connections and stop the WebSocket server
   */
  public close(): void {
    this.logger.info("Closing WebSocket server");

    // Clear the ping interval
    if (this.pingInterval) {
      clearInterval(this.pingInterval);
      this.pingInterval = null;
    }

    // Close all client connections gracefully
    this.clients.forEach((client) => {
      try {
        client.ws.close(1000, "Server shutting down");
      } catch (error) {
        this.logger.error("Error closing client connection", {
          error,
          clientId: client.clientId,
        });
      }
    });

    // Clear all tracking maps
    this.clients.clear();
    this.userConnections.clear();
    this.channels.clear();
    this.userPresence.clear();

    // Close the server
    if (this.wss) {
      this.wss.close();
      this.wss = null;
    }

    this.logger.info("WebSocket server closed");
  }

  /**
   * Periodically check connections and clean up dead ones
   */
  private checkConnections(): void {
    this.clients.forEach((client, clientId) => {
      if (!client.isAlive) {
        this.logger.debug(`Terminating inactive connection: ${clientId}`);
        client.ws.terminate();
        return;
      }

      client.isAlive = false;
      client.ws.ping();
    });
  }

  /**
   * Send a message to a specific client
   */
  public async sendToClient(
    clientId: string,
    eventType: string,
    data: unknown,
    options?: WebSocketMessageOptions,
  ): Promise<boolean> {
    if (!clientId || !eventType) {
      this.logger.warn("Cannot send to client: missing clientId or eventType");
      return false;
    }

    const client = this.clients.get(clientId);
    if (!client) {
      this.logger.debug(`Client not found: ${clientId}`);
      return false;
    }

    const messageId = options?.messageId || uuidv4();
    const message: WebSocketMessage = {
      type: "message",
      eventType,
      data,
      messageId,
    };

    this.logger.debug(`Sending message to client ${clientId}`, { eventType });
    return this.sendMessageWithAck(client, message, options);
  }

  /**
   * Broadcast a message to all connected clients
   * @param eventType Event type
   * @param data Message data
   * @param options Message options
   * @returns Number of clients the message was sent to
   */
  public async broadcast(
    eventType: string,
    data: unknown,
    options?: WebSocketMessageOptions,
  ): Promise<number> {
    if (!eventType) {
      this.logger.warn("Cannot broadcast: missing eventType");
      return 0;
    }

    this.logger.debug(`Broadcasting message to all clients`, {
      eventType,
      clientCount: this.clients.size,
    });

    const messageId = options?.messageId || uuidv4();
    const message: WebSocketMessage = {
      type: "message",
      eventType,
      data,
      messageId,
    };

    let sentCount = 0;
    const promises: Promise<boolean>[] = [];

    this.clients.forEach((client) => {
      promises.push(
        this.sendMessageWithAck(client, message, options).then((success) => {
          if (success) sentCount++;
          return success;
        }),
      );
    });

    await Promise.all(promises);
    return sentCount;
  }

  /**
   * Subscribe a client to a channel
   */
  public subscribe(clientId: string, channel: string): boolean {
    const client = this.clients.get(clientId);
    if (!client || !channel) {
      return false;
    }

    // Add client to channel
    client.subscriptions.add(channel);

    // Track channel subscribers
    if (!this.channels.has(channel)) {
      this.channels.set(channel, new Set<string>());
    }
    this.channels.get(channel)?.add(clientId);

    this.logger.debug(`Subscribed client ${clientId} to channel ${channel}`);
    return true;
  }

  /**
   * Unsubscribe a client from a channel
   */
  public unsubscribe(clientId: string, channel: string): boolean {
    const client = this.clients.get(clientId);
    if (!client || !channel) {
      return false;
    }

    // Remove client from channel
    client.subscriptions.delete(channel);

    // Update channel subscribers
    if (this.channels.has(channel)) {
      this.channels.get(channel)?.delete(clientId);

      // Clean up empty channels
      if (this.channels.get(channel)?.size === 0) {
        this.channels.delete(channel);
      }
    }

    this.logger.debug(
      `Unsubscribed client ${clientId} from channel ${channel}`,
    );
    return true;
  }

  /**
   * Get the channels a client is subscribed to
   */
  public getClientChannels(clientId: string): Set<string> {
    const client = this.clients.get(clientId);
    if (!client) {
      return new Set();
    }
    return new Set(client.subscriptions);
  }

  /**
   * Get all clients subscribed to a channel
   */
  public getChannelClients(channel: string): Set<string> {
    const clients = this.channels.get(channel);
    if (!clients) {
      return new Set();
    }
    return new Set(clients);
  }

  /**
   * Send a message to a client with optional acknowledgment tracking
   */
  private async sendMessageWithAck(
    client: ClientConnection,
    message: WebSocketMessage,
    options?: WebSocketMessageOptions,
  ): Promise<boolean> {
    return new Promise((resolve) => {
      if (options?.requireAck && message.messageId) {
        // Set up acknowledgment tracking
        const timeout = setTimeout(() => {
          // Handle acknowledgment timeout
          const pendingAck = client.pendingAcks.get(
            message.messageId as string,
          );
          if (pendingAck) {
            pendingAck.callback(false);
            client.pendingAcks.delete(message.messageId as string);
            this.logger.debug(
              `Acknowledgment timeout for message ${message.messageId}`,
              {
                clientId: client.clientId,
              },
            );
            resolve(false);
          }
        }, options.ackTimeout || 5000);

        // Store callback for later resolution
        client.pendingAcks.set(message.messageId, {
          timeout,
          callback: (success: boolean) => {
            resolve(success);
            if (!success) {
              this.logger.debug(
                `Message ${message.messageId} was not acknowledged`,
                {
                  clientId: client.clientId,
                },
              );
            }
          },
        });
      } else {
        // No acknowledgment required
        resolve(true);
      }

      if (!this.sendMessage(client.ws, message)) {
        // Failed to send message
        if (message.messageId) {
          const pendingAck = client.pendingAcks.get(message.messageId);
          if (pendingAck) {
            clearTimeout(pendingAck.timeout);
            client.pendingAcks.delete(message.messageId);
          }
        }
        resolve(false);
      }
    });
  }

  /**
   * Send a raw message to a WebSocket
   */
  private sendMessage(ws: WS, message: WebSocketMessage): boolean {
    if (ws.readyState === WS.OPEN) {
      try {
        ws.send(JSON.stringify(message));
        return true;
      } catch (error) {
        this.logger.error("Failed to send message", { error });
        return false;
      }
    }
    return false;
  }

  /**
   * Handles message acknowledgments
   */
  private handleAcknowledgment(
    clientId: string,
    message: WebSocketMessage,
  ): void {
    const messageId = message.messageId;
    if (!messageId) {
      this.logger.warn("Ack message missing messageId", { clientId });
      return;
    }

    const client = this.clients.get(clientId);
    if (!client) return;

    const pendingAck = client.pendingAcks.get(messageId);
    if (pendingAck) {
      clearTimeout(pendingAck.timeout);
      pendingAck.callback(true);
      client.pendingAcks.delete(messageId);
      this.logger.debug(
        `Received ack for message ${messageId} from client ${clientId}`,
      );
    }
  }

  /**
   * Set basic presence data for a user (infrastructure level)
   * @param userId User identifier
   * @param status Basic presence status (online or offline)
   * @param _metadata Optional metadata
   */
  public async setPresence(
    userId: string,
    status: "online" | "offline",
    _metadata?: Record<string, unknown>,
  ): Promise<void> {
    const clientIds = this.userConnections.get(userId) || new Set();

    const presence: PresenceInfo = {
      userId,
      status,
      lastSeen: new Date(),
      clientIds: Array.from(clientIds),
    };

    this.userPresence.set(userId, presence);

    // Publish a presence update message to those who need it
    await this.publish(`presence:${userId}`, "presence_update", {
      userId,
      status,
      lastSeen: presence.lastSeen,
    });

    this.logger.debug(`User presence updated: ${userId} is now ${status}`);
  }

  /**
   * Get basic presence data for a user (infrastructure level)
   * @param userId User identifier
   * @returns Basic presence data or null if not found
   */
  public async getPresence(userId: string): Promise<PresenceInfo | null> {
    return this.userPresence.get(userId) || null;
  }

  /**
   * Authenticate a client
   * @param clientId Client identifier
   * @param userId User identifier
   * @param metadata Optional metadata about the client
   * @returns Whether authentication was successful
   */
  public async authenticateClient(
    clientId: string,
    userId: string,
    metadata?: Record<string, unknown>,
  ): Promise<boolean> {
    const client = this.clients.get(clientId);
    if (!client) {
      this.logger.warn(`Cannot authenticate: Client not found: ${clientId}`);
      return false;
    }

    // Update client with user information
    client.userId = userId;
    client.authenticated = true;
    client.state = ClientState.AUTHORIZED;
    client.lastActivity = new Date();

    if (metadata) {
      client.metadata = { ...client.metadata, ...metadata };
    }

    // Add client to user connections
    let userClients = this.userConnections.get(userId);
    if (!userClients) {
      userClients = new Set();
      this.userConnections.set(userId, userClients);
    }
    userClients.add(clientId);

    // Set initial presence if not already set
    if (!this.userPresence.has(userId)) {
      await this.setPresence(userId, "online");
    }

    // Notify the client of successful auth
    await this.sendToClient(clientId, "auth_result", {
      success: true,
      userId,
    });

    this.logger.debug(`Client ${clientId} authenticated as user ${userId}`);
    return true;
  }

  /**
   * Disconnect a specific client
   * @param clientId Client identifier
   * @param reason Reason for disconnection
   */
  public disconnectClient(clientId: string, reason?: string): void {
    const client = this.clients.get(clientId);
    if (!client) {
      return;
    }

    // Send disconnect message if possible
    try {
      this.sendMessage(client.ws, {
        type: "system",
        eventType: "disconnect",
        data: { reason },
      });

      // Close the WebSocket connection
      client.ws.close();
    } catch (_error) {
      // Ignore errors during disconnect
    }

    // Clean up client resources
    this.handleClientDisconnect(clientId);

    this.logger.debug(
      `Disconnected client ${clientId}: ${reason || "No reason provided"}`,
    );
  }

  /**
   * Get connection statistics
   * @returns Connection statistics
   */
  public getStats(): {
    totalConnections: number;
    authenticatedConnections: number;
    channelCounts: Record<string, number>;
    messagesPerSecond: number;
    peakConnections: number;
  } {
    // Calculate messages per second
    const now = Date.now();
    const elapsed = (now - this.messageCountStartTime) / 1000; // in seconds
    const messagesPerSecond = elapsed > 0 ? this.messageCount / elapsed : 0;

    // If more than a minute has passed, reset the counter
    if (elapsed > 60) {
      this.messageCount = 0;
      this.messageCountStartTime = now;
    }

    // Count authenticated connections
    let authenticatedCount = 0;
    for (const client of this.clients.values()) {
      if (client.authenticated) {
        authenticatedCount++;
      }
    }

    // Get channel subscription counts
    const channelCounts: Record<string, number> = {};
    for (const [channel, subscribers] of this.channels.entries()) {
      channelCounts[channel] = subscribers.size;
    }

    return {
      totalConnections: this.clients.size,
      authenticatedConnections: authenticatedCount,
      channelCounts,
      messagesPerSecond,
      peakConnections: this.peakConnections,
    };
  }

  /**
   * Track peak connection count
   */
  private updatePeakConnections(): void {
    if (this.clients.size > this.peakConnections) {
      this.peakConnections = this.clients.size;
    }
  }
}


// ---------------------- infrastructure\pubsub\WebSocketTypes.ts (8 lines) ----------------------

export interface WebSocketMessage {
  type: string;
  eventType?: string;
  channel?: string;
  data?: unknown;
  messageId?: string;
  error?: string;
}


// ---------------------- infrastructure\pubsub\index.ts (2 lines) ----------------------

export * from "./IWebSocketService";
export * from "./WebSocketService";


// ---------------------- infrastructure\server\ServerManager.ts (573 lines) ----------------------

import http from "http";
import path from "path";

import express, { Express, Request, Response, NextFunction } from "express";
import helmet from "helmet";
import { Container } from "inversify";
import { WebSocketServer } from "ws";

import { ICacheService } from "@/server/infrastructure/cache";
import { ConfigService } from "@/server/infrastructure/config";
import { IDatabaseServer } from "@/server/infrastructure/database";
import { TYPES } from "@/server/infrastructure/di";
import { IErrorHandler } from "@/server/infrastructure/errors";
import { IJobService } from "@/server/infrastructure/jobs";
import { ILoggerService } from "@/server/infrastructure/logging";
import { ServerLogger } from "@/server/infrastructure/logging/ServerLogger";
import { IStorageService } from "@/server/infrastructure/storage";

// Service interfaces used for type assertions
interface DatabaseService {
  isConnected?: () => boolean;
  getStats?: () => { activeCount?: number };
}

interface CacheService {
  isConnected?: () => boolean;
  getStats?: () => { hits?: number };
}

interface WebSocketService {
  clients?: { size: number };
}

interface ConfigObject {
  get: (key: string) => unknown;
  storagePath?: string;
}

/**
 * Server environment configuration
 */
export interface ServerConfig {
  port: number;
  host: string;
  isProduction: boolean;
  storagePath: string;
}

/**
 * ServerManager handles server initialization, port configuration, and connection setup
 */
export class ServerManager {
  private app: Express;
  private server: http.Server;
  private wss: WebSocketServer;
  private port: number;
  private logger: ILoggerService;
  private serverLogger: ServerLogger;
  private container: Container;
  private services: {
    configService: ConfigService | null;
    databaseService: IDatabaseServer | null;
    cacheService: ICacheService | null;
    storageService: IStorageService | null;
    errorHandler: IErrorHandler | null;
    jobService: IJobService | null;
    validationService: unknown;
    businessServices: Record<string, unknown>;
    infrastructureServices: Record<string, unknown>;
  };

  constructor(logger: ILoggerService, container: Container) {
    this.logger = logger;
    this.container = container;
    this.serverLogger = new ServerLogger(logger);
    this.app = express();
    this.server = http.createServer(this.app);
    this.wss = new WebSocketServer({ server: this.server });
    this.port = 0; // Will be set during initialization

    // Initialize empty services object
    this.services = {
      configService: null as ConfigService | null,
      databaseService: null as IDatabaseServer | null,
      cacheService: null as ICacheService | null,
      storageService: null as IStorageService | null,
      errorHandler: null as IErrorHandler | null,
      jobService: null as IJobService | null,
      validationService: null,
      businessServices: {},
      infrastructureServices: {},
    };
  }

  /**
   * Load all required services from the DI container
   */
  async loadServices(): Promise<void> {
    this.logger.info("Loading services from container");

    // Load core infrastructure services
    this.services.configService = this.container.get(TYPES.ConfigService);
    this.services.databaseService = this.container.get(TYPES.DatabaseService);
    this.services.cacheService = this.container.get(TYPES.CacheService);
    this.services.storageService = this.container.get(TYPES.StorageService);
    this.services.errorHandler = this.container.get(TYPES.ErrorHandler);
    this.services.jobService = this.container.get(TYPES.JobService);

    // Load optional validation service
    this.services.validationService = this.container.isBound(
      TYPES.ValidationService,
    )
      ? this.container.get(TYPES.ValidationService)
      : null;

    // Load business services
    const businessServices: Record<string, unknown> = {};

    try {
      businessServices.metricsService = this.container.isBound(
        TYPES.MetricsService,
      )
        ? this.container.get(TYPES.MetricsService)
        : null;

      businessServices.emailService = this.container.isBound(TYPES.EmailService)
        ? this.container.get(TYPES.EmailService)
        : null;

      businessServices.tokenService = this.container.isBound(TYPES.TokenService)
        ? this.container.get(TYPES.TokenService)
        : null;

      businessServices.encryptionService = this.container.isBound(
        TYPES.EncryptionService,
      )
        ? this.container.get(TYPES.EncryptionService)
        : null;

      businessServices.sessionService = this.container.isBound(
        TYPES.SessionService,
      )
        ? this.container.get(TYPES.SessionService)
        : null;

      businessServices.messagingService = this.container.isBound(
        TYPES.MessagingService,
      )
        ? this.container.get(TYPES.MessagingService)
        : null;
    } catch (err) {
      this.logger.warn("Some optional business services are not available", {
        error: err instanceof Error ? err.message : String(err),
      });
    }

    this.services.businessServices = businessServices;

    // Load additional infrastructure services
    const infrastructureServices: Record<string, unknown> = {
      logger: this.logger,
      databaseService: this.services.databaseService,
      cacheService: this.services.cacheService,
      storageService: this.services.storageService,
      jobService: this.services.jobService,
      errorHandler: this.services.errorHandler,
      validationService: this.services.validationService,
      wss: this.wss,
      config: this.services.configService,
    };

    try {
      infrastructureServices.pubSubService = this.container.isBound(
        TYPES["PubSubService" as keyof typeof TYPES] || Symbol("PubSubService"),
      )
        ? this.container.get(
            TYPES["PubSubService" as keyof typeof TYPES] ||
              Symbol("PubSubService"),
          )
        : null;
      if (infrastructureServices.pubSubService) {
        this.logger.info("PubSub service loaded");
        this.logger.info("PubSub service type:", {
          type: infrastructureServices.pubSubService.constructor.name,
        });
      } else {
        this.logger.warn("PubSub service not found in container");
      }

      infrastructureServices.imageProcessor = this.container.isBound(
        TYPES["ImageProcessor" as keyof typeof TYPES] ||
          Symbol("ImageProcessor"),
      )
        ? this.container.get(
            TYPES["ImageProcessor" as keyof typeof TYPES] ||
              Symbol("ImageProcessor"),
          )
        : null;
      if (infrastructureServices.imageProcessor) {
        this.logger.info("Image processor loaded");
        this.logger.info("Image processor type:", {
          type: infrastructureServices.imageProcessor.constructor.name,
        });
      } else {
        this.logger.warn("Image processor not found in container");
      }

      infrastructureServices.mediaProcessor = this.container.isBound(
        TYPES["MediaProcessor" as keyof typeof TYPES] ||
          Symbol("MediaProcessor"),
      )
        ? this.container.get(
            TYPES["MediaProcessor" as keyof typeof TYPES] ||
              Symbol("MediaProcessor"),
          )
        : null;
      if (infrastructureServices.mediaProcessor) {
        this.logger.info("Media processor loaded");
        this.logger.info("Media processor type:", {
          type: infrastructureServices.mediaProcessor.constructor.name,
        });
      } else {
        this.logger.warn("Media processor not found in container");
      }

      infrastructureServices.streamProcessor = this.container.isBound(
        TYPES["StreamProcessor" as keyof typeof TYPES] ||
          Symbol("StreamProcessor"),
      )
        ? this.container.get(
            TYPES["StreamProcessor" as keyof typeof TYPES] ||
              Symbol("StreamProcessor"),
          )
        : null;
      if (infrastructureServices.streamProcessor) {
        this.logger.info("Stream processor loaded");
        this.logger.info("Stream processor type:", {
          type: infrastructureServices.streamProcessor.constructor.name,
        });
      } else {
        this.logger.warn("Stream processor not found in container");
      }

      infrastructureServices.storageProvider = this.container.isBound(
        TYPES["StorageProvider" as keyof typeof TYPES] ||
          Symbol("StorageProvider"),
      )
        ? this.container.get(
            TYPES["StorageProvider" as keyof typeof TYPES] ||
              Symbol("StorageProvider"),
          )
        : null;
      if (infrastructureServices.storageProvider) {
        this.logger.info("Storage provider loaded");
        this.logger.info("Storage provider type:", {
          type: infrastructureServices.storageProvider.constructor.name,
        });
      } else {
        this.logger.warn("Storage provider not found in container");
      }
    } catch (err) {
      this.logger.warn(
        "Some additional infrastructure services are not available",
        {
          error: err instanceof Error ? err.message : String(err),
        },
      );
    }

    this.services.infrastructureServices = infrastructureServices;
  }

  /**
   * Configure the Express application with middleware and routes
   */
  configureApp(config: ServerConfig): void {
    const { isProduction, storagePath } = config;

    // Apply production settings if needed
    if (isProduction) {
      // Basic server hardening settings including CORS
      const helmetMiddleware = helmet() as unknown as NextFunction;
      this.app.use(helmetMiddleware);
    }

    // Request logging
    this.app.use((req: Request, res: Response, next: NextFunction) => {
      const start = Date.now();
      res.on("finish", () => {
        const duration = Date.now() - start;
        this.logger.info(
          `${req.method} ${req.url} ${res.statusCode} ${duration}ms`,
        );
      });
      next();
    });

    // Register file server for uploads
    const uploadsPath = path.resolve(storagePath);
    this.logger.info(`Serving static files from: ${uploadsPath}`);
    this.app.use("/uploads", express.static(uploadsPath));

    // Register error handling middleware
    this.app.use(
      (err: Error, req: Request, res: Response, _next: NextFunction) => {
        return this.services.errorHandler!.handleError(err, req, res);
      },
    );

    // Add more middleware and routes as needed
  }

  /**
   * Initialize all services
   */
  async initializeServices(): Promise<void> {
    this.logger.info("Initializing core infrastructure services");

    // Initialize database
    this.logger.info("Initializing database connection...");
    await this.services.databaseService!.initialize();
    this.logger.info("Database connection initialized successfully");

    // Log database configuration for debugging
    if (this.services.configService) {
      const dbHost = this.services.configService.getString(
        "DB_HOST",
        "localhost",
      );
      const dbPort = this.services.configService.getNumber("DB_PORT", 5432);
      const dbName = this.services.configService.getString(
        "DB_NAME",
        "abe_stack",
      );
      const dbUser = this.services.configService.getString(
        "DB_USER",
        "postgres",
      );

      this.logger.info("Database configuration for status display:", {
        host: dbHost,
        port: dbPort,
        database: dbName,
        user: dbUser,
      });
    }

    // Initialize cache
    this.logger.info("Initializing cache service...");
    await this.services.cacheService!.initialize();
    this.logger.info("Cache service initialized successfully");

    // Initialize storage
    this.logger.info("Initializing storage service...");
    await (
      this.services.storageService as unknown as { initialize(): Promise<void> }
    ).initialize();
    this.logger.info("Storage service initialized successfully");

    // Initialize jobs
    this.logger.info("Initializing job service...");
    await this.services.jobService!.initialize();
    this.logger.info("Job service initialized successfully");

    // Initialize optional services
    if (this.services.validationService) {
      this.logger.info("Initializing validation service...");
      await (
        this.services.validationService as unknown as {
          initialize(): Promise<void>;
        }
      ).initialize();
      this.logger.info("Validation service initialized successfully");
    }
  }

  /**
   * Find an available port to use
   */
  async findAvailablePort(preferredPort: number): Promise<number> {
    const isPortAvailable = (port: number): Promise<boolean> => {
      return new Promise((resolve) => {
        const tempServer = http.createServer();
        tempServer.once("error", () => {
          resolve(false);
        });
        tempServer.once("listening", () => {
          tempServer.close(() => resolve(true));
        });
        tempServer.listen(port);
      });
    };

    let port = preferredPort;
    let isAvailable = await isPortAvailable(port);

    // Try up to 10 ports after the preferred port
    while (!isAvailable && port < preferredPort + 10) {
      console.log(`Port ${port} is in use, trying ${port + 1}...`);
      port++;
      isAvailable = await isPortAvailable(port);
    }

    if (!isAvailable) {
      throw new Error(
        `Could not find an available port starting from ${preferredPort}`,
      );
    }

    console.log(`Found available port: ${port}`);
    return port;
  }

  /**
   * Start the server on the configured port
   */
  async startServer(config: ServerConfig): Promise<number> {
    try {
      // Find an available port
      this.port = await this.findAvailablePort(config.port);

      // Start listening
      return new Promise((resolve) => {
        this.server.listen(this.port, () => {
          this.logger.info(`Server listening on port ${this.port}`);
          resolve(this.port);
        });
      });
    } catch (error) {
      this.logger.error("Failed to start server", {
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Update storage provider URL to match actual port
   */
  updateStorageBaseUrl(): void {
    try {
      const storageUrl = `http://localhost:${this.port}/uploads`;
      if (
        this.services.storageService &&
        typeof (
          this.services.storageService as unknown as {
            updateBaseUrl(url: string): void;
          }
        ).updateBaseUrl === "function"
      ) {
        (
          this.services.storageService as unknown as {
            updateBaseUrl(url: string): void;
          }
        ).updateBaseUrl(storageUrl);
      }
    } catch (err) {
      this.logger.warn("Failed to update storage base URL", {
        error: err instanceof Error ? err.message : String(err),
      });
    }
  }

  /**
   * Display server status information
   */
  displayServerStatus(): void {
    try {
      this.serverLogger.displayServerStatus(
        this.port,
        this.services.configService as unknown as ConfigObject,
        this.services.infrastructureServices as unknown as {
          logger: ILoggerService;
          databaseService: DatabaseService;
          cacheService: CacheService;
          storageService: unknown;
          jobService: unknown;
          errorHandler: unknown;
          validationService: unknown;
          wss: WebSocketService;
          pubSubService: unknown;
          imageProcessor: unknown;
          mediaProcessor: unknown;
          streamProcessor: unknown;
          storageProvider: unknown;
          config: ConfigObject;
        },
        this.services.businessServices as Record<string, unknown>,
      );
    } catch (err) {
      this.logger.error("Error during server status display", {
        error: err instanceof Error ? err.message : String(err),
      });
    }
  }

  /**
   * Initialize the server completely
   */
  async initialize(config: ServerConfig): Promise<void> {
    try {
      // 1. Load services from DI container
      await this.loadServices();

      // 2. Configure Express application
      this.configureApp(config);

      // 3. Initialize all services
      await this.initializeServices();

      // 4. Start the server
      await this.startServer(config);

      // 5. Update storage URL after port is known
      this.updateStorageBaseUrl();

      // 6. Display server status
      this.displayServerStatus();
    } catch (error) {
      this.logger.error("Failed to initialize server", {
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Set up graceful shutdown
   */
  setupGracefulShutdown(): void {
    const shutdown = async (signal: string): Promise<void> => {
      this.logger.info(`Received ${signal}. Starting graceful shutdown...`);

      // Close HTTP server first to stop accepting new connections
      this.server.close(() => {
        this.logger.info("HTTP server closed");
      });

      // Close WebSocket server
      this.wss.close(() => {
        this.logger.info("WebSocket server closed");
      });

      // Rest of your shutdown logic for each service...
      // For brevity, I've omitted the detailed shutdown code
    };

    // Register shutdown handlers
    process.on("SIGTERM", () => shutdown("SIGTERM"));
    process.on("SIGINT", () => shutdown("SIGINT"));
  }

  /**
   * Get the Express app instance
   */
  getApp(): Express {
    return this.app;
  }

  /**
   * Get the server instance
   */
  getServer(): http.Server {
    return this.server;
  }

  /**
   * Get the WebSocket server instance
   */
  getWebSocketServer(): WebSocketServer {
    return this.wss;
  }
}


// ---------------------- infrastructure\server\index.ts (2 lines) ----------------------

export { ServerManager } from "./ServerManager";
export type { ServerConfig } from "./ServerManager";


// ---------------------- infrastructure\storage\ContentTypes.ts (143 lines) ----------------------

// ContentTypes.ts
/**
 * Enumeration of common content type categories
 */
export enum ContentCategory {
  IMAGE = "image",
  VIDEO = "video",
  AUDIO = "audio",
  DOCUMENT = "document",
  ARCHIVE = "archive",
  OTHER = "other",
}

/**
 * Common image formats
 */
export enum ImageFormat {
  JPEG = "jpeg",
  PNG = "png",
  WEBP = "webp",
  GIF = "gif",
  AVIF = "avif",
  SVG = "svg+xml",
  ORIGINAL = "original",
}

/**
 * Common video formats
 */
export enum VideoFormat {
  MP4 = "mp4",
  WEBM = "webm",
  AVI = "avi",
  MOV = "quicktime",
  HLS = "hls",
  DASH = "dash",
  ORIGINAL = "original",
}

/**
 * Common audio formats
 */
export enum AudioFormat {
  MP3 = "mp3",
  WAV = "wav",
  OGG = "ogg",
  AAC = "aac",
  FLAC = "flac",
  ORIGINAL = "original",
}

/**
 * Map MIME types to their respective content categories
 * @param contentType Content type string
 * @returns Content category
 */
export function getContentCategory(contentType: string): ContentCategory {
  if (contentType.startsWith("image/")) {
    return ContentCategory.IMAGE;
  } else if (contentType.startsWith("video/")) {
    return ContentCategory.VIDEO;
  } else if (contentType.startsWith("audio/")) {
    return ContentCategory.AUDIO;
  } else if (
    contentType.startsWith("text/") ||
    contentType.startsWith("application/pdf") ||
    contentType.includes("document") ||
    contentType.includes("spreadsheet") ||
    contentType.includes("presentation")
  ) {
    return ContentCategory.DOCUMENT;
  } else if (
    contentType.includes("zip") ||
    contentType.includes("tar") ||
    contentType.includes("gzip") ||
    contentType.includes("compressed")
  ) {
    return ContentCategory.ARCHIVE;
  } else {
    return ContentCategory.OTHER;
  }
}

/**
 * Get MIME type from format
 * @param format Format string
 * @param contentCategory Content category
 * @returns MIME type
 */
export function getMimeType(
  format: string,
  contentCategory: ContentCategory,
): string {
  switch (contentCategory) {
    case ContentCategory.IMAGE:
      switch (format) {
        case ImageFormat.JPEG:
          return "image/jpeg";
        case ImageFormat.PNG:
          return "image/png";
        case ImageFormat.WEBP:
          return "image/webp";
        case ImageFormat.GIF:
          return "image/gif";
        case ImageFormat.AVIF:
          return "image/avif";
        case ImageFormat.SVG:
          return "image/svg+xml";
        default:
          return "image/jpeg";
      }
    case ContentCategory.VIDEO:
      switch (format) {
        case VideoFormat.MP4:
          return "video/mp4";
        case VideoFormat.WEBM:
          return "video/webm";
        case VideoFormat.AVI:
          return "video/x-msvideo";
        case VideoFormat.MOV:
          return "video/quicktime";
        default:
          return "video/mp4";
      }
    case ContentCategory.AUDIO:
      switch (format) {
        case AudioFormat.MP3:
          return "audio/mpeg";
        case AudioFormat.WAV:
          return "audio/wav";
        case AudioFormat.OGG:
          return "audio/ogg";
        case AudioFormat.AAC:
          return "audio/aac";
        case AudioFormat.FLAC:
          return "audio/flac";
        default:
          return "audio/mpeg";
      }
    default:
      return "application/octet-stream";
  }
}


// ---------------------- infrastructure\storage\FileUtils.ts (291 lines) ----------------------

// FileUtils.ts
import fs from "fs";
import path from "path";
import { Stream, Readable } from "stream";
import { pipeline } from "stream/promises";
import { promisify } from "util";

import { ILoggerService } from "@/server/infrastructure/logging";

// Promisify fs functions
const mkdir = promisify(fs.mkdir);
const access = promisify(fs.access);
const stat = promisify(fs.stat);
const readFile = promisify(fs.readFile);
const writeFile = promisify(fs.writeFile);
const readdir = promisify(fs.readdir);
const unlink = promisify(fs.unlink);

/**
 * Consolidated file utilities for storage operations
 */
export class FileUtils {
  private logger: ILoggerService;

  constructor(logger: ILoggerService) {
    this.logger = logger.createLogger("FileUtils");
  }

  /**
   * Ensure directory exists
   * @param dirPath Directory path
   */
  async ensureDirectory(dirPath: string): Promise<void> {
    await mkdir(dirPath, { recursive: true });
  }

  /**
   * Check if file exists
   * @param filePath File path
   */
  async fileExists(filePath: string): Promise<boolean> {
    try {
      await access(filePath, fs.constants.F_OK);
      return true;
    } catch (_error) {
      return false;
    }
  }

  /**
   * Get file stats
   * @param filePath File path
   */
  async getFileStats(filePath: string): Promise<fs.Stats> {
    return await stat(filePath);
  }

  /**
   * Read file as buffer
   * @param filePath File path
   */
  async readFile(filePath: string): Promise<Buffer> {
    return await readFile(filePath);
  }

  /**
   * Write file from buffer or stream
   * @param filePath File path
   * @param data File data
   * @param overwrite Whether to overwrite existing file
   */
  async writeFile(
    filePath: string,
    data: Buffer | Stream,
    overwrite = true,
  ): Promise<void> {
    // Create directory if needed
    const dirname = path.dirname(filePath);
    await this.ensureDirectory(dirname);

    // Check if we can overwrite
    if (!overwrite && (await this.fileExists(filePath))) {
      throw new Error(`File already exists: ${filePath}`);
    }

    try {
      if (Buffer.isBuffer(data)) {
        await writeFile(filePath, data);
      } else if ("pipe" in data) {
        const writeStream = fs.createWriteStream(filePath);
        await pipeline(data as Readable, writeStream);
      } else {
        throw new Error("Unsupported file data type");
      }
    } catch (error) {
      this.logger.error(`Error writing file: ${filePath}`, {
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Delete a file
   * @param filePath File path
   */
  async deleteFile(filePath: string): Promise<boolean> {
    try {
      if (!(await this.fileExists(filePath))) {
        return true; // File doesn't exist, consider it deleted
      }

      await unlink(filePath);
      return true;
    } catch (error) {
      this.logger.warn(`Failed to delete file ${filePath}`, {
        error: error instanceof Error ? error.message : String(error),
      });
      return false;
    }
  }

  /**
   * List files in a directory
   * @param directory Directory path
   * @param pattern Optional pattern to filter files
   */
  async listFiles(
    directory: string,
    pattern?: string | RegExp,
  ): Promise<string[]> {
    try {
      // Read directory contents
      const entries = await readdir(directory, { withFileTypes: true });

      // Filter for files only
      let files = entries
        .filter((entry) => entry.isFile())
        .map((entry) => path.join(directory, entry.name));

      // Apply pattern filtering if provided
      if (pattern) {
        const regex =
          pattern instanceof RegExp
            ? pattern
            : new RegExp(pattern.replace(/\*/g, ".*"));

        files = files.filter((file) => regex.test(path.basename(file)));
      }

      return files;
    } catch (error) {
      this.logger.error(`Error listing files in directory: ${directory}`, {
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Copy a file
   * @param sourcePath Source file path
   * @param targetPath Target file path
   */
  async copyFile(sourcePath: string, targetPath: string): Promise<boolean> {
    try {
      // Ensure source file exists
      if (!(await this.fileExists(sourcePath))) {
        throw new Error(`Source file does not exist: ${sourcePath}`);
      }

      // Create target directory if needed
      const targetDir = path.dirname(targetPath);
      await this.ensureDirectory(targetDir);

      // Copy the file
      const data = await this.readFile(sourcePath);
      await this.writeFile(targetPath, data, true);
      return true;
    } catch (error) {
      this.logger.warn(
        `Failed to copy file from ${sourcePath} to ${targetPath}`,
        {
          error: error instanceof Error ? error.message : String(error),
        },
      );
      return false;
    }
  }

  /**
   * Move a file
   * @param sourcePath Source file path
   * @param targetPath Target file path
   */
  async moveFile(sourcePath: string, targetPath: string): Promise<boolean> {
    try {
      // First copy the file
      const copied = await this.copyFile(sourcePath, targetPath);
      if (!copied) {
        return false;
      }

      // Then delete the source
      return await this.deleteFile(sourcePath);
    } catch (error) {
      this.logger.warn(
        `Failed to move file from ${sourcePath} to ${targetPath}`,
        {
          error: error instanceof Error ? error.message : String(error),
        },
      );
      return false;
    }
  }

  /**
   * Create a read stream
   * @param filePath File path
   * @param options Stream options
   */
  createReadStream(
    filePath: string,
    options?: { start?: number; end?: number; highWaterMark?: number },
  ): fs.ReadStream {
    return fs.createReadStream(filePath, options);
  }

  /**
   * Create a write stream
   * @param filePath File path
   * @param options Stream options
   */
  createWriteStream(
    filePath: string,
    options?: { highWaterMark?: number },
  ): fs.WriteStream {
    // Ensure directory exists
    const dirPath = path.dirname(filePath);
    if (!fs.existsSync(dirPath)) {
      fs.mkdirSync(dirPath, { recursive: true });
    }

    return fs.createWriteStream(filePath, options);
  }

  /**
   * Detect content type of a file
   * @param filePath File path
   */
  detectContentType(filePath: string): string {
    // Use a simple extension-based detection
    const extension = path.extname(filePath).toLowerCase();

    const contentTypes: Record<string, string> = {
      // Images
      ".jpg": "image/jpeg",
      ".jpeg": "image/jpeg",
      ".png": "image/png",
      ".gif": "image/gif",
      ".webp": "image/webp",
      ".svg": "image/svg+xml",
      ".avif": "image/avif",
      // Documents
      ".pdf": "application/pdf",
      ".txt": "text/plain",
      ".html": "text/html",
      ".css": "text/css",
      ".js": "application/javascript",
      ".json": "application/json",
      ".xml": "application/xml",
      // Audio
      ".mp3": "audio/mpeg",
      ".wav": "audio/wav",
      ".ogg": "audio/ogg",
      // Video
      ".mp4": "video/mp4",
      ".webm": "video/webm",
      ".avi": "video/x-msvideo",
      // Archives
      ".zip": "application/zip",
      ".gz": "application/gzip",
      // Others
      ".doc": "application/msword",
      ".docx":
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    };

    return contentTypes[extension] || "application/octet-stream";
  }
}


// ---------------------- infrastructure\storage\IStorageProvider.ts (108 lines) ----------------------

// StorageProvider.ts
import { ReadStream } from "fs";

import {
  FileMetadata,
  StorageSaveOptions,
  FileSaveResult,
  FileData,
  StreamOptions,
} from "@/server/infrastructure/storage";

/**
 * Interface for storage providers
 */
export interface IStorageProvider {
  /**
   * Initialize the storage provider
   */
  initialize(): Promise<void>;

  /**
   * Shutdown the storage provider
   */
  shutdown(): Promise<void>;

  /**
   * Update the base URL (useful when port changes)
   * @param baseUrl New base URL
   */
  updateBaseUrl(baseUrl: string): void;

  /**
   * Create a directory
   * @param path Directory path
   */
  createDirectory(path: string): Promise<void>;

  /**
   * Save a file
   * @param filePath File path
   * @param data File data
   * @param options Storage options
   */
  saveFile(
    filePath: string,
    data: FileData,
    options?: StorageSaveOptions,
  ): Promise<FileSaveResult>;

  /**
   * Get a file as buffer
   * @param filePath File path
   */
  getFile(filePath: string): Promise<Buffer>;

  /**
   * Get a file as stream
   * @param filePath File path
   * @param options Stream options
   */
  getFileStream(filePath: string, options?: StreamOptions): Promise<ReadStream>;

  /**
   * Get file metadata
   * @param filePath File path
   */
  getFileMetadata(filePath: string): Promise<FileMetadata>;

  /**
   * Delete a file
   * @param filePath File path
   */
  deleteFile(filePath: string): Promise<boolean>;

  /**
   * Check if file exists
   * @param filePath File path
   */
  fileExists(filePath: string): Promise<boolean>;

  /**
   * List files in a directory
   * @param directory Directory path
   * @param pattern Optional file pattern
   */
  listFiles(directory: string, pattern?: string | RegExp): Promise<string[]>;

  /**
   * Copy a file
   * @param sourcePath Source file path
   * @param targetPath Target file path
   */
  copyFile(sourcePath: string, targetPath: string): Promise<boolean>;

  /**
   * Move a file
   * @param sourcePath Source file path
   * @param targetPath Target file path
   */
  moveFile(sourcePath: string, targetPath: string): Promise<boolean>;

  /**
   * Get a URL for a file
   * @param filePath File path
   * @param expiresIn Expiration time in seconds
   */
  getFileUrl(filePath: string, expiresIn?: number): Promise<string>;
}


// ---------------------- infrastructure\storage\LocalStorageProvider.ts (558 lines) ----------------------

// LocalStorageProvider.ts
import fs from "fs";
import path from "path";
import { Readable } from "stream";

import { injectable, inject } from "inversify";
import { v4 as uuidv4 } from "uuid";

import { StorageConfigProvider } from "@/server/infrastructure/config";
import { TYPES } from "@/server/infrastructure/di/types";
import type { ILoggerService } from "@/server/infrastructure/logging";
import { StreamProcessor } from "@/server/infrastructure/processor/StreamProcessor";

import { FileUtils } from "./FileUtils";
import { IStorageProvider } from "./IStorageProvider";
import { MediaProcessor } from "./processor/MediaProcessor";

import type {
  StreamOptions,
  StorageSaveOptions,
  FileSaveResult,
  FileData,
  FileMetadata,
} from "./StorageTypes";
import type { ReadStream } from "fs";

/**
 * Storage configuration
 */
export interface StorageConfig {
  /**
   * Base path for storage
   */
  basePath: string;

  /**
   * Base URL for public file access
   */
  baseUrl?: string;

  /**
   * Temporary directory
   */
  tempDir: string;
}

/**
 * Local filesystem storage provider
 */
@injectable()
export class LocalStorageProvider implements IStorageProvider {
  private logger: ILoggerService;
  private fileUtils: FileUtils;
  private mediaProcessor: MediaProcessor;
  private basePath: string;
  private baseUrl: string;
  private tempDir: string;

  /**
   * Helper method to normalize path for display purposes
   * @param pathToNormalize Path to be normalized with forward slashes
   */
  private normalizePath(pathToNormalize: string): string {
    return pathToNormalize.replace(/\\/g, "/");
  }

  /**
   * Create a new LocalStorageProvider
   * @param logger Logger service
   * @param config Storage configuration
   */
  constructor(
    @inject(TYPES.LoggerService) logger: ILoggerService,
    @inject(TYPES.StorageConfig) configProvider: StorageConfigProvider,
  ) {
    this.logger = logger.createLogger("LocalStorageProvider");

    // Get full config from provider
    const config = configProvider.getConfig();

    // Validate required paths
    if (!config.basePath) {
      throw new Error("Storage basePath is required");
    }

    if (!config.tempDir) {
      throw new Error("Storage tempDir is required");
    }

    this.basePath = config.basePath;
    this.baseUrl = config.baseUrl || "";
    this.tempDir = config.tempDir;

    // Log configuration with normalized paths for display
    this.logger.info("LocalStorageProvider configuration", {
      basePath: this.normalizePath(this.basePath),
      tempDir: this.normalizePath(this.tempDir),
      baseUrl: this.baseUrl,
    });

    // Initialize utilities
    this.fileUtils = new FileUtils(logger);
    this.mediaProcessor = new MediaProcessor(
      logger,
      this.fileUtils,
      this.baseUrl,
    );

    // Ensure base directories exist
    this.ensureDirectories();
  }

  /**
   * Ensure required directories exist
   */
  private ensureDirectories(): void {
    try {
      // Check if we should disable real storage (for testing)
      if (process.env.DISABLE_REAL_STORAGE === "true") {
        this.logger.debug("Storage directory creation disabled (test mode)");
        return;
      }

      // Check if we're in test environment (NODE_ENV=test)
      if (process.env.NODE_ENV === "test") {
        this.logger.debug("Test environment detected, using mock directories");
        return;
      }

      // Log directory creation with normalized paths
      this.logger.debug("Ensuring storage directories exist", {
        basePath: this.normalizePath(this.basePath),
        tempDir: this.normalizePath(this.tempDir),
      });

      // Synchronously create these on initialization
      if (!fs.existsSync(this.basePath)) {
        this.logger.info(
          `Creating base storage directory: ${this.normalizePath(this.basePath)}`,
        );
        fs.mkdirSync(this.basePath, { recursive: true });
      }

      if (!fs.existsSync(this.tempDir)) {
        this.logger.info(
          `Creating temporary storage directory: ${this.normalizePath(this.tempDir)}`,
        );
        fs.mkdirSync(this.tempDir, { recursive: true });
      }

      this.logger.info("Storage directories verified and created if needed");
    } catch (error) {
      this.logger.error("Failed to create storage directories", {
        error: error instanceof Error ? error.message : String(error),
        basePath: this.normalizePath(this.basePath),
        tempDir: this.normalizePath(this.tempDir),
      });
      throw new Error(
        `Failed to create storage directories: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Initialize the storage provider
   */
  async initialize(): Promise<void> {
    this.logger.info("LocalStorageProvider initialized", {
      basePath: this.normalizePath(this.basePath),
      tempDir: this.normalizePath(this.tempDir),
      baseUrl: this.baseUrl,
    });

    return Promise.resolve();
  }

  /**
   * Shutdown the storage provider
   */
  async shutdown(): Promise<void> {
    return Promise.resolve();
  }

  /**
   * Get absolute path from relative path
   * @param filePath Relative file path
   */
  private getAbsolutePath(filePath: string): string {
    return path.join(this.basePath, filePath);
  }

  /**
   * Save a file
   * @param filePath File path
   * @param data File data
   * @param options Storage options
   */
  async saveFile(
    filePath: string,
    data: FileData,
    options?: StorageSaveOptions,
  ): Promise<FileSaveResult> {
    const absolutePath = this.getAbsolutePath(filePath);
    const tempFilePath = `${this.tempDir}/${uuidv4()}`;

    try {
      // First save to temp file
      if (Buffer.isBuffer(data)) {
        await this.fileUtils.writeFile(tempFilePath, data);
      } else {
        const writeStream = this.fileUtils.createWriteStream(tempFilePath);
        await StreamProcessor.processStream(data as Readable, writeStream);
      }

      // Detect content type
      const contentType =
        options?.contentType || this.fileUtils.detectContentType(tempFilePath);

      // Create output directory
      const outputDir = path.dirname(absolutePath);
      await this.fileUtils.ensureDirectory(outputDir);

      // Check if we need media processing
      if (
        contentType.startsWith("image/") ||
        contentType.startsWith("video/") ||
        contentType.startsWith("audio/")
      ) {
        // Process as media
        const mediaOptions = {
          // Copy any relevant options from StorageSaveOptions
          width: options?.width,
          height: options?.height,
          quality: options?.quality,
          format: options?.format,
          targetPath: absolutePath,
        };

        const result = await this.mediaProcessor.processMedia(
          tempFilePath,
          mediaOptions,
        );

        // Delete temp file
        await this.fileUtils.deleteFile(tempFilePath);

        // Create file metadata
        const stats = await this.fileUtils.getFileStats(result.path);

        return {
          path: filePath,
          url: result.url,
          metadata: {
            contentType: result.contentType,
            size: stats.size,
            lastModified: stats.mtime,
            etag: `"${uuidv4()}"`,
            dimensions: result.dimensions,
            custom: options?.metadata,
          },
        };
      } else {
        // Just move the file
        await this.fileUtils.moveFile(tempFilePath, absolutePath);

        // Get file stats
        const stats = await this.fileUtils.getFileStats(absolutePath);

        // Return basic result
        return {
          path: filePath,
          url: await this.getFileUrl(filePath),
          metadata: {
            contentType,
            size: stats.size,
            lastModified: stats.mtime,
            etag: `"${uuidv4()}"`,
            custom: options?.metadata,
          },
        };
      }
    } catch (error) {
      // Clean up temp file
      await this.fileUtils.deleteFile(tempFilePath);

      this.logger.error(`Error saving file: ${filePath}`, {
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Get a file as buffer
   * @param filePath File path
   */
  async getFile(filePath: string): Promise<Buffer> {
    const absolutePath = this.getAbsolutePath(filePath);

    try {
      // Check if file exists
      if (!(await this.fileUtils.fileExists(absolutePath))) {
        throw new Error(`File not found: ${filePath}`);
      }

      // Read file
      return await this.fileUtils.readFile(absolutePath);
    } catch (error) {
      this.logger.error(`Error getting file: ${filePath}`, {
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Get a file as stream
   * @param filePath File path
   * @param options Stream options
   */
  async getFileStream(
    filePath: string,
    options?: StreamOptions,
  ): Promise<ReadStream> {
    const absolutePath = this.getAbsolutePath(filePath);

    try {
      // Check if file exists
      if (!(await this.fileUtils.fileExists(absolutePath))) {
        throw new Error(`File not found: ${filePath}`);
      }

      // Create stream
      return this.fileUtils.createReadStream(absolutePath, options);
    } catch (error) {
      this.logger.error(`Error creating file stream: ${filePath}`, {
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Get file metadata
   * @param filePath File path
   */
  async getFileMetadata(filePath: string): Promise<FileMetadata> {
    const absolutePath = this.getAbsolutePath(filePath);

    try {
      // Check if file exists
      if (!(await this.fileUtils.fileExists(absolutePath))) {
        throw new Error(`File not found: ${filePath}`);
      }

      // Get file stats
      const stats = await this.fileUtils.getFileStats(absolutePath);

      // Detect content type
      const contentType = this.fileUtils.detectContentType(absolutePath);

      // Create basic metadata
      const metadata: FileMetadata = {
        contentType,
        size: stats.size,
        lastModified: stats.mtime,
        etag: `"${stats.mtime.getTime().toString(16)}"`,
      };

      // If it's an image, get dimensions
      if (contentType.startsWith("image/")) {
        try {
          // Process the image to get metadata
          const tempImagePath = `${this.tempDir}/${uuidv4()}_temp.jpg`;
          const processResult = await this.mediaProcessor.processMedia(
            absolutePath,
            {
              targetPath: tempImagePath,
            },
          );

          // Fix the dimensions extraction
          if (processResult.dimensions) {
            metadata.dimensions = processResult.dimensions;
          }
        } catch (error) {
          this.logger.warn(`Could not get image dimensions for ${filePath}`, {
            error: error instanceof Error ? error.message : String(error),
          });
        }
      }

      return metadata;
    } catch (error) {
      this.logger.error(`Error getting file metadata: ${filePath}`, {
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Delete a file
   * @param filePath File path
   */
  async deleteFile(filePath: string): Promise<boolean> {
    const absolutePath = this.getAbsolutePath(filePath);

    try {
      return await this.fileUtils.deleteFile(absolutePath);
    } catch (error) {
      this.logger.error(`Error deleting file: ${filePath}`, {
        error: error instanceof Error ? error.message : String(error),
      });
      return false;
    }
  }

  /**
   * Check if file exists
   * @param filePath File path
   */
  async fileExists(filePath: string): Promise<boolean> {
    const absolutePath = this.getAbsolutePath(filePath);
    return await this.fileUtils.fileExists(absolutePath);
  }

  /**
   * List files in a directory
   * @param directory Directory path
   * @param pattern Optional file pattern
   */
  async listFiles(
    directory: string,
    pattern?: string | RegExp,
  ): Promise<string[]> {
    const absolutePath = this.getAbsolutePath(directory);

    try {
      const files = await this.fileUtils.listFiles(absolutePath, pattern);

      // Convert absolute paths back to relative paths
      return files.map((file) => path.relative(this.basePath, file));
    } catch (error) {
      this.logger.error(`Error listing files in directory: ${directory}`, {
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Copy a file
   * @param sourcePath Source file path
   * @param targetPath Target file path
   */
  async copyFile(sourcePath: string, targetPath: string): Promise<boolean> {
    const absoluteSourcePath = this.getAbsolutePath(sourcePath);
    const absoluteTargetPath = this.getAbsolutePath(targetPath);

    try {
      return await this.fileUtils.copyFile(
        absoluteSourcePath,
        absoluteTargetPath,
      );
    } catch (error) {
      this.logger.error(
        `Error copying file from ${sourcePath} to ${targetPath}`,
        {
          error: error instanceof Error ? error.message : String(error),
        },
      );
      return false;
    }
  }

  /**
   * Move a file
   * @param sourcePath Source file path
   * @param targetPath Target file path
   */
  async moveFile(sourcePath: string, targetPath: string): Promise<boolean> {
    const absoluteSourcePath = this.getAbsolutePath(sourcePath);
    const absoluteTargetPath = this.getAbsolutePath(targetPath);

    try {
      return await this.fileUtils.moveFile(
        absoluteSourcePath,
        absoluteTargetPath,
      );
    } catch (error) {
      this.logger.error(
        `Error moving file from ${sourcePath} to ${targetPath}`,
        {
          error: error instanceof Error ? error.message : String(error),
        },
      );
      return false;
    }
  }

  /**
   * Get a URL for a file
   * @param filePath File path
   * @param expiresIn Expiration time in seconds
   */
  async getFileUrl(filePath: string, expiresIn?: number): Promise<string> {
    // Normalize path for URL
    const normalizedPath = filePath.replace(/\\/g, "/");

    // Remove any leading slash to avoid double slashes
    const cleanPath = normalizedPath.startsWith("/")
      ? normalizedPath.substring(1)
      : normalizedPath;

    let url = this.baseUrl ? `${this.baseUrl}/${cleanPath}` : cleanPath;

    // Add expiration if needed
    if (expiresIn) {
      const expiresAt = Math.floor(Date.now() / 1000) + expiresIn;
      url += `?expires=${expiresAt}`;
    }

    return url;
  }

  /**
   * Create a directory
   * @param path Directory path
   */
  async createDirectory(path: string): Promise<void> {
    try {
      await fs.promises.mkdir(path, { recursive: true });
    } catch (error) {
      this.logger.error(`Failed to create directory: ${path}`, { error });
      throw error;
    }
  }

  /**
   * Update the base URL (useful when port changes)
   * @param baseUrl New base URL
   */
  updateBaseUrl(baseUrl: string): void {
    if (baseUrl) {
      this.baseUrl = baseUrl;
      this.logger.info("Updated storage base URL", { baseUrl: this.baseUrl });

      // Update the media processor's base URL as well
      if (
        this.mediaProcessor &&
        typeof this.mediaProcessor.updateBaseUrl === "function"
      ) {
        this.mediaProcessor.updateBaseUrl(baseUrl);
      }
    }
  }
}


// ---------------------- infrastructure\storage\StorageService.ts (268 lines) ----------------------

// StorageService.ts
import { ReadStream } from "fs";

import { injectable, inject } from "inversify";

import { TYPES } from "@/server/infrastructure/di/types";
import type { ILoggerService } from "@/server/infrastructure/logging";
import type { IStorageProvider } from "@/server/infrastructure/storage/IStorageProvider";
import {
  FileMetadata,
  StorageSaveOptions,
  FileSaveResult,
  FileData,
  StreamOptions,
} from "@/server/infrastructure/storage/StorageTypes";

/**
 * Interface for storage service
 */
export interface IStorageService {
  /**
   * Create a directory
   * @param path Directory path
   */
  createDirectory(path: string): Promise<void>;

  /**
   * List files in a directory
   * @param directory Directory path
   * @param pattern Optional file pattern
   */
  listFiles(directory: string, pattern?: string): Promise<string[]>;

  /**
   * Save a file
   * @param path File path
   * @param data File data
   * @param options Storage options
   */
  saveFile(
    path: string,
    data: FileData,
    options?: StorageSaveOptions,
  ): Promise<FileSaveResult>;

  /**
   * Get a file as buffer
   * @param path File path
   */
  getFile(path: string): Promise<Buffer>;

  /**
   * Get a file as stream
   * @param path File path
   * @param options Stream options
   */
  getFileStream(path: string, options?: StreamOptions): Promise<ReadStream>;

  /**
   * Get file metadata
   * @param path File path
   */
  getFileMetadata(path: string): Promise<FileMetadata>;

  /**
   * Delete a file
   * @param path File path
   */
  deleteFile(path: string): Promise<boolean>;

  /**
   * Check if file exists
   * @param path File path
   */
  fileExists(path: string): Promise<boolean>;

  /**
   * Get URL for a file
   * @param path File path
   * @param expiresIn Expiration time in seconds
   */
  getFileUrl(path: string, expiresIn?: number): Promise<string>;
}

/**
 * Storage service implementation
 */
@injectable()
export class StorageService implements IStorageService {
  private logger: ILoggerService;
  private provider: IStorageProvider;

  /**
   * Create a new StorageService
   * @param logger Logger service
   * @param storageProvider Storage provider
   */
  constructor(
    @inject(TYPES.LoggerService) logger: ILoggerService,
    @inject(TYPES.StorageProvider) storageProvider: IStorageProvider,
  ) {
    this.logger = logger.createLogger("StorageService");
    this.provider = storageProvider;
  }

  /**
   * Initialize the storage service
   */
  async initialize(): Promise<void> {
    await this.provider.initialize();
    this.logger.info("Storage service initialized");
  }

  /**
   * Shutdown the storage service
   */
  async shutdown(): Promise<void> {
    await this.provider.shutdown();
    this.logger.info("Storage service shutdown");
  }

  /**
   * Create a directory
   * @param path Directory path
   */
  async createDirectory(path: string): Promise<void> {
    try {
      await this.provider.createDirectory(path);
    } catch (error) {
      this.logger.error(`Failed to create directory: ${path}`, {
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * List files in a directory
   * @param directory Directory path
   * @param pattern Optional file pattern
   */
  async listFiles(directory: string, pattern?: string): Promise<string[]> {
    try {
      return await this.provider.listFiles(directory, pattern);
    } catch (error) {
      this.logger.error(`Failed to list files: ${directory}`, {
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Save a file
   * @param path File path
   * @param data File data
   * @param options Storage options
   */
  async saveFile(
    path: string,
    data: FileData,
    options?: StorageSaveOptions,
  ): Promise<FileSaveResult> {
    try {
      return await this.provider.saveFile(path, data, options);
    } catch (error) {
      this.logger.error(`Failed to save file: ${path}`, {
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Get a file as buffer
   * @param path File path
   */
  async getFile(path: string): Promise<Buffer> {
    try {
      return await this.provider.getFile(path);
    } catch (error) {
      this.logger.error(`Failed to get file: ${path}`, {
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Get a file as stream
   * @param path File path
   * @param options Stream options
   */
  async getFileStream(
    path: string,
    options?: StreamOptions,
  ): Promise<ReadStream> {
    try {
      return await this.provider.getFileStream(path, options);
    } catch (error) {
      this.logger.error(`Failed to get file stream: ${path}`, {
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Get file metadata
   * @param path File path
   */
  async getFileMetadata(path: string): Promise<FileMetadata> {
    try {
      return await this.provider.getFileMetadata(path);
    } catch (error) {
      this.logger.error(`Failed to get file metadata: ${path}`, {
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Delete a file
   * @param path File path
   */
  async deleteFile(path: string): Promise<boolean> {
    try {
      return await this.provider.deleteFile(path);
    } catch (error) {
      this.logger.error(`Failed to delete file: ${path}`, {
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Check if file exists
   * @param path File path
   */
  async fileExists(path: string): Promise<boolean> {
    try {
      return await this.provider.fileExists(path);
    } catch (error) {
      this.logger.error(`Failed to check if file exists: ${path}`, {
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Get URL for a file
   * @param path File path
   * @param expiresIn Expiration time in seconds
   */
  async getFileUrl(path: string, expiresIn?: number): Promise<string> {
    try {
      return await this.provider.getFileUrl(path, expiresIn);
    } catch (error) {
      this.logger.error(`Failed to get file URL: ${path}`, {
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }
}


// ---------------------- infrastructure\storage\StorageTypes.ts (156 lines) ----------------------

// StorageTypes.ts
import { ReadStream } from "fs";
import { Stream } from "stream";

/**
 * File metadata
 */
export interface FileMetadata {
  /**
   * Content type
   */
  contentType: string;

  /**
   * File size in bytes
   */
  size: number;

  /**
   * Last modified date
   */
  lastModified: Date;

  /**
   * Entity tag for caching
   */
  etag?: string;

  /**
   * Media dimensions (for images and videos)
   */
  dimensions?: {
    width: number;
    height: number;
  };

  /**
   * Duration in seconds (for audio and video)
   */
  duration?: number;

  /**
   * Custom metadata
   */
  custom?: Record<string, string>;
}

/**
 * File save options
 */
export interface StorageSaveOptions {
  /**
   * Content type override
   */
  contentType?: string;

  /**
   * Whether to overwrite existing file
   */
  overwrite?: boolean;

  /**
   * Custom metadata
   */
  metadata?: Record<string, string>;

  /**
   * Stream options
   */
  stream?: StreamOptions;

  /**
   * Width for image/video processing
   */
  width?: number;

  /**
   * Height for image/video processing
   */
  height?: number;

  /**
   * Quality for image/video processing (1-100)
   */
  quality?: number;

  /**
   * Output format for media processing
   */
  format?: string;
}

/**
 * Stream options
 */
export interface StreamOptions {
  /**
   * Start byte position
   */
  start?: number;

  /**
   * End byte position
   */
  end?: number;

  /**
   * Buffer size in bytes
   */
  bufferSize?: number;

  /**
   * High water mark for stream
   */
  highWaterMark?: number;
}

/**
 * Result of a file save operation
 */
export interface FileSaveResult {
  /**
   * File path
   */
  path: string;

  /**
   * URL to access the file
   */
  url: string;

  /**
   * File metadata
   */
  metadata: FileMetadata;

  /**
   * Processing information (optional)
   */
  processing?: {
    originalSize?: number;
    processedSize?: number;
    transformations?: string[];
    thumbnail?: string;
  };
}

/**
 * Type for file data input
 */
export type FileData = Buffer | ReadStream | Stream;

/**
 * Type for file data output
 */
export type FileOutput = Buffer | ReadStream;


// ---------------------- infrastructure\storage\index.ts (26 lines) ----------------------

// index.ts - Export all storage components

// Core interfaces and types
export * from "./StorageTypes";
export * from "./IStorageProvider";
export * from "./StorageService";
export * from "./ContentTypes";

// Implementations
export { LocalStorageProvider } from "./LocalStorageProvider";
export type { StorageConfig } from "./LocalStorageProvider";
export { FileUtils } from "./FileUtils";
export { MediaProcessor } from "./processor/MediaProcessor";

// Note: These processors are exported for convenience but defined elsewhere
export { ImageProcessor } from "@/server/infrastructure/processor/ImageProcessor";
export type {
  ImageOptions,
  ImageMetadata,
} from "@/server/infrastructure/processor/ImageProcessor";
export type {
  MediaOptions,
  MediaProcessingResult,
} from "@/server/infrastructure/processor/MediaProcessor";
export { StreamProcessor } from "@/server/infrastructure/processor/StreamProcessor";
export type { StreamStats } from "@/server/infrastructure/processor/StreamProcessor";


// ---------------------- infrastructure\storage\processor\MediaProcessor.ts (141 lines) ----------------------

import { injectable, inject } from "inversify";

import { TYPES } from "@/server/infrastructure/di/types";
import type { ILoggerService } from "@/server/infrastructure/logging";

import type { FileUtils } from "../FileUtils";

/**
 * Media processor for handling image and video processing operations
 */
@injectable()
export class MediaProcessor {
  private logger: ILoggerService;

  constructor(
    @inject(TYPES.LoggerService) logger: ILoggerService,
    private fileUtils: FileUtils,
    private baseUrl: string,
  ) {
    this.logger = logger.createLogger("MediaProcessor");
  }

  /**
   * Process an image file (resize, optimize, etc.)
   * @param sourcePath Path to the source image
   * @param targetPath Path where processed image will be saved
   * @param options Processing options
   */
  async processImage(
    sourcePath: string,
    targetPath: string,
    options?: {
      width?: number;
      height?: number;
      quality?: number;
      format?: string;
    },
  ): Promise<void> {
    this.logger.info("Processing image", { sourcePath, targetPath, options });
    // Implementation would go here
  }

  /**
   * Create a thumbnail for an image or video
   * @param sourcePath Path to the source file
   * @param targetPath Path where thumbnail will be saved
   * @param options Thumbnail generation options
   */
  async createThumbnail(
    sourcePath: string,
    targetPath: string,
    options?: {
      width?: number;
      height?: number;
      quality?: number;
    },
  ): Promise<void> {
    this.logger.info("Creating thumbnail", { sourcePath, targetPath, options });
    // Implementation would go here
  }

  /**
   * Process a video file (transcode, optimize, etc.)
   * @param sourcePath Path to the source video
   * @param targetPath Path where processed video will be saved
   * @param options Processing options
   */
  async processVideo(
    sourcePath: string,
    targetPath: string,
    options?: {
      width?: number;
      height?: number;
      bitrate?: string;
      format?: string;
    },
  ): Promise<void> {
    this.logger.info("Processing video", { sourcePath, targetPath, options });
    // Implementation would go here
  }

  /**
   * Process any media file (detect type and apply appropriate processing)
   * @param sourcePath Path to the source file
   * @param options Processing options
   */
  async processMedia(
    sourcePath: string,
    options?: {
      width?: number;
      height?: number;
      quality?: number;
      format?: string;
      targetPath?: string;
    },
  ): Promise<{
    path: string;
    url: string;
    contentType: string;
    size: number;
    dimensions?: { width: number; height: number };
  }> {
    this.logger.info("Processing media", { sourcePath, options });

    // This is a stub implementation for testing
    const targetPath = options?.targetPath || `${sourcePath}.processed`;
    const contentType = await this.fileUtils.detectContentType(sourcePath);
    const isImage = contentType.startsWith("image/");

    if (isImage) {
      await this.processImage(sourcePath, targetPath, options);
    } else if (contentType.startsWith("video/")) {
      await this.processVideo(sourcePath, targetPath, options);
    }

    // Mock implementation for tests
    return {
      path: targetPath,
      url: `${this.baseUrl}/${targetPath.replace(/^\//, "")}`,
      contentType,
      size: 12345, // Mock file size
      dimensions:
        options?.width && options?.height
          ? { width: options.width, height: options.height }
          : undefined,
    };
  }

  /**
   * Update the base URL (useful when port changes)
   * @param baseUrl New base URL
   */
  updateBaseUrl(baseUrl: string): void {
    if (baseUrl) {
      this.baseUrl = baseUrl;
      this.logger.info("Updated media processor base URL", {
        baseUrl: this.baseUrl,
      });
    }
  }
}
