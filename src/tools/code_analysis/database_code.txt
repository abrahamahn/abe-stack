===========================================================
DATABASE LAYER CODE EXTRACTION
===========================================================

Total Files: 64
Total Lines: 19527

File Listing:
1. config.ts (253 lines)
2. index.ts (1 lines)
3. migrations\migrationConfig.ts (48 lines)
4. migrations\migrationManager.ts (400 lines)
5. models\BaseModel.ts (74 lines)
6. models\analytics\ActivityLog.ts (110 lines)
7. models\auth\PasswordResetToken.ts (160 lines)
8. models\auth\Permission.ts (110 lines)
9. models\auth\Role.ts (98 lines)
10. models\auth\RolePermission.ts (69 lines)
11. models\auth\Token.ts (138 lines)
12. models\auth\User.ts (217 lines)
13. models\auth\UserRole.ts (86 lines)
14. models\community\Group.ts (260 lines)
15. models\community\GroupMember.ts (192 lines)
16. models\discovery\SearchIndex.ts (445 lines)
17. models\index.ts (82 lines)
18. models\media\Media.ts (616 lines)
19. models\media\MediaCollection.ts (214 lines)
20. models\media\MediaTag.ts (167 lines)
21. models\messaging\Conversation.ts (417 lines)
22. models\messaging\Message.ts (319 lines)
23. models\moderation\ContentReport.ts (353 lines)
24. models\moderation\ModerationAction.ts (188 lines)
25. models\shared\EntityTypes.ts (23 lines)
26. models\social\Bookmark.ts (124 lines)
27. models\social\Comment.ts (120 lines)
28. models\social\CommentLike.ts (56 lines)
29. models\social\Follow.ts (68 lines)
30. models\social\Hashtag.ts (148 lines)
31. models\social\Like.ts (139 lines)
32. models\social\Notification.ts (161 lines)
33. models\social\Post.ts (560 lines)
34. repositories\BaseRepository.ts (591 lines)
35. repositories\analytics\ActivityLogRepository.ts (193 lines)
36. repositories\auth\PasswordResetTokenRepository.ts (216 lines)
37. repositories\auth\PermissionRepository.ts (140 lines)
38. repositories\auth\RolePermissionRepository.ts (193 lines)
39. repositories\auth\RoleRepository.ts (120 lines)
40. repositories\auth\TokenRepository.ts (186 lines)
41. repositories\auth\UserRepository.ts (262 lines)
42. repositories\auth\UserRoleRepository.ts (211 lines)
43. repositories\community\GroupMemberRepository.ts (642 lines)
44. repositories\community\GroupRepository.ts (370 lines)
45. repositories\discovery\SearchIndexRepository.ts (847 lines)
46. repositories\index.ts (93 lines)
47. repositories\media\MediaCollectionRepository.ts (622 lines)
48. repositories\media\MediaRepository.ts (709 lines)
49. repositories\media\MediaTagRepository.ts (607 lines)
50. repositories\messaging\ConversationRepository.ts (811 lines)
51. repositories\messaging\MessageRepository.ts (602 lines)
52. repositories\moderation\ContentReportRepository.ts (826 lines)
53. repositories\moderation\ModerationActionRepository.ts (734 lines)
54. repositories\notification\NotificationRepository.ts (298 lines)
55. repositories\social\BookmarkRepository.ts (336 lines)
56. repositories\social\CommentLikeRepository.ts (417 lines)
57. repositories\social\CommentRepository.ts (602 lines)
58. repositories\social\FollowRepository.ts (467 lines)
59. repositories\social\HashtagRepository.ts (465 lines)
60. repositories\social\LikeRepository.ts (472 lines)
61. repositories\social\NotificationRepository.ts (370 lines)
62. repositories\social\PostRepository.ts (434 lines)
63. transactions\transactionManager.ts (223 lines)
64. utils\typeGuards.ts (52 lines)


===========================================================
FILE 1: config.ts
===========================================================

// src/config/database.ts
import { EventEmitter } from "events";

import { Pool, PoolClient } from "pg";

import { env } from "../config/environment";
import { Logger } from "../services/LoggerService";

const logger = new Logger("DatabaseConnectionManager");
const MAX_RETRIES = 5;
const RETRY_INTERVAL = 5000; // 5 seconds
const HEALTH_CHECK_INTERVAL = 30000; // 30 seconds

export class DatabaseConnectionManager {
  private static instance: DatabaseConnectionManager;
  private static pool: Pool | null = null;
  private static connected: boolean = false;
  private static healthCheckInterval: NodeJS.Timeout | null = null;

  private constructor() {}

  public static getInstance(): DatabaseConnectionManager {
    if (!DatabaseConnectionManager.instance) {
      DatabaseConnectionManager.instance = new DatabaseConnectionManager();
    }
    return DatabaseConnectionManager.instance;
  }

  private static async healthCheck(): Promise<void> {
    if (!this.pool) return;

    try {
      const startTime = Date.now();
      await this.pool.query("SELECT 1");
      const duration = Date.now() - startTime;

      if (duration > 1000) {
        // Log slow health checks (>1s)
        logger.warn(`Database health check took ${duration}ms`);
      } else {
        logger.info(`Database health check successful (${duration}ms)`);
      }
    } catch (error) {
      this.connected = false;
      logger.error("Database health check failed", { error });
      // Try to reconnect
      await this.initialize();
    }
  }

  static async initialize(): Promise<void> {
    let retries = 0;

    while (retries < MAX_RETRIES) {
      try {
        logger.info("Initializing database connection", {
          host: env.DB_HOST,
          port: env.DB_PORT,
          database: env.DB_NAME,
          user: env.DB_USER,
        });

        this.pool = new Pool({
          host: env.DB_HOST,
          port: env.DB_PORT,
          database: env.DB_NAME,
          user: env.DB_USER,
          password: env.DB_PASSWORD,
          // Add some connection pool settings
          max: 20, // Maximum number of clients
          idleTimeoutMillis: 30000, // Close idle clients after 30 seconds
          connectionTimeoutMillis: 2000, // Return an error after 2 seconds if connection could not be established
        });

        // Handle pool events
        (this.pool as unknown as EventEmitter).on(
          "connect",
          (_client: PoolClient) => {
            logger.info("New client connected to database pool");
          },
        );

        (this.pool as unknown as EventEmitter).on("error", (err: Error) => {
          logger.error("Unexpected error on idle client", { error: err });
        });

        (this.pool as unknown as EventEmitter).on(
          "remove",
          (_client: PoolClient) => {
            logger.info("Client removed from pool");
          },
        );

        // Test the connection
        const startTime = Date.now();
        const result = await this.pool.query("SELECT version()");
        const duration = Date.now() - startTime;

        this.connected = true;
        logger.info("Database connection successful", {
          duration: `${duration}ms`,
          version: result.rows[0].version,
          poolSize: (this.pool as Pool).totalCount,
          idleCount: (this.pool as Pool).idleCount,
        });

        // Start periodic health checks
        if (this.healthCheckInterval) {
          clearInterval(this.healthCheckInterval);
        }
        this.healthCheckInterval = setInterval(
          () => this.healthCheck(),
          HEALTH_CHECK_INTERVAL,
        );

        // Initialize tables
        await this.initializeTables();
        return;
      } catch (error) {
        retries++;
        logger.error(
          `Database connection attempt ${retries}/${MAX_RETRIES} failed`,
          {
            error,
            nextRetryIn: `${RETRY_INTERVAL / 1000} seconds`,
          },
        );

        if (retries === MAX_RETRIES) {
          throw new Error(
            `Failed to connect to database after ${MAX_RETRIES} attempts`,
          );
        }

        await new Promise((resolve) => setTimeout(resolve, RETRY_INTERVAL));
      }
    }
  }

  private static async initializeTables(): Promise<void> {
    // Create users table
    await this.pool?.query(`
      CREATE TABLE IF NOT EXISTS users (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        username VARCHAR(255) NOT NULL UNIQUE,
        email VARCHAR(255) NOT NULL UNIQUE,
        password VARCHAR(255) NOT NULL,
        display_name VARCHAR(255),
        first_name VARCHAR(255),
        last_name VARCHAR(255),
        bio TEXT,
        profile_image VARCHAR(255),
        banner_image VARCHAR(255),
        role VARCHAR(50) DEFAULT 'user',
        is_verified BOOLEAN DEFAULT FALSE,
        email_confirmed BOOLEAN DEFAULT FALSE,
        email_token VARCHAR(255),
        email_token_expire TIMESTAMP,
        last_email_sent TIMESTAMP,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Add more table creation statements here as needed
  }

  static getPool(): Pool {
    if (!this.pool) {
      throw new Error("Database connection not initialized");
    }
    return this.pool;
  }

  static isConnected(): boolean {
    return this.connected && this.pool !== null;
  }

  static async close(): Promise<void> {
    if (this.healthCheckInterval) {
      clearInterval(this.healthCheckInterval);
      this.healthCheckInterval = null;
    }

    if (this.pool) {
      logger.info("Closing database connection pool");
      await this.pool.end();
      this.pool = null;
      this.connected = false;
      logger.info("Database connection pool closed successfully");
    }
  }

  // Helper function to get a client from the pool with error handling
  static async withClient<T>(
    callback: (client: PoolClient) => Promise<T>,
  ): Promise<T> {
    const client = await this.getPool().connect();
    try {
      return await callback(client);
    } finally {
      client.release();
    }
  }

  // Transaction helper function
  static async withTransaction<T>(
    callback: (client: PoolClient) => Promise<T>,
  ): Promise<T> {
    return this.withClient(async (client) => {
      try {
        await client.query("BEGIN");
        const result = await callback(client);
        await client.query("COMMIT");
        return result;
      } catch (error) {
        await client.query("ROLLBACK");
        throw error;
      }
    });
  }

  static async reset(): Promise<void> {
    if (this.connected && this.pool instanceof Pool) {
      // Only allow reset in development
      if (env.NODE_ENV !== "production") {
        try {
          // Drop all tables and recreate them using migrations
          await this.pool.query(`
            DO $$ DECLARE
              r RECORD;
            BEGIN
              FOR r IN (SELECT tablename FROM pg_tables WHERE schemaname = current_schema()) LOOP
                EXECUTE 'DROP TABLE IF EXISTS ' || quote_ident(r.tablename) || ' CASCADE';
              END LOOP;
            END $$;
          `);
          // Reinitialize tables
          await this.initializeTables();
          logger.info("Database reset complete");
        } catch (error) {
          logger.error("Database reset failed:", { error });
          throw error;
        }
      } else {
        logger.warn(
          "Database reset attempted in production mode - operation skipped",
        );
      }
    }
  }
}



===========================================================
FILE 2: index.ts
===========================================================




===========================================================
FILE 3: migrations\migrationConfig.ts
===========================================================

import path from "path";

export interface MigrationConfig {
  migrations_path: string;
  migrations_table: string;
  migration_file_extension: string;
  migration_template_path?: string;
}

export const migrationConfig: MigrationConfig = {
  migrations_path: path.join(
    process.cwd(),
    "src/server/database/migrations/migrations",
  ),
  migrations_table: "migrations",
  migration_file_extension: ".ts", // Support for TypeScript migrations
};

export const createMigrationTemplate = (name: string): string => `
import { MigrationBuilder, ColumnDefinitions } from 'node-pg-migrate';

export const shorthands: ColumnDefinitions | undefined = undefined;

// Migration: ${name}
// Created: ${new Date().toISOString()}

export function up(pgm: MigrationBuilder): void {
  // Add migration code here
  // Examples:
  // pgm.createTable('table_name', {
  //   id: 'id',
  //   name: { type: 'varchar(1000)', notNull: true },
  //   created_at: {
  //     type: 'timestamp',
  //     notNull: true,
  //     default: pgm.func('current_timestamp'),
  //   },
  // });
  // pgm.createIndex('table_name', 'name');
}

export function down(pgm: MigrationBuilder): void {
  // Add rollback code here
  // Examples:
  // pgm.dropTable('table_name');
}
`;



===========================================================
FILE 4: migrations\migrationManager.ts
===========================================================

// src/database/migrations/migrationManager.ts
import { existsSync } from "fs";
import { mkdir, readdir, readFile } from "fs/promises";
import { join } from "path";

import { Pool, PoolClient } from "pg";

import { Logger } from "../../services/LoggerService";
import { DatabaseConnectionManager } from "../config";

import { createMigrationTemplate, migrationConfig } from "./migrationConfig";

interface MigrationRecord {
  id: number;
  name: string;
  executed_at: Date;
}

export class MigrationManager {
  private logger: Logger;
  private pool: Pool;
  private migrationsPath: string;
  private migrationsTable: string;
  private migrationExtension: string;

  constructor() {
    this.logger = new Logger("MigrationManager");
    const pool = DatabaseConnectionManager.getPool();
    if (!(pool instanceof Pool)) {
      throw new Error("Migrations require a PostgreSQL database connection");
    }
    this.pool = pool;
    this.migrationsPath = migrationConfig.migrations_path;
    this.migrationsTable = migrationConfig.migrations_table;
    this.migrationExtension = migrationConfig.migration_file_extension;

    this.ensureMigrationsDirectory();
  }

  /**
   * Ensure migrations directory exists
   */
  private async ensureMigrationsDirectory(): Promise<void> {
    if (!existsSync(this.migrationsPath)) {
      try {
        await mkdir(this.migrationsPath, { recursive: true });
        this.logger.info(
          `Created migrations directory: ${this.migrationsPath}`,
        );
      } catch (error) {
        this.logger.error("Failed to create migrations directory", { error });
        throw error;
      }
    }
  }

  /**
   * Create migrations table if it doesn't exist
   */
  async createMigrationsTable(): Promise<void> {
    const query = `
      CREATE TABLE IF NOT EXISTS ${this.migrationsTable} (
        id SERIAL PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `;

    try {
      await this.pool.query(query);
      this.logger.info(
        `Ensured migrations table exists: ${this.migrationsTable}`,
      );
    } catch (error) {
      this.logger.error("Failed to create migrations table", { error });
      throw error;
    }
  }

  /**
   * Get list of executed migrations
   */
  async getExecutedMigrations(): Promise<string[]> {
    const query = `SELECT name FROM ${this.migrationsTable} ORDER BY id ASC`;

    try {
      const result = await this.pool.query<{ name: string }>(query);
      return result.rows.map((row: { name: string }) => row.name);
    } catch (error) {
      this.logger.error("Failed to get executed migrations", { error });
      throw error;
    }
  }

  /**
   * Create a new migration file
   */
  async createMigration(name: string): Promise<string> {
    const timestamp = new Date()
      .toISOString()
      .replace(/[-:]/g, "")
      .replace("T", "_")
      .split(".")[0];
    const fileName = `${timestamp}_${name}${this.migrationExtension}`;
    const filePath = join(this.migrationsPath, fileName);

    const template = createMigrationTemplate(name);

    try {
      const { writeFile } = await import("fs/promises");
      await writeFile(filePath, template, "utf8");
      this.logger.info(`Created migration: ${fileName}`);
      return fileName;
    } catch (error) {
      this.logger.error("Failed to create migration file", { error });
      throw error;
    }
  }

  /**
   * Get list of all migration files
   */
  private async getMigrationFiles(): Promise<string[]> {
    try {
      const files = await readdir(this.migrationsPath);
      // Support both .sql and .ts/.js files based on config
      return files.filter(
        (file) =>
          (file.endsWith(".sql") || file.endsWith(this.migrationExtension)) &&
          !file.includes(".down."),
      );
    } catch (error) {
      this.logger.error("Failed to read migrations directory", { error });
      throw error;
    }
  }

  /**
   * Get list of pending migrations
   */
  private async getPendingMigrations(): Promise<string[]> {
    const files = await this.getMigrationFiles();
    const executedMigrations = await this.getExecutedMigrations();

    // Filter out migrations that have already been executed
    return files.filter((file) => !executedMigrations.includes(file));
  }

  /**
   * Execute a SQL migration
   */
  private async executeSqlMigration(
    client: PoolClient,
    filename: string,
  ): Promise<void> {
    const filePath = join(this.migrationsPath, filename);
    const sql = await readFile(filePath, "utf8");

    // Execute the migration SQL
    await client.query(sql);
  }

  /**
   * Execute a TypeScript/JavaScript migration
   */
  private async executeJsMigration(
    _client: PoolClient,
    filename: string,
  ): Promise<void> {
    // For TypeScript migrations we need to compile and run them
    try {
      // When using TypeScript, ensure ts-node is installed
      const migrationModule = await import(join(this.migrationsPath, filename));

      if (typeof migrationModule.up !== "function") {
        throw new Error(
          `Migration ${filename} does not export an 'up' function`,
        );
      }

      // Create a migration builder object
      const pgm = {
        createTable: async (
          tableName: string,
          _columns: unknown,
          _options?: unknown,
        ) => {
          this.logger.info(`Creating table ${tableName}`);
        },
        addColumn: async (tableName: string, columnName: string) => {
          this.logger.info(`Adding column ${columnName} to ${tableName}`);
        },
      };

      // Execute the migration
      await migrationModule.up(pgm);
    } catch (err) {
      this.logger.error(`Error executing JS/TS migration ${filename}:`, err);
      throw err;
    }
  }

  /**
   * Execute a single migration
   */
  private async executeMigration(filename: string): Promise<void> {
    const client = await this.pool.connect();

    try {
      await client.query("BEGIN");

      if (filename.endsWith(".sql")) {
        await this.executeSqlMigration(client, filename);
      } else if (filename.endsWith(".ts") || filename.endsWith(".js")) {
        await this.executeJsMigration(client, filename);
      } else {
        throw new Error(`Unsupported migration file type: ${filename}`);
      }

      // Record the migration
      await client.query(
        `INSERT INTO ${this.migrationsTable} (name) VALUES ($1)`,
        [filename],
      );

      await client.query("COMMIT");
      this.logger.info(`Executed migration: ${filename}`);
    } catch (err) {
      await client.query("ROLLBACK");
      this.logger.error(`Error executing migration ${filename}:`, err);
      throw err;
    } finally {
      client.release();
    }
  }

  /**
   * Run all pending migrations
   */
  async migrate(): Promise<void> {
    await this.createMigrationsTable();
    const pendingMigrations = await this.getPendingMigrations();

    if (pendingMigrations.length === 0) {
      this.logger.info("No pending migrations");
      return;
    }

    this.logger.info(`Found ${pendingMigrations.length} pending migrations`);

    // Sort migrations by filename to ensure correct order
    pendingMigrations.sort();

    for (const migration of pendingMigrations) {
      await this.executeMigration(migration);
    }

    this.logger.info("All migrations completed successfully");
  }

  /**
   * Get migration status
   */
  async status(): Promise<{ executed: string[]; pending: string[] }> {
    await this.createMigrationsTable();
    const executed = await this.getExecutedMigrations();
    const pending = await this.getPendingMigrations();

    return { executed, pending };
  }

  /**
   * Roll back last migration
   */
  async rollbackMigration(): Promise<void> {
    const client = await this.pool.connect();
    try {
      await client.query("BEGIN");
      const result = await client.query<MigrationRecord>(
        `DELETE FROM ${this.migrationsTable} WHERE id = (SELECT MAX(id) FROM ${this.migrationsTable}) RETURNING *`,
      );
      if (result.rows.length === 0) {
        this.logger.info("No migrations to roll back");
        await client.query("ROLLBACK");
        return;
      }

      const migration = result.rows[0];
      const { name: migrationName } = migration;

      if (migrationName.endsWith(".sql")) {
        // For SQL migrations, look for a corresponding down file
        const downFileName = migrationName.replace(".sql", ".down.sql");
        const downFilePath = join(this.migrationsPath, downFileName);

        try {
          const downSql = await readFile(downFilePath, "utf8");
          await client.query(downSql);
        } catch (error) {
          this.logger.error(`Rollback file not found: ${downFileName}`, {
            error,
          });
          throw new Error(`Rollback file not found: ${downFileName}`);
        }
      } else if (
        migrationName.endsWith(".ts") ||
        migrationName.endsWith(".js")
      ) {
        // For TypeScript/JavaScript migrations, call the down function
        try {
          const migrationModule = await import(
            join(this.migrationsPath, migrationName)
          );

          if (typeof migrationModule.down !== "function") {
            throw new Error(
              `Migration ${migrationName} does not export a 'down' function`,
            );
          }

          // Similar to up, you'd want a proper migration builder here
          const pgm = {
            dropTable: async (tableName: string, _options?: unknown) => {
              // Implementation would build and execute SQL
              this.logger.info(`Dropping table ${tableName}`);
            },
            dropColumn: async (tableName: string, _columnName: string) => {
              // Implementation would build and execute SQL
              this.logger.info(
                `Dropping column ${_columnName} from ${tableName}`,
              );
            },
            // ... other migration methods
          };

          await migrationModule.down(pgm);
        } catch (error) {
          this.logger.error(
            `Error running down migration for ${migrationName}:`,
            error,
          );
          throw error;
        }
      }

      await client.query("COMMIT");
      this.logger.info(`Rolled back migration: ${migrationName}`);
    } catch (error) {
      await client.query("ROLLBACK");
      this.logger.error("Failed to rollback migration", { error });
      throw error;
    } finally {
      client.release();
    }
  }

  /**
   * Reset database (dangerous - use with caution!)
   */
  async resetDatabase(): Promise<void> {
    this.logger.warn("RESETTING DATABASE - ALL DATA WILL BE LOST");

    const client = await this.pool.connect();
    try {
      await client.query("BEGIN");

      // Get all tables except the migrations table
      const tablesResult = await client.query<{ tablename: string }>(
        `
        SELECT tablename 
        FROM pg_tables 
        WHERE schemaname = 'public' 
          AND tablename != $1
      `,
        [this.migrationsTable],
      );

      // Drop all tables in reverse order of creation (to handle dependencies)
      if (tablesResult.rows.length > 0) {
        const tables = tablesResult.rows.map((row) => row.tablename);
        await client.query(`DROP TABLE IF EXISTS ${tables.join(", ")} CASCADE`);
      }

      // Clear migration records
      await client.query(`TRUNCATE ${this.migrationsTable}`);

      await client.query("COMMIT");
      this.logger.info("Database reset completed");
    } catch (error) {
      await client.query("ROLLBACK");
      this.logger.error("Failed to reset database", { error });
      throw error;
    } finally {
      client.release();
    }
  }
}

export default new MigrationManager();



===========================================================
FILE 5: models\BaseModel.ts
===========================================================

import { v4 as uuidv4 } from "uuid";

/**
 * Base model interface that all models should extend.
 * Models are responsible for:
 * 1. Defining the data structure and types
 * 2. Implementing business logic and validation rules
 * 3. Providing methods for data transformation and manipulation
 * 4. NOT handling database operations (that's the repository's job)
 */
export interface BaseModelInterface extends Record<string, unknown> {
  /**
   * Unique identifier for the model
   */
  id: string;

  /**
   * Creation timestamp
   */
  createdAt: Date;

  /**
   * Last update timestamp
   */
  updatedAt: Date;
}

/**
 * Base model class that provides common functionality for all models.
 * This class should be extended by all domain models.
 *
 * Responsibilities:
 * - Define the data structure
 * - Implement business logic
 * - Handle data validation
 * - Provide data transformation methods
 * - NOT handle database operations
 */
export class BaseModel implements BaseModelInterface {
  /**
   * Unique identifier for the model
   */
  id: string;

  /**
   * Creation timestamp
   */
  createdAt: Date;

  /**
   * Last update timestamp
   */
  updatedAt: Date;

  /**
   * Index signature to allow additional properties
   */
  [key: string]: unknown;

  constructor() {
    this.id = "";
    this.createdAt = new Date();
    this.updatedAt = new Date();
  }

  /**
   * Generate a unique ID for new model instances.
   * This is a utility method for model creation, not database operations.
   */
  protected generateId(): string {
    return uuidv4();
  }
}



===========================================================
FILE 6: models\analytics\ActivityLog.ts
===========================================================

import { BaseModel } from "../BaseModel";

/**
 * Enum defining all possible activity types in the system.
 * This represents the different kinds of user actions that can be logged.
 */
export enum ActivityType {
  USER_LOGIN = "USER_LOGIN",
  USER_SIGNUP = "USER_SIGNUP",
  POST_CREATED = "POST_CREATED",
  POST_LIKED = "POST_LIKED",
  POST_COMMENTED = "POST_COMMENTED",
  USER_FOLLOWED = "USER_FOLLOWED",
  MEDIA_UPLOADED = "MEDIA_UPLOADED",
  MEDIA_VIEWED = "MEDIA_VIEWED",
  GROUP_JOINED = "GROUP_JOINED",
  MESSAGE_SENT = "MESSAGE_SENT",
  SEARCH_PERFORMED = "SEARCH_PERFORMED",
  PROFILE_VIEWED = "PROFILE_VIEWED",
  NOTIFICATION_CLICKED = "NOTIFICATION_CLICKED",
}

/**
 * Interface defining the structure of an activity log entry.
 * This represents the data structure that will be stored in the database.
 */
export interface ActivityLogAttributes {
  id: string;
  userId: string;
  type: ActivityType;
  targetId?: string;
  targetType?: string;
  metadata?: Record<string, unknown>;
  ipAddress?: string;
  userAgent?: string;
  createdAt: Date;
}

/**
 * ActivityLog model class that represents user activity in the system.
 * This class is responsible for:
 * 1. Defining the structure of activity log entries
 * 2. Providing methods for manipulating activity data
 * 3. Validating activity data
 * 4. Converting between different data formats
 *
 * It does NOT handle database operations - those are handled by ActivityLogRepository.
 */
export class ActivityLog extends BaseModel implements ActivityLogAttributes {
  id: string;
  userId: string;
  type: ActivityType;
  targetId?: string;
  targetType?: string;
  metadata?: Record<string, unknown>;
  ipAddress?: string;
  userAgent?: string;
  createdAt: Date;

  constructor(
    data: Partial<ActivityLogAttributes> & {
      userId: string;
      type: ActivityType;
    },
  ) {
    super();
    this.id = data.id || this.generateId();
    this.userId = data.userId;
    this.type = data.type;
    this.targetId = data.targetId;
    this.targetType = data.targetType;
    this.metadata = data.metadata || {};
    this.ipAddress = data.ipAddress;
    this.userAgent = data.userAgent;
    this.createdAt = data.createdAt || new Date();
  }

  /**
   * Converts the activity log to a plain object format.
   * This is useful for serialization and API responses.
   */
  toJSON(): ActivityLogAttributes {
    return {
      id: this.id,
      userId: this.userId,
      type: this.type,
      targetId: this.targetId,
      targetType: this.targetType,
      metadata: this.metadata,
      ipAddress: this.ipAddress,
      userAgent: this.userAgent,
      createdAt: this.createdAt,
    };
  }

  /**
   * Adds additional metadata to the activity log.
   * This is a business logic method for manipulating the activity data.
   *
   * @param key The metadata key
   * @param value The metadata value
   */
  addMetadata(key: string, value: unknown): void {
    if (!this.metadata) {
      this.metadata = {};
    }
    this.metadata[key] = value;
  }
}



===========================================================
FILE 7: models\auth\PasswordResetToken.ts
===========================================================

import { BaseModel } from "../BaseModel";

/**
 * Status of password reset token
 */
export enum PasswordResetTokenStatus {
  ACTIVE = "active",
  USED = "used",
  EXPIRED = "expired",
}

/**
 * Interface for password reset token attributes
 */
export interface PasswordResetTokenAttributes {
  /**
   * Unique identifier for the token
   */
  id: string;

  /**
   * The user ID this token belongs to
   */
  userId: string;

  /**
   * The actual token value (should be stored hashed)
   */
  token: string;

  /**
   * When the token expires
   */
  expiresAt: Date;

  /**
   * Current status of the token
   */
  status: PasswordResetTokenStatus;

  /**
   * When the token was used (if applicable)
   */
  usedAt?: Date;

  /**
   * Creation timestamp
   */
  createdAt: Date;

  /**
   * Last update timestamp
   */
  updatedAt: Date;
}

/**
 * PasswordResetToken model class for handling password reset functionality.
 * This class is responsible for:
 * 1. Defining the data structure
 * 2. Implementing business logic related to token status
 * 3. Validating token state
 * 4. NOT handling database operations - that belongs in the repository
 */
export class PasswordResetToken
  extends BaseModel
  implements Omit<PasswordResetTokenAttributes, "id">
{
  userId: string;
  token: string;
  expiresAt: Date;
  status: PasswordResetTokenStatus;
  usedAt?: Date;

  /**
   * Constructor for PasswordResetToken
   */
  constructor(
    attributes: Partial<PasswordResetTokenAttributes> & {
      userId: string;
      token: string;
    },
  ) {
    super();
    this.id = attributes.id || this.generateId();
    this.userId = attributes.userId;
    this.token = attributes.token;
    this.expiresAt =
      attributes.expiresAt || new Date(Date.now() + 24 * 60 * 60 * 1000); // Default 24h expiry
    this.status = attributes.status || PasswordResetTokenStatus.ACTIVE;
    this.usedAt = attributes.usedAt;
    this.createdAt = attributes.createdAt || new Date();
    this.updatedAt = attributes.updatedAt || new Date();
  }

  /**
   * Convert to JSON representation
   */
  toJSON(): PasswordResetTokenAttributes {
    return {
      id: this.id,
      userId: this.userId,
      token: this.token,
      expiresAt: this.expiresAt,
      status: this.status,
      usedAt: this.usedAt,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt,
    };
  }

  /**
   * Check if token is expired
   * This is business logic that belongs in the model
   */
  isExpired(): boolean {
    return (
      this.status === PasswordResetTokenStatus.EXPIRED ||
      this.expiresAt < new Date()
    );
  }

  /**
   * Check if token has been used
   * This is business logic that belongs in the model
   */
  isUsed(): boolean {
    return (
      this.status === PasswordResetTokenStatus.USED && this.usedAt !== undefined
    );
  }

  /**
   * Check if token is valid (not expired and not used)
   * This is business logic that belongs in the model
   */
  isValid(): boolean {
    return this.status === PasswordResetTokenStatus.ACTIVE && !this.isExpired();
  }

  /**
   * Mark token as used
   * This is business logic that belongs in the model
   */
  markAsUsed(): void {
    this.status = PasswordResetTokenStatus.USED;
    this.usedAt = new Date();
    this.updatedAt = new Date();
  }

  /**
   * Mark token as expired
   * This is business logic that belongs in the model
   */
  markAsExpired(): void {
    this.status = PasswordResetTokenStatus.EXPIRED;
    this.updatedAt = new Date();
  }
}



===========================================================
FILE 8: models\auth\Permission.ts
===========================================================

import { BaseModel } from "../BaseModel";

/**
 * Interface defining the structure of a Permission
 */
export interface PermissionAttributes extends BaseModel {
  name: string;
  description: string | null;
  resource: string;
  action: string;
}

/**
 * Permission model representing a system permission.
 * This class handles:
 * 1. Permission data structure
 * 2. Permission validation and comparison
 * 3. Permission state management
 * 4. NOT database operations - those belong in PermissionRepository
 */
export class Permission
  extends BaseModel
  implements Omit<PermissionAttributes, keyof BaseModel>
{
  name: string;
  description: string | null;
  resource: string;
  action: string;

  constructor(data: Partial<PermissionAttributes>) {
    super();
    this.name = data.name || "";
    this.description = data.description || null;
    this.resource = data.resource || "";
    this.action = data.action || "";
  }

  /**
   * Converts the permission to a plain object
   */
  toJSON(): Omit<PermissionAttributes, "generateId"> {
    return {
      id: this.id,
      name: this.name,
      description: this.description,
      resource: this.resource,
      action: this.action,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt,
    };
  }

  /**
   * Checks if this permission matches another permission
   * @param other The permission to compare against
   */
  equals(other: Permission): boolean {
    return this.resource === other.resource && this.action === other.action;
  }

  /**
   * Checks if this permission matches a resource and action
   * @param resource The resource to check
   * @param action The action to check
   */
  matches(resource: string, action: string): boolean {
    return this.resource === resource && this.action === action;
  }

  /**
   * Creates a permission string in the format "resource:action"
   */
  toString(): string {
    return `${this.resource}:${this.action}`;
  }

  /**
   * Validates the permission data
   * @throws Error if the permission is invalid
   */
  validate(): void {
    if (!this.resource) {
      throw new Error("Resource is required");
    }
    if (!this.action) {
      throw new Error("Action is required");
    }
    if (this.name && this.name.length > 100) {
      throw new Error("Name must be less than 100 characters");
    }
    if (this.description && this.description.length > 500) {
      throw new Error("Description must be less than 500 characters");
    }
  }

  /**
   * Creates a new permission from a string in the format "resource:action"
   * @param permissionString The permission string to parse
   */
  static fromString(permissionString: string): Permission {
    const [resource, action] = permissionString.split(":");
    if (!resource || !action) {
      throw new Error(
        'Invalid permission string format. Expected "resource:action"',
      );
    }
    return new Permission({ resource, action });
  }
}



===========================================================
FILE 9: models\auth\Role.ts
===========================================================

import { BaseModel } from "../BaseModel";

/**
 * Interface defining the structure of a Role
 */
export interface RoleAttributes extends BaseModel {
  name: string;
  description: string | null;
}

/**
 * Role model representing a system role.
 * This class handles:
 * 1. Role data structure
 * 2. Role validation and equality checking
 * 3. Role state management
 * 4. NOT database operations - those belong in RoleRepository
 */
export class Role
  extends BaseModel
  implements Omit<RoleAttributes, keyof BaseModel>
{
  name: string;
  description: string | null;

  constructor(data: Partial<RoleAttributes>) {
    super();
    this.name = data.name || "";
    this.description = data.description || null;
  }

  /**
   * Converts the role to a plain object
   */
  toJSON(): Omit<RoleAttributes, "generateId"> {
    return {
      id: this.id,
      name: this.name,
      description: this.description,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt,
    };
  }

  /**
   * Checks if this role is equal to another role
   * @param other The other role to compare with
   */
  equals(other: Role): boolean {
    return this.id === other.id || this.name === other.name;
  }

  /**
   * Validates the role data
   * @throws Error if validation fails
   */
  validate(): void {
    if (!this.name) {
      throw new Error("Role name is required");
    }

    if (this.name.length > 50) {
      throw new Error("Role name must be less than 50 characters");
    }

    if (this.description && this.description.length > 500) {
      throw new Error("Role description must be less than 500 characters");
    }
  }

  /**
   * Determines if this role is a system role (roles that cannot be modified)
   */
  isSystemRole(): boolean {
    return ["admin", "user", "moderator"].includes(this.name.toLowerCase());
  }

  /**
   * Creates an admin role
   */
  static createAdminRole(): Role {
    return new Role({
      name: "admin",
      description: "Administrator with full system access",
    });
  }

  /**
   * Creates a regular user role
   */
  static createUserRole(): Role {
    return new Role({
      name: "user",
      description: "Regular application user",
    });
  }
}



===========================================================
FILE 10: models\auth\RolePermission.ts
===========================================================

import { BaseModel } from "../BaseModel";

/**
 * Interface defining the structure of a RolePermission association
 * This is a join table between roles and permissions
 */
export interface RolePermissionAttributes extends BaseModel {
  roleId: string;
  permissionId: string;
}

/**
 * RolePermission model representing an association between a role and a permission.
 * This class handles:
 * 1. RolePermission data structure
 * 2. RolePermission validation
 * 3. NOT database operations - those belong in RolePermissionRepository
 */
export class RolePermission
  extends BaseModel
  implements Omit<RolePermissionAttributes, keyof BaseModel>
{
  roleId: string;
  permissionId: string;

  constructor(data: Partial<RolePermissionAttributes>) {
    super();
    this.roleId = data.roleId || "";
    this.permissionId = data.permissionId || "";
  }

  /**
   * Converts the role permission to a plain object
   */
  toJSON(): Omit<RolePermissionAttributes, "generateId"> {
    return {
      id: this.id,
      roleId: this.roleId,
      permissionId: this.permissionId,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt,
    };
  }

  /**
   * Validates the role permission data
   * @throws Error if validation fails
   */
  validate(): void {
    if (!this.roleId) {
      throw new Error("Role ID is required");
    }

    if (!this.permissionId) {
      throw new Error("Permission ID is required");
    }
  }

  /**
   * Checks if this role permission is equal to another role permission
   * @param other The role permission to compare with
   */
  equals(other: RolePermission): boolean {
    return (
      this.roleId === other.roleId && this.permissionId === other.permissionId
    );
  }
}



===========================================================
FILE 11: models\auth\Token.ts
===========================================================

import { BaseModel } from "../BaseModel";

/**
 * Enumeration defining the different types of tokens in the system
 */
export enum TokenType {
  ACCESS = "access",
  REFRESH = "refresh",
  PASSWORD_RESET = "password_reset",
  EMAIL_VERIFICATION = "email_verification",
}

/**
 * Interface defining the structure of a Token
 */
export interface TokenAttributes extends BaseModel {
  userId: string;
  token: string;
  type: TokenType;
  deviceInfo: string | null;
  ipAddress: string | null;
  expiresAt: Date;
  lastUsedAt: Date | null;
  revoked: boolean;
}

/**
 * Token model representing an authentication or verification token.
 * This class handles:
 * 1. Token data structure
 * 2. Token validation and state checking
 * 3. Token-related business logic
 * 4. NOT database operations - those belong in TokenRepository
 */
export class Token
  extends BaseModel
  implements Omit<TokenAttributes, keyof BaseModel>
{
  userId: string;
  token: string;
  type: TokenType;
  deviceInfo: string | null;
  ipAddress: string | null;
  expiresAt: Date;
  lastUsedAt: Date | null;
  revoked: boolean;

  constructor(data: Partial<TokenAttributes>) {
    super();
    this.userId = data.userId || "";
    this.token = data.token || "";
    this.type = data.type || TokenType.ACCESS;
    this.deviceInfo = data.deviceInfo || null;
    this.ipAddress = data.ipAddress || null;
    this.expiresAt = data.expiresAt || new Date();
    this.lastUsedAt = data.lastUsedAt || null;
    this.revoked = data.revoked || false;
  }

  /**
   * Converts the token to a plain object
   */
  toJSON(): Omit<TokenAttributes, "generateId"> {
    return {
      id: this.id,
      userId: this.userId,
      token: this.token,
      type: this.type,
      deviceInfo: this.deviceInfo,
      ipAddress: this.ipAddress,
      expiresAt: this.expiresAt,
      lastUsedAt: this.lastUsedAt,
      revoked: this.revoked,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt,
    };
  }

  /**
   * Checks if the token is valid (not expired and not revoked)
   */
  isValid(): boolean {
    return !this.revoked && this.expiresAt > new Date();
  }

  /**
   * Checks if the token is expired
   */
  isExpired(): boolean {
    return this.expiresAt <= new Date();
  }

  /**
   * Checks if the token has been revoked
   */
  isRevoked(): boolean {
    return this.revoked;
  }

  /**
   * Marks the token as used by updating the lastUsedAt field
   * Note: This only updates the model, not the database
   */
  markAsUsed(): void {
    this.lastUsedAt = new Date();
  }

  /**
   * Revokes the token
   * Note: This only updates the model, not the database
   */
  revokeToken(): void {
    this.revoked = true;
  }

  /**
   * Validates the token data
   * @throws Error if validation fails
   */
  validate(): void {
    if (!this.userId) {
      throw new Error("User ID is required");
    }

    if (!this.token) {
      throw new Error("Token string is required");
    }

    if (!Object.values(TokenType).includes(this.type)) {
      throw new Error(`Invalid token type: ${this.type}`);
    }

    if (!this.expiresAt) {
      throw new Error("Expiration date is required");
    }
  }
}



===========================================================
FILE 12: models\auth\User.ts
===========================================================

// src/server/models/User.ts
import bcrypt from "bcrypt";

import { BaseModel } from "../BaseModel";

/**
 * Interface defining the structure of a User
 */
export interface UserAttributes extends BaseModel {
  username: string;
  email: string;
  password: string;
  displayName: string | null;
  firstName: string | null;
  lastName: string | null;
  bio: string | null;
  profileImage: string | null;
  bannerImage: string | null;
  role: string;
  isVerified: boolean;
  emailConfirmed: boolean;
  emailToken: string | null;
  emailTokenExpire: Date | null;
  lastEmailSent: Date | null;
}

/**
 * Interface for serialized User object (without sensitive fields)
 */
export interface UserJSON
  extends Omit<
    User,
    | "password"
    | "update"
    | "delete"
    | "comparePassword"
    | "updatePassword"
    | "toJSON"
    | "emailToken"
    | "emailTokenExpire"
    | "validate"
  > {
  posts?: UserAttributes[];
  isFollowing?: boolean;
}

/**
 * User model representing a user account.
 * This class handles:
 * 1. User data structure
 * 2. User validation and state checking
 * 3. User-related business logic (password hashing, comparison)
 * 4. NOT database operations - those belong in UserRepository
 */
export class User
  extends BaseModel
  implements Omit<UserAttributes, keyof BaseModel>
{
  username: string;
  email: string;
  password: string;
  displayName: string | null;
  firstName: string | null;
  lastName: string | null;
  bio: string | null;
  profileImage: string | null;
  bannerImage: string | null;
  role: string;
  isVerified: boolean;
  emailConfirmed: boolean;
  emailToken: string | null;
  emailTokenExpire: Date | null;
  lastEmailSent: Date | null;

  constructor(data: Partial<UserAttributes>) {
    super();
    this.username = data.username || "";
    this.email = data.email || "";
    this.password = data.password || "";
    this.displayName = data.displayName || null;
    this.firstName = data.firstName || null;
    this.lastName = data.lastName || null;
    this.bio = data.bio || null;
    this.profileImage = data.profileImage || null;
    this.bannerImage = data.bannerImage || null;
    this.role = data.role || "user";
    this.isVerified = data.isVerified || false;
    this.emailConfirmed = data.emailConfirmed || false;
    this.emailToken = data.emailToken || null;
    this.emailTokenExpire = data.emailTokenExpire || null;
    this.lastEmailSent = data.lastEmailSent || null;
  }

  /**
   * Converts the user to a JSON object, omitting sensitive fields
   */
  toJSON(): Omit<
    UserAttributes,
    "password" | "emailToken" | "emailTokenExpire" | "generateId"
  > {
    const {
      password: _,
      emailToken: __,
      emailTokenExpire: ___,
      ...userJson
    } = this;
    return userJson;
  }

  /**
   * Compares a plain text password with the hashed password
   * @param candidatePassword The plain text password to compare
   * @returns True if the passwords match, false otherwise
   */
  async comparePassword(candidatePassword: string): Promise<boolean> {
    return bcrypt.compare(candidatePassword, this.password);
  }

  /**
   * Updates the user's password with a new hashed password
   * @param newPassword The new plain text password
   */
  async updatePassword(newPassword: string): Promise<void> {
    this.password = await bcrypt.hash(newPassword, 10);
    this.updatedAt = new Date();
  }

  /**
   * Validates user data
   * @throws Error if validation fails
   */
  validate(): void {
    if (!this.username) {
      throw new Error("Username is required");
    }

    if (!this.email) {
      throw new Error("Email is required");
    }

    if (!this.isValidEmail(this.email)) {
      throw new Error("Invalid email format");
    }

    if (!this.password) {
      throw new Error("Password is required");
    }
  }

  /**
   * Verifies the user's email
   */
  verifyEmail(): void {
    this.emailConfirmed = true;
    this.emailToken = null;
    this.emailTokenExpire = null;
    this.updatedAt = new Date();
  }

  /**
   * Sets a new email verification token
   * @param token The verification token
   * @param expiresIn Time in milliseconds until the token expires
   */
  setEmailVerificationToken(
    token: string,
    expiresIn: number = 24 * 60 * 60 * 1000,
  ): void {
    this.emailToken = token;
    this.emailTokenExpire = new Date(Date.now() + expiresIn);
    this.lastEmailSent = new Date();
    this.updatedAt = new Date();
  }

  /**
   * Checks if the user's email is confirmed
   */
  isEmailConfirmed(): boolean {
    return this.emailConfirmed;
  }

  /**
   * Checks if the user is an admin
   */
  isAdmin(): boolean {
    return this.role === "admin";
  }

  /**
   * Gets the full name of the user (if available)
   */
  getFullName(): string {
    if (this.firstName && this.lastName) {
      return `${this.firstName} ${this.lastName}`;
    }

    if (this.firstName) {
      return this.firstName;
    }

    if (this.displayName) {
      return this.displayName;
    }

    return this.username;
  }

  /**
   * Validates email format
   * @param email The email to validate
   */
  private isValidEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }
}



===========================================================
FILE 13: models\auth\UserRole.ts
===========================================================

import { BaseModel } from "../BaseModel";

/**
 * Interface defining the structure of a UserRole
 * Represents the many-to-many relationship between users and roles
 */
export interface UserRoleAttributes extends BaseModel {
  userId: string;
  roleId: string;
}

/**
 * UserRole model representing the relationship between users and roles.
 * This class handles:
 * 1. User-role relationship data structure
 * 2. Validation of user-role assignments
 * 3. Business logic related to role assignments
 * 4. NOT database operations - those belong in UserRoleRepository
 */
export class UserRole
  extends BaseModel
  implements Omit<UserRoleAttributes, keyof BaseModel>
{
  userId: string;
  roleId: string;

  constructor(data: Partial<UserRoleAttributes>) {
    super();
    this.userId = data.userId || "";
    this.roleId = data.roleId || "";
  }

  /**
   * Converts the user role to a JSON object
   * @returns A plain object representation of the user role
   */
  toJSON(): Omit<UserRoleAttributes, "generateId"> {
    return {
      id: this.id,
      userId: this.userId,
      roleId: this.roleId,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt,
    };
  }

  /**
   * Validates the user role data
   * @throws Error if validation fails
   */
  validate(): void {
    if (!this.userId) {
      throw new Error("User ID is required");
    }
    if (!this.roleId) {
      throw new Error("Role ID is required");
    }
  }

  /**
   * Checks if this user role assignment is valid
   * @returns True if both user ID and role ID are present
   */
  isValid(): boolean {
    return Boolean(this.userId && this.roleId);
  }

  /**
   * Checks if this role assignment is for a specific user
   * @param userId The user ID to check against
   * @returns True if this role is assigned to the specified user
   */
  isForUser(userId: string): boolean {
    return this.userId === userId;
  }

  /**
   * Checks if this role assignment is for a specific role
   * @param roleId The role ID to check against
   * @returns True if this assignment is for the specified role
   */
  isForRole(roleId: string): boolean {
    return this.roleId === roleId;
  }
}



===========================================================
FILE 14: models\community\Group.ts
===========================================================

import { BaseModel } from "../BaseModel";

/**
 * Defines the visibility level of a group
 */
export enum GroupVisibility {
  PUBLIC = "public",
  PRIVATE = "private",
}

/**
 * Defines the role of a member within a group
 */
export enum GroupMemberRole {
  MEMBER = "member",
  MODERATOR = "moderator",
  ADMIN = "admin",
}

/**
 * Defines the current status of a group
 */
export enum GroupStatus {
  ACTIVE = "active",
  ARCHIVED = "archived",
  SUSPENDED = "suspended",
}

/**
 * Interface defining the structure of a Group
 */
export interface GroupAttributes {
  id: string;
  name: string;
  slug: string;
  description: string | null;
  imageUrl: string | null;
  bannerUrl: string | null;
  ownerId: string;
  visibility: GroupVisibility;
  status: GroupStatus;
  memberCount: number;
  createdAt: Date;
  updatedAt: Date;
}

/**
 * Group model representing a community group.
 * This class handles:
 * 1. Group data structure
 * 2. Validation of group data
 * 3. Business logic related to groups
 * 4. NOT database operations - those belong in GroupRepository
 */
export class Group extends BaseModel implements GroupAttributes {
  id: string;
  name: string;
  slug: string;
  description: string | null;
  imageUrl: string | null;
  bannerUrl: string | null;
  ownerId: string;
  visibility: GroupVisibility;
  status: GroupStatus;
  memberCount: number;
  createdAt: Date;
  updatedAt: Date;

  /**
   * Creates a new Group instance
   * @param data The group data
   */
  constructor(
    data: Partial<GroupAttributes> & { name: string; ownerId: string },
  ) {
    super();
    this.id = data.id || this.generateId();
    this.name = data.name;
    this.slug = data.slug || this.generateSlug(data.name);
    this.description = data.description || null;
    this.imageUrl = data.imageUrl || null;
    this.bannerUrl = data.bannerUrl || null;
    this.ownerId = data.ownerId;
    this.visibility = data.visibility || GroupVisibility.PRIVATE;
    this.status = data.status || GroupStatus.ACTIVE;
    this.memberCount = data.memberCount || 0;
    this.createdAt = data.createdAt || new Date();
    this.updatedAt = data.updatedAt || new Date();
  }

  /**
   * Converts the group to a JSON object
   * @returns A plain object representation of the group
   */
  toJSON(): GroupAttributes {
    return {
      id: this.id,
      name: this.name,
      slug: this.slug,
      description: this.description,
      imageUrl: this.imageUrl,
      bannerUrl: this.bannerUrl,
      ownerId: this.ownerId,
      visibility: this.visibility,
      status: this.status,
      memberCount: this.memberCount,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt,
    };
  }

  /**
   * Validates the group data
   * @throws Error if validation fails
   */
  validate(): void {
    if (!this.name || this.name.trim().length === 0) {
      throw new Error("Group name is required");
    }

    if (this.name.length > 100) {
      throw new Error("Group name cannot exceed 100 characters");
    }

    if (!this.ownerId) {
      throw new Error("Owner ID is required");
    }

    if (this.description && this.description.length > 1000) {
      throw new Error("Group description cannot exceed 1000 characters");
    }
  }

  /**
   * Generates a URL-friendly slug from the group name
   * @param name The group name
   * @returns A slug string
   */
  private generateSlug(name: string): string {
    return name
      .toLowerCase()
      .replace(/[^\w\s-]/g, "")
      .replace(/[\s_-]+/g, "-")
      .replace(/^-+|-+$/g, "");
  }

  /**
   * Updates the group name and regenerates the slug
   * @param name The new group name
   */
  updateName(name: string): void {
    this.name = name;
    this.slug = this.generateSlug(name);
    this.updatedAt = new Date();
  }

  /**
   * Updates the group description
   * @param description The new group description
   */
  updateDescription(description: string | null): void {
    this.description = description;
    this.updatedAt = new Date();
  }

  /**
   * Updates the group profile image URL
   * @param imageUrl The new image URL
   */
  updateImageUrl(imageUrl: string | null): void {
    this.imageUrl = imageUrl;
    this.updatedAt = new Date();
  }

  /**
   * Updates the group banner image URL
   * @param bannerUrl The new banner URL
   */
  updateBannerUrl(bannerUrl: string | null): void {
    this.bannerUrl = bannerUrl;
    this.updatedAt = new Date();
  }

  /**
   * Updates the group visibility
   * @param visibility The new visibility
   */
  updateVisibility(visibility: GroupVisibility): void {
    this.visibility = visibility;
    this.updatedAt = new Date();
  }

  /**
   * Updates the group status
   * @param status The new status
   */
  updateStatus(status: GroupStatus): void {
    this.status = status;
    this.updatedAt = new Date();
  }

  /**
   * Increments the member count
   * @param count The number to increment by
   */
  incrementMemberCount(count = 1): void {
    this.memberCount += count;
    this.updatedAt = new Date();
  }

  /**
   * Decrements the member count
   * @param count The number to decrement by
   */
  decrementMemberCount(count = 1): void {
    this.memberCount = Math.max(0, this.memberCount - count);
    this.updatedAt = new Date();
  }

  /**
   * Checks if the group is public
   * @returns True if the group is public
   */
  isPublic(): boolean {
    return this.visibility === GroupVisibility.PUBLIC;
  }

  /**
   * Checks if the group is private
   * @returns True if the group is private
   */
  isPrivate(): boolean {
    return this.visibility === GroupVisibility.PRIVATE;
  }

  /**
   * Checks if the group is active
   * @returns True if the group is active
   */
  isActive(): boolean {
    return this.status === GroupStatus.ACTIVE;
  }

  /**
   * Checks if the group is archived
   * @returns True if the group is archived
   */
  isArchived(): boolean {
    return this.status === GroupStatus.ARCHIVED;
  }

  /**
   * Checks if the group is suspended
   * @returns True if the group is suspended
   */
  isSuspended(): boolean {
    return this.status === GroupStatus.SUSPENDED;
  }
}



===========================================================
FILE 15: models\community\GroupMember.ts
===========================================================

import { BaseModel } from "../BaseModel";

import { GroupMemberRole } from "./Group";

/**
 * Defines the status of a group membership
 */
export enum MembershipStatus {
  PENDING = "pending",
  APPROVED = "approved",
  REJECTED = "rejected",
  BANNED = "banned",
}

/**
 * Interface defining the structure of a GroupMember
 */
export interface GroupMemberAttributes extends BaseModel {
  groupId: string;
  userId: string;
  role: GroupMemberRole;
  status: MembershipStatus;
  notificationSettings: Record<string, boolean> | null;
  lastActivity: Date | null;
}

/**
 * GroupMember model representing a user's membership in a group.
 * This class handles:
 * 1. GroupMember data structure
 * 2. Validation of membership data
 * 3. Business logic related to group memberships
 * 4. NOT database operations - those belong in GroupMemberRepository
 */
export class GroupMember
  extends BaseModel
  implements Omit<GroupMemberAttributes, keyof BaseModel>
{
  groupId: string;
  userId: string;
  role: GroupMemberRole;
  status: MembershipStatus;
  notificationSettings: Record<string, boolean> | null;
  lastActivity: Date | null;

  constructor(
    data: Partial<GroupMemberAttributes> & { groupId: string; userId: string },
  ) {
    super();
    this.id = data.id || this.generateId();
    this.groupId = data.groupId;
    this.userId = data.userId;
    this.role = data.role || GroupMemberRole.MEMBER;
    this.status = data.status || MembershipStatus.APPROVED;
    this.notificationSettings = data.notificationSettings || {
      posts: true,
      events: true,
      announcements: true,
    };
    this.lastActivity = data.lastActivity || new Date();
    this.createdAt = data.createdAt || new Date();
    this.updatedAt = data.updatedAt || new Date();
  }

  toJSON(): Omit<GroupMemberAttributes, "generateId"> {
    return {
      id: this.id,
      groupId: this.groupId,
      userId: this.userId,
      role: this.role,
      status: this.status,
      notificationSettings: this.notificationSettings,
      lastActivity: this.lastActivity,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt,
    };
  }

  /**
   * Validates the group member data
   * @throws Error if validation fails
   */
  validate(): void {
    if (!this.groupId) {
      throw new Error("Group ID is required");
    }

    if (!this.userId) {
      throw new Error("User ID is required");
    }

    if (!Object.values(GroupMemberRole).includes(this.role)) {
      throw new Error("Invalid role");
    }

    if (!Object.values(MembershipStatus).includes(this.status)) {
      throw new Error("Invalid status");
    }
  }

  /**
   * Update the member's role
   */
  updateRole(role: GroupMemberRole): void {
    this.role = role;
    this.updatedAt = new Date();
  }

  /**
   * Update the membership status
   */
  updateStatus(status: MembershipStatus): void {
    this.status = status;
    this.updatedAt = new Date();
  }

  /**
   * Update notification settings
   */
  updateNotificationSettings(settings: Record<string, boolean>): void {
    this.notificationSettings = {
      ...this.notificationSettings,
      ...settings,
    };
    this.updatedAt = new Date();
  }

  /**
   * Update last activity timestamp
   */
  updateLastActivity(): void {
    this.lastActivity = new Date();
    this.updatedAt = new Date();
  }

  /**
   * Check if member is an admin
   */
  isAdmin(): boolean {
    return this.role === GroupMemberRole.ADMIN;
  }

  /**
   * Check if member is a moderator
   */
  isModerator(): boolean {
    return this.role === GroupMemberRole.MODERATOR;
  }

  /**
   * Check if the member has moderation privileges
   */
  hasModeratorPrivileges(): boolean {
    return this.isModerator() || this.isAdmin();
  }

  /**
   * Check if membership is approved
   */
  isApproved(): boolean {
    return this.status === MembershipStatus.APPROVED;
  }

  /**
   * Check if membership is pending
   */
  isPending(): boolean {
    return this.status === MembershipStatus.PENDING;
  }

  /**
   * Check if user is banned from the group
   */
  isBanned(): boolean {
    return this.status === MembershipStatus.BANNED;
  }

  /**
   * Check if user is rejected from the group
   */
  isRejected(): boolean {
    return this.status === MembershipStatus.REJECTED;
  }

  /**
   * Check if the membership is active (not banned or rejected)
   */
  isActive(): boolean {
    return !this.isBanned() && !this.isRejected();
  }
}



===========================================================
FILE 16: models\discovery\SearchIndex.ts
===========================================================

import { BaseModel } from "../BaseModel";

/**
 * Types of content that can be indexed
 */
export enum IndexedContentType {
  USER = "user",
  POST = "post",
  MEDIA = "media",
  GROUP = "group",
  COMMENT = "comment",
  TAG = "tag",
}

/**
 * Status of an indexed item
 */
export enum IndexStatus {
  PENDING = "pending",
  INDEXED = "indexed",
  FAILED = "failed",
  DELETED = "deleted",
}

/**
 * Interface for search weights for ranking results
 */
export interface SearchWeights {
  /**
   * Relevance score (0-1) - how relevant the content is to the query
   */
  relevance: number;

  /**
   * Recency score (0-1) - how recently the content was created/updated
   * Optional weight, defaulting to 0.5
   */
  recency?: number;

  /**
   * Popularity score (0-1) - how popular the content is
   * Optional weight, defaulting to 0.5
   */
  popularity?: number;

  /**
   * Quality score (0-1) - quality of the content (calculated from various factors)
   * Optional weight, defaulting to 0.5
   */
  quality?: number;
}

/**
 * Interface for indexed content in search
 */
export interface SearchIndexAttributes extends BaseModel {
  /**
   * ID of the indexed content
   */
  contentId: string;

  /**
   * Type of content indexed
   */
  contentType: IndexedContentType;

  /**
   * Primary text used for searching (e.g., post title, user name)
   */
  title: string;

  /**
   * Secondary text used for searching (e.g., post body, user bio)
   */
  description?: string;

  /**
   * Normalized text used for searching (lowercase, no special chars, etc.)
   */
  searchText: string;

  /**
   * User ID who owns this content (if applicable)
   */
  ownerId?: string;

  /**
   * Status of this item in the index
   */
  status: IndexStatus;

  /**
   * When the index was last updated
   */
  lastIndexedAt?: Date;

  /**
   * Tags and categories for this content
   */
  tags: string[];

  /**
   * Weight values for ranking
   */
  weights: SearchWeights;

  /**
   * Error message if indexing failed
   */
  errorMessage?: string;

  /**
   * Language of the content (ISO code)
   */
  language?: string;

  /**
   * When the content was published
   */
  publishedAt?: Date;
}

/**
 * SearchIndex class for content discovery
 *
 * This class is responsible for:
 * 1. Defining the structure of searchable content
 * 2. Generating search text from content
 * 3. Managing search-specific metadata
 * 4. Handling state transitions (indexed, deleted, etc.)
 * 5. NOT handling persistence - that belongs in SearchIndexRepository
 */
export class SearchIndex
  extends BaseModel
  implements Omit<SearchIndexAttributes, keyof BaseModel>
{
  contentId: string;
  contentType: IndexedContentType;
  title: string;
  description?: string;
  searchText: string;
  ownerId?: string;
  status: IndexStatus;
  lastIndexedAt?: Date;
  tags: string[];
  weights: SearchWeights;
  errorMessage?: string;
  language?: string;
  publishedAt?: Date;

  /**
   * Create a new SearchIndex instance
   *
   * @param data Partial data for the search index
   */
  constructor(
    data: Partial<SearchIndexAttributes> & {
      contentId: string;
      contentType: IndexedContentType;
      title: string;
    },
  ) {
    super();
    this.id = data.id || this.generateId();
    this.contentId = data.contentId;
    this.contentType = data.contentType;
    this.title = data.title;
    this.description = data.description;
    this.searchText = data.searchText || this.generateSearchText(data);
    this.ownerId = data.ownerId;
    this.status = data.status || IndexStatus.PENDING;
    this.lastIndexedAt = data.lastIndexedAt;
    this.tags = data.tags || [];
    this.weights = {
      relevance: data.weights?.relevance || 0.5,
      recency: data.weights?.recency || 0.5,
      popularity: data.weights?.popularity || 0.5,
      quality: data.weights?.quality || 0.5,
    };
    this.errorMessage = data.errorMessage;
    this.language = data.language || "en";
    this.publishedAt = data.publishedAt || data.createdAt || new Date();
    this.createdAt = data.createdAt || new Date();
    this.updatedAt = data.updatedAt || new Date();
  }

  /**
   * Convert the model to a plain object for serialization
   *
   * @returns A plain object representation of the search index
   */
  toJSON(): Omit<SearchIndexAttributes, "generateId"> {
    return {
      id: this.id,
      contentId: this.contentId,
      contentType: this.contentType,
      title: this.title,
      description: this.description,
      searchText: this.searchText,
      ownerId: this.ownerId,
      status: this.status,
      lastIndexedAt: this.lastIndexedAt,
      tags: this.tags,
      weights: this.weights,
      errorMessage: this.errorMessage,
      language: this.language,
      publishedAt: this.publishedAt,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt,
    };
  }

  /**
   * Validate the search index data
   *
   * @throws Error if validation fails
   */
  validate(): void {
    if (!this.contentId) {
      throw new Error("Content ID is required");
    }

    if (!this.contentType) {
      throw new Error("Content type is required");
    }

    if (!this.title) {
      throw new Error("Title is required");
    }

    if (!Object.values(IndexedContentType).includes(this.contentType)) {
      throw new Error("Invalid content type");
    }

    if (!Object.values(IndexStatus).includes(this.status)) {
      throw new Error("Invalid status");
    }

    if (this.weights.relevance < 0 || this.weights.relevance > 1) {
      throw new Error("Relevance weight must be between 0 and 1");
    }
  }

  /**
   * Generate search text from title, description, and tags
   * This normalizes the text for better searching
   *
   * @param data The data to generate search text from
   * @returns Normalized search text
   */
  private generateSearchText(data: Partial<SearchIndexAttributes>): string {
    const parts: string[] = [];

    if (data.title) {
      parts.push(data.title.toLowerCase());
    }

    if (data.description) {
      parts.push(data.description.toLowerCase());
    }

    if (data.tags && data.tags.length > 0) {
      parts.push(data.tags.join(" ").toLowerCase());
    }

    return parts
      .join(" ")
      .replace(/[^\w\s]/g, " ")
      .replace(/\s+/g, " ")
      .trim();
  }

  /**
   * Mark the item as indexed
   */
  markAsIndexed(): void {
    this.status = IndexStatus.INDEXED;
    this.lastIndexedAt = new Date();
    this.errorMessage = undefined;
    this.updatedAt = new Date();
  }

  /**
   * Mark the item as failed
   *
   * @param errorMessage Optional error message
   */
  markAsFailed(errorMessage?: string): void {
    this.status = IndexStatus.FAILED;
    this.errorMessage = errorMessage;
    this.updatedAt = new Date();
  }

  /**
   * Mark the item as deleted
   */
  markAsDeleted(): void {
    this.status = IndexStatus.DELETED;
    this.updatedAt = new Date();
  }

  /**
   * Update content metadata
   *
   * @param title Optional new title
   * @param description Optional new description
   */
  updateContent(title?: string, description?: string): void {
    let changed = false;

    if (title !== undefined && title !== this.title) {
      this.title = title;
      changed = true;
    }

    if (description !== undefined && description !== this.description) {
      this.description = description;
      changed = true;
    }

    if (changed) {
      this.searchText = this.generateSearchText(this);
      this.status = IndexStatus.PENDING;
      this.updatedAt = new Date();
    }
  }

  /**
   * Add tags to the index
   *
   * @param newTags Tags to add
   */
  addTags(newTags: string[]): void {
    if (!newTags.length) return;

    const uniqueNewTags = newTags.filter((tag) => !this.tags.includes(tag));

    if (uniqueNewTags.length > 0) {
      this.tags = [...this.tags, ...uniqueNewTags];
      this.searchText = this.generateSearchText(this);
      this.status = IndexStatus.PENDING;
      this.updatedAt = new Date();
    }
  }

  /**
   * Remove tags from the index
   *
   * @param tagsToRemove Tags to remove
   */
  removeTags(tagsToRemove: string[]): void {
    if (!tagsToRemove.length) return;

    const initialLength = this.tags.length;
    this.tags = this.tags.filter((tag) => !tagsToRemove.includes(tag));

    if (this.tags.length !== initialLength) {
      this.searchText = this.generateSearchText(this);
      this.status = IndexStatus.PENDING;
      this.updatedAt = new Date();
    }
  }

  /**
   * Update relevance weight
   *
   * @param relevance New relevance score (0-1)
   */
  updateRelevance(relevance: number): void {
    this.weights.relevance = Math.max(0, Math.min(1, relevance));
    this.updatedAt = new Date();
  }

  /**
   * Update all weights at once
   *
   * @param weights New weights to apply
   */
  updateWeights(weights: Partial<SearchWeights>): void {
    if (weights.relevance !== undefined) {
      this.weights.relevance = Math.max(0, Math.min(1, weights.relevance));
    }

    if (weights.recency !== undefined) {
      this.weights.recency = Math.max(0, Math.min(1, weights.recency));
    }

    if (weights.popularity !== undefined) {
      this.weights.popularity = Math.max(0, Math.min(1, weights.popularity));
    }

    if (weights.quality !== undefined) {
      this.weights.quality = Math.max(0, Math.min(1, weights.quality));
    }

    this.updatedAt = new Date();
  }

  /**
   * Update the language
   *
   * @param language The ISO language code
   */
  updateLanguage(language: string): void {
    this.language = language;
    this.updatedAt = new Date();
  }

  /**
   * Check if the index is pending
   *
   * @returns True if the status is pending
   */
  isPending(): boolean {
    return this.status === IndexStatus.PENDING;
  }

  /**
   * Check if the index is indexed
   *
   * @returns True if the status is indexed
   */
  isIndexed(): boolean {
    return this.status === IndexStatus.INDEXED;
  }

  /**
   * Check if the index is deleted
   *
   * @returns True if the status is deleted
   */
  isDeleted(): boolean {
    return this.status === IndexStatus.DELETED;
  }

  /**
   * Check if the index failed
   *
   * @returns True if the status is failed
   */
  isFailed(): boolean {
    return this.status === IndexStatus.FAILED;
  }
}



===========================================================
FILE 17: models\index.ts
===========================================================

// Auth models

import { ActivityLog } from "./analytics/ActivityLog";
import { PasswordResetToken } from "./auth/PasswordResetToken";
import { Permission } from "./auth/Permission";
import { Role } from "./auth/Role";
import { RolePermission } from "./auth/RolePermission";
import { Token } from "./auth/Token";
import { User } from "./auth/User";
import { UserRole } from "./auth/UserRole";
// Social models
import { Group } from "./community/Group";
import { GroupMember } from "./community/GroupMember";
import { SearchIndex } from "./discovery/SearchIndex";
import { Media } from "./media/Media";
import { MediaCollection } from "./media/MediaCollection";
import { MediaTag } from "./media/MediaTag";
import { Conversation } from "./messaging/Conversation";
import { Message } from "./messaging/Message";
import { ContentReport } from "./moderation/ContentReport";
import { ModerationAction } from "./moderation/ModerationAction";
import { Bookmark } from "./social/Bookmark";
import { Comment } from "./social/Comment";
import { CommentLike } from "./social/CommentLike";
import { Follow } from "./social/Follow";
import { Hashtag } from "./social/Hashtag";
import { Like } from "./social/Like";
import { Notification } from "./social/Notification";
// eslint-disable-next-line import/order
import { Post } from "./social/Post";
// Media models
// Analytics models
// Community models
// Discovery models
// Moderation models

// Messaging models

export {
  // Auth models
  User,
  Role,
  Token,
  UserRole,
  Permission,
  RolePermission,
  PasswordResetToken,

  // Social models
  Comment as CommentModel,
  CommentLike as CommentLikeModel,
  Follow as FollowModel,
  Like as LikeModel,
  Post as PostModel,
  Bookmark as BookmarkModel,
  Hashtag as HashtagModel,
  Notification as NotificationModel,

  // Media models
  Media,
  MediaCollection,
  MediaTag,

  // Analytics models
  ActivityLog,

  // Community models
  Group,
  GroupMember,

  // Discovery models
  SearchIndex,

  // Moderation models
  ContentReport,
  ModerationAction,

  // Messaging models
  Conversation,
  Message,
};



===========================================================
FILE 18: models\media\Media.ts
===========================================================

import { mediaRepository } from "../../repositories/media/MediaRepository";
import { BaseModel } from "../BaseModel";

// Media types
export enum MediaType {
  IMAGE = "image",
  VIDEO = "video",
  AUDIO = "audio",
}

// Supported formats for each media type
export enum MediaFormat {
  // Image formats
  JPEG = "jpeg",
  PNG = "png",
  GIF = "gif",
  WEBP = "webp",
  SVG = "svg",
  TIFF = "tiff",
  BMP = "bmp",

  // Video formats
  MP4 = "mp4",
  WEBM = "webm",
  MOV = "mov",
  AVI = "avi",
  MKV = "mkv",

  // Audio formats
  MP3 = "mp3",
  WAV = "wav",
  OGG = "ogg",
  AAC = "aac",
  FLAC = "flac",
}

// MIME types mapping
export const MIME_TYPES: Record<MediaFormat, string> = {
  // Image MIME types
  [MediaFormat.JPEG]: "image/jpeg",
  [MediaFormat.PNG]: "image/png",
  [MediaFormat.GIF]: "image/gif",
  [MediaFormat.WEBP]: "image/webp",
  [MediaFormat.SVG]: "image/svg+xml",
  [MediaFormat.TIFF]: "image/tiff",
  [MediaFormat.BMP]: "image/bmp",

  // Video MIME types
  [MediaFormat.MP4]: "video/mp4",
  [MediaFormat.WEBM]: "video/webm",
  [MediaFormat.MOV]: "video/quicktime",
  [MediaFormat.AVI]: "video/x-msvideo",
  [MediaFormat.MKV]: "video/x-matroska",

  // Audio MIME types
  [MediaFormat.MP3]: "audio/mpeg",
  [MediaFormat.WAV]: "audio/wav",
  [MediaFormat.OGG]: "audio/ogg",
  [MediaFormat.AAC]: "audio/aac",
  [MediaFormat.FLAC]: "audio/flac",
};

export enum MediaStatus {
  PENDING = "pending",
  PROCESSING = "processing",
  COMPLETED = "completed",
  FAILED = "failed",
}

export enum MediaPrivacy {
  PUBLIC = "public",
  PRIVATE = "private",
  FRIENDS = "friends",
}

// Video chapters interface
export interface VideoChapter {
  timestamp: number;
  title: string;
  description?: string;
}

// Base media attributes
export interface MediaAttributes extends BaseModel {
  userId: string;
  type: MediaType;
  originalFilename: string;
  filename: string;
  path: string;
  mimeType: string;
  size: number;
  width: number | null;
  height: number | null;
  duration: number | null;
  thumbnailPath: string | null;
  processingStatus: MediaStatus;
  isPublic: boolean;

  // Common fields that were in VideoMedia
  title?: string;
  description?: string | null;
  tags?: string[] | null;

  // Type-specific metadata stored as JSON
  metadata?: {
    // Image-specific metadata
    aspectRatio?: number | null;
    format?: string | null;
    colorProfile?: string | null;
    altText?: string | null;
    filters?: string[] | null;
    editInformation?: Record<string, unknown> | null;

    // Video-specific metadata
    chapters?: VideoChapter[] | null;
    orientation?: "portrait" | "landscape" | "square";
    caption?: string | null;
    hasAudio?: boolean;
    visibility?: "public" | "unlisted" | "private";
    allowComments?: boolean;

    // Audio-specific metadata could be added here in the future
    bitrate?: number;
    sampleRate?: number;
    channels?: number;
  };
}

export class Media
  extends BaseModel
  implements Omit<MediaAttributes, keyof BaseModel>
{
  userId: string;
  type: MediaType;
  originalFilename: string;
  filename: string;
  path: string;
  mimeType: string;
  size: number;
  width: number | null;
  height: number | null;
  duration: number | null;
  thumbnailPath: string | null;
  processingStatus: MediaStatus;
  isPublic: boolean;

  // Common fields
  title?: string;
  description?: string | null;
  tags?: string[] | null;

  // Type-specific metadata
  metadata: NonNullable<MediaAttributes["metadata"]>;

  constructor(
    data: Partial<MediaAttributes> & { userId: string; type: MediaType },
  ) {
    super();
    this.userId = data.userId;
    this.type = data.type || MediaType.IMAGE;
    this.originalFilename = data.originalFilename || "";
    this.filename = data.filename || "";
    this.path = data.path || "";
    this.mimeType = data.mimeType || "";
    this.size = data.size || 0;
    this.width = data.width || null;
    this.height = data.height || null;
    this.duration = data.duration || null;
    this.thumbnailPath = data.thumbnailPath || null;
    this.processingStatus = data.processingStatus || MediaStatus.PENDING;
    this.isPublic = data.isPublic || false;

    // Common fields
    this.title = data.title;
    this.description = data.description || null;
    this.tags = data.tags || null;

    // Initialize metadata
    this.metadata = data.metadata || {};

    // Set default metadata based on media type
    if (this.type === MediaType.IMAGE) {
      this.metadata = {
        ...this.metadata,
        aspectRatio: this.metadata.aspectRatio || this.calculateAspectRatio(),
        format: this.metadata.format || null,
        colorProfile: this.metadata.colorProfile || null,
        altText: this.metadata.altText || null,
        filters: this.metadata.filters || null,
        editInformation: this.metadata.editInformation || null,
      };
    } else if (this.type === MediaType.VIDEO) {
      this.metadata = {
        ...this.metadata,
        chapters: this.metadata.chapters || null,
        orientation: this.metadata.orientation || this.calculateOrientation(),
        caption: this.metadata.caption || null,
        hasAudio:
          this.metadata.hasAudio !== undefined ? this.metadata.hasAudio : true,
        visibility: this.metadata.visibility || "private",
        allowComments:
          this.metadata.allowComments !== undefined
            ? this.metadata.allowComments
            : true,
      };
    } else if (this.type === MediaType.AUDIO) {
      this.metadata = {
        ...this.metadata,
        bitrate: this.metadata.bitrate || undefined,
        sampleRate: this.metadata.sampleRate || undefined,
        channels: this.metadata.channels || undefined,
      };
    }
  }

  /**
   * Check if media is an image
   */
  get isImage(): boolean {
    return this.type === MediaType.IMAGE;
  }

  /**
   * Check if media is a video
   */
  get isVideo(): boolean {
    return this.type === MediaType.VIDEO;
  }

  /**
   * Check if media is an audio file
   */
  get isAudio(): boolean {
    return this.type === MediaType.AUDIO;
  }

  /**
   * Calculate aspect ratio from dimensions
   */
  calculateAspectRatio(): number | null {
    if (this.width && this.height && this.height > 0) {
      return parseFloat((this.width / this.height).toFixed(2));
    }
    return null;
  }

  /**
   * Calculate video orientation based on dimensions
   */
  calculateOrientation(): "portrait" | "landscape" | "square" {
    if (!this.width || !this.height) {
      return "portrait"; // Default to portrait if dimensions not available
    }

    if (this.width > this.height) {
      return "landscape";
    } else if (this.height > this.width) {
      return "portrait";
    } else {
      return "square";
    }
  }

  /**
   * Create a new media item
   */
  static async create(
    data: Omit<MediaAttributes, "id" | "createdAt" | "updatedAt">,
  ): Promise<Media> {
    const mediaData: Omit<MediaAttributes, "id" | "createdAt" | "updatedAt"> = {
      ...data,
      userId: data.userId,
      type: data.type,
      originalFilename: data.originalFilename,
      filename: data.filename,
      path: data.path,
      mimeType: data.mimeType,
      size: data.size,
      width: data.width,
      height: data.height,
      duration: data.duration,
      thumbnailPath: data.thumbnailPath,
      processingStatus: data.processingStatus,
      isPublic: data.isPublic,
    };
    const media = await mediaRepository.create(mediaData);
    return new Media(media);
  }

  /**
   * Find public media
   */
  static async findPublic(limit = 20, offset = 0): Promise<Media[]> {
    return mediaRepository.findPublic(limit, offset);
  }

  /**
   * Find media by user ID
   */
  static async findByUserId(
    userId: string,
    limit = 20,
    offset = 0,
    type?: MediaType,
  ): Promise<Media[]> {
    return mediaRepository.findByUserId(userId, type, limit, offset);
  }

  /**
   * Find media by type
   */
  static async findByType(
    type: MediaType,
    limit = 20,
    offset = 0,
  ): Promise<Media[]> {
    return mediaRepository.findByType(type, limit, offset);
  }

  /**
   * Find media by ID
   */
  static async findById(id: string): Promise<Media | null> {
    return mediaRepository.findById(id);
  }

  /**
   * Update a media item
   */
  async update(data: Partial<MediaAttributes>): Promise<Media> {
    const updateData = {
      ...data,
      ...(data.userId !== undefined && { user_id: data.userId }),
      ...(data.originalFilename !== undefined && {
        original_filename: data.originalFilename,
      }),
      ...(data.thumbnailPath !== undefined && {
        thumbnail_path: data.thumbnailPath,
      }),
      ...(data.processingStatus !== undefined && {
        processing_status: data.processingStatus,
      }),
      ...(data.isPublic !== undefined && { is_public: data.isPublic }),
    };
    const updated = await mediaRepository.update(
      this.id,
      updateData as Partial<MediaAttributes>,
    );
    if (updated) {
      Object.assign(this, updated);
    }
    return this;
  }

  /**
   * Delete a media item
   */
  async delete(): Promise<boolean> {
    return mediaRepository.delete(this.id);
  }

  // Image-specific methods
  /**
   * Set alt text for the image
   */
  setAltText(text: string): void {
    if (!this.isImage) return;
    this.metadata.altText = text;
  }

  /**
   * Check if the image has high enough resolution for printing
   */
  isPrintQuality(minimumDpi: number = 300): boolean {
    if (!this.isImage) return false;
    return !!(
      this.width &&
      this.height &&
      this.width >= minimumDpi &&
      this.height >= minimumDpi
    );
  }

  // Video-specific methods
  /**
   * Add a chapter to the video
   */
  addChapter(chapter: VideoChapter): void {
    if (!this.isVideo) return;
    if (!this.metadata.chapters) {
      this.metadata.chapters = [];
    }
    this.metadata.chapters.push(chapter);
    // Sort chapters by timestamp
    this.metadata.chapters.sort((a, b) => a.timestamp - b.timestamp);
  }

  /**
   * Remove a chapter from the video
   */
  removeChapter(timestamp: number): void {
    if (!this.isVideo || !this.metadata.chapters) return;
    this.metadata.chapters = this.metadata.chapters.filter(
      (chapter) => chapter.timestamp !== timestamp,
    );
  }

  /**
   * Manage tags for any media type
   */
  manageTags(tags: string[], operation: "add" | "remove"): void {
    if (!this.tags) {
      this.tags = [];
    }

    if (operation === "add") {
      tags.forEach((tag) => {
        if (this.tags && !this.tags.includes(tag)) {
          this.tags.push(tag);
        }
      });
    } else {
      this.tags = this.tags.filter((tag) => !tags.includes(tag));
    }
  }

  /**
   * Set caption for video
   */
  setCaption(text: string): void {
    if (!this.isVideo) return;
    this.metadata.caption = text;
  }

  /**
   * Toggle audio setting for video
   */
  toggleAudio(): void {
    if (!this.isVideo) return;
    this.metadata.hasAudio = !this.metadata.hasAudio;
  }

  /**
   * Set video visibility and update isPublic accordingly
   */
  setVisibility(visibility: "public" | "unlisted" | "private"): void {
    if (!this.isVideo) return;
    this.metadata.visibility = visibility;
    // If setting to public, also update the isPublic flag
    this.isPublic = visibility === "public";
  }

  /**
   * Validates the media format and MIME type
   * @throws {Error} If format validation fails
   */
  public validateFormat(): void {
    const format = this.getFormatFromMimeType();
    if (!format) {
      throw new Error("Unsupported MIME type");
    }

    // Validate format against media type
    switch (this.type) {
      case MediaType.IMAGE:
        if (
          !Object.values(MediaFormat).some((f) =>
            ["jpeg", "png", "gif", "webp", "svg", "tiff", "bmp"].includes(f),
          )
        ) {
          throw new Error("Invalid image format");
        }
        break;
      case MediaType.VIDEO:
        if (
          !Object.values(MediaFormat).some((f) =>
            ["mp4", "webm", "mov", "avi", "mkv"].includes(f),
          )
        ) {
          throw new Error("Invalid video format");
        }
        break;
      case MediaType.AUDIO:
        if (
          !Object.values(MediaFormat).some((f) =>
            ["mp3", "wav", "ogg", "aac", "flac"].includes(f),
          )
        ) {
          throw new Error("Invalid audio format");
        }
        break;
    }
  }

  /**
   * Get format from MIME type
   * @returns The media format or null if not found
   */
  private getFormatFromMimeType(): MediaFormat | null {
    const format = Object.entries(MIME_TYPES).find(
      ([_, mime]) => mime === this.mimeType,
    );
    return format ? (format[0] as MediaFormat) : null;
  }

  /**
   * Validates the media data before saving
   * @throws {Error} If validation fails
   */
  public validate(): void {
    if (!this.userId) {
      throw new Error("User ID is required");
    }
    if (!this.type) {
      throw new Error("Media type is required");
    }
    if (!this.originalFilename) {
      throw new Error("Original filename is required");
    }
    if (!this.filename) {
      throw new Error("Filename is required");
    }
    if (!this.path) {
      throw new Error("File path is required");
    }
    if (!this.mimeType) {
      throw new Error("MIME type is required");
    }
    if (typeof this.size !== "number" || this.size <= 0) {
      throw new Error("Valid file size is required");
    }
    if (
      this.width !== undefined &&
      (typeof this.width !== "number" || this.width <= 0)
    ) {
      throw new Error("Width must be a positive number");
    }
    if (
      this.height !== undefined &&
      (typeof this.height !== "number" || this.height <= 0)
    ) {
      throw new Error("Height must be a positive number");
    }
    if (
      this.duration !== undefined &&
      (typeof this.duration !== "number" || this.duration < 0)
    ) {
      throw new Error("Duration must be a non-negative number");
    }
    if (!Object.values(MediaStatus).includes(this.processingStatus)) {
      throw new Error("Invalid processing status");
    }
    if (typeof this.isPublic !== "boolean") {
      throw new Error("isPublic must be a boolean");
    }

    // Validate format and MIME type
    this.validateFormat();
  }

  /**
   * Validates type-specific metadata
   * @throws {Error} If metadata validation fails
   */
  public validateMetadata(): void {
    switch (this.type) {
      case MediaType.IMAGE:
        if (
          this.metadata.aspectRatio &&
          (typeof this.metadata.aspectRatio !== "number" ||
            this.metadata.aspectRatio <= 0)
        ) {
          throw new Error("Invalid aspect ratio for image");
        }
        if (this.metadata.format && typeof this.metadata.format !== "string") {
          throw new Error("Invalid format for image");
        }
        break;
      case MediaType.VIDEO:
        if (
          this.metadata.orientation &&
          !["landscape", "portrait", "square"].includes(
            this.metadata.orientation,
          )
        ) {
          throw new Error("Invalid orientation for video");
        }
        if (
          this.metadata.hasAudio !== undefined &&
          typeof this.metadata.hasAudio !== "boolean"
        ) {
          throw new Error("hasAudio must be a boolean for video");
        }
        break;
      case MediaType.AUDIO:
        if (
          this.metadata.bitrate &&
          (typeof this.metadata.bitrate !== "number" ||
            this.metadata.bitrate <= 0)
        ) {
          throw new Error("Invalid bitrate for audio");
        }
        if (
          this.metadata.channels &&
          (typeof this.metadata.channels !== "number" ||
            this.metadata.channels <= 0)
        ) {
          throw new Error("Invalid number of channels for audio");
        }
        break;
    }
  }
}

export default Media;



===========================================================
FILE 19: models\media\MediaCollection.ts
===========================================================

import { BaseModel } from "../BaseModel";

export enum CollectionType {
  GALLERY = "gallery",
  FOLDER = "folder",
}

export enum CollectionPrivacy {
  PUBLIC = "public",
  PRIVATE = "private",
}

export interface MediaCollectionAttributes {
  id: string;
  userId: string;
  title: string;
  description: string | null;
  type: CollectionType;
  privacy: CollectionPrivacy;
  coverMediaId: string | null;
  mediaIds: string[];
  sortOrder?: string | null;
  metadata?: Record<string, unknown> | null;
  isOfficial?: boolean;
  itemCount: number;
  isDeleted?: boolean;
  createdAt: Date;
  updatedAt: Date;
}

export class MediaCollection
  extends BaseModel
  implements MediaCollectionAttributes
{
  id: string;
  userId: string;
  title: string;
  description: string | null;
  type: CollectionType;
  privacy: CollectionPrivacy;
  coverMediaId: string | null;
  mediaIds: string[];
  sortOrder: string | null;
  metadata: Record<string, unknown> | null;
  isOfficial: boolean;
  itemCount: number;
  isDeleted: boolean;
  createdAt: Date;
  updatedAt: Date;

  constructor(
    data: Partial<MediaCollectionAttributes> & {
      userId: string;
      title: string;
      type: CollectionType;
    },
  ) {
    super();
    this.id = data.id || this.generateId();
    this.userId = data.userId;
    this.title = data.title;
    this.description = data.description || null;
    this.type = data.type;
    this.privacy = data.privacy || CollectionPrivacy.PRIVATE;
    this.coverMediaId = data.coverMediaId || null;
    this.mediaIds = data.mediaIds || [];
    this.sortOrder = data.sortOrder || null;
    this.metadata = data.metadata || null;
    this.isOfficial = data.isOfficial || false;
    this.itemCount =
      data.itemCount !== undefined ? data.itemCount : this.mediaIds.length;
    this.isDeleted = data.isDeleted || false;
    this.createdAt = data.createdAt || new Date();
    this.updatedAt = data.updatedAt || new Date();
  }

  /**
   * Convert object to JSON representation
   */
  toJSON(): MediaCollectionAttributes {
    return {
      id: this.id,
      userId: this.userId,
      title: this.title,
      description: this.description,
      type: this.type,
      privacy: this.privacy,
      coverMediaId: this.coverMediaId,
      mediaIds: this.mediaIds,
      sortOrder: this.sortOrder,
      metadata: this.metadata,
      isOfficial: this.isOfficial,
      itemCount: this.itemCount,
      isDeleted: this.isDeleted,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt,
    };
  }

  /**
   * Validates the collection data before saving
   * @throws {Error} If validation fails
   */
  validate(): void {
    if (!this.userId) {
      throw new Error("User ID is required");
    }
    if (!this.title) {
      throw new Error("Title is required");
    }
    if (this.title.length < 2) {
      throw new Error("Title must be at least 2 characters long");
    }
    if (this.title.length > 100) {
      throw new Error("Title cannot exceed 100 characters");
    }
    if (!Object.values(CollectionType).includes(this.type)) {
      throw new Error("Invalid collection type");
    }
    if (!Object.values(CollectionPrivacy).includes(this.privacy)) {
      throw new Error("Invalid privacy setting");
    }

    // Validate media IDs are unique
    const uniqueMediaIds = [...new Set(this.mediaIds)];
    if (uniqueMediaIds.length !== this.mediaIds.length) {
      this.mediaIds = uniqueMediaIds;
    }

    if (this.coverMediaId && !this.mediaIds.includes(this.coverMediaId)) {
      throw new Error("Cover media must be part of the collection");
    }
  }

  /**
   * Check if the collection is empty
   */
  isEmpty(): boolean {
    return this.mediaIds.length === 0;
  }

  /**
   * Add a media item to the collection
   */
  addMedia(mediaId: string): void {
    if (!this.mediaIds.includes(mediaId)) {
      this.mediaIds.push(mediaId);
      this.itemCount = this.mediaIds.length;
      this.updatedAt = new Date();
    }
  }

  /**
   * Remove a media item from the collection
   */
  removeMedia(mediaId: string): void {
    const initialLength = this.mediaIds.length;
    this.mediaIds = this.mediaIds.filter((id) => id !== mediaId);

    if (this.mediaIds.length !== initialLength) {
      this.itemCount = this.mediaIds.length;
      this.updatedAt = new Date();

      // If removed media was cover, reset cover
      if (this.coverMediaId === mediaId) {
        this.coverMediaId = this.mediaIds.length > 0 ? this.mediaIds[0] : null;
      }
    }
  }

  /**
   * Set the cover media
   */
  setCoverMedia(mediaId: string | null): void {
    if (mediaId && !this.mediaIds.includes(mediaId)) {
      throw new Error("Cover media must be part of the collection");
    }
    this.coverMediaId = mediaId;
    this.updatedAt = new Date();
  }

  /**
   * Update collection privacy
   */
  setPrivacy(privacy: CollectionPrivacy): void {
    this.privacy = privacy;
    this.updatedAt = new Date();
  }

  /**
   * Mark collection as deleted
   */
  markAsDeleted(): void {
    this.isDeleted = true;
    this.updatedAt = new Date();
  }

  /**
   * Restore deleted collection
   */
  restore(): void {
    this.isDeleted = false;
    this.updatedAt = new Date();
  }

  /**
   * Update the sort order of media items
   */
  updateSortOrder(sortOrder: string): void {
    this.sortOrder = sortOrder;
    this.updatedAt = new Date();
  }
}



===========================================================
FILE 20: models\media\MediaTag.ts
===========================================================

import { BaseModel } from "../BaseModel";

export interface MediaTagAttributes {
  id: string;
  name: string;
  slug: string;
  description?: string | null;
  category: string | null;
  isOfficial?: boolean;
  usageCount: number;
  parentTagId?: string | null;
  createdAt: Date;
  updatedAt: Date;
}

export class MediaTag extends BaseModel implements MediaTagAttributes {
  id: string;
  name: string;
  slug: string;
  description: string | null;
  category: string | null;
  isOfficial: boolean;
  usageCount: number;
  parentTagId: string | null;
  createdAt: Date;
  updatedAt: Date;

  constructor(data: Partial<MediaTagAttributes> & { name: string }) {
    super();
    this.id = data.id || this.generateId();
    this.name = data.name;
    this.slug = data.slug || this.generateSlug(data.name);
    this.description = data.description || null;
    this.category = data.category || null;
    this.isOfficial = data.isOfficial || false;
    this.usageCount = data.usageCount || 0;
    this.parentTagId = data.parentTagId || null;
    this.createdAt = data.createdAt || new Date();
    this.updatedAt = data.updatedAt || new Date();
  }

  /**
   * Convert object to JSON representation
   */
  toJSON(): MediaTagAttributes {
    return {
      id: this.id,
      name: this.name,
      slug: this.slug,
      description: this.description,
      category: this.category,
      isOfficial: this.isOfficial,
      usageCount: this.usageCount,
      parentTagId: this.parentTagId,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt,
    };
  }

  /**
   * Validates the tag data before saving
   * @throws {Error} If validation fails
   */
  validate(): void {
    if (!this.name) {
      throw new Error("Tag name is required");
    }
    if (this.name.length < 2) {
      throw new Error("Tag name must be at least 2 characters long");
    }
    if (this.name.length > 50) {
      throw new Error("Tag name cannot exceed 50 characters");
    }
    if (!this.slug) {
      throw new Error("Tag slug is required");
    }
    if (this.description && this.description.length > 500) {
      throw new Error("Tag description cannot exceed 500 characters");
    }
    if (this.usageCount < 0) {
      this.usageCount = 0; // Automatically correct negative usage counts
    }
  }

  /**
   * Generate a URL-friendly slug from the tag name
   */
  private generateSlug(name: string): string {
    return name
      .toLowerCase()
      .replace(/[^\w\s-]/g, "") // Remove non-word chars
      .replace(/[\s_-]+/g, "-") // Replace spaces, underscores, and hyphens with a single hyphen
      .replace(/^-+|-+$/g, ""); // Trim hyphens from both ends
  }

  /**
   * Increment usage count
   */
  incrementUsage(count: number = 1): void {
    this.usageCount += count;
    this.updatedAt = new Date();
  }

  /**
   * Decrement usage count
   */
  decrementUsage(count: number = 1): void {
    this.usageCount = Math.max(0, this.usageCount - count);
    this.updatedAt = new Date();
  }

  /**
   * Update tag name and regenerate slug
   */
  updateName(name: string): void {
    this.name = name;
    this.slug = this.generateSlug(name);
    this.updatedAt = new Date();
  }

  /**
   * Set tag category
   */
  setCategory(category: string): void {
    this.category = category;
    this.updatedAt = new Date();
  }

  /**
   * Set description for the tag
   */
  setDescription(description: string | null): void {
    this.description = description;
    this.updatedAt = new Date();
  }

  /**
   * Set official status for the tag
   */
  setOfficial(isOfficial: boolean): void {
    this.isOfficial = isOfficial;
    this.updatedAt = new Date();
  }

  /**
   * Set parent tag ID for hierarchical tagging
   */
  setParentTag(parentTagId: string | null): void {
    this.parentTagId = parentTagId;
    this.updatedAt = new Date();
  }

  /**
   * Check if tag is a parent tag
   */
  isParentTag(): boolean {
    return this.parentTagId === null;
  }

  /**
   * Check if tag is a child tag
   */
  isChildTag(): boolean {
    return this.parentTagId !== null;
  }
}



===========================================================
FILE 21: models\messaging\Conversation.ts
===========================================================

import { BaseModel } from "../BaseModel";

export enum ConversationType {
  DIRECT = "direct",
  GROUP = "group",
}

export enum ConversationStatus {
  ACTIVE = "active",
  ARCHIVED = "archived",
  MUTED = "muted",
  BLOCKED = "blocked",
}

export enum ParticipantRole {
  ADMIN = "admin",
  MEMBER = "member",
}

export interface Participant {
  userId: string;
  role: ParticipantRole;
  joinedAt: Date;
}

export interface ConversationAttributes extends BaseModel {
  title: string | null;
  type: ConversationType;
  participantIds: string[];
  participantDetails?: Participant[] | null; // Optional detailed participant info
  creatorId: string;
  lastMessageId: string | null;
  lastMessageSentAt: Date | null;
  status: ConversationStatus;
  isEncrypted: boolean;
  metadata: Record<string, unknown> | null;
  isReadOnly?: boolean;
  maxParticipants?: number | null;
}

export class Conversation
  extends BaseModel
  implements Omit<ConversationAttributes, keyof BaseModel>
{
  title: string | null;
  type: ConversationType;
  participantIds: string[];
  participantDetails: Participant[] | null;
  creatorId: string;
  lastMessageId: string | null;
  lastMessageSentAt: Date | null;
  status: ConversationStatus;
  isEncrypted: boolean;
  metadata: Record<string, unknown> | null;
  isReadOnly: boolean;
  maxParticipants: number | null;

  constructor(
    data: Partial<ConversationAttributes> & {
      creatorId: string;
      participantIds: string[];
    },
  ) {
    super();
    this.id = data.id || this.generateId();
    this.title = data.title || null;
    this.type = data.type || ConversationType.DIRECT;
    this.participantIds = [...data.participantIds];
    this.participantDetails = data.participantDetails || null;
    this.creatorId = data.creatorId;
    this.lastMessageId = data.lastMessageId || null;
    this.lastMessageSentAt = data.lastMessageSentAt || null;
    this.status = data.status || ConversationStatus.ACTIVE;
    this.isEncrypted =
      data.isEncrypted !== undefined ? data.isEncrypted : false;
    this.metadata = data.metadata || null;
    this.isReadOnly = data.isReadOnly || false;
    this.maxParticipants = data.maxParticipants || null;
    this.createdAt = data.createdAt || new Date();
    this.updatedAt = data.updatedAt || new Date();
  }

  /**
   * Convert object to JSON representation
   */
  toJSON(): Omit<ConversationAttributes, "generateId"> {
    return {
      id: this.id,
      title: this.title,
      type: this.type,
      participantIds: this.participantIds,
      participantDetails: this.participantDetails,
      creatorId: this.creatorId,
      lastMessageId: this.lastMessageId,
      lastMessageSentAt: this.lastMessageSentAt,
      status: this.status,
      isEncrypted: this.isEncrypted,
      metadata: this.metadata,
      isReadOnly: this.isReadOnly,
      maxParticipants: this.maxParticipants,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt,
    };
  }

  /**
   * Validates the conversation data
   * @throws {Error} If validation fails
   */
  validate(): void {
    if (!this.creatorId) {
      throw new Error("Creator ID is required");
    }

    if (
      !Array.isArray(this.participantIds) ||
      this.participantIds.length === 0
    ) {
      throw new Error("At least one participant is required");
    }

    if (!Object.values(ConversationType).includes(this.type)) {
      throw new Error("Invalid conversation type");
    }

    if (!Object.values(ConversationStatus).includes(this.status)) {
      throw new Error("Invalid conversation status");
    }

    // Direct messages must have exactly 2 participants
    if (
      this.type === ConversationType.DIRECT &&
      this.participantIds.length !== 2
    ) {
      throw new Error(
        "Direct conversations must have exactly two participants",
      );
    }

    // Check maximum participants if specified
    if (
      this.maxParticipants !== null &&
      this.participantIds.length > this.maxParticipants
    ) {
      throw new Error(
        `Maximum number of participants (${this.maxParticipants}) exceeded`,
      );
    }

    // Make sure creator is a participant
    if (!this.participantIds.includes(this.creatorId)) {
      throw new Error("Creator must be a participant in the conversation");
    }

    // Validate participant details if present
    if (this.participantDetails) {
      // Ensure all participantIds have a matching detail entry
      const detailUserIds = this.participantDetails.map((p) => p.userId);
      if (!this.participantIds.every((id) => detailUserIds.includes(id))) {
        throw new Error(
          "All participants must have corresponding participant details",
        );
      }

      // Validate that at least one admin exists in group conversations
      if (
        this.type === ConversationType.GROUP &&
        !this.participantDetails.some((p) => p.role === ParticipantRole.ADMIN)
      ) {
        throw new Error("Group conversations must have at least one admin");
      }
    }
  }

  /**
   * Determine if the conversation is a direct message
   */
  isDirectMessage(): boolean {
    return this.type === ConversationType.DIRECT;
  }

  /**
   * Determine if the conversation is a group chat
   */
  isGroupChat(): boolean {
    return this.type === ConversationType.GROUP;
  }

  /**
   * Add a participant to the conversation
   * @throws {Error} If adding the participant would exceed the maximum
   */
  addParticipant(
    userId: string,
    role: ParticipantRole = ParticipantRole.MEMBER,
  ): void {
    // Check if participant already exists
    if (this.participantIds.includes(userId)) {
      return;
    }

    // Check maximum participants constraint
    if (
      this.maxParticipants !== null &&
      this.participantIds.length >= this.maxParticipants
    ) {
      throw new Error(
        `Cannot add participant: maximum of ${this.maxParticipants} participants reached`,
      );
    }

    // Add to participantIds
    this.participantIds.push(userId);

    // Add to participantDetails if tracking details
    if (this.participantDetails) {
      this.participantDetails.push({
        userId,
        role,
        joinedAt: new Date(),
      });
    }

    this.updatedAt = new Date();
  }

  /**
   * Remove a participant from the conversation
   * @throws {Error} If trying to remove the last administrator
   */
  removeParticipant(userId: string): void {
    const initialLength = this.participantIds.length;

    // Check if we're removing the last admin
    if (this.participantDetails && this.type === ConversationType.GROUP) {
      const isAdmin = this.participantDetails.some(
        (p) => p.userId === userId && p.role === ParticipantRole.ADMIN,
      );
      const adminCount = this.participantDetails.filter(
        (p) => p.role === ParticipantRole.ADMIN,
      ).length;

      if (isAdmin && adminCount <= 1) {
        throw new Error(
          "Cannot remove the last administrator from a group conversation",
        );
      }
    }

    // Remove from participantIds
    this.participantIds = this.participantIds.filter((id) => id !== userId);

    // Remove from participantDetails if tracking details
    if (this.participantDetails) {
      this.participantDetails = this.participantDetails.filter(
        (p) => p.userId !== userId,
      );
    }

    if (this.participantIds.length !== initialLength) {
      this.updatedAt = new Date();
    }
  }

  /**
   * Update participant role
   */
  updateParticipantRole(userId: string, role: ParticipantRole): void {
    if (!this.participantDetails) {
      this.participantDetails = this.participantIds.map((id) => ({
        userId: id,
        role:
          id === this.creatorId
            ? ParticipantRole.ADMIN
            : ParticipantRole.MEMBER,
        joinedAt: this.createdAt,
      }));
    }

    const participantIndex = this.participantDetails.findIndex(
      (p) => p.userId === userId,
    );

    if (participantIndex === -1) {
      throw new Error(
        `User ${userId} is not a participant in this conversation`,
      );
    }

    // Check if this would remove the last admin
    if (
      this.type === ConversationType.GROUP &&
      this.participantDetails[participantIndex].role ===
        ParticipantRole.ADMIN &&
      role !== ParticipantRole.ADMIN
    ) {
      const adminCount = this.participantDetails.filter(
        (p) => p.role === ParticipantRole.ADMIN,
      ).length;

      if (adminCount <= 1) {
        throw new Error(
          "Cannot remove the last administrator from a group conversation",
        );
      }
    }

    this.participantDetails[participantIndex].role = role;
    this.updatedAt = new Date();
  }

  /**
   * Update the last message information
   */
  updateLastMessage(messageId: string, sentAt: Date): void {
    this.lastMessageId = messageId;
    this.lastMessageSentAt = sentAt;
    this.updatedAt = new Date();
  }

  /**
   * Set the conversation status
   */
  setStatus(status: ConversationStatus): void {
    this.status = status;
    this.updatedAt = new Date();
  }

  /**
   * Toggle the read-only status
   */
  setReadOnly(isReadOnly: boolean): void {
    this.isReadOnly = isReadOnly;
    this.updatedAt = new Date();
  }

  /**
   * Set the maximum number of participants
   * @throws {Error} If current participant count exceeds the new maximum
   */
  setMaxParticipants(maxParticipants: number | null): void {
    if (
      maxParticipants !== null &&
      this.participantIds.length > maxParticipants
    ) {
      throw new Error(
        `Cannot set maximum participants to ${maxParticipants}: current count (${this.participantIds.length}) exceeds this limit`,
      );
    }

    this.maxParticipants = maxParticipants;
    this.updatedAt = new Date();
  }

  /**
   * Check if a user is a participant in the conversation
   */
  hasParticipant(userId: string): boolean {
    return this.participantIds.includes(userId);
  }

  /**
   * Check if a user is an admin in the conversation
   */
  isAdmin(userId: string): boolean {
    if (!this.participantDetails) {
      // Default: creator is the only admin
      return userId === this.creatorId;
    }

    return this.participantDetails.some(
      (p) => p.userId === userId && p.role === ParticipantRole.ADMIN,
    );
  }

  /**
   * Set the conversation title
   */
  setTitle(title: string | null): void {
    this.title = title;
    this.updatedAt = new Date();
  }

  /**
   * Update metadata
   */
  updateMetadata(metadata: Record<string, unknown>): void {
    this.metadata = {
      ...this.metadata,
      ...metadata,
    };
    this.updatedAt = new Date();
  }

  /**
   * Convert to a display name for a specific user
   * Returns the name of the other participant for direct messages
   */
  getNameForUser(userId: string, userNames: Record<string, string>): string {
    if (this.title) {
      return this.title;
    }

    if (this.isDirectMessage()) {
      const otherParticipantId = this.participantIds.find(
        (id) => id !== userId,
      );
      if (otherParticipantId && userNames[otherParticipantId]) {
        return userNames[otherParticipantId];
      }
      return "Direct Message";
    }

    return "Group Conversation";
  }
}



===========================================================
FILE 22: models\messaging\Message.ts
===========================================================

import { BaseModel } from "../BaseModel";

export enum MessageType {
  TEXT = "TEXT",
  IMAGE = "IMAGE",
  VIDEO = "VIDEO",
  AUDIO = "AUDIO",
  FILE = "FILE",
  SYSTEM = "SYSTEM",
}

export enum MessageStatus {
  SENT = "SENT",
  DELIVERED = "DELIVERED",
  READ = "READ",
  FAILED = "FAILED",
  DELETED = "DELETED",
}

export interface MessageAttachment {
  id: string;
  type: string;
  url: string;
  thumbnailUrl?: string;
  name?: string;
  size?: number;
  duration?: number;
  width?: number;
  height?: number;
  mimeType?: string;
}

export interface MessageAttributes extends BaseModel {
  conversationId: string;
  senderId: string;
  content: string;
  type: MessageType;
  status: MessageStatus;
  replyToId?: string;
  metadata?: Record<string, unknown> | null;
  readBy?: string[];
  isEdited?: boolean;
  editedAt?: Date | null;
  attachments: MessageAttachment[];
  deletedForUserIds: string[];
  sentAt: Date;
}

export class Message implements Omit<MessageAttributes, keyof BaseModel> {
  id: string;
  conversationId: string;
  senderId: string;
  content: string;
  type: MessageType;
  status: MessageStatus;
  replyToId?: string;
  metadata?: Record<string, unknown> | null;
  readBy: string[];
  isEdited: boolean;
  editedAt: Date | null;
  createdAt: Date;
  updatedAt: Date;
  attachments: MessageAttachment[];
  deletedForUserIds: string[];
  sentAt: Date;

  constructor(
    data: Partial<MessageAttributes> & {
      conversationId: string;
      senderId: string;
      content: string;
    },
  ) {
    this.id = data.id || "";
    this.conversationId = data.conversationId;
    this.senderId = data.senderId;
    this.content = data.content;
    this.type = data.type || MessageType.TEXT;
    this.status = data.status || MessageStatus.SENT;
    this.replyToId = data.replyToId;
    this.metadata = data.metadata || null;
    this.readBy = data.readBy || [];
    this.isEdited = data.isEdited || false;
    this.editedAt = data.editedAt || null;
    this.attachments = data.attachments || [];
    this.deletedForUserIds = data.deletedForUserIds || [];
    this.sentAt = data.sentAt || new Date();
    this.createdAt = data.createdAt || new Date();
    this.updatedAt = data.updatedAt || new Date();
  }

  /**
   * Validate message data
   */
  validate(): void {
    // Required fields
    if (!this.conversationId) {
      throw new Error("Conversation ID is required");
    }

    if (!this.senderId) {
      throw new Error("Sender ID is required");
    }

    if (this.content === undefined || this.content === null) {
      throw new Error("Content is required");
    }

    // Type validation
    if (!Object.values(MessageType).includes(this.type)) {
      throw new Error(`Invalid message type: ${this.type}`);
    }

    // Status validation
    if (!Object.values(MessageStatus).includes(this.status)) {
      throw new Error(`Invalid message status: ${this.status}`);
    }

    // Content validation based on type
    if (this.type === MessageType.TEXT && this.content.trim().length === 0) {
      throw new Error("Text message cannot be empty");
    }

    // For other types, a valid URL or data URI should be in the content
    // or appropriate information in the metadata
    if (this.type !== MessageType.TEXT && this.type !== MessageType.SYSTEM) {
      if (
        !this.content &&
        (!this.metadata || !Object.keys(this.metadata).length)
      ) {
        throw new Error(`${this.type} message requires content or metadata`);
      }
    }
  }

  /**
   * Mark message as read by a user
   */
  markAsReadBy(userId: string): boolean {
    if (this.readBy.includes(userId)) {
      return false;
    }
    this.readBy.push(userId);
    return true;
  }

  /**
   * Mark message as delivered
   */
  markAsDelivered(): boolean {
    if (this.status === MessageStatus.SENT) {
      this.status = MessageStatus.DELIVERED;
      return true;
    }
    return false;
  }

  /**
   * Mark message as read
   */
  markAsRead(): boolean {
    if (
      this.status === MessageStatus.SENT ||
      this.status === MessageStatus.DELIVERED
    ) {
      this.status = MessageStatus.READ;
      return true;
    }
    return false;
  }

  /**
   * Edit message content
   */
  editContent(newContent: string): void {
    if (this.status === MessageStatus.DELETED) {
      throw new Error("Cannot edit a deleted message");
    }

    if (this.type !== MessageType.TEXT) {
      throw new Error(`Cannot edit a ${this.type} message`);
    }

    if (newContent.trim().length === 0) {
      throw new Error("Text message cannot be empty");
    }

    this.content = newContent;
    this.isEdited = true;
    this.editedAt = new Date();
  }

  /**
   * Soft delete message
   */
  softDelete(): void {
    this.status = MessageStatus.DELETED;
    this.content = ""; // Clear content for privacy
    this.metadata = null; // Clear metadata
  }

  /**
   * Check if message is from a specific sender
   */
  isFromSender(userId: string): boolean {
    return this.senderId === userId;
  }

  /**
   * Convert to JSON
   */
  toJSON(): Omit<MessageAttributes, "generateId"> & {
    id: string;
    createdAt: Date;
    updatedAt: Date;
  } {
    return {
      id: this.id,
      conversationId: this.conversationId,
      senderId: this.senderId,
      content: this.content,
      type: this.type,
      status: this.status,
      replyToId: this.replyToId,
      metadata: this.metadata,
      readBy: this.readBy,
      isEdited: this.isEdited,
      editedAt: this.editedAt,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt,
      attachments: this.attachments,
      deletedForUserIds: this.deletedForUserIds,
      sentAt: this.sentAt,
    };
  }

  /**
   * Check if the message has been read by a specific user
   */
  isReadBy(userId: string): boolean {
    return this.readBy.includes(userId);
  }

  /**
   * Check if the message is deleted for a specific user
   */
  isDeletedFor(userId: string): boolean {
    return this.deletedForUserIds.includes(userId);
  }

  /**
   * Mark the message as deleted for a specific user
   */
  markAsDeletedFor(userId: string): void {
    if (!this.deletedForUserIds.includes(userId)) {
      this.deletedForUserIds.push(userId);
      this.updatedAt = new Date();
    }
  }

  /**
   * Update the message status
   */
  updateStatus(status: MessageStatus): void {
    this.status = status;
    this.updatedAt = new Date();
  }

  /**
   * Add an attachment to the message
   */
  addAttachment(attachment: MessageAttachment): void {
    this.attachments.push(attachment);
    this.updatedAt = new Date();
  }

  /**
   * Remove an attachment from the message
   */
  removeAttachment(attachmentId: string): void {
    const initialCount = this.attachments.length;
    this.attachments = this.attachments.filter(
      (attachment) => attachment.id !== attachmentId,
    );

    if (this.attachments.length !== initialCount) {
      this.updatedAt = new Date();
    }
  }

  /**
   * Check if the message has attachments
   */
  hasAttachments(): boolean {
    return this.attachments.length > 0;
  }

  /**
   * Check if the message is a reply
   */
  isReply(): boolean {
    return this.replyToId !== null;
  }

  /**
   * Check if the message is a system message
   */
  isSystemMessage(): boolean {
    return this.type === MessageType.SYSTEM;
  }

  /**
   * Check if the message has text content
   */
  hasContent(): boolean {
    return this.content !== null && this.content.trim().length > 0;
  }
}



===========================================================
FILE 23: models\moderation\ContentReport.ts
===========================================================

import { BaseModel } from "../BaseModel";
import { EntityType } from "../shared/EntityTypes";

export enum ReportType {
  SPAM = "SPAM",
  HARASSMENT = "HARASSMENT",
  HATE_SPEECH = "HATE_SPEECH",
  VIOLENCE = "VIOLENCE",
  NUDITY = "NUDITY",
  COPYRIGHT = "COPYRIGHT",
  OTHER = "OTHER",
}

export enum ReportStatus {
  PENDING = "PENDING",
  IN_REVIEW = "IN_REVIEW",
  RESOLVED = "RESOLVED",
  DISMISSED = "DISMISSED",
}

export enum ReportSeverity {
  LOW = "LOW",
  MEDIUM = "MEDIUM",
  HIGH = "HIGH",
  CRITICAL = "CRITICAL",
}

export interface ContentReportAttributes extends BaseModel {
  reporterId: string;
  contentId: string;
  contentType: EntityType;
  contentOwnerId?: string;
  type: ReportType;
  description?: string;
  status: ReportStatus;
  severity: ReportSeverity;
  reviewerId?: string;
  resolution?: string;
  reviewNotes?: string;
  evidence?: string[];
  metadata?: Record<string, unknown> | null;
}

export class ContentReport
  extends BaseModel
  implements Omit<ContentReportAttributes, keyof BaseModel>
{
  reporterId: string;
  contentId: string;
  contentType: EntityType;
  contentOwnerId?: string;
  type: ReportType;
  description?: string;
  status: ReportStatus;
  severity: ReportSeverity;
  reviewerId?: string;
  resolution?: string;
  reviewNotes?: string;
  evidence?: string[];
  metadata?: Record<string, unknown> | null;

  constructor(
    data: Partial<ContentReportAttributes> & {
      reporterId: string;
      contentId: string;
      contentType: EntityType;
      type: ReportType;
    },
  ) {
    super();
    this.reporterId = data.reporterId;
    this.contentId = data.contentId;
    this.contentType = data.contentType;
    this.contentOwnerId = data.contentOwnerId;
    this.type = data.type;
    this.description = data.description;
    this.status = data.status || ReportStatus.PENDING;
    this.severity = data.severity || ReportSeverity.MEDIUM;
    this.reviewerId = data.reviewerId;
    this.resolution = data.resolution;
    this.reviewNotes = data.reviewNotes;
    this.evidence = data.evidence || [];
    this.metadata = data.metadata || null;
  }

  /**
   * Validates the report data
   * @throws Error if validation fails
   */
  validate(): void {
    if (!this.reporterId) {
      throw new Error("Reporter ID is required");
    }

    if (!this.contentId) {
      throw new Error("Content ID is required");
    }

    if (!this.contentType) {
      throw new Error("Content type is required");
    }

    if (!Object.values(EntityType).includes(this.contentType)) {
      throw new Error(`Invalid content type: ${this.contentType}`);
    }

    if (!this.type) {
      throw new Error("Report type is required");
    }

    if (!Object.values(ReportType).includes(this.type)) {
      throw new Error(`Invalid report type: ${this.type}`);
    }

    if (!Object.values(ReportStatus).includes(this.status)) {
      throw new Error(`Invalid report status: ${this.status}`);
    }

    if (!Object.values(ReportSeverity).includes(this.severity)) {
      throw new Error(`Invalid report severity: ${this.severity}`);
    }

    // Description is required for OTHER report type
    if (this.type === ReportType.OTHER && !this.description) {
      throw new Error('Description is required for "OTHER" report type');
    }

    // Resolution is required for RESOLVED or DISMISSED status
    if (
      (this.status === ReportStatus.RESOLVED ||
        this.status === ReportStatus.DISMISSED) &&
      !this.resolution
    ) {
      throw new Error(`Resolution is required for ${this.status} status`);
    }

    // Reviewer ID is required for statuses other than PENDING
    if (this.status !== ReportStatus.PENDING && !this.reviewerId) {
      throw new Error(`Reviewer ID is required for ${this.status} status`);
    }
  }

  /**
   * Convert to JSON representation
   */
  toJSON(): Omit<ContentReportAttributes, "generateId"> & {
    id: string;
    createdAt: Date;
    updatedAt: Date;
  } {
    return {
      id: this.id,
      reporterId: this.reporterId,
      contentId: this.contentId,
      contentType: this.contentType,
      contentOwnerId: this.contentOwnerId,
      type: this.type,
      description: this.description,
      status: this.status,
      severity: this.severity,
      reviewerId: this.reviewerId,
      resolution: this.resolution,
      reviewNotes: this.reviewNotes,
      evidence: this.evidence,
      metadata: this.metadata,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt,
    };
  }

  /**
   * Start the review process
   * @param reviewerId ID of the moderator reviewing the report
   */
  startReview(reviewerId: string): void {
    if (!reviewerId) {
      throw new Error("Reviewer ID is required");
    }

    if (![ReportStatus.PENDING, ReportStatus.IN_REVIEW].includes(this.status)) {
      throw new Error(
        `Cannot start review for report with status: ${this.status}`,
      );
    }

    this.status = ReportStatus.IN_REVIEW;
    this.reviewerId = reviewerId;
    this.updatedAt = new Date();
  }

  /**
   * Resolve the report
   * @param resolution Resolution description
   */
  resolve(resolution: string): void {
    if (!resolution) {
      throw new Error("Resolution is required");
    }

    if (!this.reviewerId) {
      throw new Error(
        "Report must be assigned to a reviewer before resolution",
      );
    }

    this.status = ReportStatus.RESOLVED;
    this.resolution = resolution;
    this.updatedAt = new Date();
  }

  /**
   * Dismiss the report
   * @param reason Reason for dismissal
   */
  dismiss(reason: string): void {
    if (!reason) {
      throw new Error("Dismissal reason is required");
    }

    if (!this.reviewerId) {
      throw new Error("Report must be assigned to a reviewer before dismissal");
    }

    this.status = ReportStatus.DISMISSED;
    this.resolution = reason;
    this.updatedAt = new Date();
  }

  /**
   * Add review notes
   * @param notes Notes from the reviewer
   */
  addReviewNotes(notes: string): void {
    if (!notes) {
      throw new Error("Notes content is required");
    }

    if (!this.reviewerId) {
      throw new Error("Report must be assigned to a reviewer to add notes");
    }

    this.reviewNotes = notes;
    this.updatedAt = new Date();
  }

  /**
   * Set report severity
   * @param severity The severity level
   */
  setSeverity(severity: ReportSeverity): void {
    if (!Object.values(ReportSeverity).includes(severity)) {
      throw new Error(`Invalid severity level: ${severity}`);
    }

    this.severity = severity;
    this.updatedAt = new Date();
  }

  /**
   * Add evidence to the report
   * @param evidenceUrl URL or reference to evidence
   */
  addEvidence(evidenceUrl: string): void {
    if (!evidenceUrl) {
      throw new Error("Evidence URL is required");
    }

    if (!this.evidence) {
      this.evidence = [];
    }

    if (!this.evidence.includes(evidenceUrl)) {
      this.evidence.push(evidenceUrl);
      this.updatedAt = new Date();
    }
  }

  /**
   * Remove evidence from the report
   * @param evidenceUrl URL or reference to evidence
   */
  removeEvidence(evidenceUrl: string): void {
    if (!this.evidence || this.evidence.length === 0) {
      return;
    }

    const initialLength = this.evidence.length;
    this.evidence = this.evidence.filter((url) => url !== evidenceUrl);

    if (this.evidence.length !== initialLength) {
      this.updatedAt = new Date();
    }
  }

  /**
   * Set content owner ID
   * @param ownerId User ID of the content owner
   */
  setContentOwnerId(ownerId: string): void {
    if (!ownerId) {
      throw new Error("Content owner ID is required");
    }

    this.contentOwnerId = ownerId;
    this.updatedAt = new Date();
  }

  /**
   * Check if the report is pending
   */
  isPending(): boolean {
    return this.status === ReportStatus.PENDING;
  }

  /**
   * Check if the report is under review
   */
  isInReview(): boolean {
    return this.status === ReportStatus.IN_REVIEW;
  }

  /**
   * Check if the report has been resolved
   */
  isResolved(): boolean {
    return this.status === ReportStatus.RESOLVED;
  }

  /**
   * Check if the report has been dismissed
   */
  isDismissed(): boolean {
    return this.status === ReportStatus.DISMISSED;
  }

  /**
   * Check if the report is closed (resolved or dismissed)
   */
  isClosed(): boolean {
    return this.isResolved() || this.isDismissed();
  }

  /**
   * Check if the report is high priority (HIGH or CRITICAL severity)
   */
  isHighPriority(): boolean {
    return (
      this.severity === ReportSeverity.HIGH ||
      this.severity === ReportSeverity.CRITICAL
    );
  }
}



===========================================================
FILE 24: models\moderation\ModerationAction.ts
===========================================================

import { BaseModel } from "../BaseModel";
import { EntityType } from "../shared/EntityTypes";

export enum ActionType {
  WARNING = "WARNING",
  CONTENT_REMOVAL = "CONTENT_REMOVAL",
  TEMPORARY_BAN = "TEMPORARY_BAN",
  PERMANENT_BAN = "PERMANENT_BAN",
}

export enum ActionStatus {
  PENDING = "PENDING",
  APPLIED = "APPLIED",
  REVERSED = "REVERSED",
  EXPIRED = "EXPIRED",
}

export interface ModerationActionAttributes {
  id: string;
  moderatorId: string;
  targetUserId: string;
  contentId?: string;
  contentType?: EntityType;
  reportId?: string; // Reference to related report if any
  type: ActionType;
  reason: string;
  status: ActionStatus;
  expiresAt?: Date; // For temporary actions
  createdAt: Date;
  updatedAt: Date;
}

export class ModerationAction
  extends BaseModel
  implements ModerationActionAttributes
{
  id: string;
  moderatorId: string;
  targetUserId: string;
  contentId?: string;
  contentType?: EntityType;
  reportId?: string;
  type: ActionType;
  reason: string;
  status: ActionStatus;
  expiresAt?: Date;
  createdAt: Date;
  updatedAt: Date;

  constructor(
    data: Partial<ModerationActionAttributes> & {
      moderatorId: string;
      targetUserId: string;
      type: ActionType;
      reason: string;
    },
  ) {
    super();
    this.id = data.id || this.generateId();
    this.moderatorId = data.moderatorId;
    this.targetUserId = data.targetUserId;
    this.contentId = data.contentId;
    this.contentType = data.contentType;
    this.reportId = data.reportId;
    this.type = data.type;
    this.reason = data.reason;
    this.status = data.status || ActionStatus.PENDING;
    this.expiresAt = data.expiresAt;
    this.createdAt = data.createdAt || new Date();
    this.updatedAt = data.updatedAt || new Date();
  }

  /**
   * Convert to JSON representation
   */
  toJSON(): Omit<ModerationActionAttributes, "generateId"> & {
    id: string;
    createdAt: Date;
    updatedAt: Date;
  } {
    return {
      id: this.id,
      moderatorId: this.moderatorId,
      targetUserId: this.targetUserId,
      contentId: this.contentId,
      contentType: this.contentType,
      reportId: this.reportId,
      type: this.type,
      reason: this.reason,
      status: this.status,
      expiresAt: this.expiresAt,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt,
    };
  }

  /**
   * Apply the moderation action
   */
  apply(): void {
    this.status = ActionStatus.APPLIED;
    this.updatedAt = new Date();
  }

  /**
   * Reverse the moderation action
   */
  reverse(): void {
    this.status = ActionStatus.REVERSED;
    this.updatedAt = new Date();
  }

  /**
   * Mark the action as expired
   */
  expire(): void {
    if (this.isTemporary() && this.status === ActionStatus.APPLIED) {
      this.status = ActionStatus.EXPIRED;
      this.updatedAt = new Date();
    }
  }

  /**
   * Check if the action is still active (applied and not expired/reversed)
   */
  isActive(): boolean {
    if (this.status !== ActionStatus.APPLIED) {
      return false;
    }

    if (this.isTemporary() && this.expiresAt) {
      const now = new Date();
      return now < this.expiresAt;
    }

    return true;
  }

  /**
   * Check if this is a temporary action
   */
  isTemporary(): boolean {
    return this.type === ActionType.TEMPORARY_BAN;
  }

  /**
   * Validate the action data
   * @throws Error if validation fails
   */
  validate(): void {
    if (!this.moderatorId) {
      throw new Error("Moderator ID is required");
    }

    if (!this.targetUserId) {
      throw new Error("Target user ID is required");
    }

    if (!this.type) {
      throw new Error("Action type is required");
    }

    if (!Object.values(ActionType).includes(this.type)) {
      throw new Error(`Invalid action type: ${this.type}`);
    }

    if (!Object.values(ActionStatus).includes(this.status)) {
      throw new Error(`Invalid action status: ${this.status}`);
    }

    if (!this.reason || this.reason.trim().length === 0) {
      throw new Error("Reason is required");
    }

    if (this.contentId && !this.contentType) {
      throw new Error("Content type is required when content ID is provided");
    }

    if (this.expiresAt && !(this.expiresAt instanceof Date)) {
      throw new Error("Expiration date must be a valid Date object");
    }

    if (this.type === ActionType.TEMPORARY_BAN && !this.expiresAt) {
      throw new Error("Expiration date is required for temporary bans");
    }
  }
}



===========================================================
FILE 25: models\shared\EntityTypes.ts
===========================================================

/**
 * Shared enum for entity types across the application
 */
export enum EntityType {
  USER = "user",
  POST = "post",
  COMMENT = "comment",
  MEDIA = "media",
  GROUP = "group",
  MESSAGE = "message",
}

/**
 * Shared enum for content status across the application
 */
export enum ContentStatus {
  DRAFT = "draft",
  PUBLISHED = "published",
  ARCHIVED = "archived",
  DELETED = "deleted",
  PENDING_REVIEW = "pending_review",
}



===========================================================
FILE 26: models\social\Bookmark.ts
===========================================================

import { BaseModel } from "../BaseModel";
import { EntityType } from "../shared/EntityTypes";

/**
 * Interface for bookmark attributes
 */
export interface BookmarkAttributes {
  id: string;
  userId: string;
  entityId: string;
  entityType: EntityType;
  collectionId?: string | null;
  notes?: string | null;
  createdAt: Date;
  updatedAt: Date;
}

/**
 * Bookmark model representing a user's saved content
 */
export class Bookmark
  extends BaseModel
  implements Omit<BookmarkAttributes, keyof BaseModel>
{
  userId: string;
  entityId: string;
  entityType: EntityType;
  collectionId: string | null;
  notes: string | null;

  /**
   * Constructor for Bookmark
   */
  constructor(
    data: Partial<BookmarkAttributes> & {
      userId: string;
      entityId: string;
      entityType: EntityType;
    },
  ) {
    super();
    this.id = data.id || this.generateId();
    this.userId = data.userId;
    this.entityId = data.entityId;
    this.entityType = data.entityType;
    this.collectionId = data.collectionId || null;
    this.notes = data.notes || null;
    this.createdAt = data.createdAt ? new Date(data.createdAt) : new Date();
    this.updatedAt = data.updatedAt ? new Date(data.updatedAt) : new Date();
  }

  /**
   * Validates the bookmark data
   * @throws Error if validation fails
   */
  validate(): void {
    if (!this.userId) {
      throw new Error("User ID is required");
    }

    if (!this.entityId) {
      throw new Error("Entity ID is required");
    }

    if (!this.entityType) {
      throw new Error("Entity type is required");
    }

    if (!Object.values(EntityType).includes(this.entityType)) {
      throw new Error(`Invalid entity type: ${this.entityType}`);
    }

    if (this.notes && this.notes.length > 1000) {
      throw new Error("Notes cannot exceed 1000 characters");
    }
  }

  /**
   * Update bookmark notes
   */
  updateNotes(notes: string | null): void {
    this.notes = notes;
    this.updatedAt = new Date();
  }

  /**
   * Move bookmark to a different collection
   */
  moveToCollection(collectionId: string | null): void {
    this.collectionId = collectionId;
    this.updatedAt = new Date();
  }

  /**
   * Check if bookmark belongs to a specific user
   */
  belongsToUser(userId: string): boolean {
    return this.userId === userId;
  }

  /**
   * Check if bookmark is for a specific entity
   */
  isForEntity(entityId: string, entityType: EntityType): boolean {
    return this.entityId === entityId && this.entityType === entityType;
  }

  /**
   * Convert to JSON representation
   */
  toJSON(): Omit<BookmarkAttributes, "generateId"> {
    return {
      id: this.id,
      userId: this.userId,
      entityId: this.entityId,
      entityType: this.entityType,
      collectionId: this.collectionId,
      notes: this.notes,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt,
    };
  }
}



===========================================================
FILE 27: models\social\Comment.ts
===========================================================

import { BaseModel } from "../BaseModel";
import { ContentStatus } from "../shared/EntityTypes";

export enum CommentTargetType {
  POST = "POST",
  MEDIA = "MEDIA",
  ARTICLE = "ARTICLE",
}

export interface CommentAttributes {
  id: string;
  userId: string;
  postId: string;
  parentId: string | null;
  content: string;
  likesCount: number;
  status: ContentStatus;
  createdAt: Date;
  updatedAt: Date;
}

export interface CommentJSON {
  id: string;
  userId: string;
  postId: string;
  parentId: string | null;
  content: string;
  likesCount: number;
  status: ContentStatus;
  createdAt: string;
  updatedAt: string;
  isLiked?: boolean;
}

export class Comment extends BaseModel implements CommentAttributes {
  id: string;
  userId: string;
  postId: string;
  parentId: string | null;
  content: string;
  likesCount: number;
  status: ContentStatus;
  createdAt: Date;
  updatedAt: Date;

  constructor(data: Partial<CommentAttributes>) {
    super();
    this.id = data.id || this.generateId();
    this.userId = data.userId || "";
    this.postId = data.postId || "";
    this.parentId = data.parentId || null;
    this.content = data.content || "";
    this.likesCount = data.likesCount || 0;
    this.status = data.status || ContentStatus.DRAFT;
    this.createdAt = data.createdAt || new Date();
    this.updatedAt = data.updatedAt || new Date();
  }

  /**
   * Validate comment data
   * @returns Array of validation error messages
   */
  validate(): string[] {
    const errors: string[] = [];

    if (!this.userId) {
      errors.push("User ID is required");
    }

    if (!this.postId) {
      errors.push("Post ID is required");
    }

    if (!this.content) {
      errors.push("Content is required");
    }

    if (this.content && this.content.length > 2000) {
      errors.push("Content exceeds maximum length of 2000 characters");
    }

    return errors;
  }

  /**
   * Increment the like count for this comment
   */
  incrementLikeCount(): void {
    this.likesCount++;
    this.updatedAt = new Date();
  }

  /**
   * Decrement the like count for this comment
   */
  decrementLikeCount(): void {
    this.likesCount = Math.max(0, this.likesCount - 1);
    this.updatedAt = new Date();
  }

  /**
   * Convert to JSON representation
   */
  toJSON(): Omit<CommentJSON, "generateId"> {
    return {
      id: this.id,
      userId: this.userId,
      postId: this.postId,
      parentId: this.parentId,
      content: this.content,
      likesCount: this.likesCount,
      status: this.status,
      createdAt: this.createdAt.toISOString(),
      updatedAt: this.updatedAt.toISOString(),
    };
  }
}

export default Comment;



===========================================================
FILE 28: models\social\CommentLike.ts
===========================================================

import { BaseModel } from "../BaseModel";

export interface CommentLikeAttributes extends BaseModel {
  userId: string;
  commentId: string;
}

export class CommentLike
  extends BaseModel
  implements Omit<CommentLikeAttributes, keyof BaseModel>
{
  userId: string;
  commentId: string;

  constructor(
    data: Partial<CommentLikeAttributes> & {
      userId: string;
      commentId: string;
    },
  ) {
    super();
    this.userId = data.userId;
    this.commentId = data.commentId;
  }

  /**
   * Validate comment like data
   * @returns Array of validation error messages
   */
  validate(): string[] {
    const errors: string[] = [];

    if (!this.userId) {
      errors.push("User ID is required");
    }

    if (!this.commentId) {
      errors.push("Comment ID is required");
    }

    return errors;
  }

  toJSON(): Omit<CommentLikeAttributes, "generateId"> {
    return {
      id: this.id,
      userId: this.userId,
      commentId: this.commentId,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt,
    };
  }
}

export default CommentLike;



===========================================================
FILE 29: models\social\Follow.ts
===========================================================

import { v4 as uuidv4 } from "uuid";

export interface FollowAttributes {
  id: string;
  followerId: string;
  followingId: string;
  createdAt: Date;
  updatedAt: Date;
  [key: string]: unknown;
}

/**
 * Class representing a Follow relationship between users
 */
export class Follow {
  public id: string;
  public followerId: string;
  public followingId: string;
  public createdAt: Date;
  public updatedAt: Date;
  [key: string]: unknown;

  constructor(attributes: Partial<FollowAttributes> = {}) {
    this.id = attributes.id || uuidv4();
    this.followerId = attributes.followerId || "";
    this.followingId = attributes.followingId || "";
    this.createdAt = attributes.createdAt || new Date();
    this.updatedAt = attributes.updatedAt || new Date();
  }

  /**
   * Validate the follow data
   * @returns Array of validation error messages
   */
  validate(): string[] {
    const errors: string[] = [];

    if (!this.followerId) {
      errors.push("Follower ID is required");
    }

    if (!this.followingId) {
      errors.push("Following ID is required");
    }

    if (this.followerId === this.followingId) {
      errors.push("User cannot follow themselves");
    }

    return errors;
  }

  /**
   * Convert the follow to a plain object for JSON serialization
   */
  toJSON(): Omit<FollowAttributes, "generateId"> {
    return {
      id: this.id,
      followerId: this.followerId,
      followingId: this.followingId,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt,
    };
  }
}

export default Follow;



===========================================================
FILE 30: models\social\Hashtag.ts
===========================================================

import { BaseModel } from "../BaseModel";

/**
 * Category for classifying hashtags
 */
export enum HashtagCategory {
  GENERAL = "general",
  TRENDING = "trending",
  CONTENT = "content",
}

/**
 * Interface for hashtag attributes
 */
export interface HashtagAttributes {
  id: string;
  /**
   * The tag text without the # symbol
   */
  tag: string;

  /**
   * Optional normalized version of the tag
   */
  normalizedTag: string;

  /**
   * Number of times the hashtag has been used
   */
  usageCount: number;

  /**
   * Category of the hashtag
   */
  category: HashtagCategory;

  createdAt: Date;
  updatedAt: Date;
}

/**
 * Hashtag class for social media tagging
 */
export class Hashtag extends BaseModel implements HashtagAttributes {
  id: string;
  tag: string;
  normalizedTag: string;
  usageCount: number;
  category: HashtagCategory;
  createdAt: Date;
  updatedAt: Date;

  /**
   * Constructor for Hashtag
   */
  constructor(data: Partial<HashtagAttributes> & { tag: string }) {
    super();
    this.id = data.id || this.generateId();
    this.tag = data.tag;
    this.normalizedTag = data.normalizedTag || this.normalizeTag(data.tag);
    this.usageCount = data.usageCount || 0;
    this.category = data.category || HashtagCategory.GENERAL;
    this.createdAt = data.createdAt || new Date();
    this.updatedAt = data.updatedAt || new Date();
  }

  /**
   * Validates the hashtag data
   * @throws Error if validation fails
   */
  validate(): void {
    if (!this.tag) {
      throw new Error("Tag is required");
    }

    if (this.tag.length > 50) {
      throw new Error("Tag exceeds maximum length of 50 characters");
    }

    // Check if the tag contains invalid characters (only allow alphanumeric and underscores)
    const validTagRegex = /^[a-zA-Z0-9_]+$/;
    if (!validTagRegex.test(this.tag)) {
      throw new Error("Tag can only contain letters, numbers, and underscores");
    }

    if (!Object.values(HashtagCategory).includes(this.category)) {
      throw new Error(`Invalid hashtag category: ${this.category}`);
    }

    if (this.usageCount < 0) {
      throw new Error("Usage count cannot be negative");
    }
  }

  /**
   * Convert to JSON representation
   */
  toJSON(): Omit<HashtagAttributes, "generateId"> & {
    id: string;
    createdAt: Date;
    updatedAt: Date;
  } {
    return {
      id: this.id,
      tag: this.tag,
      normalizedTag: this.normalizedTag,
      usageCount: this.usageCount,
      category: this.category,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt,
    };
  }

  /**
   * Get the hashtag with the # symbol
   */
  getFormattedTag(): string {
    return `#${this.tag}`;
  }

  /**
   * Normalize a tag for consistent lookups
   */
  private normalizeTag(tag: string): string {
    // Remove any # prefix if present
    const cleanTag = tag.startsWith("#") ? tag.substring(1) : tag;

    // Lowercase and trim any whitespace
    return cleanTag.toLowerCase().trim();
  }

  /**
   * Increment the usage count
   */
  incrementUsage(count: number = 1): void {
    this.usageCount += count;
    this.updatedAt = new Date();
  }

  /**
   * Update category
   */
  updateCategory(category: HashtagCategory): void {
    this.category = category;
    this.updatedAt = new Date();
  }
}



===========================================================
FILE 31: models\social\Like.ts
===========================================================

import { likeRepository } from "../../repositories/social/LikeRepository";
import { BaseModel } from "../BaseModel";

/**
 * Enum for different types of like targets
 */
export enum LikeTargetType {
  POST = "post",
  COMMENT = "comment",
  MEDIA = "media",
  ARTICLE = "article",
}

/**
 * Interface for like attributes
 */
export interface LikeAttributes extends BaseModel {
  userId: string;
  targetId: string;
  targetType: LikeTargetType;
}

/**
 * Like model representing a user's like on a piece of content
 */
export class Like
  extends BaseModel
  implements Omit<LikeAttributes, keyof BaseModel>
{
  id: string;
  userId: string;
  targetId: string;
  targetType: LikeTargetType;
  createdAt: Date;
  updatedAt: Date;

  /**
   * Constructor for Like
   */
  constructor(
    data: Partial<LikeAttributes> & {
      userId: string;
      targetId: string;
      targetType: LikeTargetType;
    },
  ) {
    super();
    this.id = data.id || this.generateId();
    this.userId = data.userId;
    this.targetId = data.targetId;
    this.targetType = data.targetType;
    this.createdAt = data.createdAt ? new Date(data.createdAt) : new Date();
    this.updatedAt = data.updatedAt ? new Date(data.updatedAt) : new Date();
  }

  /**
   * Validates the like data
   * @throws Error if validation fails
   */
  validate(): void {
    if (!this.userId) {
      throw new Error("User ID is required");
    }

    if (!this.targetId) {
      throw new Error("Target ID is required");
    }

    if (!this.targetType) {
      throw new Error("Target type is required");
    }

    if (!Object.values(LikeTargetType).includes(this.targetType)) {
      throw new Error(`Invalid target type: ${this.targetType}`);
    }
  }

  // Static methods that use the repository
  static async findByPk(id: string): Promise<Like | null> {
    const like = await likeRepository.findById(id);
    return like ? new Like(like) : null;
  }

  static async findByUserAndPost(
    userId: string,
    postId: string,
  ): Promise<Like | null> {
    const like = await likeRepository.findByUserAndTarget(
      userId,
      postId,
      LikeTargetType.POST,
    );
    return like ? new Like(like) : null;
  }

  static async findByUserAndPosts(
    _userId: string,
    postIds: string[],
  ): Promise<Like[]> {
    const likes = await Promise.all(
      postIds.map((id) =>
        likeRepository.getLikesForTarget(id, LikeTargetType.POST),
      ),
    );
    return likes.flat().map((like: LikeAttributes) => new Like(like));
  }

  static async create(
    data: Omit<LikeAttributes, "id" | "createdAt">,
  ): Promise<Like> {
    const like = await likeRepository.create(data);
    return new Like(like);
  }

  async delete(): Promise<boolean> {
    return likeRepository.delete(this.id);
  }

  /**
   * Convert to JSON representation
   */
  toJSON(): Omit<LikeAttributes, "generateId" | "createdAt" | "updatedAt"> & {
    id: string;
    createdAt: string;
    updatedAt: string;
  } {
    return {
      id: this.id,
      userId: this.userId,
      targetId: this.targetId,
      targetType: this.targetType,
      createdAt: this.createdAt.toISOString(),
      updatedAt: this.updatedAt.toISOString(),
    };
  }
}

export default Like;



===========================================================
FILE 32: models\social\Notification.ts
===========================================================

import { BaseModel } from "../BaseModel";
import { EntityType } from "../shared/EntityTypes";

/**
 * Enum defining different types of notifications
 */
export enum NotificationType {
  LIKE = "like",
  COMMENT = "comment",
  FOLLOW = "follow",
  MENTION = "mention",
  SYSTEM = "system",
  MESSAGE = "message",
}

/**
 * Interface for notification attributes
 */
export interface NotificationAttributes {
  id: string;
  type: NotificationType;
  userId: string;
  actorId: string | null;
  entityId: string | null;
  entityType: EntityType | null;
  content: string | null;
  read: boolean;
  delivered: boolean;
  createdAt: Date;
  updatedAt: Date;
}

/**
 * Notification model representing a user notification
 */
export class Notification
  extends BaseModel
  implements Omit<NotificationAttributes, keyof BaseModel>
{
  type: NotificationType;
  userId: string;
  actorId: string | null;
  entityId: string | null;
  entityType: EntityType | null;
  content: string | null;
  read: boolean;
  delivered: boolean;

  /**
   * Constructor for Notification
   */
  constructor(
    data: Partial<NotificationAttributes> & {
      userId: string;
      type: NotificationType;
    },
  ) {
    super();
    this.id = data.id || this.generateId();
    this.type = data.type;
    this.userId = data.userId;
    this.actorId = data.actorId || null;
    this.entityId = data.entityId || null;
    this.entityType = data.entityType || null;
    this.content = data.content || null;
    this.read = data.read || false;
    this.delivered = data.delivered || false;
    this.createdAt = data.createdAt ? new Date(data.createdAt) : new Date();
    this.updatedAt = data.updatedAt ? new Date(data.updatedAt) : new Date();
  }

  /**
   * Validates the notification data
   * @throws Error if validation fails
   */
  validate(): void {
    if (!this.userId) {
      throw new Error("User ID is required");
    }

    if (!this.type) {
      throw new Error("Notification type is required");
    }

    if (!Object.values(NotificationType).includes(this.type)) {
      throw new Error(`Invalid notification type: ${this.type}`);
    }

    if (this.entityId && !this.entityType) {
      throw new Error("Entity type is required when entity ID is provided");
    }

    if (this.entityType && !this.entityId) {
      throw new Error("Entity ID is required when entity type is provided");
    }

    if (
      this.entityType &&
      !Object.values(EntityType).includes(this.entityType)
    ) {
      throw new Error(`Invalid entity type: ${this.entityType}`);
    }
  }

  /**
   * Mark the notification as read
   */
  markAsRead(): void {
    this.read = true;
    this.updatedAt = new Date();
  }

  /**
   * Mark the notification as delivered
   */
  markAsDelivered(): void {
    this.delivered = true;
    this.updatedAt = new Date();
  }

  /**
   * Check if the notification is for a specific user
   */
  isForUser(userId: string): boolean {
    return this.userId === userId;
  }

  /**
   * Check if the notification is from a specific actor
   */
  isFromActor(actorId: string): boolean {
    return this.actorId === actorId;
  }

  /**
   * Check if the notification is about a specific entity
   */
  isAboutEntity(entityId: string, entityType: EntityType): boolean {
    return this.entityId === entityId && this.entityType === entityType;
  }

  /**
   * Convert to JSON representation
   */
  toJSON(): Omit<NotificationAttributes, "generateId"> {
    return {
      id: this.id,
      type: this.type,
      userId: this.userId,
      actorId: this.actorId,
      entityId: this.entityId,
      entityType: this.entityType,
      content: this.content,
      read: this.read,
      delivered: this.delivered,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt,
    };
  }
}



===========================================================
FILE 33: models\social\Post.ts
===========================================================

import { BaseModel } from "../BaseModel";

/**
 * Enum for different types of posts
 */
export enum PostType {
  TEXT = "TEXT",
  IMAGE = "IMAGE",
  VIDEO = "VIDEO",
  LINK = "LINK",
  POLL = "POLL",
}

/**
 * Enum defining the visibility level of a post
 */
export enum PostVisibility {
  PUBLIC = "public",
  FOLLOWERS = "followers",
  PRIVATE = "private",
  UNLISTED = "unlisted",
}

/**
 * Enum for different post statuses
 */
export enum PostStatus {
  DRAFT = "draft",
  PUBLISHED = "published",
  SCHEDULED = "scheduled",
  ARCHIVED = "archived",
  DELETED = "deleted",
  PENDING_REVIEW = "pending_review",
}

/**
 * Interface for location data
 */
export interface PostLocation {
  name: string;
  latitude: number;
  longitude: number;
}

/**
 * Interface for post metadata
 */
export interface PostMetadata {
  tags?: string[];
  mentions?: string[];
  pollOptions?: string[];
  pollEndsAt?: Date;
  pollResults?: Record<string, number>;
  originalAuthor?: string;
  topic?: string;
  mood?: string;
  [key: string]: unknown;
}

/**
 * Interface for post attributes - the data structure for database operations
 */
export interface PostAttributes {
  id: string;
  userId: string;
  content: Record<string, unknown>;
  type: PostType;
  status: PostStatus;
  visibility: PostVisibility;
  location?: PostLocation | null;
  mediaIds: string[];
  metadata?: PostMetadata | null;
  likeCount: number;
  commentCount: number;
  shareCount: number;
  viewCount: number;
  isEdited: boolean;
  isPinned: boolean;
  parentId?: string | null;
  originalPostId?: string | null;
  scheduledAt?: Date | null;
  publishedAt?: Date | null;
  createdAt: Date;
  updatedAt: Date;
}

/**
 * Interface for the JSON representation of a post
 */
export interface PostJSON
  extends Omit<
    PostAttributes,
    "createdAt" | "updatedAt" | "scheduledAt" | "publishedAt"
  > {
  createdAt: string;
  updatedAt: string;
  scheduledAt?: string | null;
  publishedAt?: string | null;
  isLiked?: boolean;
}

/**
 * Post domain model representing a social media post
 *
 * Responsibilities:
 * 1. Encapsulate post data structure
 * 2. Provide business logic and validation
 * 3. Handle state changes and updates
 * 4. NOT handle persistence (that's the repository's job)
 */
export class Post
  extends BaseModel
  implements Omit<PostAttributes, keyof BaseModel>
{
  // Core properties
  readonly userId: string;
  private _content: Record<string, unknown>;
  private _type: PostType;
  private _status: PostStatus;
  private _visibility: PostVisibility;
  private _location?: PostLocation | null;
  private _mediaIds: string[];
  private _metadata?: PostMetadata | null;

  // Engagement metrics
  private _likeCount: number;
  private _commentCount: number;
  private _shareCount: number;
  private _viewCount: number;

  // Status flags
  private _isEdited: boolean;
  private _isPinned: boolean;

  // Relationships
  private _parentId?: string | null;
  private _originalPostId?: string | null;

  // Timestamps
  private _scheduledAt?: Date | null;
  private _publishedAt?: Date | null;

  /**
   * Constructor for Post
   */
  constructor(data: Partial<PostAttributes> & { userId: string }) {
    super();
    this.id = data.id || this.generateId();
    this.userId = data.userId;
    this._content = data.content || {};
    this._type = data.type || PostType.TEXT;
    this._status = data.status || PostStatus.DRAFT;
    this._visibility = data.visibility || PostVisibility.PUBLIC;
    this._location = data.location || null;
    this._mediaIds = data.mediaIds || [];
    this._metadata = data.metadata || null;
    this._likeCount = data.likeCount || 0;
    this._commentCount = data.commentCount || 0;
    this._shareCount = data.shareCount || 0;
    this._viewCount = data.viewCount || 0;
    this._isEdited = data.isEdited || false;
    this._isPinned = data.isPinned || false;
    this._parentId = data.parentId || null;
    this._originalPostId = data.originalPostId || null;
    this._scheduledAt = data.scheduledAt ? new Date(data.scheduledAt) : null;
    this._publishedAt = data.publishedAt ? new Date(data.publishedAt) : null;
    this.createdAt = data.createdAt ? new Date(data.createdAt) : new Date();
    this.updatedAt = data.updatedAt ? new Date(data.updatedAt) : new Date();
  }

  // Getters for private properties
  get content(): Record<string, unknown> {
    return this._content;
  }
  get type(): PostType {
    return this._type;
  }
  get status(): PostStatus {
    return this._status;
  }
  get visibility(): PostVisibility {
    return this._visibility;
  }
  get location(): PostLocation | null {
    return this._location || null;
  }
  get mediaIds(): string[] {
    return [...this._mediaIds];
  }
  get metadata(): PostMetadata | null {
    return this._metadata ? { ...this._metadata } : null;
  }
  get likeCount(): number {
    return this._likeCount;
  }
  get commentCount(): number {
    return this._commentCount;
  }
  get shareCount(): number {
    return this._shareCount;
  }
  get viewCount(): number {
    return this._viewCount;
  }
  get isEdited(): boolean {
    return this._isEdited;
  }
  get isPinned(): boolean {
    return this._isPinned;
  }
  get parentId(): string | null {
    return this._parentId || null;
  }
  get originalPostId(): string | null {
    return this._originalPostId || null;
  }
  get scheduledAt(): Date | null {
    return this._scheduledAt ? new Date(this._scheduledAt.getTime()) : null;
  }
  get publishedAt(): Date | null {
    return this._publishedAt ? new Date(this._publishedAt.getTime()) : null;
  }

  /**
   * Update post content and mark as edited
   */
  updateContent(content: Record<string, unknown>): void {
    if (content !== this._content) {
      this._content = content;
      this._isEdited = true;
      this.updatedAt = new Date();
    }
  }

  /**
   * Update post type
   */
  updateType(type: PostType): void {
    if (type !== this._type) {
      this._type = type;
      this.updatedAt = new Date();
    }
  }

  /**
   * Update post visibility
   */
  updateVisibility(visibility: PostVisibility): void {
    if (visibility !== this._visibility) {
      this._visibility = visibility;
      this.updatedAt = new Date();
    }
  }

  /**
   * Set post location
   */
  setLocation(location: PostLocation | null): void {
    this._location = location;
    this.updatedAt = new Date();
  }

  /**
   * Validates the post data
   * @throws Error if validation fails
   */
  validate(): void {
    if (!this.userId) {
      throw new Error("User ID is required");
    }

    // Check content size using JSON serialization
    if (JSON.stringify(this._content).length > 10000) {
      throw new Error("Content object is too large");
    }

    if (this._type === PostType.IMAGE && this._mediaIds.length === 0) {
      throw new Error("Image posts must have at least one media item");
    }

    if (this._type === PostType.VIDEO && this._mediaIds.length === 0) {
      throw new Error("Video posts must have at least one media item");
    }

    if (this._status === PostStatus.SCHEDULED && !this._scheduledAt) {
      throw new Error("Scheduled posts must have a scheduled date");
    }

    if (!Object.values(PostType).includes(this._type)) {
      throw new Error(`Invalid post type: ${this._type}`);
    }

    if (!Object.values(PostStatus).includes(this._status)) {
      throw new Error(`Invalid post status: ${this._status}`);
    }

    if (!Object.values(PostVisibility).includes(this._visibility)) {
      throw new Error(`Invalid post visibility: ${this._visibility}`);
    }

    if (this._scheduledAt && this._scheduledAt < new Date()) {
      throw new Error("Scheduled date must be in the future");
    }
  }

  /**
   * Publish the post
   */
  publish(): void {
    this._status = PostStatus.PUBLISHED;
    this._publishedAt = new Date();
    this.updatedAt = new Date();
  }

  /**
   * Schedule the post for future publishing
   */
  schedule(date: Date): void {
    if (date <= new Date()) {
      throw new Error("Scheduled date must be in the future");
    }
    this._status = PostStatus.SCHEDULED;
    this._scheduledAt = date;
    this.updatedAt = new Date();
  }

  /**
   * Archive the post
   */
  archive(): void {
    this._status = PostStatus.ARCHIVED;
    this.updatedAt = new Date();
  }

  /**
   * Delete the post (soft delete)
   */
  softDelete(): void {
    this._status = PostStatus.DELETED;
    this.updatedAt = new Date();
  }

  /**
   * Mark post as edited
   */
  markAsEdited(): void {
    this._isEdited = true;
    this.updatedAt = new Date();
  }

  /**
   * Increment like count
   */
  incrementLikeCount(): void {
    this._likeCount++;
    this.updatedAt = new Date();
  }

  /**
   * Decrement like count
   */
  decrementLikeCount(): void {
    this._likeCount = Math.max(0, this._likeCount - 1);
    this.updatedAt = new Date();
  }

  /**
   * Increment comment count
   */
  incrementCommentCount(): void {
    this._commentCount++;
    this.updatedAt = new Date();
  }

  /**
   * Decrement comment count
   */
  decrementCommentCount(): void {
    this._commentCount = Math.max(0, this._commentCount - 1);
    this.updatedAt = new Date();
  }

  /**
   * Increment share count
   */
  incrementShareCount(): void {
    this._shareCount++;
    this.updatedAt = new Date();
  }

  /**
   * Increment view count
   */
  incrementViewCount(): void {
    this._viewCount++;
    this.updatedAt = new Date();
  }

  /**
   * Pin the post
   */
  pin(): void {
    this._isPinned = true;
    this.updatedAt = new Date();
  }

  /**
   * Unpin the post
   */
  unpin(): void {
    this._isPinned = false;
    this.updatedAt = new Date();
  }

  /**
   * Add a tag to the post
   */
  addTag(tag: string): void {
    if (!this._metadata) {
      this._metadata = { tags: [] };
    }

    if (!this._metadata.tags) {
      this._metadata.tags = [];
    }

    if (!this._metadata.tags.includes(tag)) {
      this._metadata.tags.push(tag);
      this.updatedAt = new Date();
    }
  }

  /**
   * Remove a tag from the post
   */
  removeTag(tag: string): void {
    if (this._metadata && this._metadata.tags) {
      this._metadata.tags = this._metadata.tags.filter((t) => t !== tag);
      this.updatedAt = new Date();
    }
  }

  /**
   * Add a media item to the post
   */
  addMedia(mediaId: string): void {
    if (!this._mediaIds.includes(mediaId)) {
      this._mediaIds.push(mediaId);
      this.updatedAt = new Date();
    }
  }

  /**
   * Remove a media item from the post
   */
  removeMedia(mediaId: string): void {
    this._mediaIds = this._mediaIds.filter((id) => id !== mediaId);
    this.updatedAt = new Date();
  }

  /**
   * Check if post is published
   */
  isPublished(): boolean {
    return this._status === PostStatus.PUBLISHED;
  }

  /**
   * Check if post is a reply to another post
   */
  isReply(): boolean {
    return !!this._parentId;
  }

  /**
   * Check if post is a shared post
   */
  isShare(): boolean {
    return !!this._originalPostId;
  }

  /**
   * Check if post is scheduled
   */
  isScheduled(): boolean {
    return this._status === PostStatus.SCHEDULED;
  }

  /**
   * Check if post is ready to be published based on its scheduled date
   */
  isReadyToPublish(): boolean {
    if (this._status !== PostStatus.SCHEDULED) {
      return false;
    }

    return !!this._scheduledAt && this._scheduledAt <= new Date();
  }

  /**
   * Get attributes for repository operations
   */
  getAttributes(): PostAttributes {
    return {
      id: this.id,
      userId: this.userId,
      content: this._content,
      type: this._type,
      status: this._status,
      visibility: this._visibility,
      location: this._location,
      mediaIds: this._mediaIds,
      metadata: this._metadata,
      likeCount: this._likeCount,
      commentCount: this._commentCount,
      shareCount: this._shareCount,
      viewCount: this._viewCount,
      isEdited: this._isEdited,
      isPinned: this._isPinned,
      parentId: this._parentId,
      originalPostId: this._originalPostId,
      scheduledAt: this._scheduledAt,
      publishedAt: this._publishedAt,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt,
    };
  }

  /**
   * Convert post to JSON for API responses
   */
  toJSON(): PostJSON {
    return {
      id: this.id,
      userId: this.userId,
      content: this._content,
      type: this._type,
      status: this._status,
      visibility: this._visibility,
      location: this._location,
      mediaIds: [...this._mediaIds],
      metadata: this._metadata ? { ...this._metadata } : null,
      likeCount: this._likeCount,
      commentCount: this._commentCount,
      shareCount: this._shareCount,
      viewCount: this._viewCount,
      isEdited: this._isEdited,
      isPinned: this._isPinned,
      parentId: this._parentId,
      originalPostId: this._originalPostId,
      scheduledAt: this._scheduledAt ? this._scheduledAt.toISOString() : null,
      publishedAt: this._publishedAt ? this._publishedAt.toISOString() : null,
      createdAt: this.createdAt.toISOString(),
      updatedAt: this.updatedAt.toISOString(),
    };
  }
}

export default Post;



===========================================================
FILE 34: repositories\BaseRepository.ts
===========================================================

import { Pool, PoolClient } from "pg";

import { Logger } from "../../services/LoggerService";
import { DatabaseConnectionManager } from "../config";
import { BaseModelInterface } from "../models/BaseModel";

/**
 * Represents a validation error with field and message
 */
export interface ValidationError {
  field: string;
  message: string;
}

/**
 * Custom error thrown when validation fails
 */
export class ValidationFailedError extends Error {
  public errors: ValidationError[];

  constructor(errors: ValidationError[]) {
    super("Validation failed");
    this.name = "ValidationFailedError";
    this.errors = errors;
  }
}

/**
 * Base repository class that provides common database operations.
 * Repositories are responsible for:
 * 1. Handling all database operations (CRUD)
 * 2. Managing database connections and transactions
 * 3. Converting between database and model formats
 * 4. NOT implementing business logic (that's the model's job)
 *
 * @template T The type of model this repository handles
 */
export abstract class BaseRepository<T extends BaseModelInterface> {
  /**
   * The database table name for this repository
   */
  protected abstract tableName: string;

  /**
   * The columns available in the database table
   */
  protected abstract columns: string[];

  /**
   * Logger instance for this repository
   */
  protected logger: Logger;

  constructor() {
    this.logger = new Logger(this.constructor.name);
  }

  /**
   * Helper method for executing operations within a transaction
   * @param callback Function to execute within the transaction
   * @returns Result of the callback function
   */
  protected async withTransaction<R>(
    callback: (client: PoolClient) => Promise<R>,
  ): Promise<R> {
    return DatabaseConnectionManager.withTransaction(callback);
  }

  /**
   * Validate data before database operations
   * Override this method in child repositories to add specific validation rules
   * @param data The data to validate
   * @param isUpdate Whether this is for an update operation (partial data allowed)
   * @returns Validation errors if any
   */
  protected validateData(
    _data: Partial<T>,
    _isUpdate: boolean = false,
  ): ValidationError[] {
    const errors: ValidationError[] = [];

    // Basic validation that can be overridden in child repositories
    // This is just a placeholder for common validation logic

    return errors;
  }

  /**
   * Validate data and throw an error if validation fails
   * @param data The data to validate
   * @param isUpdate Whether this is for an update operation
   * @throws ValidationFailedError if validation fails
   */
  protected validateAndThrow(
    data: Partial<T>,
    isUpdate: boolean = false,
  ): void {
    const errors = this.validateData(data, isUpdate);
    if (errors.length > 0) {
      throw new ValidationFailedError(errors);
    }
  }

  /**
   * Convert an object to SQL parameters for prepared statements
   */
  protected objectToParams(
    obj: Partial<T>,
    startIndex: number = 1,
  ): [string[], (string | number | boolean | Date | null)[]] {
    const values: (string | number | boolean | Date | null)[] = [];
    const placeholders: string[] = [];

    Object.entries(obj).forEach(([_key, value], index) => {
      if (
        value !== undefined &&
        (typeof value === "string" ||
          typeof value === "number" ||
          typeof value === "boolean" ||
          value instanceof Date ||
          value === null)
      ) {
        values.push(value as string | number | boolean | Date | null);
        placeholders.push(`$${startIndex + index}`);
      }
    });

    return [placeholders, values];
  }

  /**
   * Execute a raw SQL query with proper error handling
   * @param sql SQL query string with placeholders
   * @param params Parameters for the query
   * @param client Optional database client for transactions
   * @returns Query result
   */
  protected async executeQuery<R extends Record<string, unknown>>(
    sql: string,
    params: unknown[] = [],
    client?: Pool,
  ): Promise<{ rows: R[]; rowCount: number }> {
    try {
      const dbClient = client || DatabaseConnectionManager.getPool();
      const result = await dbClient.query<R>(sql, params);
      return {
        rows: result.rows,
        rowCount: result.rowCount ?? 0,
      };
    } catch (error) {
      this.logger.error("Error executing query", {
        sql: sql.replace(/\s+/g, " ").trim(),
        params: params.map((p) =>
          typeof p === "string" && p.includes("password") ? "[REDACTED]" : p,
        ),
        error: error instanceof Error ? error.message : error,
        stack: error instanceof Error ? error.stack : undefined,
      });
      throw error;
    }
  }

  /**
   * Find records by a single field
   * @param field Field name
   * @param value Field value
   * @param options Query options
   * @returns Array of records
   */
  protected async findByField<R extends Record<string, unknown>>(
    field: string,
    value: string | number | boolean | Date | null,
    options: {
      limit?: number;
      offset?: number;
      orderBy?: string;
      client?: Pool;
    } = {},
  ): Promise<R[]> {
    const orderClause = options.orderBy ? `ORDER BY ${options.orderBy}` : "";
    const limitClause = options.limit ? `LIMIT ${options.limit}` : "";
    const offsetClause = options.offset ? `OFFSET ${options.offset}` : "";

    const query = `
      SELECT ${this.columns.join(", ")}
      FROM ${this.tableName}
      WHERE ${field} = $1
      ${orderClause}
      ${limitClause}
      ${offsetClause}
    `;

    const params = [value];
    if (options.limit) params.push(options.limit);
    if (options.offset) params.push(options.offset);

    const result = await this.executeQuery<R>(query, [value], options.client);
    return result.rows;
  }

  /**
   * Find a single record by a field
   * @param field Field name
   * @param value Field value
   * @param client Optional client for transactions
   * @returns Single record or null if not found
   */
  protected async findOneByField<R extends Record<string, unknown>>(
    field: string,
    value: string | number | boolean | Date | null,
    client?: Pool,
  ): Promise<R | null> {
    const query = `
      SELECT ${this.columns.join(", ")}
      FROM ${this.tableName}
      WHERE ${field} = $1
      LIMIT 1
    `;

    const result = await this.executeQuery<R>(query, [value], client);
    return result.rows.length > 0 ? result.rows[0] : null;
  }

  /**
   * Count records by a field
   * @param field Field name
   * @param value Field value
   * @param client Optional client for transactions
   * @returns Count of matching records
   */
  protected async countByField(
    field: string,
    value: string | number | boolean | Date | null,
    client?: Pool,
  ): Promise<number> {
    const query = `
      SELECT COUNT(*) as count
      FROM ${this.tableName}
      WHERE ${field} = $1
    `;

    const result = await this.executeQuery<{ count: string }>(
      query,
      [value],
      client,
    );
    return parseInt(result.rows[0].count, 10);
  }

  /**
   * Find a record by its ID
   */
  async findById(id: string, client?: Pool): Promise<T | null> {
    const query = `
      SELECT ${this.columns.join(", ")}
      FROM ${this.tableName}
      WHERE id = $1
    `;

    try {
      const result = await (
        client || DatabaseConnectionManager.getPool()
      ).query<T>(query, [id]);
      return result.rows[0] as T | null;
    } catch (error) {
      this.logger.error("Error in findById", {
        id,
        error: error instanceof Error ? error.message : error,
        stack: error instanceof Error ? error.stack : undefined,
      });
      throw error;
    }
  }

  /**
   * Find all records matching the given criteria
   */
  async findAll(
    where: Partial<T> = {},
    options: {
      limit?: number;
      offset?: number;
      orderBy?: string;
      client?: Pool;
    } = {},
  ): Promise<T[]> {
    const conditions: string[] = [];
    const values: (string | number | boolean | Date | null)[] = [];
    let paramIndex = 1;

    Object.entries(where).forEach(([key, value]) => {
      if (value !== undefined) {
        conditions.push(`${key} = $${paramIndex}`);
        if (
          typeof value === "string" ||
          typeof value === "number" ||
          typeof value === "boolean" ||
          value instanceof Date ||
          value === null
        ) {
          values.push(value as string | number | boolean | Date | null);
          paramIndex++;
        }
      }
    });

    const query = `
      SELECT ${this.columns.join(", ")}
      FROM ${this.tableName}
      ${conditions.length ? "WHERE " + conditions.join(" AND ") : ""}
      ${options.orderBy ? `ORDER BY ${options.orderBy}` : ""}
      ${options.limit ? `LIMIT $${paramIndex++}` : ""}
      ${options.offset ? `OFFSET $${paramIndex}` : ""}
    `;

    if (options.limit) values.push(options.limit);
    if (options.offset) values.push(options.offset);

    try {
      const result = await (
        options.client || DatabaseConnectionManager.getPool()
      ).query<T>(query, values);
      return result.rows;
    } catch (error) {
      this.logger.error("Error in findAll", {
        where,
        options,
        error: error instanceof Error ? error.message : error,
        stack: error instanceof Error ? error.stack : undefined,
      });
      throw error;
    }
  }

  /**
   * Convert camelCase to snake_case
   */
  protected camelToSnake(str: string): string {
    return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
  }

  /**
   * Create a new record
   */
  async create(data: Partial<T>, client?: Pool): Promise<T> {
    try {
      // Validate data before inserting
      this.validateAndThrow(data, false);

      // Convert camelCase keys to snake_case
      const snakeCaseData = Object.entries(data).reduce(
        (acc, [key, value]) => {
          acc[this.camelToSnake(key)] = value;
          return acc;
        },
        {} as Record<string, unknown>,
      ) as unknown as Partial<T>;

      const [placeholders, values] = this.objectToParams(snakeCaseData);
      const columns = Object.keys(snakeCaseData).join(", ");

      const query = `
        INSERT INTO ${this.tableName} (${columns})
        VALUES (${placeholders.join(", ")})
        RETURNING ${this.columns.join(", ")}
      `;

      this.logger.info("Creating record:", {
        table: this.tableName,
        data: Object.entries(snakeCaseData).reduce(
          (acc, [key, value]) => {
            acc[key] = key.includes("password") ? "[REDACTED]" : value;
            return acc;
          },
          {} as Record<string, unknown>,
        ),
      });

      this.logger.info("Generated SQL:", {
        query,
        values: values.map((v, i) => {
          if (
            typeof values[i] === "string" &&
            values[i].toString().includes("password")
          ) {
            return "[REDACTED]";
          }
          return v instanceof Date ? v.toISOString() : v;
        }),
      });

      const result = await (
        client || DatabaseConnectionManager.getPool()
      ).query<T>(query, values);

      this.logger.info("Create query successful:", {
        rowCount: result.rowCount,
        returnedColumns: Object.keys(result.rows[0] || {}),
      });

      return result.rows[0];
    } catch (error) {
      if (error instanceof ValidationFailedError) {
        this.logger.warn("Validation failed in create", {
          table: this.tableName,
          errors: error.errors,
          data: Object.entries(data).reduce(
            (acc, [key, value]) => {
              acc[key] = key.includes("password") ? "[REDACTED]" : value;
              return acc;
            },
            {} as Record<string, unknown>,
          ),
        });
        throw error;
      }

      this.logger.error("Error in create", {
        table: this.tableName,
        error: error instanceof Error ? error.message : error,
        stack: error instanceof Error ? error.stack : undefined,
      });
      throw error;
    }
  }

  /**
   * Update an existing record
   */
  async update(id: string, data: Partial<T>, client?: Pool): Promise<T | null> {
    try {
      // Validate data before updating
      this.validateAndThrow(data, true);

      const [placeholders, values] = this.objectToParams(data);
      const setClause = Object.keys(data)
        .map((key, index) => `${key} = ${placeholders[index]}`)
        .join(", ");

      const query = `
        UPDATE ${this.tableName}
        SET ${setClause}, updated_at = NOW()
        WHERE id = $${values.length + 1}
        RETURNING ${this.columns.join(", ")}
      `;

      this.logger.info("Updating record:", {
        table: this.tableName,
        id,
        data: Object.entries(data).reduce(
          (acc, [key, value]) => {
            acc[key] = key.includes("password") ? "[REDACTED]" : value;
            return acc;
          },
          {} as Record<string, unknown>,
        ),
      });

      const result = await (
        client || DatabaseConnectionManager.getPool()
      ).query<T>(query, [...values, id]);
      return result.rows[0] || null;
    } catch (error) {
      if (error instanceof ValidationFailedError) {
        this.logger.warn("Validation failed in update", {
          table: this.tableName,
          id,
          errors: error.errors,
          data: Object.entries(data).reduce(
            (acc, [key, value]) => {
              acc[key] = key.includes("password") ? "[REDACTED]" : value;
              return acc;
            },
            {} as Record<string, unknown>,
          ),
        });
        throw error;
      }

      this.logger.error("Error in update", {
        id,
        data: Object.entries(data).reduce(
          (acc, [key, value]) => {
            acc[key] = key.includes("password") ? "[REDACTED]" : value;
            return acc;
          },
          {} as Record<string, unknown>,
        ),
        error: error instanceof Error ? error.message : error,
        stack: error instanceof Error ? error.stack : undefined,
      });
      throw error;
    }
  }

  /**
   * Delete a record
   */
  async delete(id: string, client?: Pool): Promise<boolean> {
    const query = `
      DELETE FROM ${this.tableName}
      WHERE id = $1
      RETURNING id
    `;

    try {
      this.logger.info("Deleting record:", {
        table: this.tableName,
        id,
      });

      const pool = client || DatabaseConnectionManager.getPool();
      const result = await pool.query<T>(query, [id]);
      const rowCount = result.rowCount ?? 0;
      return rowCount > 0;
    } catch (error) {
      this.logger.error("Error in delete", {
        id,
        error: error instanceof Error ? error.message : error,
        stack: error instanceof Error ? error.stack : undefined,
      });
      throw error;
    }
  }

  /**
   * Count records matching the given criteria
   */
  async count(where: Partial<T> = {}, client?: Pool): Promise<number> {
    const conditions: string[] = [];
    const values: (string | number | boolean | Date | null)[] = [];
    let paramIndex = 1;

    Object.entries(where).forEach(([key, value]) => {
      if (value !== undefined) {
        conditions.push(`${key} = $${paramIndex}`);
        if (
          typeof value === "string" ||
          typeof value === "number" ||
          typeof value === "boolean" ||
          value instanceof Date ||
          value === null
        ) {
          values.push(value as string | number | boolean | Date | null);
          paramIndex++;
        }
      }
    });

    const query = `
      SELECT COUNT(*) as count
      FROM ${this.tableName}
      ${conditions.length ? "WHERE " + conditions.join(" AND ") : ""}
    `;

    try {
      const result = await (
        client || DatabaseConnectionManager.getPool()
      ).query<{ count: string }>(query, values);
      return parseInt(result.rows[0].count);
    } catch (error) {
      this.logger.error("Error in count", {
        where,
        error: error instanceof Error ? error.message : error,
        stack: error instanceof Error ? error.stack : undefined,
      });
      throw error;
    }
  }

  // Add a safe mapping method for query results
  protected mapResultRows<R>(
    rows: unknown[],
    mapper: (row: Record<string, unknown>) => R,
  ): R[] {
    return rows.map((row) => mapper(row as Record<string, unknown>));
  }

  // Add a safe method to get a single result
  protected getSingleResult<R>(
    rows: unknown[],
    mapper: (row: Record<string, unknown>) => R,
  ): R | null {
    if (!rows.length) return null;
    return this.mapResultRows(rows, mapper)[0];
  }

  // Ensure the mapper includes type checking
  protected abstract mapResultToModel(row: Record<string, unknown>): T;
}



===========================================================
FILE 35: repositories\analytics\ActivityLogRepository.ts
===========================================================

import {
  ActivityLog,
  ActivityLogAttributes,
  ActivityType,
} from "../../models/analytics/ActivityLog";
import { BaseRepository } from "../BaseRepository";

/**
 * Repository class for handling ActivityLog database operations.
 * This class is responsible for:
 * 1. All database operations related to activity logs
 * 2. Converting between database and model formats
 * 3. Providing specific query methods for activity logs
 * 4. NOT implementing business logic - that belongs in the ActivityLog model
 */
export class ActivityLogRepository extends BaseRepository<ActivityLog> {
  protected tableName = "activity_logs";
  protected columns = [
    "id",
    "user_id",
    "type",
    "target_id",
    "target_type",
    "metadata",
    "ip_address",
    "user_agent",
    "created_at",
  ];

  constructor() {
    super();
  }

  /**
   * Creates a new activity log entry.
   * This method handles the database operation and model conversion.
   *
   * @param data The activity log data to create
   * @returns The created ActivityLog instance
   */
  async create(
    data: Partial<ActivityLogAttributes> & {
      userId: string;
      type: ActivityType;
    },
  ): Promise<ActivityLog> {
    const activityLog = new ActivityLog(data);
    await super.create(activityLog);
    return activityLog;
  }

  /**
   * Finds an activity log by its ID.
   *
   * @param id The activity log ID
   * @returns The ActivityLog instance or null if not found
   */
  async findById(id: string): Promise<ActivityLog | null> {
    const result = await this.findOneByField("id", id);
    if (!result) return null;
    return new ActivityLog(result as unknown as ActivityLogAttributes);
  }

  /**
   * Finds all activity logs for a specific user.
   *
   * @param userId The user ID
   * @param options Query options for pagination
   * @returns Array of ActivityLog instances
   */
  async findByUserId(
    userId: string,
    options?: { limit?: number; offset?: number },
  ): Promise<ActivityLog[]> {
    const results = await this.findByField("user_id", userId, {
      limit: options?.limit,
      offset: options?.offset,
      orderBy: "created_at DESC",
    });

    return this.mapResultRows(
      results,
      (result) => new ActivityLog(result as unknown as ActivityLogAttributes),
    );
  }

  /**
   * Finds all activity logs of a specific type.
   *
   * @param type The activity type to search for
   * @param options Query options for pagination
   * @returns Array of ActivityLog instances
   */
  async findByType(
    type: ActivityType,
    options?: { limit?: number; offset?: number },
  ): Promise<ActivityLog[]> {
    const results = await this.findByField("type", type, {
      limit: options?.limit,
      offset: options?.offset,
      orderBy: "created_at DESC",
    });

    return this.mapResultRows(
      results,
      (result) => new ActivityLog(result as unknown as ActivityLogAttributes),
    );
  }

  /**
   * Finds all activity logs within a specific time range.
   *
   * @param startDate The start date
   * @param endDate The end date
   * @param options Query options for pagination
   * @returns Array of ActivityLog instances
   */
  async findByTimeRange(
    startDate: Date,
    endDate: Date,
    options?: { limit?: number; offset?: number },
  ): Promise<ActivityLog[]> {
    const query = `
      SELECT ${this.columns.join(", ")}
      FROM ${this.tableName}
      WHERE created_at >= $1 AND created_at <= $2
      ORDER BY created_at DESC
      ${options?.limit ? "LIMIT $3" : ""}
      ${options?.offset ? "OFFSET $4" : ""}
    `;

    const params: (Date | number)[] = [startDate, endDate];
    if (options?.limit) params.push(options.limit);
    if (options?.offset) params.push(options.offset);

    const results = await this.executeQuery<Record<string, unknown>>(
      query,
      params,
    );
    return this.mapResultRows(
      results.rows,
      (result) => new ActivityLog(result as unknown as ActivityLogAttributes),
    );
  }

  /**
   * Gets a summary of user activity within a specified time period.
   * This is a database operation that aggregates activity data.
   *
   * @param userId The user ID
   * @param days The number of days to look back
   * @returns Object containing activity counts by type
   */
  async getUserActivitySummary(
    userId: string,
    days: number = 30,
  ): Promise<Record<string, number>> {
    const endDate = new Date();
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);

    const query = `
      SELECT type, COUNT(*) as count
      FROM ${this.tableName}
      WHERE user_id = $1 
      AND created_at >= $2 
      AND created_at <= $3
      GROUP BY type
    `;

    const results = await this.executeQuery<{
      type: ActivityType;
      count: string;
    }>(query, [userId, startDate, endDate]);

    return results.rows.reduce((summary: Record<string, number>, row) => {
      summary[row.type] = parseInt(row.count, 10);
      return summary;
    }, {});
  }

  /**
   * Maps a database row to an ActivityLog model instance
   *
   * @param row The database row
   * @returns ActivityLog instance
   */
  protected mapResultToModel(row: Record<string, unknown>): ActivityLog {
    if (!row) return null as unknown as ActivityLog;
    return new ActivityLog(row as unknown as ActivityLogAttributes);
  }
}



===========================================================
FILE 36: repositories\auth\PasswordResetTokenRepository.ts
===========================================================

import crypto from "crypto";

import {
  PasswordResetToken,
  PasswordResetTokenAttributes,
  PasswordResetTokenStatus,
} from "../../models/auth/PasswordResetToken";
import { BaseRepository } from "../BaseRepository";

/**
 * Repository for managing password reset tokens.
 * Responsible for:
 * 1. Database operations for password reset tokens
 * 2. Token generation and verification
 * 3. Managing token lifecycle
 * 4. NOT implementing business logic - that belongs in the model
 */
export class PasswordResetTokenRepository extends BaseRepository<PasswordResetToken> {
  protected tableName = "password_reset_tokens";
  protected columns = [
    "id",
    "user_id",
    "token",
    "expires_at",
    "status",
    "used_at",
    "created_at",
    "updated_at",
  ];

  constructor() {
    super();
  }

  /**
   * Find token by token value
   */
  async findByToken(token: string): Promise<PasswordResetToken | null> {
    // Hash the token for lookup
    const hashedToken = this.hashToken(token);
    const result = await this.findOneByField("token", hashedToken);
    if (!result) return null;
    return new PasswordResetToken(
      result as unknown as PasswordResetTokenAttributes,
    );
  }

  /**
   * Find active tokens for a user
   */
  async findActiveTokensByUserId(
    userId: string,
  ): Promise<PasswordResetToken[]> {
    const query = `
      SELECT ${this.columns.join(", ")}
      FROM ${this.tableName}
      WHERE user_id = $1 AND status = $2 AND expires_at > NOW()
    `;

    const result = await this.executeQuery<Record<string, unknown>>(query, [
      userId,
      PasswordResetTokenStatus.ACTIVE,
    ]);

    return result.rows.map((row) => this.mapResultToModel(row));
  }

  /**
   * Create a new password reset token
   */
  async createToken(
    userId: string,
    expiresInHours = 24,
  ): Promise<PasswordResetToken> {
    // Generate a random token
    const tokenValue = crypto.randomBytes(32).toString("hex");

    // Hash the token for storage
    const hashedToken = this.hashToken(tokenValue);

    // Calculate expiration date
    const expiresAt = new Date();
    expiresAt.setHours(expiresAt.getHours() + expiresInHours);

    const data = {
      userId,
      token: hashedToken,
      expiresAt,
      status: PasswordResetTokenStatus.ACTIVE,
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    const token = new PasswordResetToken(data);
    await super.create(token);

    // Return token with unhashed value for sending to user
    const resultToken = new PasswordResetToken({
      ...token.toJSON(),
      token: tokenValue,
    });
    return resultToken;
  }

  /**
   * Mark a token as used
   */
  async markAsUsed(tokenId: string): Promise<PasswordResetToken | null> {
    const query = `
      UPDATE ${this.tableName}
      SET status = $1, used_at = NOW(), updated_at = NOW()
      WHERE id = $2
      RETURNING ${this.columns.join(", ")}
    `;

    const result = await this.executeQuery<Record<string, unknown>>(query, [
      PasswordResetTokenStatus.USED,
      tokenId,
    ]);

    if (result.rows.length === 0) {
      return null;
    }

    return this.mapResultToModel(result.rows[0]);
  }

  /**
   * Invalidate all tokens for a user
   */
  async invalidateAllUserTokens(userId: string): Promise<number> {
    const query = `
      UPDATE ${this.tableName}
      SET status = $1, updated_at = NOW()
      WHERE user_id = $2 AND status = $3
      RETURNING id
    `;

    const result = await this.executeQuery<{ id: string }>(query, [
      PasswordResetTokenStatus.EXPIRED,
      userId,
      PasswordResetTokenStatus.ACTIVE,
    ]);

    return result.rows.length;
  }

  /**
   * Clean up expired tokens (maintenance function)
   */
  async cleanupExpiredTokens(): Promise<number> {
    const query = `
      UPDATE ${this.tableName}
      SET status = $1, updated_at = NOW()
      WHERE (expires_at < NOW() AND status = $2)
      RETURNING id
    `;

    const result = await this.executeQuery<{ id: string }>(query, [
      PasswordResetTokenStatus.EXPIRED,
      PasswordResetTokenStatus.ACTIVE,
    ]);

    return result.rows.length;
  }

  /**
   * Verify a reset token
   */
  async verifyToken(tokenValue: string, userId: string): Promise<boolean> {
    // Hash the provided token for comparison
    const hashedToken = this.hashToken(tokenValue);

    const query = `
      SELECT id FROM ${this.tableName}
      WHERE token = $1 AND user_id = $2 AND status = $3 AND expires_at > NOW()
    `;

    const result = await this.executeQuery<{ id: string }>(query, [
      hashedToken,
      userId,
      PasswordResetTokenStatus.ACTIVE,
    ]);

    return result.rows.length > 0;
  }

  /**
   * Helper method to hash a token
   */
  private hashToken(token: string): string {
    return crypto.createHash("sha256").update(token).digest("hex");
  }

  /**
   * Maps database result to model instance
   */
  protected mapResultToModel(row: Record<string, unknown>): PasswordResetToken {
    if (!row) return null as unknown as PasswordResetToken;

    // Transform snake_case DB fields to camelCase for the model
    const tokenData = {
      id: row.id as string,
      userId: row.user_id as string,
      token: row.token as string,
      expiresAt: row.expires_at as Date,
      status: row.status as PasswordResetTokenStatus,
      usedAt: row.used_at ? (row.used_at as Date) : undefined,
      createdAt: row.created_at as Date,
      updatedAt: row.updated_at as Date,
    };

    return new PasswordResetToken(tokenData);
  }
}



===========================================================
FILE 37: repositories\auth\PermissionRepository.ts
===========================================================

import { Logger } from "../../../services/LoggerService";
import { Permission, PermissionAttributes } from "../../models/auth/Permission";
import { BaseRepository } from "../BaseRepository";

/**
 * Repository class for handling Permission database operations.
 * This class is responsible for:
 * 1. All database operations related to permissions
 * 2. Converting between database and model formats
 * 3. Providing specific query methods for permissions
 * 4. NOT implementing business logic - that belongs in the Permission model
 */
export class PermissionRepository extends BaseRepository<Permission> {
  protected logger = new Logger("PermissionRepository");
  protected tableName = "permissions";
  protected columns = [
    "id",
    "name",
    "description",
    "resource",
    "action",
    "created_at as createdAt",
    "updated_at as updatedAt",
  ];

  constructor() {
    super();
  }

  /**
   * Find a permission by its primary key
   */
  async findByPk(id: string): Promise<Permission | null> {
    const result = await this.findOneByField("id", id);
    if (!result) return null;
    return new Permission(result as unknown as PermissionAttributes);
  }

  /**
   * Find all permissions
   */
  async findAll(): Promise<Permission[]> {
    const results = await this.findByField("id", null, {
      orderBy: "resource, action ASC",
    });
    return this.mapResultRows(
      results,
      (result) => new Permission(result as unknown as PermissionAttributes),
    );
  }

  /**
   * Find permissions by resource
   */
  async findByResource(resource: string): Promise<Permission[]> {
    const results = await this.findByField("resource", resource, {
      orderBy: "action ASC",
    });
    return this.mapResultRows(
      results,
      (result) => new Permission(result as unknown as PermissionAttributes),
    );
  }

  /**
   * Find a permission by resource and action
   */
  async findByResourceAndAction(
    resource: string,
    action: string,
  ): Promise<Permission | null> {
    const query = `
      SELECT ${this.columns.join(", ")}
      FROM ${this.tableName}
      WHERE resource = $1 AND action = $2
    `;

    const result = await this.executeQuery<PermissionAttributes>(query, [
      resource,
      action,
    ]);
    if (!result.rows.length) return null;

    return new Permission(result.rows[0] as unknown as PermissionAttributes);
  }

  /**
   * Create a new permission
   */
  async create(
    data: Omit<PermissionAttributes, "id" | "createdAt" | "updatedAt">,
  ): Promise<Permission> {
    const permission = new Permission(data);
    permission.validate();

    const result = await super.create(permission);
    return new Permission(result as unknown as PermissionAttributes);
  }

  /**
   * Update a permission
   */
  async update(
    id: string,
    data: Partial<PermissionAttributes>,
  ): Promise<Permission | null> {
    const permission = new Permission(data);
    permission.validate();

    const result = await super.update(id, permission);
    if (!result) return null;

    return new Permission(result as unknown as PermissionAttributes);
  }

  /**
   * Delete a permission
   */
  async delete(id: string): Promise<boolean> {
    return super.delete(id);
  }

  /**
   * Map database result to Permission model
   */
  protected mapResultToModel(row: Record<string, unknown>): Permission {
    if (!row) return null as unknown as Permission;

    return new Permission({
      id: row.id as string,
      name: row.name as string,
      description: row.description as string,
      resource: row.resource as string,
      action: row.action as string,
      createdAt: (row.createdAt || row.created_at) as Date,
      updatedAt: (row.updatedAt || row.updated_at) as Date,
    });
  }
}



===========================================================
FILE 38: repositories\auth\RolePermissionRepository.ts
===========================================================

import { Logger } from "../../../services/LoggerService";
import { Permission } from "../../models/auth/Permission";
import { Role } from "../../models/auth/Role";
import {
  RolePermission,
  RolePermissionAttributes,
} from "../../models/auth/RolePermission";
import { BaseRepository } from "../BaseRepository";

/**
 * Repository class for handling RolePermission database operations.
 * This class is responsible for:
 * 1. All database operations related to role permissions
 * 2. Converting between database and model formats
 * 3. Providing specific query methods for role permissions
 * 4. NOT implementing business logic - that belongs in the RolePermission model
 */
export class RolePermissionRepository extends BaseRepository<RolePermission> {
  protected logger = new Logger("RolePermissionRepository");
  protected tableName = "role_permissions";
  protected columns = [
    "id",
    "role_id as roleId",
    "permission_id as permissionId",
    "created_at as createdAt",
    "updated_at as updatedAt",
  ];

  constructor() {
    super();
  }

  /**
   * Find role permissions by role ID
   */
  async findByRoleId(roleId: string): Promise<RolePermission[]> {
    const results = await this.findByField("role_id", roleId);
    return results.map((result) => new RolePermission(result));
  }

  /**
   * Find permissions for a role
   */
  async findPermissionsForRole(roleId: string): Promise<Permission[]> {
    const query = `
      SELECT p.id, p.name, p.description, p.resource, p.action, p.created_at as "createdAt", p.updated_at as "updatedAt"
      FROM permissions p
      JOIN ${this.tableName} rp ON p.id = rp.permission_id
      WHERE rp.role_id = $1
      ORDER BY p.resource, p.action
    `;

    const results = await this.executeQuery<Record<string, unknown>>(query, [
      roleId,
    ]);
    return results.rows.map((row) => {
      return new Permission({
        id: row.id as string,
        name: row.name as string,
        description: row.description as string,
        resource: row.resource as string,
        action: row.action as string,
        createdAt: (row.createdAt || row.created_at) as Date,
        updatedAt: (row.updatedAt || row.updated_at) as Date,
      });
    });
  }

  /**
   * Find roles for a permission
   */
  async findRolesForPermission(permissionId: string): Promise<Role[]> {
    const query = `
      SELECT r.id, r.name, r.description, r.created_at as "createdAt", r.updated_at as "updatedAt"
      FROM roles r
      JOIN ${this.tableName} rp ON r.id = rp.role_id
      WHERE rp.permission_id = $1
      ORDER BY r.name
    `;

    const results = await this.executeQuery<Record<string, unknown>>(query, [
      permissionId,
    ]);
    return results.rows.map((row) => {
      return new Role({
        id: row.id as string,
        name: row.name as string,
        description: row.description as string,
        createdAt: (row.createdAt || row.created_at) as Date,
        updatedAt: (row.updatedAt || row.updated_at) as Date,
      });
    });
  }

  /**
   * Check if a role has a specific permission
   */
  async hasPermission(roleId: string, permissionId: string): Promise<boolean> {
    const query = `
      SELECT id
      FROM ${this.tableName}
      WHERE role_id = $1 AND permission_id = $2
      LIMIT 1
    `;

    const result = await this.executeQuery<{ id: string }>(query, [
      roleId,
      permissionId,
    ]);
    return result.rows.length > 0;
  }

  /**
   * Assign a permission to a role
   */
  async assignPermission(
    roleId: string,
    permissionId: string,
  ): Promise<RolePermission> {
    // Check if assignment already exists
    const query = `
      SELECT ${this.columns.join(", ")}
      FROM ${this.tableName}
      WHERE role_id = $1 AND permission_id = $2
      LIMIT 1
    `;

    const result = await this.executeQuery(query, [roleId, permissionId]);
    if (result.rows.length > 0) {
      return new RolePermission(result.rows[0] as RolePermissionAttributes);
    }

    // Create new role permission
    const rolePermission = new RolePermission({
      roleId,
      permissionId,
    });

    rolePermission.validate();
    const createResult = await super.create(rolePermission);
    return new RolePermission(createResult);
  }

  /**
   * Remove a permission from a role
   */
  async removePermission(
    roleId: string,
    permissionId: string,
  ): Promise<boolean> {
    const query = `
      DELETE FROM ${this.tableName}
      WHERE role_id = $1 AND permission_id = $2
      RETURNING id
    `;

    const result = await this.executeQuery<{ id: string }>(query, [
      roleId,
      permissionId,
    ]);
    return result.rowCount > 0;
  }

  /**
   * Remove all permissions from a role
   */
  async removeAllPermissions(roleId: string): Promise<number> {
    const query = `
      DELETE FROM ${this.tableName}
      WHERE role_id = $1
      RETURNING id
    `;

    const result = await this.executeQuery<{ id: string }>(query, [roleId]);
    return result.rowCount;
  }

  /**
   * Map database result to RolePermission model
   */
  protected mapResultToModel(row: Record<string, unknown>): RolePermission {
    if (!row) return null as unknown as RolePermission;

    return new RolePermission({
      id: row.id as string,
      roleId: (row.roleId || row.role_id) as string,
      permissionId: (row.permissionId || row.permission_id) as string,
      createdAt: (row.createdAt || row.created_at) as Date,
      updatedAt: (row.updatedAt || row.updated_at) as Date,
    });
  }
}



===========================================================
FILE 39: repositories\auth\RoleRepository.ts
===========================================================

import { Logger } from "../../../services/LoggerService";
import { Role, RoleAttributes } from "../../models/auth/Role";
import { BaseRepository } from "../BaseRepository";

/**
 * Repository class for handling Role database operations.
 * This class is responsible for:
 * 1. All database operations related to roles
 * 2. Converting between database and model formats
 * 3. Providing specific query methods for roles
 * 4. NOT implementing business logic - that belongs in the Role model
 */
export class RoleRepository extends BaseRepository<Role> {
  protected logger = new Logger("RoleRepository");
  protected tableName = "roles";
  protected columns = [
    "id",
    "name",
    "description",
    "created_at as createdAt",
    "updated_at as updatedAt",
  ];

  constructor() {
    super();
  }

  /**
   * Find a role by its primary key
   */
  async findByPk(id: string): Promise<Role | null> {
    const result = await this.findOneByField("id", id);
    if (!result) return null;
    return new Role(result as unknown as RoleAttributes);
  }

  /**
   * Find all roles
   */
  async findAll(): Promise<Role[]> {
    const results = await this.findByField("id", null, { orderBy: "name ASC" });
    return this.mapResultRows(
      results,
      (result) => new Role(result as unknown as RoleAttributes),
    );
  }

  /**
   * Find a role by name
   */
  async findByName(name: string): Promise<Role | null> {
    const result = await this.findOneByField("name", name);
    if (!result) return null;
    return new Role(result as unknown as RoleAttributes);
  }

  /**
   * Create a new role
   */
  async create(
    data: Omit<RoleAttributes, "id" | "createdAt" | "updatedAt">,
  ): Promise<Role> {
    const role = new Role(data);
    role.validate();

    const result = await super.create(role);
    return new Role(result as unknown as RoleAttributes);
  }

  /**
   * Update a role
   */
  async update(
    id: string,
    data: Partial<RoleAttributes>,
  ): Promise<Role | null> {
    const role = new Role(data);
    role.validate();

    // Prevent updating system roles
    const existingRole = await this.findByPk(id);
    if (existingRole && existingRole.isSystemRole()) {
      throw new Error(`Cannot modify system role: ${existingRole.name}`);
    }

    const result = await super.update(id, role);
    if (!result) return null;

    return new Role(result as unknown as RoleAttributes);
  }

  /**
   * Delete a role
   */
  async delete(id: string): Promise<boolean> {
    // Prevent deleting system roles
    const existingRole = await this.findByPk(id);
    if (existingRole && existingRole.isSystemRole()) {
      throw new Error(`Cannot delete system role: ${existingRole.name}`);
    }

    return super.delete(id);
  }

  /**
   * Map database result to Role model
   */
  protected mapResultToModel(row: Record<string, unknown>): Role {
    if (!row) return null as unknown as Role;

    return new Role({
      id: row.id as string,
      name: row.name as string,
      description: row.description as string,
      createdAt: (row.createdAt || row.created_at) as Date,
      updatedAt: (row.updatedAt || row.updated_at) as Date,
    });
  }
}



===========================================================
FILE 40: repositories\auth\TokenRepository.ts
===========================================================

import { Logger } from "../../../services/LoggerService";
import { Token, TokenAttributes, TokenType } from "../../models/auth/Token";
import { BaseRepository } from "../BaseRepository";

/**
 * Repository class for handling Token database operations.
 * This class is responsible for:
 * 1. All database operations related to tokens
 * 2. Converting between database and model formats
 * 3. Providing specific query methods for tokens
 * 4. NOT implementing business logic - that belongs in the Token model
 */
export class TokenRepository extends BaseRepository<Token> {
  protected logger = new Logger("TokenRepository");
  protected tableName = "tokens";
  protected columns = [
    "id",
    "user_id as userId",
    "token",
    "type",
    "device_info as deviceInfo",
    "ip_address as ipAddress",
    "expires_at as expiresAt",
    "last_used_at as lastUsedAt",
    "revoked",
    "created_at as createdAt",
    "updated_at as updatedAt",
  ];

  constructor() {
    super();
  }

  /**
   * Find a token by its primary key
   */
  async findByPk(id: string): Promise<Token | null> {
    const result = await this.findOneByField("id", id);
    if (!result) return null;
    return new Token(result);
  }

  /**
   * Find a token by its token string
   */
  async findByToken(token: string): Promise<Token | null> {
    const result = await this.findOneByField("token", token);
    if (!result) return null;
    return new Token(result);
  }

  /**
   * Find tokens by user ID and type
   */
  async findByUserAndType(userId: string, type: TokenType): Promise<Token[]> {
    const query = `
      SELECT ${this.columns.join(", ")}
      FROM ${this.tableName}
      WHERE user_id = $1 AND type = $2 AND revoked = false AND expires_at > NOW()
      ORDER BY created_at DESC
    `;

    const result = await this.executeQuery<TokenAttributes>(query, [
      userId,
      type,
    ]);
    return this.mapResultRows(
      result.rows,
      (result) => new Token(result as unknown as TokenAttributes),
    );
  }

  /**
   * Create a new token
   */
  async create(
    data: Omit<TokenAttributes, "id" | "createdAt" | "updatedAt">,
  ): Promise<Token> {
    const token = new Token(data);
    token.validate();

    const result = await super.create(token);
    return new Token(result as unknown as TokenAttributes);
  }

  /**
   * Update a token
   */
  async update(
    id: string,
    data: Partial<TokenAttributes>,
  ): Promise<Token | null> {
    const token = new Token(data);

    const result = await super.update(id, token);
    if (!result) return null;

    return new Token(result as unknown as TokenAttributes);
  }

  /**
   * Update last used timestamp
   */
  async updateLastUsed(id: string): Promise<Token | null> {
    const token = await this.findByPk(id);
    if (!token) return null;

    token.markAsUsed();
    const result = await super.update(id, token);
    if (!result) return null;

    return new Token(result as unknown as TokenAttributes);
  }

  /**
   * Revoke a token
   */
  async revoke(id: string): Promise<Token | null> {
    const token = await this.findByPk(id);
    if (!token) return null;

    token.revokeToken();
    const result = await super.update(id, token);
    if (!result) return null;

    return new Token(result as unknown as TokenAttributes);
  }

  /**
   * Revoke all tokens for a user
   */
  async revokeAllForUser(
    userId: string,
    exceptTokenId?: string,
  ): Promise<number> {
    const query = `
      UPDATE ${this.tableName}
      SET revoked = true, updated_at = NOW()
      WHERE user_id = $1 AND revoked = false
      ${exceptTokenId ? "AND id != $2" : ""}
    `;

    const params = [userId];
    if (exceptTokenId) {
      params.push(exceptTokenId);
    }

    const result = await this.executeQuery<{ id: string }>(query, params);
    return result.rowCount;
  }

  /**
   * Delete expired tokens
   */
  async deleteExpired(): Promise<number> {
    const query = `
      DELETE FROM ${this.tableName}
      WHERE expires_at < NOW() AND revoked = true
    `;

    const result = await this.executeQuery<{ id: string }>(query);
    return result.rowCount;
  }

  /**
   * Map database result to Token model
   */
  protected mapResultToModel(row: Record<string, unknown>): Token {
    if (!row) return null as unknown as Token;

    return new Token({
      id: row.id as string,
      userId: (row.userId || row.user_id) as string,
      token: row.token as string,
      type: row.type as TokenType,
      deviceInfo: (row.deviceInfo || row.device_info) as string,
      ipAddress: (row.ipAddress || row.ip_address) as string,
      expiresAt: (row.expiresAt || row.expires_at) as Date,
      lastUsedAt: (row.lastUsedAt || row.last_used_at) as Date,
      revoked: row.revoked as boolean,
      createdAt: (row.createdAt || row.created_at) as Date,
      updatedAt: (row.updatedAt || row.updated_at) as Date,
    });
  }
}



===========================================================
FILE 41: repositories\auth\UserRepository.ts
===========================================================

import bcrypt from "bcrypt";

import { Logger } from "../../../services/LoggerService";
import { User, UserAttributes } from "../../models/auth/User";
import { BaseRepository } from "../BaseRepository";

/**
 * Repository class for handling User database operations.
 * This class is responsible for:
 * 1. All database operations related to users
 * 2. Converting between database and model formats
 * 3. Providing specific query methods for users
 * 4. NOT implementing business logic - that belongs in the User model
 */
export class UserRepository extends BaseRepository<User> {
  protected logger = new Logger("UserRepository");
  protected tableName = "users";
  protected columns = [
    "id",
    "username",
    "email",
    "password",
    "display_name as displayName",
    "first_name as firstName",
    "last_name as lastName",
    "bio",
    "profile_image as profileImage",
    "banner_image as bannerImage",
    "role",
    "is_verified as isVerified",
    "email_confirmed as emailConfirmed",
    "email_token as emailToken",
    "email_token_expire as emailTokenExpire",
    "last_email_sent as lastEmailSent",
    "created_at as createdAt",
    "updated_at as updatedAt",
  ];

  constructor() {
    super();
  }

  /**
   * Find a user by ID
   * @param id The user ID
   * @returns The user or null if not found
   */
  async findByPk(id: string): Promise<User | null> {
    const result = await this.findOneByField("id", id);
    if (!result) return null;
    return new User(result as unknown as UserAttributes);
  }

  /**
   * Find all users
   * @returns An array of users
   */
  async findAll(): Promise<User[]> {
    const results = await this.findByField("id", null);
    return this.mapResultRows(
      results,
      (result) => new User(result as unknown as UserAttributes),
    );
  }

  /**
   * Find a user by email
   * @param email The email to search for
   * @returns The user or null if not found
   */
  async findByEmail(email: string): Promise<User | null> {
    const result = await this.findOneByField("email", email);
    if (!result) return null;
    return new User(result as unknown as UserAttributes);
  }

  /**
   * Find a user by username
   * @param username The username to search for
   * @returns The user or null if not found
   */
  async findByUsername(username: string): Promise<User | null> {
    const result = await this.findOneByField("username", username);
    if (!result) return null;
    return new User(result as unknown as UserAttributes);
  }

  /**
   * Find a user by multiple conditions
   * @param conditions The conditions to search by
   * @returns The user or null if not found
   */
  async findOne(conditions: Partial<UserAttributes>): Promise<User | null> {
    const whereConditions: Record<string, unknown> = {};

    Object.entries(conditions).forEach(([key, value]) => {
      if (value !== undefined) {
        whereConditions[key] = value;
      }
    });

    if (Object.keys(whereConditions).length === 0) {
      return null;
    }

    // For simple single-field conditions, use findOneByField
    if (Object.keys(whereConditions).length === 1) {
      const [key, value] = Object.entries(whereConditions)[0];
      return this.findOneByField(
        key,
        value as string | number | boolean | Date | null,
      );
    }

    // For multiple conditions, build a custom query
    const whereClause = Object.keys(whereConditions)
      .map((key, index) => `${this.camelToSnake(key)} = $${index + 1}`)
      .join(" AND ");

    const query = `
      SELECT ${this.columns.join(", ")}
      FROM ${this.tableName}
      WHERE ${whereClause}
    `;

    const values = Object.values(whereConditions);
    const result = await this.executeQuery<UserAttributes>(query, values);

    if (!result.rows.length) return null;
    return new User(result.rows[0] as unknown as UserAttributes);
  }

  /**
   * Create a new user with a hashed password
   * @param data The user data
   * @returns The created user
   */
  async createWithHashedPassword(
    data: Omit<UserAttributes, "id" | "createdAt" | "updatedAt">,
  ): Promise<User> {
    // Create a new user instance
    const user = new User(data);

    // Validate the user data
    user.validate();

    // Hash the password
    user.password = await bcrypt.hash(data.password as string, 10);

    // Create the user in the database
    const result = await super.create(user);

    return new User(result as unknown as UserAttributes);
  }

  /**
   * Update a user
   * @param id The user ID
   * @param data The data to update
   * @returns The updated user
   */
  async update(
    id: string,
    data: Partial<UserAttributes>,
  ): Promise<User | null> {
    // If password is included, hash it
    if (data.password) {
      data.password = await bcrypt.hash(data.password, 10);
    }

    // Create a user instance with the data
    const user = new User(data);

    // Update the user in the database
    const result = await super.update(id, user);
    if (!result) return null;

    return new User(result as unknown as UserAttributes);
  }

  /**
   * Delete a user
   * @param id The user ID
   * @returns True if the user was deleted, false otherwise
   */
  async delete(id: string): Promise<boolean> {
    return super.delete(id);
  }

  /**
   * Find users by their role
   * @param role The role to search for
   * @returns An array of users with the specified role
   */
  async findByRole(role: string): Promise<User[]> {
    const results = await this.findByField("role", role);
    return this.mapResultRows(
      results,
      (result) => new User(result as unknown as UserAttributes),
    );
  }

  /**
   * Find unverified users
   * @returns An array of unverified users
   */
  async findUnverifiedUsers(): Promise<User[]> {
    const query = `
      SELECT ${this.columns.join(", ")}
      FROM ${this.tableName}
      WHERE is_verified = false AND email_confirmed = false
    `;

    const result = await this.executeQuery<Record<string, unknown>>(query);
    return this.mapResultRows(
      result.rows,
      (result) => new User(result as unknown as UserAttributes),
    );
  }

  /**
   * Convert camelCase to snake_case
   * @param str The string to convert
   * @returns The converted string
   */
  protected camelToSnake(str: string): string {
    return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
  }

  /**
   * Maps database result to User model
   */
  protected mapResultToModel(row: Record<string, unknown>): User {
    if (!row) return null as unknown as User;

    return new User({
      id: row.id as string,
      username: row.username as string,
      email: row.email as string,
      password: row.password as string,
      displayName: (row.displayName || row.display_name) as string,
      firstName: (row.firstName || row.first_name) as string,
      lastName: (row.lastName || row.last_name) as string,
      bio: row.bio as string,
      profileImage: (row.profileImage || row.profile_image) as string,
      bannerImage: (row.bannerImage || row.banner_image) as string,
      role: row.role as string,
      isVerified: (row.isVerified || row.is_verified) as boolean,
      emailConfirmed: (row.emailConfirmed || row.email_confirmed) as boolean,
      emailToken: (row.emailToken || row.email_token) as string,
      emailTokenExpire: (row.emailTokenExpire ||
        row.email_token_expire) as Date,
      lastEmailSent: (row.lastEmailSent || row.last_email_sent) as Date,
      createdAt: (row.createdAt || row.created_at) as Date,
      updatedAt: (row.updatedAt || row.updated_at) as Date,
    });
  }
}

// Export a singleton instance
export const userRepository = new UserRepository();



===========================================================
FILE 42: repositories\auth\UserRoleRepository.ts
===========================================================

import { Logger } from "../../../services/LoggerService";
import { Role, RoleAttributes } from "../../models/auth/Role";
import { UserAttributes } from "../../models/auth/User";
import { UserRole, UserRoleAttributes } from "../../models/auth/UserRole";
import { BaseRepository } from "../BaseRepository";

/**
 * Repository class for handling UserRole database operations.
 * This class is responsible for:
 * 1. All database operations related to user-role assignments
 * 2. Converting between database and model formats
 * 3. Providing specific query methods for user-role relationships
 * 4. NOT implementing business logic - that belongs in the UserRole model
 */
export class UserRoleRepository extends BaseRepository<UserRole> {
  protected logger = new Logger("UserRoleRepository");
  protected tableName = "user_roles";
  protected columns = [
    "id",
    "user_id as userId",
    "role_id as roleId",
    "created_at as createdAt",
    "updated_at as updatedAt",
  ];

  constructor() {
    super();
  }

  /**
   * Find user roles by user ID
   * @param userId The user ID to search for
   * @returns Array of UserRole instances
   */
  async findByUserId(userId: string): Promise<UserRole[]> {
    const results = await this.findByField("user_id", userId);
    return this.mapResultRows(
      results,
      (result) => new UserRole(result as unknown as UserRoleAttributes),
    );
  }

  /**
   * Find roles for a user
   * @param userId The user ID to search for
   * @returns Array of Role instances
   */
  async findRolesForUser(userId: string): Promise<Role[]> {
    const query = `
      SELECT r.id, r.name, r.description, r.created_at as "createdAt", r.updated_at as "updatedAt"
      FROM roles r
      JOIN ${this.tableName} ur ON r.id = ur.role_id
      WHERE ur.user_id = $1
      ORDER BY r.name
    `;

    const result = await this.executeQuery<Record<string, unknown>>(query, [
      userId,
    ]);
    return this.mapResultRows(
      result.rows,
      (row) => new Role(row as unknown as RoleAttributes),
    );
  }

  /**
   * Find users with a specific role
   * @param roleId The role ID to search for
   * @param limit Maximum number of users to return
   * @param offset Number of users to skip
   * @returns Array of UserAttributes
   */
  async findUsersWithRole(
    roleId: string,
    limit: number = 50,
    offset: number = 0,
  ): Promise<UserAttributes[]> {
    const query = `
      SELECT u.id, u.username, u.email, u.display_name as "displayName", 
        u.first_name as "firstName", u.last_name as "lastName", 
        u.bio, u.profile_image as "profileImage", u.banner_image as "bannerImage",
        u.role, u.is_verified as "isVerified", u.email_confirmed as "emailConfirmed",
        u.created_at as "createdAt", u.updated_at as "updatedAt"
      FROM users u
      JOIN ${this.tableName} ur ON u.id = ur.user_id
      WHERE ur.role_id = $1
      ORDER BY u.username
      LIMIT $2 OFFSET $3
    `;

    const result = await this.executeQuery<Record<string, unknown>>(query, [
      roleId,
      limit,
      offset,
    ]);
    return result.rows as unknown as UserAttributes[];
  }

  /**
   * Check if a user has a specific role
   * @param userId The user ID to check
   * @param roleId The role ID to check
   * @returns True if the user has the role
   */
  async hasRole(userId: string, roleId: string): Promise<boolean> {
    const query = `
      SELECT id
      FROM ${this.tableName}
      WHERE user_id = $1 AND role_id = $2
      LIMIT 1
    `;

    const result = await this.executeQuery<{ id: string }>(query, [
      userId,
      roleId,
    ]);
    return result.rows.length > 0;
  }

  /**
   * Assign a role to a user
   * @param userId The user ID to assign the role to
   * @param roleId The role ID to assign
   * @returns The created UserRole instance
   */
  async assignRole(userId: string, roleId: string): Promise<UserRole> {
    // Create a new user role instance
    const userRole = new UserRole({ userId, roleId });
    userRole.validate();

    // Check if assignment already exists
    const existingRoleQuery = `
      SELECT ${this.columns.join(", ")}
      FROM ${this.tableName}
      WHERE user_id = $1 AND role_id = $2
      LIMIT 1
    `;

    const existingResult = await this.executeQuery<UserRoleAttributes>(
      existingRoleQuery,
      [userId, roleId],
    );
    const existing =
      existingResult.rows.length > 0
        ? new UserRole(existingResult.rows[0])
        : null;

    if (existing) {
      return existing;
    }

    // Create new assignment
    const result = await super.create(userRole);
    return new UserRole(result as unknown as UserRoleAttributes);
  }

  /**
   * Remove a role from a user
   * @param userId The user ID to remove the role from
   * @param roleId The role ID to remove
   * @returns True if the role was removed
   */
  async removeRole(userId: string, roleId: string): Promise<boolean> {
    const query = `
      DELETE FROM ${this.tableName}
      WHERE user_id = $1 AND role_id = $2
      RETURNING id
    `;

    const result = await this.executeQuery<{ id: string }>(query, [
      userId,
      roleId,
    ]);
    return result.rows.length > 0;
  }

  /**
   * Remove all roles from a user
   * @param userId The user ID to remove all roles from
   * @returns Number of roles removed
   */
  async removeAllRoles(userId: string): Promise<number> {
    const query = `
      DELETE FROM ${this.tableName}
      WHERE user_id = $1
      RETURNING id
    `;

    const result = await this.executeQuery<{ id: string }>(query, [userId]);
    return result.rows.length;
  }

  /**
   * Map database result to UserRole model
   */
  protected mapResultToModel(row: Record<string, unknown>): UserRole {
    if (!row) return null as unknown as UserRole;

    return new UserRole({
      id: row.id as string,
      userId: (row.userId || row.user_id) as string,
      roleId: (row.roleId || row.role_id) as string,
      createdAt: (row.createdAt || row.created_at) as Date,
      updatedAt: (row.updatedAt || row.updated_at) as Date,
    });
  }
}

// Export a singleton instance
export const userRoleRepository = new UserRoleRepository();



===========================================================
FILE 43: repositories\community\GroupMemberRepository.ts
===========================================================

import { Logger } from "../../../services/LoggerService";
import { GroupMemberRole } from "../../models/community/Group";
import {
  GroupMember,
  GroupMemberAttributes,
  MembershipStatus,
} from "../../models/community/GroupMember";
import { BaseRepository } from "../BaseRepository";

/**
 * Repository class for handling GroupMember database operations.
 * This class is responsible for:
 * 1. All database operations related to group members
 * 2. Converting between database and model formats
 * 3. Providing specific query methods for group memberships
 * 4. NOT implementing business logic - that belongs in the GroupMember model
 */
export class GroupMemberRepository extends BaseRepository<GroupMember> {
  protected logger = new Logger("GroupMemberRepository");
  protected tableName = "group_members";
  protected columns = [
    "id",
    "group_id as groupId",
    "user_id as userId",
    "role",
    "status",
    "notification_settings as notificationSettings",
    "metadata",
    "last_activity as lastActivity",
    "created_at as createdAt",
    "updated_at as updatedAt",
  ];

  constructor() {
    super();
  }

  /**
   * Find members of a group
   * @param groupId The group ID
   * @param limit Maximum number of members to return
   * @param offset Number of members to skip
   * @param status The membership status to filter by
   * @returns Array of GroupMember instances
   */
  async findByGroupId(
    groupId: string,
    limit = 50,
    offset = 0,
    status = MembershipStatus.APPROVED,
  ): Promise<GroupMember[]> {
    const query = `
      SELECT ${this.columns.join(", ")}
      FROM ${this.tableName}
      WHERE group_id = $1 AND status = $2
      ORDER BY role, created_at ASC
      LIMIT $3 OFFSET $4
    `;

    const result = await this.executeQuery<GroupMemberAttributes>(query, [
      groupId,
      status,
      limit,
      offset,
    ]);

    return this.mapResultRows(
      result.rows,
      (result) => new GroupMember(result as unknown as GroupMemberAttributes),
    );
  }

  /**
   * Find groups that a user is a member of
   * @param userId The user ID
   * @param limit Maximum number of memberships to return
   * @param offset Number of memberships to skip
   * @param status The membership status to filter by
   * @returns Array of GroupMember instances
   */
  async findByUserId(
    userId: string,
    limit = 20,
    offset = 0,
    status = MembershipStatus.APPROVED,
  ): Promise<GroupMember[]> {
    const query = `
      SELECT ${this.columns.join(", ")}
      FROM ${this.tableName}
      WHERE user_id = $1 AND status = $2
      ORDER BY last_activity DESC NULLS LAST, created_at DESC
      LIMIT $3 OFFSET $4
    `;

    const result = await this.executeQuery<GroupMemberAttributes>(query, [
      userId,
      status,
      limit,
      offset,
    ]);

    return this.mapResultRows(
      result.rows,
      (result) => new GroupMember(result as unknown as GroupMemberAttributes),
    );
  }

  /**
   * Find membership record by group and user IDs
   * @param groupId The group ID
   * @param userId The user ID
   * @returns The GroupMember instance or null if not found
   */
  async findByGroupAndUserId(
    groupId: string,
    userId: string,
  ): Promise<GroupMember | null> {
    const query = `
      SELECT ${this.columns.join(", ")}
      FROM ${this.tableName}
      WHERE group_id = $1 AND user_id = $2
      LIMIT 1
    `;

    const result = await this.executeQuery<GroupMemberAttributes>(query, [
      groupId,
      userId,
    ]);

    if (result.rows.length === 0) {
      return null;
    }

    return new GroupMember(result.rows[0] as unknown as GroupMemberAttributes);
  }

  /**
   * Find members by role
   * @param groupId The group ID
   * @param role The role to filter by
   * @param limit Maximum number of members to return
   * @param offset Number of members to skip
   * @returns Array of GroupMember instances
   */
  async findByRole(
    groupId: string,
    role: GroupMemberRole,
    limit = 20,
    offset = 0,
  ): Promise<GroupMember[]> {
    const query = `
      SELECT ${this.columns.join(", ")}
      FROM ${this.tableName}
      WHERE group_id = $1 AND role = $2 AND status = $3
      ORDER BY created_at ASC
      LIMIT $4 OFFSET $5
    `;

    const result = await this.executeQuery<GroupMemberAttributes>(query, [
      groupId,
      role,
      MembershipStatus.APPROVED,
      limit,
      offset,
    ]);

    return this.mapResultRows(
      result.rows,
      (result) => new GroupMember(result as unknown as GroupMemberAttributes),
    );
  }

  /**
   * Find members by status
   * @param groupId The group ID
   * @param status The status to filter by
   * @param limit Maximum number of members to return
   * @param offset Number of members to skip
   * @returns Array of GroupMember instances
   */
  async findByStatus(
    groupId: string,
    status: MembershipStatus,
    limit = 20,
    offset = 0,
  ): Promise<GroupMember[]> {
    const query = `
      SELECT ${this.columns.join(", ")}
      FROM ${this.tableName}
      WHERE group_id = $1 AND status = $2
      ORDER BY created_at ASC
      LIMIT $3 OFFSET $4
    `;

    const result = await this.executeQuery<GroupMemberAttributes>(query, [
      groupId,
      status,
      limit,
      offset,
    ]);

    return this.mapResultRows(
      result.rows,
      (result) => new GroupMember(result as unknown as GroupMemberAttributes),
    );
  }

  /**
   * Count members by status
   * @param groupId The group ID
   * @param status The status to count
   * @returns The count of members with the specified status
   */
  async countByStatus(
    groupId: string,
    status: MembershipStatus,
  ): Promise<number> {
    const query = `
      SELECT COUNT(*) as count
      FROM ${this.tableName}
      WHERE group_id = $1 AND status = $2
    `;

    const result = await this.executeQuery<{ count: string }>(query, [
      groupId,
      status,
    ]);

    return parseInt(result.rows[0].count, 10);
  }

  /**
   * Update member role
   * @param groupId The group ID
   * @param userId The user ID
   * @param role The new role
   * @returns The updated GroupMember instance or null if not found
   */
  async updateRole(
    groupId: string,
    userId: string,
    role: GroupMemberRole,
  ): Promise<GroupMember | null> {
    const query = `
      UPDATE ${this.tableName}
      SET role = $3,
          updated_at = NOW()
      WHERE group_id = $1 AND user_id = $2
      RETURNING ${this.columns.join(", ")}
    `;

    const result = await this.executeQuery<GroupMemberAttributes>(query, [
      groupId,
      userId,
      role,
    ]);

    if (result.rows.length === 0) {
      return null;
    }

    return new GroupMember(result.rows[0] as unknown as GroupMemberAttributes);
  }

  /**
   * Update member status
   * @param groupId The group ID
   * @param userId The user ID
   * @param status The new status
   * @returns The updated GroupMember instance or null if not found
   */
  async updateStatus(
    groupId: string,
    userId: string,
    status: MembershipStatus,
  ): Promise<GroupMember | null> {
    return this.withTransaction(async (client) => {
      try {
        const query = `
          UPDATE ${this.tableName}
          SET status = $3,
              updated_at = NOW()
          WHERE group_id = $1 AND user_id = $2
          RETURNING ${this.columns.join(", ")}
        `;

        const { rows } = await client.query(query, [groupId, userId, status]);

        if (rows.length === 0) {
          return null;
        }

        const previousStatus = (rows[0] as { status: MembershipStatus }).status;

        // Only update group member count if status changes to or from APPROVED
        if (
          status === MembershipStatus.APPROVED &&
          previousStatus !== MembershipStatus.APPROVED
        ) {
          // Update group member count when a new member is approved
          await client.query(
            `
            UPDATE groups
            SET member_count = member_count + 1,
                updated_at = NOW()
            WHERE id = $1
          `,
            [groupId],
          );
        } else if (
          status !== MembershipStatus.APPROVED &&
          previousStatus === MembershipStatus.APPROVED
        ) {
          // Decrease group member count when a member is no longer approved
          await client.query(
            `
            UPDATE groups
            SET member_count = GREATEST(member_count - 1, 0),
                updated_at = NOW()
            WHERE id = $1
          `,
            [groupId],
          );
        }

        return new GroupMember(rows[0] as unknown as GroupMemberAttributes);
      } catch (error) {
        this.logger.error("Error updating member status", {
          groupId,
          userId,
          status,
          error: error instanceof Error ? error.message : error,
        });
        throw error;
      }
    });
  }

  /**
   * Update last activity timestamp
   * @param groupId The group ID
   * @param userId The user ID
   * @returns True if the update was successful
   */
  async updateLastActivity(groupId: string, userId: string): Promise<boolean> {
    const query = `
      UPDATE ${this.tableName}
      SET last_activity = NOW(),
          updated_at = NOW()
      WHERE group_id = $1 AND user_id = $2
      RETURNING id
    `;

    const result = await this.executeQuery<{ id: string }>(query, [
      groupId,
      userId,
    ]);

    return result.rows.length > 0;
  }

  /**
   * Update notification settings
   * @param id The membership ID
   * @param settings The notification settings to update
   * @returns The updated GroupMember instance or null if not found
   */
  async updateNotificationSettings(
    id: string,
    settings: Record<string, boolean>,
  ): Promise<GroupMember | null> {
    const query = `
      UPDATE ${this.tableName}
      SET notification_settings = notification_settings || $2::jsonb,
          updated_at = NOW()
      WHERE id = $1
      RETURNING ${this.columns.join(", ")}
    `;

    const result = await this.executeQuery<GroupMemberAttributes>(query, [
      id,
      JSON.stringify(settings),
    ]);

    if (result.rows.length === 0) {
      return null;
    }

    return new GroupMember(result.rows[0] as unknown as GroupMemberAttributes);
  }

  /**
   * Create a new group member
   * @param data The group member data
   * @returns The created GroupMember instance
   */
  async create(
    data: Omit<GroupMemberAttributes, "id" | "createdAt" | "updatedAt">,
  ): Promise<GroupMember> {
    return this.withTransaction(async (client) => {
      try {
        // Create the group member instance and validate it
        const groupMember = new GroupMember(data as GroupMemberAttributes);
        groupMember.validate();

        // Check if membership already exists
        const existingQuery = `
          SELECT ${this.columns.join(", ")}
          FROM ${this.tableName}
          WHERE group_id = $1 AND user_id = $2
          LIMIT 1
        `;

        const { rows: existingRows } = await client.query(existingQuery, [
          data.groupId,
          data.userId,
        ]);

        if (existingRows.length > 0) {
          // If the membership exists but is not approved, update it
          if (
            (existingRows[0] as { status: MembershipStatus }).status !==
              MembershipStatus.APPROVED &&
            data.status === MembershipStatus.APPROVED
          ) {
            const updateQuery = `
              UPDATE ${this.tableName}
              SET status = $3, role = $4, updated_at = NOW()
              WHERE group_id = $1 AND user_id = $2
              RETURNING ${this.columns.join(", ")}
            `;

            const { rows } = await client.query(updateQuery, [
              data.groupId,
              data.userId,
              data.status,
              data.role,
            ]);

            // Update group member count if status changed to APPROVED
            if (data.status === MembershipStatus.APPROVED) {
              await client.query(
                `
                UPDATE groups
                SET member_count = member_count + 1,
                    updated_at = NOW()
                WHERE id = $1
              `,
                [data.groupId],
              );
            }

            return new GroupMember(rows[0] as unknown as GroupMemberAttributes);
          }

          return new GroupMember(
            existingRows[0] as unknown as GroupMemberAttributes,
          );
        }

        // Create a new membership
        const result = await super.create(groupMember);

        // Update group member count if new member is approved
        if (data.status === MembershipStatus.APPROVED) {
          await client.query(
            `
            UPDATE groups
            SET member_count = member_count + 1,
                updated_at = NOW()
            WHERE id = $1
          `,
            [data.groupId],
          );
        }

        return new GroupMember(result as unknown as GroupMemberAttributes);
      } catch (error) {
        this.logger.error("Error creating group member", {
          data,
          error: error instanceof Error ? error.message : error,
        });
        throw error;
      }
    });
  }

  /**
   * Delete a group member by ID
   * @param id The membership ID
   * @returns True if deletion was successful
   */
  async delete(id: string): Promise<boolean> {
    return this.withTransaction(async (client) => {
      try {
        // Get the member first to check if they were approved
        const getQuery = `
          SELECT ${this.columns.join(", ")}
          FROM ${this.tableName}
          WHERE id = $1
          LIMIT 1
        `;

        const { rows } = await client.query(getQuery, [id]);

        if (rows.length === 0) {
          return false;
        }

        const wasApproved =
          (rows[0] as { status: MembershipStatus }).status ===
          MembershipStatus.APPROVED;
        const groupId = (rows[0] as { groupId: string }).groupId;

        // Delete the member
        const deleteQuery = `
          DELETE FROM ${this.tableName}
          WHERE id = $1
          RETURNING id
        `;

        const result = await client.query(deleteQuery, [id]);
        const isDeleted = result.rowCount !== null && result.rowCount > 0;

        // Update group member count if the deleted member was approved
        if (isDeleted && wasApproved) {
          await client.query(
            `
            UPDATE groups
            SET member_count = GREATEST(member_count - 1, 0),
                updated_at = NOW()
            WHERE id = $1
          `,
            [groupId],
          );
        }

        return isDeleted;
      } catch (error) {
        this.logger.error("Error deleting group member", {
          id,
          error: error instanceof Error ? error.message : error,
        });
        throw error;
      }
    });
  }

  /**
   * Remove a user from a group
   * @param groupId The group ID
   * @param userId The user ID
   * @returns True if removal was successful
   */
  async removeFromGroup(groupId: string, userId: string): Promise<boolean> {
    return this.withTransaction(async (client) => {
      try {
        // Get the member first to check if they were approved
        const getQuery = `
          SELECT ${this.columns.join(", ")}
          FROM ${this.tableName}
          WHERE group_id = $1 AND user_id = $2
          LIMIT 1
        `;

        const { rows } = await client.query(getQuery, [groupId, userId]);

        if (rows.length === 0) {
          return false;
        }

        const wasApproved =
          (rows[0] as { status: MembershipStatus }).status ===
          MembershipStatus.APPROVED;

        // Delete the member
        const deleteQuery = `
          DELETE FROM ${this.tableName}
          WHERE group_id = $1 AND user_id = $2
          RETURNING id
        `;

        const result = await client.query(deleteQuery, [groupId, userId]);
        const isDeleted = result.rowCount !== null && result.rowCount > 0;

        // Update group member count if the deleted member was approved
        if (isDeleted && wasApproved) {
          await client.query(
            `
            UPDATE groups
            SET member_count = GREATEST(member_count - 1, 0),
                updated_at = NOW()
            WHERE id = $1
          `,
            [groupId],
          );
        }

        return isDeleted;
      } catch (error) {
        this.logger.error("Error removing user from group", {
          groupId,
          userId,
          error: error instanceof Error ? error.message : error,
        });
        throw error;
      }
    });
  }

  /**
   * Convert camelCase to snake_case
   * @param str The string to convert
   * @returns The converted string
   */
  protected camelToSnake(str: string): string {
    return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
  }

  protected mapResultToModel(row: Record<string, unknown>): GroupMember {
    if (!row) return null as unknown as GroupMember;

    return new GroupMember({
      id: row.id as string,
      groupId: row.group_id as string,
      userId: row.user_id as string,
      role: row.role as GroupMemberRole,
      status: row.status as MembershipStatus,
      notificationSettings: row.notification_settings as Record<
        string,
        boolean
      >,
      lastActivity: row.last_activity as Date,
      createdAt: row.created_at as Date,
      updatedAt: row.updated_at as Date,
    });
  }
}

// Export a singleton instance
export const groupMemberRepository = new GroupMemberRepository();



===========================================================
FILE 44: repositories\community\GroupRepository.ts
===========================================================

import { Logger } from "../../../services/LoggerService";
import {
  Group,
  GroupAttributes,
  GroupStatus,
  GroupVisibility,
} from "../../models/community/Group";
import { BaseRepository } from "../BaseRepository";

export class GroupRepository extends BaseRepository<Group> {
  protected logger = new Logger("GroupRepository");
  protected tableName = "groups";
  protected columns = [
    "id",
    "name",
    "slug",
    "description",
    "image_url as imageUrl",
    "banner_url as bannerUrl",
    "owner_id as ownerId",
    "visibility",
    "status",
    "member_count as memberCount",
    "rules",
    "metadata",
    "is_verified as isVerified",
    "created_at as createdAt",
    "updated_at as updatedAt",
  ];

  protected mapResultToModel(row: Record<string, unknown>): Group {
    if (!row) return null as unknown as Group;
    return new Group(row as unknown as GroupAttributes);
  }

  /**
   * Find group by primary key
   */
  async findByPk(id: string): Promise<Group | null> {
    try {
      this.logger.info("Finding group by PK", { id });
      const group = await this.findById(id);
      if (!group) return null;

      return new Group(group as GroupAttributes);
    } catch (error) {
      this.logger.error("Error finding group by PK", {
        id,
        error: error instanceof Error ? error.message : error,
        stack: error instanceof Error ? error.stack : undefined,
      });
      throw error;
    }
  }

  /**
   * Find group by slug
   */
  async findBySlug(slug: string): Promise<Group | null> {
    try {
      this.logger.info("Finding group by slug", { slug });
      const group = await this.findOneByField("slug", slug);
      if (!group) return null;

      return new Group(group as unknown as GroupAttributes);
    } catch (error) {
      this.logger.error("Error finding group by slug", {
        slug,
        error: error instanceof Error ? error.message : error,
        stack: error instanceof Error ? error.stack : undefined,
      });
      throw error;
    }
  }

  /**
   * Find groups by owner ID
   */
  async findByOwnerId(
    ownerId: string,
    limit: number = 20,
    offset: number = 0,
  ): Promise<Group[]> {
    try {
      this.logger.info("Finding groups by owner ID", {
        ownerId,
        limit,
        offset,
      });
      const groups = await this.findAll({
        owner_id: ownerId,
        limit,
        offset,
        orderBy: "created_at DESC",
      });
      return groups.map(
        (group) => new Group(group as unknown as GroupAttributes),
      );
    } catch (error) {
      this.logger.error("Error finding groups by owner ID", {
        ownerId,
        limit,
        offset,
        error: error instanceof Error ? error.message : error,
        stack: error instanceof Error ? error.stack : undefined,
      });
      throw error;
    }
  }

  /**
   * Find public groups
   */
  async findPublic(limit: number = 20, offset: number = 0): Promise<Group[]> {
    try {
      this.logger.info("Finding public groups", { limit, offset });

      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE visibility = $1 AND status = $2
        ORDER BY member_count DESC, created_at DESC
        LIMIT $3 OFFSET $4
      `;

      const result = await this.executeQuery(query, [
        GroupVisibility.PUBLIC,
        GroupStatus.ACTIVE,
        limit,
        offset,
      ]);

      return result.rows.map(
        (group) => new Group(group as unknown as GroupAttributes),
      );
    } catch (error) {
      this.logger.error("Error finding public groups", {
        limit,
        offset,
        error: error instanceof Error ? error.message : error,
        stack: error instanceof Error ? error.stack : undefined,
      });
      throw error;
    }
  }

  /**
   * Search groups by name
   */
  async searchByName(
    searchTerm: string,
    limit: number = 20,
    offset: number = 0,
  ): Promise<Group[]> {
    try {
      this.logger.info("Searching groups by name", {
        searchTerm,
        limit,
        offset,
      });

      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE (name ILIKE $1 OR description ILIKE $1) AND visibility = $2 AND status = $3
        ORDER BY member_count DESC, created_at DESC
        LIMIT $4 OFFSET $5
      `;

      const result = await this.executeQuery(query, [
        `%${searchTerm}%`,
        GroupVisibility.PUBLIC,
        GroupStatus.ACTIVE,
        limit,
        offset,
      ]);

      return result.rows.map(
        (group) => new Group(group as unknown as GroupAttributes),
      );
    } catch (error) {
      this.logger.error("Error searching groups by name", {
        searchTerm,
        limit,
        offset,
        error: error instanceof Error ? error.message : error,
        stack: error instanceof Error ? error.stack : undefined,
      });
      throw error;
    }
  }

  /**
   * Create a new group
   */
  async create(
    data: Omit<GroupAttributes, "id" | "createdAt" | "updatedAt">,
  ): Promise<Group> {
    return this.withTransaction(async (client) => {
      try {
        // Convert camelCase to snake_case for database columns
        const insertData: Record<string, unknown> = {};
        Object.entries(data).forEach(([key, value]) => {
          insertData[this.snakeCase(key)] = value;
        });

        const insertColumns = Object.keys(insertData);
        const placeholders = insertColumns.map((_, idx) => `$${idx + 1}`);
        const values = Object.values(insertData);

        const query = `
          INSERT INTO ${this.tableName} (${insertColumns.join(", ")}, created_at, updated_at)
          VALUES (${placeholders.join(", ")}, NOW(), NOW())
          RETURNING ${this.columns.join(", ")}
        `;

        this.logger.info("Creating group", {
          data: {
            ...data,
            // Redact any sensitive fields if needed
          },
        });

        const { rows } = await client.query(query, values);
        return new Group(rows[0] as GroupAttributes);
      } catch (error) {
        this.logger.error("Error creating group", {
          data,
          error: error instanceof Error ? error.message : error,
          stack: error instanceof Error ? error.stack : undefined,
        });
        throw error;
      }
    });
  }

  /**
   * Update a group
   */
  async update(
    id: string,
    data: Partial<GroupAttributes>,
  ): Promise<Group | null> {
    return this.withTransaction(async (client) => {
      try {
        const updateData = { ...data };
        delete updateData.id;
        delete updateData.createdAt;
        delete updateData.updatedAt;
        delete updateData.ownerId; // Owner cannot be changed

        if (Object.keys(updateData).length === 0) {
          const group = await this.findById(id);
          return group ? new Group(group as GroupAttributes) : null;
        }

        // Convert camelCase to snake_case for database columns
        const updateColumns: Record<string, unknown> = {};
        Object.entries(updateData).forEach(([key, value]) => {
          updateColumns[this.snakeCase(key)] = value;
        });

        const updates = Object.keys(updateColumns).map(
          (key, idx) => `${key} = $${idx + 2}`,
        );
        const values = [id, ...Object.values(updateColumns)];

        const query = `
          UPDATE ${this.tableName}
          SET ${updates.join(", ")}, updated_at = NOW()
          WHERE id = $1
          RETURNING ${this.columns.join(", ")}
        `;

        this.logger.info("Updating group", {
          id,
          data: updateData,
        });

        const { rows } = await client.query(query, values);
        if (rows.length === 0) return null;

        return new Group(rows[0] as GroupAttributes);
      } catch (error) {
        this.logger.error("Error updating group", {
          id,
          data,
          error: error instanceof Error ? error.message : error,
          stack: error instanceof Error ? error.stack : undefined,
        });
        throw error;
      }
    });
  }

  /**
   * Increment member count
   */
  async incrementMemberCount(
    id: string,
    count: number = 1,
  ): Promise<Group | null> {
    try {
      this.logger.info("Incrementing group member count", { id, count });

      const query = `
        UPDATE ${this.tableName}
        SET member_count = member_count + $2, updated_at = NOW()
        WHERE id = $1
        RETURNING ${this.columns.join(", ")}
      `;

      const result = await this.executeQuery(query, [id, count]);
      if (result.rows.length === 0) return null;

      return new Group(result.rows[0] as unknown as GroupAttributes);
    } catch (error) {
      this.logger.error("Error incrementing group member count", {
        id,
        count,
        error: error instanceof Error ? error.message : error,
        stack: error instanceof Error ? error.stack : undefined,
      });
      throw error;
    }
  }

  /**
   * Decrement member count
   */
  async decrementMemberCount(
    id: string,
    count: number = 1,
  ): Promise<Group | null> {
    try {
      this.logger.info("Decrementing group member count", { id, count });

      const query = `
        UPDATE ${this.tableName}
        SET member_count = GREATEST(0, member_count - $2), updated_at = NOW()
        WHERE id = $1
        RETURNING ${this.columns.join(", ")}
      `;

      const result = await this.executeQuery(query, [id, count]);
      if (result.rows.length === 0) return null;

      return new Group(result.rows[0] as unknown as GroupAttributes);
    } catch (error) {
      this.logger.error("Error decrementing group member count", {
        id,
        count,
        error: error instanceof Error ? error.message : error,
        stack: error instanceof Error ? error.stack : undefined,
      });
      throw error;
    }
  }

  /**
   * Convert camelCase to snake_case
   */
  private snakeCase(str: string): string {
    return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
  }
}

// Singleton instance
export const groupRepository = new GroupRepository();



===========================================================
FILE 45: repositories\discovery\SearchIndexRepository.ts
===========================================================

import { Logger } from "../../../services/LoggerService";
import {
  IndexedContentType,
  IndexStatus,
  SearchIndex,
  SearchIndexAttributes,
  SearchWeights,
} from "../../models/discovery/SearchIndex";
import { BaseRepository } from "../BaseRepository";

/**
 * Repository for managing search indices
 *
 * This class is responsible for:
 * 1. All database operations related to search index
 * 2. Converting between database and model formats
 * 3. Providing specific query methods for search functionality
 * 4. NOT implementing business logic - that belongs in the SearchIndex model
 */
export class SearchIndexRepository extends BaseRepository<SearchIndex> {
  protected logger = new Logger("SearchIndexRepository");
  protected tableName = "search_indices";
  protected columns = [
    "id",
    "content_id as contentId",
    "content_type as contentType",
    "title",
    "description",
    "search_text as searchText",
    "owner_id as ownerId",
    "status",
    "last_indexed_at as lastIndexedAt",
    "tags",
    "weights",
    "error_message as errorMessage",
    "language",
    "published_at as publishedAt",
    "created_at as createdAt",
    "updated_at as updatedAt",
  ];

  protected mapResultToModel(row: Record<string, unknown>): SearchIndex {
    if (!row) return null as unknown as SearchIndex;
    return new SearchIndex(row as unknown as SearchIndexAttributes);
  }

  constructor() {
    super();
  }

  /**
   * Find a search index item by ID
   *
   * @param id The search index item ID
   * @returns The search index item or null if not found
   */
  async findById(id: string): Promise<SearchIndex | null> {
    try {
      const result = await this.findOneByField("id", id);
      if (!result) return null;
      return this.mapResultToModel(result);
    } catch (error) {
      this.logger.error("Error finding search index by ID", {
        error: error instanceof Error ? error.message : error,
        id,
      });
      throw error;
    }
  }

  /**
   * Find a search index item by content ID and type
   *
   * @param contentId The ID of the indexed content
   * @param contentType The type of the indexed content
   * @returns The search index item or null if not found
   */
  async findByContentId(
    contentId: string,
    contentType: IndexedContentType,
  ): Promise<SearchIndex | null> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE content_id = $1 AND content_type = $2
        LIMIT 1
      `;

      const result = await this.executeQuery<SearchIndexAttributes>(query, [
        contentId,
        contentType,
      ]);

      if (result.rows.length === 0) {
        return null;
      }

      return new SearchIndex(result.rows[0]);
    } catch (error) {
      this.logger.error("Error finding search index by content ID", {
        error: error instanceof Error ? error.message : error,
        contentId,
        contentType,
      });
      throw error;
    }
  }

  /**
   * Find items that need to be indexed
   *
   * @param limit Maximum number of items to return
   * @returns Array of search index items
   */
  async findPendingIndexItems(limit: number = 50): Promise<SearchIndex[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE status = $1
        ORDER BY updated_at ASC
        LIMIT $2
      `;

      const result = await this.executeQuery<SearchIndexAttributes>(query, [
        IndexStatus.PENDING,
        limit,
      ]);

      return result.rows.map((row) => new SearchIndex(row));
    } catch (error) {
      this.logger.error("Error finding pending index items", {
        error: error instanceof Error ? error.message : error,
        limit,
      });
      throw error;
    }
  }

  /**
   * Search across the index
   *
   * @param searchTerm The search term
   * @param contentTypes Optional types of content to search for
   * @param tags Optional tags to filter by
   * @param ownerId Optional owner ID to filter by
   * @param languages Optional languages to filter by
   * @param limit Maximum number of results to return
   * @param offset Number of results to skip
   * @returns Array of search index items
   */
  async search(
    searchTerm: string,
    contentTypes?: IndexedContentType[],
    tags?: string[],
    ownerId?: string,
    languages?: string[],
    limit: number = 20,
    offset: number = 0,
  ): Promise<SearchIndex[]> {
    try {
      let query = `
        SELECT ${this.columns.join(", ")},
               ts_rank_cd(
                 to_tsvector('english', search_text),
                 to_tsquery('english', $1)
               ) AS search_rank
        FROM ${this.tableName}
        WHERE status = $2
          AND to_tsvector('english', search_text) @@ to_tsquery('english', $1)
      `;

      const queryParams: unknown[] = [
        this.formatSearchQuery(searchTerm),
        IndexStatus.INDEXED,
      ];
      let paramIndex = 3;

      if (contentTypes && contentTypes.length > 0) {
        query += ` AND content_type = ANY($${paramIndex})`;
        queryParams.push(contentTypes);
        paramIndex += 1;
      }

      if (tags && tags.length > 0) {
        query += ` AND tags && $${paramIndex}`;
        queryParams.push(tags);
        paramIndex += 1;
      }

      if (ownerId) {
        query += ` AND owner_id = $${paramIndex}`;
        queryParams.push(ownerId);
        paramIndex += 1;
      }

      if (languages && languages.length > 0) {
        query += ` AND language = ANY($${paramIndex})`;
        queryParams.push(languages);
        paramIndex += 1;
      }

      query += `
        ORDER BY 
          search_rank DESC,
          (weights->>'relevance')::float * 0.4 +
          COALESCE((weights->>'recency')::float, 0.5) * 0.3 +
          COALESCE((weights->>'popularity')::float, 0.5) * 0.2 +
          COALESCE((weights->>'quality')::float, 0.5) * 0.1 DESC,
          published_at DESC
        LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
      `;

      queryParams.push(limit, offset);

      const result = await this.executeQuery<
        SearchIndexAttributes & { search_rank: number }
      >(query, queryParams);

      return result.rows.map((row) => new SearchIndex(row));
    } catch (error) {
      this.logger.error("Error searching index", {
        error: error instanceof Error ? error.message : error,
        searchTerm,
        contentTypes,
        tags,
      });
      throw error;
    }
  }

  /**
   * Find by tag
   *
   * @param tag The tag to search for
   * @param contentTypes Optional types of content to filter by
   * @param limit Maximum number of results to return
   * @param offset Number of results to skip
   * @returns Array of search index items
   */
  async findByTag(
    tag: string,
    contentTypes?: IndexedContentType[],
    limit: number = 20,
    offset: number = 0,
  ): Promise<SearchIndex[]> {
    try {
      let query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE status = $1
          AND $2 = ANY(tags)
      `;

      const queryParams: unknown[] = [IndexStatus.INDEXED, tag];
      let paramIndex = 3;

      if (contentTypes && contentTypes.length > 0) {
        query += ` AND content_type = ANY($${paramIndex})`;
        queryParams.push(contentTypes);
        paramIndex += 1;
      }

      query += `
        ORDER BY 
          (weights->>'relevance')::float * 0.4 +
          COALESCE((weights->>'recency')::float, 0.5) * 0.3 +
          COALESCE((weights->>'popularity')::float, 0.5) * 0.2 +
          COALESCE((weights->>'quality')::float, 0.5) * 0.1 DESC,
          published_at DESC
        LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
      `;

      queryParams.push(limit, offset);

      const result = await this.executeQuery<SearchIndexAttributes>(
        query,
        queryParams,
      );

      return result.rows.map((row) => new SearchIndex(row));
    } catch (error) {
      this.logger.error("Error finding by tag", {
        error: error instanceof Error ? error.message : error,
        tag,
        contentTypes,
      });
      throw error;
    }
  }

  /**
   * Find by owner (user)
   *
   * @param ownerId The owner ID
   * @param contentTypes Optional types of content to filter by
   * @param limit Maximum number of results to return
   * @param offset Number of results to skip
   * @returns Array of search index items
   */
  async findByOwner(
    ownerId: string,
    contentTypes?: IndexedContentType[],
    limit: number = 20,
    offset: number = 0,
  ): Promise<SearchIndex[]> {
    try {
      let query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE status = $1
          AND owner_id = $2
      `;

      const queryParams: unknown[] = [IndexStatus.INDEXED, ownerId];
      let paramIndex = 3;

      if (contentTypes && contentTypes.length > 0) {
        query += ` AND content_type = ANY($${paramIndex})`;
        queryParams.push(contentTypes);
        paramIndex += 1;
      }

      query += `
        ORDER BY published_at DESC
        LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
      `;

      queryParams.push(limit, offset);

      const result = await this.executeQuery<SearchIndexAttributes>(
        query,
        queryParams,
      );

      return result.rows.map((row) => new SearchIndex(row));
    } catch (error) {
      this.logger.error("Error finding by owner", {
        error: error instanceof Error ? error.message : error,
        ownerId,
        contentTypes,
      });
      throw error;
    }
  }

  /**
   * Find recent content
   *
   * @param contentTypes Optional types of content to filter by
   * @param limit Maximum number of results to return
   * @param offset Number of results to skip
   * @returns Array of search index items
   */
  async findRecent(
    contentTypes?: IndexedContentType[],
    limit: number = 20,
    offset: number = 0,
  ): Promise<SearchIndex[]> {
    try {
      let query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE status = $1
      `;

      const queryParams: unknown[] = [IndexStatus.INDEXED];
      let paramIndex = 2;

      if (contentTypes && contentTypes.length > 0) {
        query += ` AND content_type = ANY($${paramIndex})`;
        queryParams.push(contentTypes);
        paramIndex += 1;
      }

      query += `
        ORDER BY published_at DESC
        LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
      `;

      queryParams.push(limit, offset);

      const result = await this.executeQuery<SearchIndexAttributes>(
        query,
        queryParams,
      );

      return result.rows.map((row) => new SearchIndex(row));
    } catch (error) {
      this.logger.error("Error finding recent content", {
        error: error instanceof Error ? error.message : error,
        contentTypes,
      });
      throw error;
    }
  }

  /**
   * Create or update a search index item
   *
   * @param data The data to upsert
   * @returns The created or updated SearchIndex
   */
  async upsert(
    data: Partial<SearchIndexAttributes> & {
      contentId: string;
      contentType: IndexedContentType;
    },
  ): Promise<SearchIndex> {
    return this.withTransaction(async (client) => {
      try {
        // Check if the item already exists
        const existingQuery = `
          SELECT ${this.columns.join(", ")}
          FROM ${this.tableName}
          WHERE content_id = $1 AND content_type = $2
        `;

        const { rows } = await client.query(existingQuery, [
          data.contentId,
          data.contentType,
        ]);

        if (rows.length > 0) {
          // Update existing item
          const existingItem = new SearchIndex(rows[0]);

          // Merge existing data with new data
          const updatedData = {
            ...existingItem,
            ...data,
            status: data.status || existingItem.status,
            updatedAt: new Date(),
          };

          const searchIndex = new SearchIndex(updatedData);
          searchIndex.validate();

          const result = await this.update(existingItem.id, searchIndex);
          if (!result) {
            throw new Error(
              `Failed to update search index with ID ${existingItem.id}`,
            );
          }
          return new SearchIndex(result);
        } else {
          // Create new item with required title
          if (!data.title) {
            throw new Error("Title is required for new search index items");
          }
          const searchIndex = new SearchIndex(data as SearchIndexAttributes);
          searchIndex.validate();

          const result = await this.create(searchIndex);
          return new SearchIndex(result);
        }
      } catch (error) {
        this.logger.error("Error upserting search index", {
          error: error instanceof Error ? error.message : error,
          data,
        });
        throw error;
      }
    });
  }

  /**
   * Create a new search index item
   *
   * @param data The search index data or model instance
   * @returns The created search index
   */
  async create(
    data: Partial<SearchIndexAttributes> | SearchIndex,
  ): Promise<SearchIndex> {
    try {
      let searchIndex: SearchIndex;

      if (data instanceof SearchIndex) {
        searchIndex = data;
      } else {
        searchIndex = new SearchIndex(data as unknown as SearchIndexAttributes);
      }

      searchIndex.validate();

      // Set default values
      if (!searchIndex.searchText) {
        searchIndex.searchText =
          `${searchIndex.title} ${searchIndex.description || ""}`.toLowerCase();
      }

      const result = await super.create(searchIndex);
      return new SearchIndex(result);
    } catch (error) {
      this.logger.error("Error creating search index", {
        error: error instanceof Error ? error.message : error,
        data,
      });
      throw error;
    }
  }

  /**
   * Update a search index item
   *
   * @param id The search index ID
   * @param data The updated data or model instance
   * @returns The updated search index or null if not found
   */
  async update(
    id: string,
    data: Partial<SearchIndexAttributes> | SearchIndex,
  ): Promise<SearchIndex | null> {
    try {
      let searchIndex: SearchIndex;
      let partialData: Partial<SearchIndexAttributes>;

      if (data instanceof SearchIndex) {
        searchIndex = data;
        partialData = searchIndex.toJSON();
      } else {
        partialData = data;

        // Get the existing search index
        const existing = await this.findById(id);
        if (!existing) {
          throw new Error(`Search index with ID ${id} not found`);
        }

        // Merge existing data with new data
        searchIndex = new SearchIndex({
          ...existing,
          ...partialData,
        });
      }

      const result = await super.update(id, searchIndex);
      if (!result) return null;
      return new SearchIndex(result);
    } catch (error) {
      this.logger.error("Error updating search index", {
        error: error instanceof Error ? error.message : error,
        id,
        data,
      });
      throw error;
    }
  }

  /**
   * Mark a search index item as indexed
   *
   * @param id The search index ID
   * @returns The updated search index or null if not found
   */
  async markAsIndexed(id: string): Promise<SearchIndex | null> {
    try {
      const query = `
        UPDATE ${this.tableName}
        SET status = $1,
            last_indexed_at = NOW(),
            error_message = NULL,
            updated_at = NOW()
        WHERE id = $2
        RETURNING ${this.columns.join(", ")}
      `;

      const result = await this.executeQuery<SearchIndexAttributes>(query, [
        IndexStatus.INDEXED,
        id,
      ]);

      if (result.rows.length === 0) {
        return null;
      }

      return new SearchIndex(result.rows[0]);
    } catch (error) {
      this.logger.error("Error marking search index as indexed", {
        error: error instanceof Error ? error.message : error,
        id,
      });
      throw error;
    }
  }

  /**
   * Mark a search index item as failed
   *
   * @param id The search index ID
   * @param errorMessage Optional error message
   * @returns The updated search index or null if not found
   */
  async markAsFailed(
    id: string,
    errorMessage?: string,
  ): Promise<SearchIndex | null> {
    try {
      const query = `
        UPDATE ${this.tableName}
        SET status = $1,
            error_message = $2,
            updated_at = NOW()
        WHERE id = $3
        RETURNING ${this.columns.join(", ")}
      `;

      const result = await this.executeQuery<SearchIndexAttributes>(query, [
        IndexStatus.FAILED,
        errorMessage || null,
        id,
      ]);

      if (result.rows.length === 0) {
        return null;
      }

      return new SearchIndex(result.rows[0]);
    } catch (error) {
      this.logger.error("Error marking search index as failed", {
        error: error instanceof Error ? error.message : error,
        id,
        errorMessage,
      });
      throw error;
    }
  }

  /**
   * Mark a search index item as deleted
   *
   * @param contentId The content ID
   * @param contentType The content type
   * @returns The updated search index or null if not found
   */
  async markAsDeleted(
    contentId: string,
    contentType: IndexedContentType,
  ): Promise<SearchIndex | null> {
    try {
      const query = `
        UPDATE ${this.tableName}
        SET status = $1,
            updated_at = NOW()
        WHERE content_id = $2 AND content_type = $3
        RETURNING ${this.columns.join(", ")}
      `;

      const result = await this.executeQuery<SearchIndexAttributes>(query, [
        IndexStatus.DELETED,
        contentId,
        contentType,
      ]);

      if (result.rows.length === 0) {
        return null;
      }

      return new SearchIndex(result.rows[0]);
    } catch (error) {
      this.logger.error("Error marking search index as deleted", {
        error: error instanceof Error ? error.message : error,
        contentId,
        contentType,
      });
      throw error;
    }
  }

  /**
   * Update the weights of a search index item
   *
   * @param id The search index ID
   * @param weights The weights to update
   * @returns The updated search index or null if not found
   */
  async updateWeights(
    id: string,
    weights: Partial<SearchWeights>,
  ): Promise<SearchIndex | null> {
    try {
      // Get current search index
      const current = await this.findById(id);
      if (!current) {
        return null;
      }

      // Merge current weights with new weights
      const updatedWeights = {
        ...current.weights,
        ...weights,
      };

      const query = `
        UPDATE ${this.tableName}
        SET weights = $1::jsonb,
            updated_at = NOW()
        WHERE id = $2
        RETURNING ${this.columns.join(", ")}
      `;

      const result = await this.executeQuery<SearchIndexAttributes>(query, [
        JSON.stringify(updatedWeights),
        id,
      ]);

      if (result.rows.length === 0) {
        return null;
      }

      return new SearchIndex(result.rows[0]);
    } catch (error) {
      this.logger.error("Error updating search index weights", {
        error: error instanceof Error ? error.message : error,
        id,
        weights,
      });
      throw error;
    }
  }

  /**
   * Delete a search index item
   *
   * @param id The search index ID
   * @returns True if the item was deleted
   */
  async delete(id: string): Promise<boolean> {
    try {
      return super.delete(id);
    } catch (error) {
      this.logger.error("Error deleting search index", {
        error: error instanceof Error ? error.message : error,
        id,
      });
      throw error;
    }
  }

  /**
   * Delete a search index item by content ID and type
   *
   * @param contentId The content ID
   * @param contentType The content type
   * @returns True if the item was deleted
   */
  async deleteContent(
    contentId: string,
    contentType: IndexedContentType,
  ): Promise<boolean> {
    try {
      const query = `
        DELETE FROM ${this.tableName}
        WHERE content_id = $1 AND content_type = $2
        RETURNING id
      `;

      const result = await this.executeQuery<{ id: string }>(query, [
        contentId,
        contentType,
      ]);
      return result.rows.length > 0;
    } catch (error) {
      this.logger.error("Error deleting search index content", {
        error: error instanceof Error ? error.message : error,
        contentId,
        contentType,
      });
      throw error;
    }
  }

  /**
   * Bulk update search index item statuses
   *
   * @param fromStatus The current status
   * @param toStatus The new status
   * @param olderThanDays Only update items older than this many days
   * @returns The number of items updated
   */
  async bulkUpdateStatuses(
    fromStatus: IndexStatus,
    toStatus: IndexStatus,
    olderThanDays?: number,
  ): Promise<number> {
    try {
      let query = `
        UPDATE ${this.tableName}
        SET status = $1,
            updated_at = NOW()
        WHERE status = $2
      `;

      const params: unknown[] = [toStatus, fromStatus];

      if (olderThanDays !== undefined) {
        query += ` AND updated_at < NOW() - INTERVAL '$3 days'`;
        params.push(olderThanDays);
      }

      const result = await this.executeQuery(query, params);
      return result.rowCount || 0;
    } catch (error) {
      this.logger.error("Error bulk updating search index statuses", {
        error: error instanceof Error ? error.message : error,
        fromStatus,
        toStatus,
        olderThanDays,
      });
      throw error;
    }
  }

  /**
   * Format a search query for PostgreSQL tsquery
   *
   * @param query The search query
   * @returns Formatted query for tsquery
   */
  private formatSearchQuery(query: string): string {
    // Remove special characters, replace spaces with & for AND logic
    return query
      .trim()
      .toLowerCase()
      .replace(/[^\w\s]/g, "")
      .replace(/\s+/g, " ")
      .split(" ")
      .map((word) => word + ":*")
      .join(" & ");
  }

  /**
   * Convert camelCase to snake_case
   *
   * @param str String to convert
   * @returns snake_case string
   */
  protected camelToSnake(str: string): string {
    return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
  }
}

// Export singleton instance
export const searchIndexRepository = new SearchIndexRepository();



===========================================================
FILE 46: repositories\index.ts
===========================================================

import { ActivityLogRepository } from "./analytics/ActivityLogRepository";
import { PasswordResetTokenRepository } from "./auth/PasswordResetTokenRepository";
import { PermissionRepository } from "./auth/PermissionRepository";
import { RolePermissionRepository } from "./auth/RolePermissionRepository";
import { RoleRepository } from "./auth/RoleRepository";
import { TokenRepository } from "./auth/TokenRepository";
import { UserRepository, userRepository } from "./auth/UserRepository";
import {
  UserRoleRepository,
  userRoleRepository,
} from "./auth/UserRoleRepository";
import {
  GroupMemberRepository,
  groupMemberRepository,
} from "./community/GroupMemberRepository";
import { GroupRepository, groupRepository } from "./community/GroupRepository";
import {
  SearchIndexRepository,
  searchIndexRepository,
} from "./discovery/SearchIndexRepository";
import { MediaCollectionRepository } from "./media/MediaCollectionRepository";
import { MediaRepository, mediaRepository } from "./media/MediaRepository";
import { MediaTagRepository } from "./media/MediaTagRepository";
import { ConversationRepository } from "./messaging/ConversationRepository";
import { MessageRepository } from "./messaging/MessageRepository";
import { ContentReportRepository } from "./moderation/ContentReportRepository";
import { ModerationActionRepository } from "./moderation/ModerationActionRepository";
import { BookmarkRepository } from "./social/BookmarkRepository";
import {
  CommentLikeRepository,
  commentLikeRepository,
} from "./social/CommentLikeRepository";
import {
  CommentRepository,
  commentRepository,
} from "./social/CommentRepository";
import { FollowRepository, followRepository } from "./social/FollowRepository";
import {
  HashtagRepository,
  hashtagRepository,
} from "./social/HashtagRepository";
import { LikeRepository, likeRepository } from "./social/LikeRepository";
import {
  NotificationRepository,
  notificationRepository,
} from "./social/NotificationRepository";
import { PostRepository, postRepository } from "./social/PostRepository";

// Export repository classes and their instances
export {
  ActivityLogRepository,
  BookmarkRepository,
  CommentLikeRepository,
  CommentRepository,
  ContentReportRepository,
  ConversationRepository,
  FollowRepository,
  GroupMemberRepository,
  GroupRepository,
  HashtagRepository,
  LikeRepository,
  MediaCollectionRepository,
  MediaRepository,
  MediaTagRepository,
  MessageRepository,
  ModerationActionRepository,
  NotificationRepository,
  PasswordResetTokenRepository,
  PermissionRepository,
  PostRepository,
  RolePermissionRepository,
  RoleRepository,
  SearchIndexRepository,
  TokenRepository,
  UserRepository,
  UserRoleRepository,

  // Repository instances
  userRepository,
  userRoleRepository,
  groupMemberRepository,
  groupRepository,
  searchIndexRepository,
  mediaRepository,
  commentLikeRepository,
  commentRepository,
  followRepository,
  hashtagRepository,
  likeRepository,
  notificationRepository,
  postRepository,
};



===========================================================
FILE 47: repositories\media\MediaCollectionRepository.ts
===========================================================

import { Logger } from "../../../services/LoggerService";
import { DatabaseConnectionManager } from "../../config";
import {
  CollectionPrivacy,
  CollectionType,
  MediaCollection,
  MediaCollectionAttributes,
} from "../../models/media/MediaCollection";
import { BaseRepository } from "../BaseRepository";

export class MediaCollectionError extends Error {
  constructor(
    message: string,
    public code: string,
  ) {
    super(message);
    this.name = "MediaCollectionError";
  }
}

export class MediaCollectionNotFoundError extends MediaCollectionError {
  constructor(id: string) {
    super(`Collection with ID ${id} not found`, "COLLECTION_NOT_FOUND");
  }
}

export class MediaCollectionValidationError extends MediaCollectionError {
  constructor(message: string) {
    super(message, "COLLECTION_VALIDATION_ERROR");
  }
}

export class MediaCollectionRepository extends BaseRepository<MediaCollection> {
  protected logger = new Logger("MediaCollectionRepository");
  protected tableName = "media_collections";
  protected columns = [
    "id",
    "user_id as userId",
    "title",
    "description",
    "type",
    "privacy",
    "cover_media_id as coverMediaId",
    "media_ids as mediaIds",
    "sort_order as sortOrder",
    "metadata",
    "is_official as isOfficial",
    "item_count as itemCount",
    "is_deleted as isDeleted",
    "created_at as createdAt",
    "updated_at as updatedAt",
  ];

  constructor() {
    super();
  }

  /**
   * Creates a new media collection with validation
   */
  async create(
    data: Omit<
      MediaCollectionAttributes,
      "id" | "itemCount" | "createdAt" | "updatedAt"
    >,
  ): Promise<MediaCollection> {
    return this.withTransaction(async (_client) => {
      try {
        const collection = new MediaCollection(data);
        collection.validate();

        const result = await super.create(collection);
        return new MediaCollection(result);
      } catch (error) {
        if (error instanceof MediaCollectionError) {
          throw error;
        }
        this.logger.error("Error creating media collection", {
          data,
          error: error instanceof Error ? error.message : error,
        });
        throw new MediaCollectionError(
          "Failed to create collection",
          "CREATE_ERROR",
        );
      }
    });
  }

  /**
   * Updates an existing media collection with validation
   */
  async update(
    id: string,
    data: Partial<MediaCollectionAttributes>,
  ): Promise<MediaCollection | null> {
    return this.withTransaction(async (_client) => {
      try {
        const existing = await this.findById(id);
        if (!existing) {
          throw new MediaCollectionNotFoundError(id);
        }

        const collection = new MediaCollection({ ...existing, ...data });
        collection.validate();

        const result = await super.update(id, collection);
        if (!result) {
          throw new MediaCollectionNotFoundError(id);
        }
        return new MediaCollection(result);
      } catch (error) {
        if (error instanceof MediaCollectionError) {
          throw error;
        }
        this.logger.error("Error updating media collection", {
          id,
          data,
          error: error instanceof Error ? error.message : error,
        });
        throw new MediaCollectionError(
          "Failed to update collection",
          "UPDATE_ERROR",
        );
      }
    });
  }

  /**
   * Find collections by user ID with optional type filtering
   */
  async findByUserId(
    userId: string,
    limit = 20,
    offset = 0,
    type?: CollectionType,
    includeDeleted = false,
  ): Promise<MediaCollection[]> {
    try {
      let query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE user_id = $1
      `;

      const params: unknown[] = [userId];

      if (!includeDeleted) {
        query += " AND is_deleted = FALSE";
      }

      if (type) {
        query += ` AND type = $${params.length + 1}`;
        params.push(type);
      }

      query += " ORDER BY created_at DESC";
      query += ` LIMIT $${params.length + 1} OFFSET $${params.length + 2}`;
      params.push(limit.toString(), offset.toString());

      const { rows } = await DatabaseConnectionManager.getPool().query(
        query,
        params,
      );
      return rows.map(this.mapResultToModel);
    } catch (error) {
      this.logger.error("Error finding collections by user ID", {
        userId,
        type,
        error: error instanceof Error ? error.message : error,
      });
      throw new MediaCollectionError(
        "Failed to find collections by user ID",
        "QUERY_ERROR",
      );
    }
  }

  /**
   * Find collection by ID
   */
  async findById(id: string): Promise<MediaCollection | null> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE id = $1 AND is_deleted = FALSE
      `;

      const { rows } = await DatabaseConnectionManager.getPool().query(query, [
        id,
      ]);
      if (rows.length === 0) return null;

      return this.mapResultToModel(rows[0]);
    } catch (error) {
      this.logger.error("Error finding collection by ID", {
        id,
        error: error instanceof Error ? error.message : error,
      });
      throw new MediaCollectionError(
        "Failed to find collection by ID",
        "QUERY_ERROR",
      );
    }
  }

  /**
   * Find public collections
   */
  async findPublic(
    limit = 20,
    offset = 0,
    type?: CollectionType,
  ): Promise<MediaCollection[]> {
    try {
      let query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE privacy = $1 AND is_deleted = FALSE
      `;

      const params: unknown[] = [CollectionPrivacy.PUBLIC];

      if (type) {
        query += ` AND type = $${params.length + 1}`;
        params.push(type);
      }

      query += " ORDER BY created_at DESC";
      query += ` LIMIT $${params.length + 1} OFFSET $${params.length + 2}`;
      params.push(limit.toString(), offset.toString());

      const { rows } = await DatabaseConnectionManager.getPool().query(
        query,
        params,
      );
      return rows.map(this.mapResultToModel);
    } catch (error) {
      this.logger.error("Error finding public collections", {
        type,
        error: error instanceof Error ? error.message : error,
      });
      throw new MediaCollectionError(
        "Failed to find public collections",
        "QUERY_ERROR",
      );
    }
  }

  /**
   * Find official collections
   */
  async findOfficial(
    limit = 20,
    offset = 0,
    type?: CollectionType,
  ): Promise<MediaCollection[]> {
    try {
      let query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE is_official = TRUE AND is_deleted = FALSE
      `;

      const params: unknown[] = [];

      if (type) {
        query += ` AND type = $${params.length + 1}`;
        params.push(type);
      }

      query += " ORDER BY created_at DESC";
      query += ` LIMIT $${params.length + 1} OFFSET $${params.length + 2}`;
      params.push(limit.toString(), offset.toString());

      const { rows } = await DatabaseConnectionManager.getPool().query(
        query,
        params,
      );
      return rows.map(this.mapResultToModel);
    } catch (error) {
      this.logger.error("Error finding official collections", {
        type,
        error: error instanceof Error ? error.message : error,
      });
      throw new MediaCollectionError(
        "Failed to find official collections",
        "QUERY_ERROR",
      );
    }
  }

  /**
   * Search collections by title or description
   */
  async search(
    searchTerm: string,
    limit = 20,
    offset = 0,
    type?: CollectionType,
    userId?: string,
  ): Promise<MediaCollection[]> {
    try {
      let query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE (title ILIKE $1 OR description ILIKE $1)
        AND is_deleted = FALSE
        AND (privacy = $2
      `;

      const params: unknown[] = [`%${searchTerm}%`, CollectionPrivacy.PUBLIC];

      if (userId) {
        query += ` OR (privacy = $${params.length + 1} AND user_id = $${params.length + 2})`;
        params.push(CollectionPrivacy.PRIVATE, userId);
      }

      query += ")";

      if (type) {
        query += ` AND type = $${params.length + 1}`;
        params.push(type);
      }

      query += " ORDER BY created_at DESC";
      query += ` LIMIT $${params.length + 1} OFFSET $${params.length + 2}`;
      params.push(limit.toString(), offset.toString());

      const { rows } = await DatabaseConnectionManager.getPool().query(
        query,
        params,
      );
      return rows.map(this.mapResultToModel);
    } catch (error) {
      this.logger.error("Error searching collections", {
        searchTerm,
        type,
        userId,
        error: error instanceof Error ? error.message : error,
      });
      throw new MediaCollectionError(
        "Failed to search collections",
        "QUERY_ERROR",
      );
    }
  }

  /**
   * Find collections containing a specific media
   */
  async findByMediaId(
    mediaId: string,
    limit = 20,
    offset = 0,
    userId?: string,
  ): Promise<MediaCollection[]> {
    try {
      let query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE media_ids ? $1
        AND is_deleted = FALSE
        AND (privacy = $2
      `;

      const params: unknown[] = [mediaId, CollectionPrivacy.PUBLIC];

      if (userId) {
        query += ` OR (privacy = $${params.length + 1} AND user_id = $${params.length + 2})`;
        params.push(CollectionPrivacy.PRIVATE, userId);
      }

      query += ")";
      query += " ORDER BY created_at DESC";
      query += ` LIMIT $${params.length + 1} OFFSET $${params.length + 2}`;
      params.push(limit.toString(), offset.toString());

      const { rows } = await DatabaseConnectionManager.getPool().query(
        query,
        params,
      );
      return rows.map(this.mapResultToModel);
    } catch (error) {
      this.logger.error("Error finding collections by media ID", {
        mediaId,
        userId,
        error: error instanceof Error ? error.message : error,
      });
      throw new MediaCollectionError(
        "Failed to find collections by media ID",
        "QUERY_ERROR",
      );
    }
  }

  /**
   * Update collection privacy
   */
  async updatePrivacy(
    id: string,
    privacy: CollectionPrivacy,
  ): Promise<MediaCollection | null> {
    return this.withTransaction(async (_client) => {
      try {
        const existing = await this.findById(id);
        if (!existing) {
          throw new MediaCollectionNotFoundError(id);
        }

        const result = await super.update(id, { privacy });
        if (!result) {
          throw new MediaCollectionNotFoundError(id);
        }
        return new MediaCollection(result);
      } catch (error) {
        if (error instanceof MediaCollectionError) {
          throw error;
        }
        this.logger.error("Error updating collection privacy", {
          id,
          privacy,
          error: error instanceof Error ? error.message : error,
        });
        throw new MediaCollectionError(
          "Failed to update collection privacy",
          "UPDATE_ERROR",
        );
      }
    });
  }

  /**
   * Add media to collection
   */
  async addMedia(id: string, mediaId: string): Promise<MediaCollection | null> {
    return this.withTransaction(async (_client) => {
      try {
        const existing = await this.findById(id);
        if (!existing) {
          throw new MediaCollectionNotFoundError(id);
        }

        existing.addMedia(mediaId);

        const result = await super.update(id, {
          mediaIds: existing.mediaIds,
          itemCount: existing.itemCount,
        });

        if (!result) {
          throw new MediaCollectionNotFoundError(id);
        }
        return new MediaCollection(result);
      } catch (error) {
        if (error instanceof MediaCollectionError) {
          throw error;
        }
        this.logger.error("Error adding media to collection", {
          id,
          mediaId,
          error: error instanceof Error ? error.message : error,
        });
        throw new MediaCollectionError(
          "Failed to add media to collection",
          "UPDATE_ERROR",
        );
      }
    });
  }

  /**
   * Remove media from collection
   */
  async removeMedia(
    id: string,
    mediaId: string,
  ): Promise<MediaCollection | null> {
    return this.withTransaction(async (_client) => {
      try {
        const existing = await this.findById(id);
        if (!existing) {
          throw new MediaCollectionNotFoundError(id);
        }

        existing.removeMedia(mediaId);

        const result = await super.update(id, {
          mediaIds: existing.mediaIds,
          itemCount: existing.itemCount,
          coverMediaId: existing.coverMediaId,
        });

        if (!result) {
          throw new MediaCollectionNotFoundError(id);
        }
        return new MediaCollection(result);
      } catch (error) {
        if (error instanceof MediaCollectionError) {
          throw error;
        }
        this.logger.error("Error removing media from collection", {
          id,
          mediaId,
          error: error instanceof Error ? error.message : error,
        });
        throw new MediaCollectionError(
          "Failed to remove media from collection",
          "UPDATE_ERROR",
        );
      }
    });
  }

  /**
   * Get collection statistics
   */
  async getCollectionStatistics(): Promise<{
    total: number;
    byType: Record<CollectionType, number>;
    byPrivacy: Record<CollectionPrivacy, number>;
  }> {
    try {
      const query = `
        SELECT 
          COUNT(*) as total,
          json_object_agg(type, type_count) as by_type,
          json_object_agg(privacy, privacy_count) as by_privacy
        FROM (
          SELECT 
            type,
            COUNT(*) as type_count,
            privacy,
            COUNT(*) as privacy_count
          FROM ${this.tableName}
          WHERE is_deleted = FALSE
          GROUP BY type, privacy
        ) stats
      `;

      const { rows } = await DatabaseConnectionManager.getPool().query(query);
      const stats = rows[0] as {
        total: string;
        by_type: Record<CollectionType, number>;
        by_privacy: Record<CollectionPrivacy, number>;
      };

      return {
        total: parseInt(stats.total, 10),
        byType: stats.by_type || {},
        byPrivacy: stats.by_privacy || {},
      };
    } catch (error) {
      this.logger.error("Error getting collection statistics", {
        error: error instanceof Error ? error.message : error,
      });
      throw new MediaCollectionError(
        "Failed to get collection statistics",
        "QUERY_ERROR",
      );
    }
  }

  /**
   * Mark collection as deleted (soft delete)
   */
  async markAsDeleted(id: string): Promise<boolean> {
    return this.withTransaction(async (_client) => {
      try {
        const existing = await this.findById(id);
        if (!existing) {
          throw new MediaCollectionNotFoundError(id);
        }

        const result = await super.update(id, { isDeleted: true });
        return !!result;
      } catch (error) {
        if (error instanceof MediaCollectionError) {
          throw error;
        }
        this.logger.error("Error marking collection as deleted", {
          id,
          error: error instanceof Error ? error.message : error,
        });
        throw new MediaCollectionError(
          "Failed to mark collection as deleted",
          "UPDATE_ERROR",
        );
      }
    });
  }

  /**
   * Parse JSON array from database
   */
  private parseJsonArray(value: unknown): string[] {
    if (!value) return [];
    if (Array.isArray(value)) return value;
    try {
      return JSON.parse(value as string);
    } catch (error) {
      this.logger.warn("Error parsing JSON array", {
        value,
        error: error instanceof Error ? error.message : error,
      });
      return [];
    }
  }

  protected mapResultToModel(row: Record<string, unknown>): MediaCollection {
    if (!row) return null as unknown as MediaCollection;
    return new MediaCollection({
      ...row,
      mediaIds: this.parseJsonArray(row.mediaIds),
    } as MediaCollectionAttributes);
  }
}

// Export a singleton instance
export const mediaCollectionRepository = new MediaCollectionRepository();



===========================================================
FILE 48: repositories\media\MediaRepository.ts
===========================================================

import { Logger } from "../../../services/LoggerService";
import { DatabaseConnectionManager } from "../../config";
import {
  Media,
  MediaAttributes,
  MediaFormat,
  MediaStatus,
  MediaType,
  MIME_TYPES,
} from "../../models/media/Media";
import { BaseRepository } from "../BaseRepository";

export class MediaError extends Error {
  constructor(
    message: string,
    public code: string,
  ) {
    super(message);
    this.name = "MediaError";
  }
}

export class MediaNotFoundError extends MediaError {
  constructor(id: string) {
    super(`Media with ID ${id} not found`, "MEDIA_NOT_FOUND");
  }
}

export class MediaValidationError extends MediaError {
  constructor(message: string) {
    super(message, "MEDIA_VALIDATION_ERROR");
  }
}

export class MediaProcessingError extends MediaError {
  constructor(message: string) {
    super(message, "MEDIA_PROCESSING_ERROR");
  }
}

export class MediaFormatError extends MediaError {
  constructor(message: string) {
    super(message, "MEDIA_FORMAT_ERROR");
  }
}

/**
 * Repository class for handling Media database operations.
 * This class is responsible for:
 * 1. All database operations related to media
 * 2. Converting between database and model formats
 * 3. Providing specific query methods for media
 * 4. NOT implementing business logic - that belongs in the Media model
 */
export class MediaRepository extends BaseRepository<Media> {
  protected logger = new Logger("MediaRepository");
  protected tableName = "media";
  protected columns = [
    "id",
    "user_id as userId",
    "type",
    "original_filename as originalFilename",
    "filename",
    "path",
    "mime_type as mimeType",
    "size",
    "width",
    "height",
    "duration",
    "thumbnail_path as thumbnailPath",
    "processing_status as processingStatus",
    "is_public as isPublic",
    "metadata",
    "created_at as createdAt",
    "updated_at as updatedAt",
  ];

  protected mapResultToModel(row: Record<string, unknown>): Media {
    if (!row) return null as unknown as Media;
    return new Media(this.processMediaData(row));
  }

  constructor() {
    super();
  }

  /**
   * Creates a new media item with validation
   * @param data The media data to create
   * @returns The created Media instance
   * @throws {MediaValidationError} If validation fails
   */
  async create(
    data: Omit<MediaAttributes, "id" | "createdAt" | "updatedAt">,
  ): Promise<Media> {
    return this.withTransaction(async (_client) => {
      try {
        const media = new Media(
          data as unknown as Partial<MediaAttributes> & {
            userId: string;
            type: MediaType;
          },
        );
        media.validate();
        media.validateMetadata();

        const result = await super.create(media);
        return new Media(result);
      } catch (error) {
        if (error instanceof MediaError) {
          throw error;
        }
        this.logger.error("Error creating media", {
          data,
          error: error instanceof Error ? error.message : error,
        });
        throw new MediaError("Failed to create media", "CREATE_ERROR");
      }
    });
  }

  /**
   * Updates an existing media item with validation
   * @param id The media ID
   * @param data The data to update
   * @returns The updated Media instance
   * @throws {MediaNotFoundError} If media not found
   * @throws {MediaValidationError} If validation fails
   */
  async update(
    id: string,
    data: Partial<MediaAttributes>,
  ): Promise<Media | null> {
    return this.withTransaction(async (_client) => {
      try {
        const existing = await this.findById(id);
        if (!existing) {
          throw new MediaNotFoundError(id);
        }

        const media = new Media({ ...existing, ...data });
        media.validate();
        media.validateMetadata();

        const result = await super.update(id, media);
        if (!result) {
          throw new MediaNotFoundError(id);
        }
        return new Media(result);
      } catch (error) {
        if (error instanceof MediaError) {
          throw error;
        }
        this.logger.error("Error updating media", {
          id,
          data,
          error: error instanceof Error ? error.message : error,
        });
        throw new MediaError("Failed to update media", "UPDATE_ERROR");
      }
    });
  }

  /**
   * Updates the processing status of a media item
   * @param id The media ID
   * @param status The new processing status
   * @returns The updated Media instance
   * @throws {MediaNotFoundError} If media not found
   * @throws {MediaProcessingError} If status update fails
   */
  async updateProcessingStatus(
    id: string,
    status: MediaStatus,
  ): Promise<Media | null> {
    return this.withTransaction(async (_client) => {
      try {
        const existing = await this.findById(id);
        if (!existing) {
          throw new MediaNotFoundError(id);
        }

        const result = await super.update(id, { processingStatus: status });
        if (!result) {
          throw new MediaNotFoundError(id);
        }
        return new Media(result);
      } catch (error) {
        if (error instanceof MediaError) {
          throw error;
        }
        this.logger.error("Error updating media processing status", {
          id,
          status,
          error: error instanceof Error ? error.message : error,
        });
        throw new MediaProcessingError("Failed to update processing status");
      }
    });
  }

  /**
   * Finds media by user ID with optional type filtering
   * @param userId The user ID
   * @param type Optional media type filter
   * @param limit Maximum number of results
   * @param offset Number of results to skip
   * @returns Array of Media instances
   */
  async findByUserId(
    userId: string,
    type?: MediaType,
    limit: number = 20,
    offset: number = 0,
  ): Promise<Media[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE user_id = $1
        ${type ? "AND type = $2" : ""}
        ORDER BY created_at DESC
        LIMIT ${limit} OFFSET ${offset}
      `;

      const params = type ? [userId, type] : [userId];
      const result = await this.executeQuery<MediaAttributes>(query, params);
      return result.rows.map((row) => new Media(row));
    } catch (error) {
      this.logger.error("Error finding media by user ID", {
        userId,
        type,
        error: error instanceof Error ? error.message : error,
      });
      throw new MediaError("Failed to find media by user ID", "QUERY_ERROR");
    }
  }

  /**
   * Finds public media items
   * @param limit Maximum number of results
   * @param offset Number of results to skip
   * @returns Array of Media instances
   */
  async findPublic(limit: number = 20, offset: number = 0): Promise<Media[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE is_public = true
        AND processing_status = $1
        ORDER BY created_at DESC
        LIMIT ${limit} OFFSET ${offset}
      `;

      const result = await this.executeQuery<MediaAttributes>(query, [
        MediaStatus.COMPLETED,
      ]);
      return result.rows.map((row) => new Media(row));
    } catch (error) {
      this.logger.error("Error finding public media", {
        error: error instanceof Error ? error.message : error,
      });
      throw new MediaError("Failed to find public media", "QUERY_ERROR");
    }
  }

  /**
   * Deletes a media item and its associated files
   * @param id The media ID
   * @returns True if deletion was successful
   * @throws {MediaNotFoundError} If media not found
   */
  async delete(id: string): Promise<boolean> {
    return this.withTransaction(async (_client) => {
      try {
        const existing = await this.findById(id);
        if (!existing) {
          throw new MediaNotFoundError(id);
        }

        // Here you would typically also delete the actual files
        // This would be handled by a file service

        const result = await super.delete(id);
        return result;
      } catch (error) {
        if (error instanceof MediaError) {
          throw error;
        }
        this.logger.error("Error deleting media", {
          id,
          error: error instanceof Error ? error.message : error,
        });
        throw new MediaError("Failed to delete media", "DELETE_ERROR");
      }
    });
  }

  /**
   * Find a media item by ID
   * @param id The media ID
   * @returns The media item or null if not found
   */
  async findById(id: string): Promise<Media | null> {
    try {
      const result = await this.findOneByField("id", id);
      if (!result) return null;

      return new Media(this.processMediaData(result));
    } catch (error) {
      this.logger.error("Error finding media by ID", {
        error: error instanceof Error ? error.message : error,
        id,
      });
      throw error;
    }
  }

  /**
   * Find media by type
   * @param type The media type
   * @param limit Maximum number of items to return
   * @param offset Number of items to skip
   * @param sortBy Field to sort by
   * @param sortOrder Sort direction
   * @returns Array of media items
   */
  async findByType(
    type: MediaType,
    limit = 20,
    offset = 0,
    sortBy = "createdAt",
    sortOrder = "DESC",
  ): Promise<Media[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE type = $1
        ORDER BY ${this.snakeCase(sortBy)} ${sortOrder === "ASC" ? "ASC" : "DESC"}
        LIMIT $2 OFFSET $3
      `;

      const { rows } = await DatabaseConnectionManager.getPool().query(query, [
        type,
        limit,
        offset,
      ]);
      return rows.map((row) => new Media(this.processMediaData(row)));
    } catch (error) {
      this.logger.error("Error finding media by type", {
        error: error instanceof Error ? error.message : error,
        type,
      });
      throw error;
    }
  }

  /**
   * Find media by status
   * @param status The status to filter by
   * @param limit Maximum number of items to return
   * @param offset Number of items to skip
   * @returns Array of media items
   */
  async findByStatus(status: string, limit = 20, offset = 0): Promise<Media[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE status = $1
        ORDER BY created_at DESC
        LIMIT $2 OFFSET $3
      `;

      const { rows } = await DatabaseConnectionManager.getPool().query(query, [
        status,
        limit,
        offset,
      ]);
      return rows.map((row) => new Media(this.processMediaData(row)));
    } catch (error) {
      this.logger.error("Error finding media by status", {
        error: error instanceof Error ? error.message : error,
        status,
      });
      throw error;
    }
  }

  /**
   * Search media by title or description
   * @param searchTerm The search term
   * @param limit Maximum number of items to return
   * @param offset Number of items to skip
   * @param type Optional media type filter
   * @returns Array of media items
   */
  async search(
    searchTerm: string,
    limit = 20,
    offset = 0,
    type?: MediaType,
  ): Promise<Media[]> {
    try {
      const params = [`%${searchTerm}%`];

      let query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE (title ILIKE $1 OR description ILIKE $1)
      `;

      if (type) {
        query += ` AND type = $${params.length + 1}`;
        params.push(type);
      }

      query += ` ORDER BY created_at DESC LIMIT $${params.length + 1} OFFSET $${params.length + 2}`;
      params.push(limit.toString(), offset.toString());

      const { rows } = await DatabaseConnectionManager.getPool().query(
        query,
        params,
      );
      return rows.map((row) => new Media(this.processMediaData(row)));
    } catch (error) {
      this.logger.error("Error searching media", {
        error: error instanceof Error ? error.message : error,
        searchTerm,
        type,
      });
      throw error;
    }
  }

  /**
   * Update media status
   * @param id The media ID
   * @param status The new status
   * @returns The updated media or null if not found
   */
  async updateStatus(id: string, status: string): Promise<Media | null> {
    try {
      const query = `
        UPDATE ${this.tableName}
        SET status = $1, updated_at = NOW()
        WHERE id = $2
        RETURNING ${this.columns.join(", ")}
      `;

      const { rows } = await DatabaseConnectionManager.getPool().query(query, [
        status,
        id,
      ]);
      if (rows.length === 0) return null;

      return new Media(this.processMediaData(rows[0]));
    } catch (error) {
      this.logger.error("Error updating media status", {
        error: error instanceof Error ? error.message : error,
        id,
        status,
      });
      throw error;
    }
  }

  /**
   * Update media privacy setting
   * @param id The media ID
   * @param privacy The new privacy setting
   * @returns The updated media or null if not found
   */
  async updatePrivacy(id: string, privacy: string): Promise<Media | null> {
    try {
      const query = `
        UPDATE ${this.tableName}
        SET privacy = $1, updated_at = NOW()
        WHERE id = $2
        RETURNING ${this.columns.join(", ")}
      `;

      const { rows } = await DatabaseConnectionManager.getPool().query(query, [
        privacy,
        id,
      ]);
      if (rows.length === 0) return null;

      return new Media(this.processMediaData(rows[0]));
    } catch (error) {
      this.logger.error("Error updating media privacy", {
        error: error instanceof Error ? error.message : error,
        id,
        privacy,
      });
      throw error;
    }
  }

  /**
   * Find media by format
   * @param format The media format
   * @param limit Maximum number of items to return
   * @param offset Number of items to skip
   * @returns Array of media items
   */
  async findByFormat(
    format: MediaFormat,
    limit = 20,
    offset = 0,
  ): Promise<Media[]> {
    try {
      const mimeType = MIME_TYPES[format];
      if (!mimeType) {
        throw new MediaFormatError(`Unsupported format: ${format}`);
      }

      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE mime_type = $1
        ORDER BY created_at DESC
        LIMIT $2 OFFSET $3
      `;

      const { rows } = await DatabaseConnectionManager.getPool().query(query, [
        mimeType,
        limit,
        offset,
      ]);
      return rows.map((row) => new Media(this.processMediaData(row)));
    } catch (error) {
      this.logger.error("Error finding media by format", {
        error: error instanceof Error ? error.message : error,
        format,
      });
      throw error;
    }
  }

  /**
   * Find media by type and format
   * @param type The media type
   * @param format The media format
   * @param limit Maximum number of items to return
   * @param offset Number of items to skip
   * @returns Array of media items
   */
  async findByTypeAndFormat(
    type: MediaType,
    format: MediaFormat,
    limit = 20,
    offset = 0,
  ): Promise<Media[]> {
    try {
      const mimeType = MIME_TYPES[format];
      if (!mimeType) {
        throw new MediaFormatError(`Unsupported format: ${format}`);
      }

      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE type = $1 AND mime_type = $2
        ORDER BY created_at DESC
        LIMIT $3 OFFSET $4
      `;

      const { rows } = await DatabaseConnectionManager.getPool().query(query, [
        type,
        mimeType,
        limit,
        offset,
      ]);
      return rows.map((row) => new Media(this.processMediaData(row)));
    } catch (error) {
      this.logger.error("Error finding media by type and format", {
        error: error instanceof Error ? error.message : error,
        type,
        format,
      });
      throw error;
    }
  }

  /**
   * Get media statistics
   * @returns Object containing media statistics
   */
  async getMediaStatistics(): Promise<{
    total: number;
    byType: Record<MediaType, number>;
    byFormat: Record<MediaFormat, number>;
    byStatus: Record<MediaStatus, number>;
  }> {
    try {
      const query = `
        SELECT 
          COUNT(*) as total,
          json_object_agg(type, type_count) as by_type,
          json_object_agg(mime_type, format_count) as by_format,
          json_object_agg(processing_status, status_count) as by_status
        FROM (
          SELECT 
            type,
            COUNT(*) as type_count,
            mime_type,
            COUNT(*) as format_count,
            processing_status,
            COUNT(*) as status_count
          FROM ${this.tableName}
          GROUP BY type, mime_type, processing_status
        ) stats
      `;

      const { rows } = await DatabaseConnectionManager.getPool().query(query);
      const stats = rows[0] as {
        total: string;
        by_type: Record<MediaType, number>;
        by_format: Record<MediaFormat, number>;
        by_status: Record<MediaStatus, number>;
      };

      return {
        total: parseInt(stats.total, 10),
        byType: stats.by_type,
        byFormat: stats.by_format,
        byStatus: stats.by_status,
      };
    } catch (error) {
      this.logger.error("Error getting media statistics", {
        error: error instanceof Error ? error.message : error,
      });
      throw error;
    }
  }

  /**
   * Process database result for model instantiation
   * @param data The database data
   * @returns Processed data for model
   */
  private processMediaData(
    data: unknown,
  ): MediaAttributes & { userId: string; type: MediaType } {
    // Type assertion to work with the unknown data
    const record = data as Record<string, unknown>;

    // Parse metadata if it's a string
    if (record.metadata && typeof record.metadata === "string") {
      try {
        record.metadata = JSON.parse(record.metadata);
      } catch (error) {
        this.logger.warn("Error parsing media metadata", {
          error: error instanceof Error ? error.message : error,
          metadata: record.metadata,
        });
        record.metadata = {};
      }
    } else if (!record.metadata) {
      record.metadata = {};
    }

    // Parse tags if it's a string
    if (record.tags && typeof record.tags === "string") {
      try {
        record.tags = JSON.parse(record.tags);
      } catch (error) {
        this.logger.warn("Error parsing media tags", {
          error: error instanceof Error ? error.message : error,
          tags: record.tags,
        });
        record.tags = null;
      }
    }

    // Ensure type is a valid MediaType
    if (typeof record.type === "string") {
      record.type = record.type as MediaType;
    }

    // Validate MIME type
    if (
      record.mimeType &&
      !Object.values(MIME_TYPES).includes(record.mimeType as string)
    ) {
      this.logger.warn("Invalid MIME type detected", {
        mimeType: record.mimeType,
      });
    }

    return record as MediaAttributes & { userId: string; type: MediaType };
  }

  /**
   * Convert camelCase to snake_case
   * @param str The string to convert
   * @returns snake_case string
   */
  private snakeCase(str: string): string {
    return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
  }
}

// Export a singleton instance
export const mediaRepository = new MediaRepository();



===========================================================
FILE 49: repositories\media\MediaTagRepository.ts
===========================================================

import { Logger } from "../../../services/LoggerService";
import { DatabaseConnectionManager } from "../../config";
import { MediaTag, MediaTagAttributes } from "../../models/media/MediaTag";
import { BaseRepository } from "../BaseRepository";

export class MediaTagError extends Error {
  constructor(
    message: string,
    public code: string,
  ) {
    super(message);
    this.name = "MediaTagError";
  }
}

export class MediaTagNotFoundError extends MediaTagError {
  constructor(id: string) {
    super(`Tag with ID ${id} not found`, "TAG_NOT_FOUND");
  }
}

export class MediaTagValidationError extends MediaTagError {
  constructor(message: string) {
    super(message, "TAG_VALIDATION_ERROR");
  }
}

export class MediaTagDuplicateError extends MediaTagError {
  constructor(slug: string) {
    super(`Tag with slug '${slug}' already exists`, "TAG_DUPLICATE");
  }
}

export class MediaTagRepository extends BaseRepository<MediaTag> {
  protected logger = new Logger("MediaTagRepository");
  protected tableName = "media_tags";
  protected columns = [
    "id",
    "name",
    "slug",
    "description",
    "category",
    "is_official as isOfficial",
    "usage_count as usageCount",
    "parent_tag_id as parentTagId",
    "created_at as createdAt",
    "updated_at as updatedAt",
  ];

  protected mapResultToModel(row: Record<string, unknown>): MediaTag {
    if (!row) return null as unknown as MediaTag;
    return new MediaTag(row as unknown as MediaTagAttributes);
  }

  constructor() {
    super();
  }

  /**
   * Creates a new media tag with validation
   */
  async create(
    data: Omit<MediaTagAttributes, "id" | "createdAt" | "updatedAt">,
  ): Promise<MediaTag> {
    return this.withTransaction(async (_client) => {
      try {
        const tag = new MediaTag(data);
        tag.validate();

        // Check if tag with same slug already exists
        const existingTag = await this.findBySlug(tag.slug);
        if (existingTag) {
          throw new MediaTagDuplicateError(tag.slug);
        }

        const result = await super.create(tag);
        return new MediaTag(result);
      } catch (error) {
        if (error instanceof MediaTagError) {
          throw error;
        }
        this.logger.error("Error creating media tag", {
          data,
          error: error instanceof Error ? error.message : error,
        });
        throw new MediaTagError("Failed to create tag", "CREATE_ERROR");
      }
    });
  }

  /**
   * Updates an existing media tag with validation
   */
  async update(
    id: string,
    data: Partial<MediaTagAttributes>,
  ): Promise<MediaTag | null> {
    return this.withTransaction(async (_client) => {
      try {
        const existing = await this.findById(id);
        if (!existing) {
          throw new MediaTagNotFoundError(id);
        }

        // Create updated tag
        const tag = new MediaTag({ ...existing, ...data });
        tag.validate();

        // If slug has changed, check for duplicates
        if (data.slug || data.name) {
          const existingWithSlug = await this.findBySlug(tag.slug);
          if (existingWithSlug && existingWithSlug.id !== id) {
            throw new MediaTagDuplicateError(tag.slug);
          }
        }

        const result = await super.update(id, tag);
        if (!result) {
          throw new MediaTagNotFoundError(id);
        }
        return new MediaTag(result);
      } catch (error) {
        if (error instanceof MediaTagError) {
          throw error;
        }
        this.logger.error("Error updating media tag", {
          id,
          data,
          error: error instanceof Error ? error.message : error,
        });
        throw new MediaTagError("Failed to update tag", "UPDATE_ERROR");
      }
    });
  }

  /**
   * Find a tag by its slug
   */
  async findBySlug(slug: string): Promise<MediaTag | null> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE slug = $1
      `;

      const { rows } = await DatabaseConnectionManager.getPool().query(query, [
        slug,
      ]);
      if (rows.length === 0) return null;

      return new MediaTag(rows[0]);
    } catch (error) {
      this.logger.error("Error finding tag by slug", {
        slug,
        error: error instanceof Error ? error.message : error,
      });
      throw new MediaTagError("Failed to find tag by slug", "QUERY_ERROR");
    }
  }

  /**
   * Find tags by partial name match
   */
  async findByNameLike(
    name: string,
    limit = 20,
    offset = 0,
  ): Promise<MediaTag[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE name ILIKE $1
        ORDER BY usage_count DESC, name ASC
        LIMIT $2 OFFSET $3
      `;

      const { rows } = await DatabaseConnectionManager.getPool().query(query, [
        `%${name}%`,
        limit.toString(),
        offset.toString(),
      ]);
      return rows.map((row) => new MediaTag(row));
    } catch (error) {
      this.logger.error("Error finding tags by name", {
        name,
        error: error instanceof Error ? error.message : error,
      });
      throw new MediaTagError("Failed to find tags by name", "QUERY_ERROR");
    }
  }

  /**
   * Find tags by category
   */
  async findByCategory(
    category: string,
    limit = 20,
    offset = 0,
  ): Promise<MediaTag[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE category = $1
        ORDER BY usage_count DESC, name ASC
        LIMIT $2 OFFSET $3
      `;

      const { rows } = await DatabaseConnectionManager.getPool().query(query, [
        category,
        limit.toString(),
        offset.toString(),
      ]);
      return rows.map((row) => new MediaTag(row));
    } catch (error) {
      this.logger.error("Error finding tags by category", {
        category,
        error: error instanceof Error ? error.message : error,
      });
      throw new MediaTagError("Failed to find tags by category", "QUERY_ERROR");
    }
  }

  /**
   * Find trending tags (with usage count above threshold)
   */
  async findTrending(threshold = 10, limit = 20): Promise<MediaTag[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE usage_count >= $1
        ORDER BY usage_count DESC, updated_at DESC
        LIMIT $2
      `;

      const { rows } = await DatabaseConnectionManager.getPool().query(query, [
        threshold.toString(),
        limit.toString(),
      ]);
      return rows.map((row) => new MediaTag(row));
    } catch (error) {
      this.logger.error("Error finding trending tags", {
        threshold,
        error: error instanceof Error ? error.message : error,
      });
      throw new MediaTagError("Failed to find trending tags", "QUERY_ERROR");
    }
  }

  /**
   * Get official tags
   */
  async findOfficial(limit = 20, offset = 0): Promise<MediaTag[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE is_official = true
        ORDER BY name ASC
        LIMIT $1 OFFSET $2
      `;

      const { rows } = await DatabaseConnectionManager.getPool().query(query, [
        limit.toString(),
        offset.toString(),
      ]);
      return rows.map((row) => new MediaTag(row));
    } catch (error) {
      this.logger.error("Error finding official tags", {
        error: error instanceof Error ? error.message : error,
      });
      throw new MediaTagError("Failed to find official tags", "QUERY_ERROR");
    }
  }

  /**
   * Increment usage count for a tag
   */
  async incrementUsage(id: string, count = 1): Promise<MediaTag | null> {
    return this.withTransaction(async (_client) => {
      try {
        const existing = await this.findById(id);
        if (!existing) {
          throw new MediaTagNotFoundError(id);
        }

        const result = await super.update(id, {
          usageCount: existing.usageCount + count,
        });
        if (!result) {
          throw new MediaTagNotFoundError(id);
        }
        return new MediaTag(result);
      } catch (error) {
        if (error instanceof MediaTagError) {
          throw error;
        }
        this.logger.error("Error incrementing tag usage", {
          id,
          count,
          error: error instanceof Error ? error.message : error,
        });
        throw new MediaTagError(
          "Failed to increment tag usage",
          "UPDATE_ERROR",
        );
      }
    });
  }

  /**
   * Decrement usage count for a tag
   */
  async decrementUsage(id: string, count = 1): Promise<MediaTag | null> {
    return this.withTransaction(async (_client) => {
      try {
        const existing = await this.findById(id);
        if (!existing) {
          throw new MediaTagNotFoundError(id);
        }

        const result = await super.update(id, {
          usageCount: Math.max(0, existing.usageCount - count),
        });
        if (!result) {
          throw new MediaTagNotFoundError(id);
        }
        return new MediaTag(result);
      } catch (error) {
        if (error instanceof MediaTagError) {
          throw error;
        }
        this.logger.error("Error decrementing tag usage", {
          id,
          count,
          error: error instanceof Error ? error.message : error,
        });
        throw new MediaTagError(
          "Failed to decrement tag usage",
          "UPDATE_ERROR",
        );
      }
    });
  }

  /**
   * Find tags by parent tag ID
   */
  async findByParentTagId(parentTagId: string): Promise<MediaTag[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE parent_tag_id = $1
        ORDER BY name ASC
      `;

      const { rows } = await DatabaseConnectionManager.getPool().query(query, [
        parentTagId,
      ]);
      return rows.map((row) => new MediaTag(row));
    } catch (error) {
      this.logger.error("Error finding tags by parent ID", {
        parentTagId,
        error: error instanceof Error ? error.message : error,
      });
      throw new MediaTagError(
        "Failed to find tags by parent ID",
        "QUERY_ERROR",
      );
    }
  }

  /**
   * Find tags related to the given tag ID (siblings and parents)
   */
  async findRelatedTags(tagId: string, limit = 10): Promise<MediaTag[]> {
    return this.withTransaction(async (_client) => {
      try {
        const tag = await this.findById(tagId);
        if (!tag) {
          throw new MediaTagNotFoundError(tagId);
        }

        // Find parent tag if this is a child tag
        let relatedTags: MediaTag[] = [];
        if (tag.parentTagId) {
          const parentTag = await this.findById(tag.parentTagId);
          if (parentTag) {
            relatedTags.push(parentTag);
          }
        }

        // Find sibling tags (tags with same parent or in same category)
        let query = "";
        const params: unknown[] = [];

        if (tag.parentTagId) {
          query = `
            SELECT ${this.columns.join(", ")}
            FROM ${this.tableName}
            WHERE parent_tag_id = $1 AND id != $2
            ORDER BY usage_count DESC
            LIMIT $3
          `;
          params.push(tag.parentTagId, tagId, limit.toString());
        } else if (tag.category) {
          query = `
            SELECT ${this.columns.join(", ")}
            FROM ${this.tableName}
            WHERE category = $1 AND id != $2
            ORDER BY usage_count DESC
            LIMIT $3
          `;
          params.push(tag.category, tagId, limit.toString());
        } else {
          // Find related by common usage patterns
          query = `
            SELECT t.*
            FROM ${this.tableName} t
            JOIN media_tag_mappings m1 ON t.id = m1.tag_id
            JOIN media_tag_mappings m2 ON m1.media_id = m2.media_id
            WHERE m2.tag_id = $1 AND t.id != $2
            GROUP BY t.id
            ORDER BY COUNT(*) DESC, t.usage_count DESC
            LIMIT $3
          `;
          params.push(tagId, tagId, limit.toString());
        }

        const { rows } = await DatabaseConnectionManager.getPool().query(
          query,
          params,
        );
        relatedTags = [...relatedTags, ...rows.map((row) => new MediaTag(row))];

        return relatedTags;
      } catch (error) {
        if (error instanceof MediaTagError) {
          throw error;
        }
        this.logger.error("Error finding related tags", {
          tagId,
          error: error instanceof Error ? error.message : error,
        });
        throw new MediaTagError("Failed to find related tags", "QUERY_ERROR");
      }
    });
  }

  /**
   * Set tag as official or unofficial
   */
  async setOfficial(id: string, isOfficial: boolean): Promise<MediaTag | null> {
    return this.withTransaction(async (_client) => {
      try {
        const existing = await this.findById(id);
        if (!existing) {
          throw new MediaTagNotFoundError(id);
        }

        const result = await super.update(id, { isOfficial });
        if (!result) {
          throw new MediaTagNotFoundError(id);
        }
        return new MediaTag(result);
      } catch (error) {
        if (error instanceof MediaTagError) {
          throw error;
        }
        this.logger.error("Error setting tag official status", {
          id,
          isOfficial,
          error: error instanceof Error ? error.message : error,
        });
        throw new MediaTagError(
          "Failed to set tag official status",
          "UPDATE_ERROR",
        );
      }
    });
  }

  /**
   * Get tag statistics
   */
  async getTagStatistics(): Promise<{
    total: number;
    byCategory: Record<string, number>;
    officialCount: number;
    mostUsed: Array<{ id: string; name: string; usageCount: number }>;
  }> {
    try {
      const query = `
        SELECT 
          COUNT(*) as total,
          json_object_agg(category, category_count) as by_category,
          COUNT(*) FILTER (WHERE is_official = true) as official_count,
          json_agg(
            json_build_object(
              'id', id,
              'name', name,
              'usage_count', usage_count
            )
            ORDER BY usage_count DESC
            LIMIT 10
          ) as most_used
        FROM (
          SELECT 
            category,
            COUNT(*) as category_count
          FROM ${this.tableName}
          GROUP BY category
        ) stats
        CROSS JOIN ${this.tableName}
      `;

      const { rows } = await DatabaseConnectionManager.getPool().query(query);
      const stats = rows[0] as {
        total: string;
        by_category: Record<string, number>;
        official_count: string;
        most_used: Array<{ id: string; name: string; usage_count: number }>;
      };

      return {
        total: parseInt(stats.total, 10),
        byCategory: stats.by_category || {},
        officialCount: parseInt(stats.official_count, 10),
        mostUsed: (stats.most_used || []).map((tag) => ({
          id: tag.id,
          name: tag.name,
          usageCount: tag.usage_count,
        })),
      };
    } catch (error) {
      this.logger.error("Error getting tag statistics", {
        error: error instanceof Error ? error.message : error,
      });
      throw new MediaTagError("Failed to get tag statistics", "QUERY_ERROR");
    }
  }

  /**
   * Merge two tags (source into target), transferring all media associations
   */
  async mergeTags(
    sourceId: string,
    targetId: string,
  ): Promise<MediaTag | null> {
    return this.withTransaction(async (client) => {
      try {
        const sourceTag = await this.findById(sourceId);
        const targetTag = await this.findById(targetId);

        if (!sourceTag) {
          throw new MediaTagNotFoundError(sourceId);
        }
        if (!targetTag) {
          throw new MediaTagNotFoundError(targetId);
        }

        // Transfer media associations from source to target
        const transferQuery = `
          UPDATE media_tag_mappings
          SET tag_id = $1
          WHERE tag_id = $2 AND media_id NOT IN (
            SELECT media_id FROM media_tag_mappings WHERE tag_id = $1
          )
        `;
        await client.query(transferQuery, [targetId, sourceId]);

        // Add source tag usage count to target
        const updatedTarget = await this.update(targetId, {
          usageCount: targetTag.usageCount + sourceTag.usageCount,
        });

        // Delete the source tag
        const deleteQuery = `
          DELETE FROM ${this.tableName}
          WHERE id = $1
          RETURNING id
        `;
        await client.query(deleteQuery, [sourceId]);

        return updatedTarget;
      } catch (error) {
        if (error instanceof MediaTagError) {
          throw error;
        }
        this.logger.error("Error merging tags", {
          sourceId,
          targetId,
          error: error instanceof Error ? error.message : error,
        });
        throw new MediaTagError("Failed to merge tags", "UPDATE_ERROR");
      }
    });
  }
}

// Export a singleton instance
export const mediaTagRepository = new MediaTagRepository();



===========================================================
FILE 50: repositories\messaging\ConversationRepository.ts
===========================================================

import { Logger } from "../../../services/LoggerService";
import { DatabaseConnectionManager } from "../../config";
import {
  Conversation,
  ConversationAttributes,
  ConversationStatus,
  ConversationType,
  ParticipantRole,
} from "../../models/messaging/Conversation";
import { BaseRepository } from "../BaseRepository";

export class ConversationError extends Error {
  constructor(
    message: string,
    public code: string,
  ) {
    super(message);
    this.name = "ConversationError";
  }
}

export class ConversationNotFoundError extends ConversationError {
  constructor(id: string) {
    super(`Conversation with ID ${id} not found`, "CONVERSATION_NOT_FOUND");
  }
}

export class ConversationValidationError extends ConversationError {
  constructor(message: string) {
    super(message, "CONVERSATION_VALIDATION_ERROR");
  }
}

export class ConversationPermissionError extends ConversationError {
  constructor(message: string) {
    super(message, "CONVERSATION_PERMISSION_ERROR");
  }
}

export class ConversationRepository extends BaseRepository<Conversation> {
  protected logger = new Logger("ConversationRepository");
  protected tableName = "conversations";
  protected columns = [
    "id",
    "title",
    "type",
    "participant_ids as participantIds",
    "participant_details as participantDetails",
    "creator_id as creatorId",
    "last_message_id as lastMessageId",
    "last_message_sent_at as lastMessageSentAt",
    "status",
    "is_encrypted as isEncrypted",
    "is_read_only as isReadOnly",
    "max_participants as maxParticipants",
    "metadata",
    "created_at as createdAt",
    "updated_at as updatedAt",
  ];

  constructor() {
    super();
  }

  /**
   * Create a new conversation with validation
   */
  async create(
    data: Omit<ConversationAttributes, "id" | "createdAt" | "updatedAt"> & {
      creatorId: string;
      participantIds: string[];
    },
  ): Promise<Conversation> {
    return this.withTransaction(async (_client) => {
      try {
        const conversation = new Conversation(data);
        conversation.validate();

        // For direct messages, check if conversation already exists
        if (
          conversation.isDirectMessage() &&
          conversation.participantIds.length === 2
        ) {
          const [userA, userB] = conversation.participantIds;
          const existing = await this.findDirectConversation(userA, userB);
          if (existing) {
            return existing;
          }
        }

        const result = await super.create(conversation);
        return new Conversation(result);
      } catch (error) {
        if (error instanceof ConversationError) {
          throw error;
        }
        this.logger.error("Error creating conversation", {
          data,
          error: error instanceof Error ? error.message : error,
        });
        throw new ConversationError(
          "Failed to create conversation",
          "CREATE_ERROR",
        );
      }
    });
  }

  /**
   * Update an existing conversation with validation
   */
  async update(
    id: string,
    data: Partial<ConversationAttributes>,
  ): Promise<Conversation | null> {
    return this.withTransaction(async (_client) => {
      try {
        const existing = await this.findById(id);
        if (!existing) {
          throw new ConversationNotFoundError(id);
        }

        // Special handling for direct messages - they should always keep exactly 2 participants
        if (
          existing.isDirectMessage() &&
          data.participantIds &&
          data.participantIds.length !== 2
        ) {
          throw new ConversationValidationError(
            "Direct conversations must have exactly two participants",
          );
        }

        const conversation = new Conversation({ ...existing, ...data });
        conversation.validate();

        const result = await super.update(id, conversation);
        if (!result) {
          throw new ConversationNotFoundError(id);
        }
        return new Conversation(result);
      } catch (error) {
        if (error instanceof ConversationError) {
          throw error;
        }
        this.logger.error("Error updating conversation", {
          id,
          data,
          error: error instanceof Error ? error.message : error,
        });
        throw new ConversationError(
          "Failed to update conversation",
          "UPDATE_ERROR",
        );
      }
    });
  }

  /**
   * Delete a conversation
   */
  async delete(id: string): Promise<boolean> {
    return this.withTransaction(async (_client) => {
      try {
        const existing = await this.findById(id);
        if (!existing) {
          throw new ConversationNotFoundError(id);
        }

        return await super.delete(id);
      } catch (error) {
        if (error instanceof ConversationError) {
          throw error;
        }
        this.logger.error("Error deleting conversation", {
          id,
          error: error instanceof Error ? error.message : error,
        });
        throw new ConversationError(
          "Failed to delete conversation",
          "DELETE_ERROR",
        );
      }
    });
  }

  /**
   * Find a conversation by ID
   */
  async findById(id: string): Promise<Conversation | null> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE id = $1
      `;

      const { rows } = await DatabaseConnectionManager.getPool().query(query, [
        id,
      ]);
      if (rows.length === 0) return null;

      return new Conversation(this.processConversationData(rows[0]));
    } catch (error) {
      this.logger.error("Error finding conversation by ID", {
        id,
        error: error instanceof Error ? error.message : error,
      });
      throw new ConversationError(
        "Failed to find conversation by ID",
        "QUERY_ERROR",
      );
    }
  }

  /**
   * Find conversations for a specific user
   */
  async findByUserId(
    userId: string,
    limit = 20,
    offset = 0,
    excludeArchived = true,
  ): Promise<Conversation[]> {
    try {
      let query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE participant_ids @> ARRAY[$1]::uuid[]
      `;

      const params: unknown[] = [userId];

      if (excludeArchived) {
        query += ` AND status != $${params.length + 1}`;
        params.push(ConversationStatus.ARCHIVED);
      }

      query += ` ORDER BY last_message_sent_at DESC NULLS LAST`;
      query += ` LIMIT $${params.length + 1} OFFSET $${params.length + 2}`;
      params.push(limit.toString(), offset.toString());

      const { rows } = await DatabaseConnectionManager.getPool().query(
        query,
        params,
      );
      return rows.map(
        (row) => new Conversation(this.processConversationData(row)),
      );
    } catch (error) {
      this.logger.error("Error finding conversations by user ID", {
        userId,
        error: error instanceof Error ? error.message : error,
      });
      throw new ConversationError(
        "Failed to find conversations by user ID",
        "QUERY_ERROR",
      );
    }
  }

  /**
   * Find direct conversation between two users
   */
  async findDirectConversation(
    userIdA: string,
    userIdB: string,
  ): Promise<Conversation | null> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE type = $1
          AND array_length(participant_ids, 1) = 2
          AND participant_ids @> ARRAY[$2, $3]::uuid[]
        LIMIT 1
      `;

      const { rows } = await DatabaseConnectionManager.getPool().query(query, [
        ConversationType.DIRECT,
        userIdA,
        userIdB,
      ]);

      if (rows.length === 0) {
        return null;
      }

      return new Conversation(this.processConversationData(rows[0]));
    } catch (error) {
      this.logger.error("Error finding direct conversation", {
        userIdA,
        userIdB,
        error: error instanceof Error ? error.message : error,
      });
      throw new ConversationError(
        "Failed to find direct conversation",
        "QUERY_ERROR",
      );
    }
  }

  /**
   * Find group conversations for a user
   */
  async findGroupConversations(
    userId: string,
    limit = 20,
    offset = 0,
  ): Promise<Conversation[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE type = $1
          AND participant_ids @> ARRAY[$2]::uuid[]
        ORDER BY last_message_sent_at DESC NULLS LAST
        LIMIT $3 OFFSET $4
      `;

      const { rows } = await DatabaseConnectionManager.getPool().query(query, [
        ConversationType.GROUP,
        userId,
        limit.toString(),
        offset.toString(),
      ]);

      return rows.map(
        (row) => new Conversation(this.processConversationData(row)),
      );
    } catch (error) {
      this.logger.error("Error finding group conversations", {
        userId,
        error: error instanceof Error ? error.message : error,
      });
      throw new ConversationError(
        "Failed to find group conversations",
        "QUERY_ERROR",
      );
    }
  }

  /**
   * Find conversations by their status
   */
  async findByStatus(
    status: ConversationStatus,
    limit = 20,
    offset = 0,
  ): Promise<Conversation[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE status = $1
        ORDER BY updated_at DESC
        LIMIT $2 OFFSET $3
      `;

      const { rows } = await DatabaseConnectionManager.getPool().query(query, [
        status,
        limit.toString(),
        offset.toString(),
      ]);

      return rows.map(
        (row) => new Conversation(this.processConversationData(row)),
      );
    } catch (error) {
      this.logger.error("Error finding conversations by status", {
        status,
        error: error instanceof Error ? error.message : error,
      });
      throw new ConversationError(
        "Failed to find conversations by status",
        "QUERY_ERROR",
      );
    }
  }

  /**
   * Search conversations by title
   */
  async searchByTitle(
    searchTerm: string,
    userId: string,
    limit = 20,
    offset = 0,
  ): Promise<Conversation[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE title ILIKE $1
          AND participant_ids @> ARRAY[$2]::uuid[]
        ORDER BY 
          CASE 
            WHEN title ILIKE $3 THEN 0
            WHEN title ILIKE $4 THEN 1
            ELSE 2
          END,
          last_message_sent_at DESC NULLS LAST
        LIMIT $5 OFFSET $6
      `;

      const { rows } = await DatabaseConnectionManager.getPool().query(query, [
        `%${searchTerm}%`,
        userId,
        `${searchTerm}%`,
        `% ${searchTerm}%`,
        limit.toString(),
        offset.toString(),
      ]);

      return rows.map(
        (row) => new Conversation(this.processConversationData(row)),
      );
    } catch (error) {
      this.logger.error("Error searching conversations by title", {
        searchTerm,
        userId,
        error: error instanceof Error ? error.message : error,
      });
      throw new ConversationError(
        "Failed to search conversations by title",
        "QUERY_ERROR",
      );
    }
  }

  /**
   * Update the last message for a conversation
   */
  async updateLastMessage(
    conversationId: string,
    messageId: string,
    sentAt: Date,
  ): Promise<boolean> {
    return this.withTransaction(async (_client) => {
      try {
        const conversation = await this.findById(conversationId);
        if (!conversation) {
          throw new ConversationNotFoundError(conversationId);
        }

        conversation.updateLastMessage(messageId, sentAt);

        const result = await super.update(conversationId, {
          lastMessageId: messageId,
          lastMessageSentAt: sentAt,
        });

        return !!result;
      } catch (error) {
        if (error instanceof ConversationError) {
          throw error;
        }
        this.logger.error("Error updating last message", {
          conversationId,
          messageId,
          error: error instanceof Error ? error.message : error,
        });
        throw new ConversationError(
          "Failed to update last message",
          "UPDATE_ERROR",
        );
      }
    });
  }

  /**
   * Add a participant to a conversation
   */
  async addParticipant(
    conversationId: string,
    userId: string,
    role: ParticipantRole = ParticipantRole.MEMBER,
  ): Promise<boolean> {
    return this.withTransaction(async (_client) => {
      try {
        const conversation = await this.findById(conversationId);
        if (!conversation) {
          throw new ConversationNotFoundError(conversationId);
        }

        // Direct messages cannot have more than 2 participants
        if (conversation.isDirectMessage()) {
          throw new ConversationValidationError(
            "Cannot add participants to direct messages",
          );
        }

        // Check if user is already a participant
        if (conversation.hasParticipant(userId)) {
          return true; // Already a participant
        }

        conversation.addParticipant(userId, role);

        const result = await super.update(conversationId, {
          participantIds: conversation.participantIds,
          participantDetails: conversation.participantDetails,
        });

        return !!result;
      } catch (error) {
        if (error instanceof ConversationError) {
          throw error;
        }
        this.logger.error("Error adding participant", {
          conversationId,
          userId,
          error: error instanceof Error ? error.message : error,
        });
        throw new ConversationError(
          "Failed to add participant",
          "UPDATE_ERROR",
        );
      }
    });
  }

  /**
   * Remove a participant from a conversation
   */
  async removeParticipant(
    conversationId: string,
    userId: string,
  ): Promise<boolean> {
    return this.withTransaction(async (_client) => {
      try {
        const conversation = await this.findById(conversationId);
        if (!conversation) {
          throw new ConversationNotFoundError(conversationId);
        }

        // Direct messages cannot remove participants
        if (conversation.isDirectMessage()) {
          throw new ConversationValidationError(
            "Cannot remove participants from direct messages",
          );
        }

        // Check if user is actually a participant
        if (!conversation.hasParticipant(userId)) {
          return true; // Not a participant, nothing to do
        }

        conversation.removeParticipant(userId);

        const result = await super.update(conversationId, {
          participantIds: conversation.participantIds,
          participantDetails: conversation.participantDetails,
        });

        return !!result;
      } catch (error) {
        if (error instanceof ConversationError) {
          throw error;
        }
        this.logger.error("Error removing participant", {
          conversationId,
          userId,
          error: error instanceof Error ? error.message : error,
        });
        throw new ConversationError(
          "Failed to remove participant",
          "UPDATE_ERROR",
        );
      }
    });
  }

  /**
   * Update participant role
   */
  async updateParticipantRole(
    conversationId: string,
    userId: string,
    role: ParticipantRole,
  ): Promise<boolean> {
    return this.withTransaction(async (_client) => {
      try {
        const conversation = await this.findById(conversationId);
        if (!conversation) {
          throw new ConversationNotFoundError(conversationId);
        }

        // Direct messages don't have roles
        if (conversation.isDirectMessage()) {
          throw new ConversationValidationError(
            "Direct messages don't support participant roles",
          );
        }

        conversation.updateParticipantRole(userId, role);

        const result = await super.update(conversationId, {
          participantDetails: conversation.participantDetails,
        });

        return !!result;
      } catch (error) {
        if (error instanceof ConversationError) {
          throw error;
        }
        this.logger.error("Error updating participant role", {
          conversationId,
          userId,
          role,
          error: error instanceof Error ? error.message : error,
        });
        throw new ConversationError(
          "Failed to update participant role",
          "UPDATE_ERROR",
        );
      }
    });
  }

  /**
   * Update conversation status
   */
  async updateStatus(
    conversationId: string,
    status: ConversationStatus,
  ): Promise<boolean> {
    return this.withTransaction(async (_client) => {
      try {
        const conversation = await this.findById(conversationId);
        if (!conversation) {
          throw new ConversationNotFoundError(conversationId);
        }

        conversation.setStatus(status);

        const result = await super.update(conversationId, { status });
        return !!result;
      } catch (error) {
        if (error instanceof ConversationError) {
          throw error;
        }
        this.logger.error("Error updating conversation status", {
          conversationId,
          status,
          error: error instanceof Error ? error.message : error,
        });
        throw new ConversationError(
          "Failed to update conversation status",
          "UPDATE_ERROR",
        );
      }
    });
  }

  /**
   * Set read-only status of a conversation
   */
  async setReadOnly(
    conversationId: string,
    isReadOnly: boolean,
  ): Promise<boolean> {
    return this.withTransaction(async (_client) => {
      try {
        const conversation = await this.findById(conversationId);
        if (!conversation) {
          throw new ConversationNotFoundError(conversationId);
        }

        conversation.setReadOnly(isReadOnly);

        const result = await super.update(conversationId, { isReadOnly });
        return !!result;
      } catch (error) {
        if (error instanceof ConversationError) {
          throw error;
        }
        this.logger.error("Error setting read-only status", {
          conversationId,
          isReadOnly,
          error: error instanceof Error ? error.message : error,
        });
        throw new ConversationError(
          "Failed to set read-only status",
          "UPDATE_ERROR",
        );
      }
    });
  }

  /**
   * Get conversation statistics (admin function)
   */
  async getConversationStatistics(): Promise<{
    total: number;
    byType: Record<ConversationType, number>;
    byStatus: Record<ConversationStatus, number>;
    activeUsersCount: number;
  }> {
    try {
      const query = `
        SELECT 
          COUNT(*) as total,
          json_object_agg(type, type_count) as by_type,
          json_object_agg(status, status_count) as by_status,
          (
            SELECT COUNT(DISTINCT unnest(participant_ids))
            FROM ${this.tableName}
            WHERE last_message_sent_at > NOW() - INTERVAL '30 days'
          ) as active_users_count
        FROM (
          SELECT 
            type,
            COUNT(*) as type_count,
            status,
            COUNT(*) as status_count
          FROM ${this.tableName}
          GROUP BY type, status
        ) stats
      `;

      const { rows } = await DatabaseConnectionManager.getPool().query(query);
      const stats = rows[0] as {
        total: string;
        by_type: Record<ConversationType, number>;
        by_status: Record<ConversationStatus, number>;
        active_users_count: string;
      };

      return {
        total: parseInt(stats.total, 10),
        byType: stats.by_type || {},
        byStatus: stats.by_status || {},
        activeUsersCount: parseInt(stats.active_users_count, 10),
      };
    } catch (error) {
      this.logger.error("Error getting conversation statistics", {
        error: error instanceof Error ? error.message : error,
      });
      throw new ConversationError(
        "Failed to get conversation statistics",
        "QUERY_ERROR",
      );
    }
  }

  /**
   * Process conversation data from database
   */
  private processConversationData(
    data: unknown,
  ): ConversationAttributes & { creatorId: string; participantIds: string[] } {
    const record = data as Record<string, unknown>;

    // Parse participantIds if string
    if (record.participantIds && typeof record.participantIds === "string") {
      try {
        record.participantIds = JSON.parse(record.participantIds);
      } catch (error) {
        this.logger.warn("Error parsing participant IDs", {
          error: error instanceof Error ? error.message : error,
          data: record.participantIds,
        });
        record.participantIds = [];
      }
    }

    // Parse participantDetails if string
    if (
      record.participantDetails &&
      typeof record.participantDetails === "string"
    ) {
      try {
        record.participantDetails = JSON.parse(record.participantDetails);
      } catch (error) {
        this.logger.warn("Error parsing participant details", {
          error: error instanceof Error ? error.message : error,
          data: record.participantDetails,
        });
        record.participantDetails = null;
      }
    }

    // Parse metadata if string
    if (record.metadata && typeof record.metadata === "string") {
      try {
        record.metadata = JSON.parse(record.metadata);
      } catch (error) {
        this.logger.warn("Error parsing metadata", {
          error: error instanceof Error ? error.message : error,
          data: record.metadata,
        });
        record.metadata = null;
      }
    }

    return record as ConversationAttributes & {
      creatorId: string;
      participantIds: string[];
    };
  }

  protected mapResultToModel(row: Record<string, unknown>): Conversation {
    if (!row) return null as unknown as Conversation;
    return new Conversation(this.processConversationData(row));
  }
}

// Export a singleton instance
export const conversationRepository = new ConversationRepository();



===========================================================
FILE 51: repositories\messaging\MessageRepository.ts
===========================================================

import { Logger } from "../../../services/LoggerService";
import { DatabaseConnectionManager } from "../../config";
import { BaseModelInterface } from "../../models/BaseModel";
import { ParticipantRole } from "../../models/messaging/Conversation";
import {
  Message,
  MessageAttributes,
  MessageStatus,
  MessageType,
} from "../../models/messaging/Message";
import { BaseRepository } from "../BaseRepository";

import {
  ConversationNotFoundError,
  conversationRepository,
} from "./ConversationRepository";

// Add custom interface to fix the type constraint error
export interface MessageWithIndex extends Message, BaseModelInterface {
  [key: string]: unknown;
}

export class MessageError extends Error {
  constructor(
    message: string,
    public code: string,
  ) {
    super(message);
    this.name = "MessageError";
  }
}

export class MessageNotFoundError extends MessageError {
  constructor(id: string) {
    super(`Message with ID ${id} not found`, "MESSAGE_NOT_FOUND");
  }
}

export class MessageValidationError extends MessageError {
  constructor(message: string) {
    super(message, "MESSAGE_VALIDATION_ERROR");
  }
}

export class MessagePermissionError extends MessageError {
  constructor(message: string) {
    super(message, "MESSAGE_PERMISSION_ERROR");
  }
}

export class MessageRepository extends BaseRepository<MessageWithIndex> {
  protected logger = new Logger("MessageRepository");
  protected tableName = "messages";
  protected columns = [
    "id",
    "conversation_id as conversationId",
    "sender_id as senderId",
    "content",
    "type",
    "status",
    "reply_to_id as replyToId",
    "metadata",
    "read_by as readBy",
    "is_edited as isEdited",
    "edited_at as editedAt",
    "created_at as createdAt",
    "updated_at as updatedAt",
  ];

  constructor() {
    super();
  }

  /**
   * Send a new message
   */
  async send(
    data: Omit<MessageAttributes, "id" | "createdAt" | "updatedAt">,
  ): Promise<Message> {
    return this.withTransaction(async (_client) => {
      try {
        // First validate the message
        const message = new Message({
          ...data,
          conversationId: data.conversationId as string,
          senderId: data.senderId as string,
          content: data.content as string,
        }) as MessageWithIndex;

        message.validate();

        // Check if conversation exists
        const conversation = await conversationRepository.findById(
          data.conversationId as string,
        );
        if (!conversation) {
          throw new ConversationNotFoundError(data.conversationId as string);
        }

        // Check if user is a participant in the conversation
        if (!conversation.hasParticipant(data.senderId as string)) {
          throw new MessagePermissionError(
            "User is not a participant in this conversation",
          );
        }

        // Check if conversation is read-only
        if (conversation.isReadOnly) {
          throw new MessagePermissionError(
            "Cannot send messages to a read-only conversation",
          );
        }

        // Create the message
        const result = await super.create(message);
        const newMessage = this.mapResultToModel(
          result as Record<string, unknown>,
        );

        // Update conversation's last message
        await conversationRepository.updateLastMessage(
          data.conversationId as string,
          newMessage.id,
          newMessage.createdAt,
        );

        return new Message({
          ...result,
          conversationId: result.conversationId,
          senderId: result.senderId,
          content: result.content,
        });
      } catch (error) {
        if (
          error instanceof MessageError ||
          error instanceof ConversationNotFoundError
        ) {
          throw error;
        }
        this.logger.error("Error sending message", {
          data,
          error: error instanceof Error ? error.message : error,
        });
        throw new MessageError("Failed to send message", "SEND_ERROR");
      }
    });
  }

  /**
   * Find messages for a conversation with pagination
   */
  async findByConversationId(
    conversationId: string,
    limit = 50,
    before?: Date,
    userId?: string,
  ): Promise<Message[]> {
    try {
      let query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE conversation_id = $1
      `;

      const params: unknown[] = [conversationId];

      // Filter by date if provided
      if (before) {
        query += ` AND created_at < $${params.length + 1}`;
        params.push(before);
      }

      // If userId is provided, exclude messages deleted for that user
      if (userId) {
        query += ` AND NOT (deleted_for_user_ids @> ARRAY[$${params.length + 1}]::uuid[])`;
        params.push(userId);
      }

      query += ` ORDER BY created_at DESC LIMIT $${params.length + 1}`;
      params.push(limit.toString());

      const { rows } = await DatabaseConnectionManager.getPool().query(
        query,
        params,
      );
      return rows.map((row) => new Message(this.processMessageData(row)));
    } catch (error) {
      this.logger.error("Error finding messages by conversation ID", {
        conversationId,
        error: error instanceof Error ? error.message : error,
      });
      throw new MessageError("Failed to find messages", "QUERY_ERROR");
    }
  }

  /**
   * Find a single message by ID
   */
  async findById(id: string): Promise<MessageWithIndex | null> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE id = $1
      `;

      const { rows } = await DatabaseConnectionManager.getPool().query(query, [
        id,
      ]);
      if (rows.length === 0) return null;

      return this.mapResultToModel(rows[0] as Record<string, unknown>);
    } catch (error) {
      this.logger.error("Error finding message by ID", {
        id,
        error: error instanceof Error ? error.message : error,
      });
      throw new MessageError("Failed to find message by ID", "QUERY_ERROR");
    }
  }

  /**
   * Mark message as read by a user
   */
  async markAsReadBy(messageId: string, userId: string): Promise<boolean> {
    return this.withTransaction(async (_client) => {
      try {
        const message = await this.findById(messageId);
        if (!message) {
          throw new MessageNotFoundError(messageId);
        }

        // Check if already read by this user
        if (message.readBy.includes(userId)) {
          return true; // Already read
        }

        message.markAsReadBy(userId);
        message.markAsRead();

        const result = await super.update(messageId, {
          readBy: message.readBy,
          status: message.status,
        });

        return !!result;
      } catch (error) {
        if (error instanceof MessageError) {
          throw error;
        }
        this.logger.error("Error marking message as read", {
          messageId,
          userId,
          error: error instanceof Error ? error.message : error,
        });
        throw new MessageError(
          "Failed to mark message as read",
          "UPDATE_ERROR",
        );
      }
    });
  }

  /**
   * Mark all messages in a conversation as read by a user
   */
  async markAllAsReadByUser(
    conversationId: string,
    userId: string,
  ): Promise<number> {
    return this.withTransaction(async (_client) => {
      try {
        const query = `
          UPDATE ${this.tableName}
          SET read_by = array_append(read_by, $1),
              status = CASE
                WHEN status = 'SENT' OR status = 'DELIVERED' THEN 'READ'::message_status
                ELSE status
              END,
              updated_at = NOW()
          WHERE conversation_id = $2
            AND sender_id != $1
            AND NOT (read_by @> ARRAY[$1]::uuid[])
          RETURNING id
        `;

        const { rowCount } = await DatabaseConnectionManager.getPool().query(
          query,
          [userId, conversationId],
        );
        return rowCount ?? 0;
      } catch (error) {
        this.logger.error("Error marking all messages as read", {
          conversationId,
          userId,
          error: error instanceof Error ? error.message : error,
        });
        throw new MessageError(
          "Failed to mark all messages as read",
          "UPDATE_ERROR",
        );
      }
    });
  }

  /**
   * Edit a message
   */
  async editMessage(
    messageId: string,
    userId: string,
    newContent: string,
  ): Promise<Message> {
    return this.withTransaction(async (_client) => {
      try {
        const message = await this.findById(messageId);
        if (!message) {
          throw new MessageNotFoundError(messageId);
        }

        // Check if user is the sender
        if (message.senderId !== userId) {
          throw new MessagePermissionError(
            "Only the sender can edit a message",
          );
        }

        // Check if message can be edited
        if (message.status === MessageStatus.DELETED) {
          throw new MessageValidationError("Cannot edit a deleted message");
        }

        if (message.type !== MessageType.TEXT) {
          throw new MessageValidationError(
            `Cannot edit a ${message.type} message`,
          );
        }

        message.editContent(newContent);

        const result = await super.update(messageId, {
          content: message.content,
          isEdited: message.isEdited,
          editedAt: message.editedAt,
        });

        if (!result) {
          throw new MessageNotFoundError(messageId);
        }

        return new Message({
          ...result,
          conversationId: result.conversationId,
          senderId: result.senderId,
          content: result.content,
        });
      } catch (error) {
        if (error instanceof MessageError) {
          throw error;
        }
        this.logger.error("Error editing message", {
          messageId,
          userId,
          error: error instanceof Error ? error.message : error,
        });
        throw new MessageError("Failed to edit message", "UPDATE_ERROR");
      }
    });
  }

  /**
   * Soft delete a message for all users
   */
  async softDelete(messageId: string, userId: string): Promise<boolean> {
    return this.withTransaction(async (_client) => {
      try {
        const message = await this.findById(messageId);
        if (!message) {
          throw new MessageNotFoundError(messageId);
        }

        // Check if user is the sender or has admin permission
        if (message.senderId !== userId) {
          // Here you would check if user has admin rights in the conversation
          const conversation = await conversationRepository.findById(
            message.conversationId,
          );
          if (
            !conversation ||
            !conversation.participantDetails?.some(
              (p) => p.userId === userId && p.role === ParticipantRole.ADMIN,
            )
          ) {
            throw new MessagePermissionError(
              "No permission to delete this message",
            );
          }
        }

        message.softDelete();

        const result = await super.update(messageId, {
          status: message.status,
          content: message.content,
          metadata: message.metadata,
        });

        return !!result;
      } catch (error) {
        if (error instanceof MessageError) {
          throw error;
        }
        this.logger.error("Error soft deleting message", {
          messageId,
          userId,
          error: error instanceof Error ? error.message : error,
        });
        throw new MessageError("Failed to delete message", "DELETE_ERROR");
      }
    });
  }

  /**
   * Find unread messages count for a user
   */
  async getUnreadCount(
    userId: string,
  ): Promise<{ total: number; byConversation: Record<string, number> }> {
    try {
      const query = `
        SELECT 
          COUNT(*) as total,
          json_object_agg(conversation_id, count) as by_conversation
        FROM (
          SELECT 
            conversation_id,
            COUNT(*) as count
          FROM ${this.tableName}
          WHERE 
            sender_id != $1
            AND NOT (read_by @> ARRAY[$1]::uuid[])
            AND status != 'DELETED'
            AND EXISTS (
              SELECT 1 FROM conversations 
              WHERE id = conversation_id
              AND participant_ids @> ARRAY[$1]::uuid[]
            )
          GROUP BY conversation_id
        ) counts
      `;

      const { rows } = await DatabaseConnectionManager.getPool().query(query, [
        userId,
      ]);
      const result = (rows[0] as {
        total?: string;
        by_conversation?: Record<string, number>;
      }) || { total: "0", by_conversation: {} };

      return {
        total: parseInt(result.total || "0", 10),
        byConversation: result.by_conversation || {},
      };
    } catch (error) {
      this.logger.error("Error getting unread count", {
        userId,
        error: error instanceof Error ? error.message : error,
      });
      throw new MessageError("Failed to get unread count", "QUERY_ERROR");
    }
  }

  /**
   * Search messages by content
   */
  async searchMessages(
    userId: string,
    searchTerm: string,
    limit = 20,
    offset = 0,
  ): Promise<Message[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName} m
        WHERE 
          content ILIKE $1
          AND EXISTS (
            SELECT 1 FROM conversations c
            WHERE c.id = m.conversation_id
            AND c.participant_ids @> ARRAY[$2]::uuid[]
          )
          AND status != 'DELETED'
          AND NOT (deleted_for_user_ids @> ARRAY[$2]::uuid[])
        ORDER BY created_at DESC
        LIMIT $3 OFFSET $4
      `;

      const { rows } = await DatabaseConnectionManager.getPool().query(query, [
        `%${searchTerm}%`,
        userId,
        limit.toString(),
        offset.toString(),
      ]);

      return rows.map((row) => new Message(this.processMessageData(row)));
    } catch (error) {
      this.logger.error("Error searching messages", {
        userId,
        searchTerm,
        error: error instanceof Error ? error.message : error,
      });
      throw new MessageError("Failed to search messages", "QUERY_ERROR");
    }
  }

  /**
   * Process message data from database
   */
  private processMessageData(
    data: unknown,
  ): MessageAttributes & { senderId: string; content: string } {
    const typedData = data as Record<string, unknown>;

    // Parse readBy if it's a string
    if (typeof typedData.readBy === "string") {
      try {
        typedData.readBy = JSON.parse(typedData.readBy) as string[];
      } catch (error) {
        this.logger.warn("Error parsing readBy", {
          error: error instanceof Error ? error.message : error,
          data: typedData.readBy,
        });
        typedData.readBy = [];
      }
    }

    // Parse metadata if it's a string
    if (typeof typedData.metadata === "string") {
      try {
        typedData.metadata = JSON.parse(typedData.metadata) as Record<
          string,
          unknown
        >;
      } catch (error) {
        this.logger.warn("Error parsing metadata", {
          error: error instanceof Error ? error.message : error,
          data: typedData.metadata,
        });
        typedData.metadata = null;
      }
    }

    // Convert null to empty string for content if needed
    if (typedData.content === null) {
      typedData.content = "";
    }

    return typedData as unknown as MessageAttributes & {
      senderId: string;
      content: string;
    };
  }

  /**
   * Map database row to Message model
   */
  protected mapResultToModel(row: Record<string, unknown>): MessageWithIndex {
    if (!row) return null as unknown as MessageWithIndex;

    // Convert database row to MessageAttributes
    const messageData = {
      id: String(row.id || ""),
      conversationId: String(row.conversationId || row.conversation_id || ""),
      senderId: String(row.senderId || row.sender_id || ""),
      content: String(row.content || ""),
      type: (row.type || MessageType.TEXT) as MessageType,
      status: (row.status || MessageStatus.SENT) as MessageStatus,
      replyToId:
        row.replyToId || row.reply_to_id
          ? String(row.replyToId || row.reply_to_id)
          : undefined,
      metadata: row.metadata as Record<string, unknown> | null,
      readBy: Array.isArray(row.readBy || row.read_by)
        ? ((row.readBy || row.read_by) as string[])
        : [],
      isEdited: Boolean(row.isEdited || row.is_edited || false),
      editedAt:
        row.editedAt || row.edited_at
          ? new Date(String(row.editedAt || row.edited_at))
          : null,
      createdAt: new Date(String(row.createdAt || row.created_at)),
      updatedAt: new Date(String(row.updatedAt || row.updated_at)),
    };

    return new Message(messageData) as MessageWithIndex;
  }
}

// Export a singleton instance
export const messageRepository = new MessageRepository();



===========================================================
FILE 52: repositories\moderation\ContentReportRepository.ts
===========================================================

import crypto from "crypto";

import { Logger } from "../../../services/LoggerService";
import {
  ContentReport,
  ContentReportAttributes,
  ReportSeverity,
  ReportStatus,
  ReportType,
} from "../../models/moderation/ContentReport";
import { EntityType } from "../../models/shared/EntityTypes";
import { BaseRepository } from "../BaseRepository";

export class ContentReportError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "ContentReportError";
  }
}

export class ContentReportNotFoundError extends ContentReportError {
  constructor(id: string) {
    super(`Content report with ID ${id} not found`);
    this.name = "ContentReportNotFoundError";
  }
}

export class ContentReportRepository extends BaseRepository<ContentReportAttributes> {
  private static instance: ContentReportRepository;
  protected logger = new Logger("ContentReportRepository");
  protected tableName = "content_reports";
  protected columns = [
    "id",
    "reporter_id as reporterId",
    "content_id as contentId",
    "content_type as contentType",
    "content_owner_id as contentOwnerId",
    "type",
    "description",
    "status",
    "severity",
    "reviewer_id as reviewerId",
    "resolution",
    "review_notes as reviewNotes",
    "evidence",
    "metadata",
    "created_at as createdAt",
    "updated_at as updatedAt",
  ];

  private constructor() {
    super();
  }

  /**
   * Get singleton instance
   */
  public static getInstance(): ContentReportRepository {
    if (!ContentReportRepository.instance) {
      ContentReportRepository.instance = new ContentReportRepository();
    }
    return ContentReportRepository.instance;
  }

  /**
   * Create a new content report
   * @param report The report to create
   * @returns The created report
   */
  async create(report: ContentReport): Promise<ContentReport> {
    try {
      // Validate the report before saving
      report.validate();

      // Generate ID if not provided
      if (!report.id) {
        report.id = crypto.randomUUID();
      }

      const evidenceJson = report.evidence
        ? JSON.stringify(report.evidence)
        : null;
      const metadataJson = report.metadata
        ? JSON.stringify(report.metadata)
        : null;

      const query = `
        INSERT INTO ${this.tableName} (
          id, reporter_id, content_id, content_type, content_owner_id, 
          type, description, status, severity, reviewer_id, 
          resolution, review_notes, evidence, metadata, created_at, updated_at
        ) 
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
        RETURNING ${this.columns.join(", ")}
      `;

      const params = [
        report.id,
        report.reporterId,
        report.contentId,
        report.contentType,
        report.contentOwnerId || null,
        report.type,
        report.description || null,
        report.status,
        report.severity,
        report.reviewerId || null,
        report.resolution || null,
        report.reviewNotes || null,
        evidenceJson,
        metadataJson,
        report.createdAt,
        report.updatedAt,
      ];

      const result = await this.executeQuery<ContentReportAttributes>(
        query,
        params,
      );
      return this.mapResultToModel(result.rows[0]);
    } catch (error) {
      this.logger.error("Error creating content report", error);
      throw new ContentReportError(
        `Failed to create content report: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Update an existing content report
   * @param report The report with updated values
   * @returns The updated report
   * @throws ContentReportNotFoundError if the report doesn't exist
   */
  async updateReport(report: ContentReport): Promise<ContentReport> {
    try {
      // Validate the report before updating
      report.validate();

      // Check if report exists
      const existingReport = await this.findById(report.id);
      if (!existingReport) {
        throw new ContentReportNotFoundError(report.id);
      }

      const evidenceJson = report.evidence
        ? JSON.stringify(report.evidence)
        : null;
      const metadataJson = report.metadata
        ? JSON.stringify(report.metadata)
        : null;

      const query = `
        UPDATE ${this.tableName} SET
          reporter_id = $2,
          content_id = $3,
          content_type = $4,
          content_owner_id = $5,
          type = $6,
          description = $7,
          status = $8,
          severity = $9,
          reviewer_id = $10,
          resolution = $11,
          review_notes = $12,
          evidence = $13,
          metadata = $14,
          updated_at = $15
        WHERE id = $1
        RETURNING ${this.columns.join(", ")}
      `;

      const params = [
        report.id,
        report.reporterId,
        report.contentId,
        report.contentType,
        report.contentOwnerId || null,
        report.type,
        report.description || null,
        report.status,
        report.severity,
        report.reviewerId || null,
        report.resolution || null,
        report.reviewNotes || null,
        evidenceJson,
        metadataJson,
        new Date(),
      ];

      const result = await this.executeQuery<ContentReportAttributes>(
        query,
        params,
      );
      return this.mapResultToModel(result.rows[0]);
    } catch (error) {
      this.logger.error("Error updating content report", error);
      if (error instanceof ContentReportNotFoundError) {
        throw error;
      }
      throw new ContentReportError(
        `Failed to update content report: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Find report by ID
   * @param id Report ID
   * @returns The report or null if not found
   */
  async findById(id: string): Promise<ContentReport | null> {
    try {
      const result = await this.findOneByField("id", id);
      if (!result) {
        return null;
      }

      return this.mapResultToModel(result);
    } catch (error) {
      this.logger.error(`Error finding content report by ID ${id}`, error);
      throw new ContentReportError(
        `Failed to find content report: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Find reports by content ID and type
   * @param contentId ID of the reported content
   * @param contentType Type of the reported content
   * @param limit Maximum number of reports to return
   * @param offset Number of reports to skip for pagination
   * @returns List of reports
   */
  async findByContent(
    contentId: string,
    contentType: EntityType,
    limit = 20,
    offset = 0,
  ): Promise<ContentReport[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE content_id = $1 AND content_type = $2
        ORDER BY created_at DESC
        LIMIT $3 OFFSET $4
      `;

      const result = await this.executeQuery<ContentReportAttributes>(query, [
        contentId,
        contentType,
        limit,
        offset,
      ]);
      return result.rows.map((row) => this.mapResultToModel(row));
    } catch (error) {
      this.logger.error(
        `Error finding content reports for content ${contentId} of type ${contentType}`,
        error,
      );
      throw new ContentReportError(
        `Failed to find reports for content: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Find reports by reporter ID
   * @param reporterId User ID of the reporter
   * @param limit Maximum number of reports to return
   * @param offset Number of reports to skip for pagination
   * @returns List of reports
   */
  async findByReporterId(
    reporterId: string,
    limit = 20,
    offset = 0,
  ): Promise<ContentReport[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE reporter_id = $1
        ORDER BY created_at DESC
        LIMIT $2 OFFSET $3
      `;

      const result = await this.executeQuery<ContentReportAttributes>(query, [
        reporterId,
        limit,
        offset,
      ]);
      return result.rows.map((row) => this.mapResultToModel(row));
    } catch (error) {
      this.logger.error(
        `Error finding content reports by reporter ID ${reporterId}`,
        error,
      );
      throw new ContentReportError(
        `Failed to find reports by reporter: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Find reports by content owner ID
   * @param contentOwnerId User ID of the content owner
   * @param limit Maximum number of reports to return
   * @param offset Number of reports to skip for pagination
   * @returns List of reports
   */
  async findByContentOwnerId(
    contentOwnerId: string,
    limit = 20,
    offset = 0,
  ): Promise<ContentReport[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE content_owner_id = $1
        ORDER BY created_at DESC
        LIMIT $2 OFFSET $3
      `;

      const result = await this.executeQuery<ContentReportAttributes>(query, [
        contentOwnerId,
        limit,
        offset,
      ]);
      return result.rows.map((row) => this.mapResultToModel(row));
    } catch (error) {
      this.logger.error(
        `Error finding content reports by content owner ID ${contentOwnerId}`,
        error,
      );
      throw new ContentReportError(
        `Failed to find reports by content owner: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Find reports by status
   * @param status Report status to filter by
   * @param limit Maximum number of reports to return
   * @param offset Number of reports to skip for pagination
   * @returns List of reports
   */
  async findByStatus(
    status: ReportStatus,
    limit = 20,
    offset = 0,
  ): Promise<ContentReport[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE status = $1
        ORDER BY created_at DESC
        LIMIT $2 OFFSET $3
      `;

      const result = await this.executeQuery<ContentReportAttributes>(query, [
        status,
        limit,
        offset,
      ]);
      return result.rows.map((row) => this.mapResultToModel(row));
    } catch (error) {
      this.logger.error(
        `Error finding content reports by status ${status}`,
        error,
      );
      throw new ContentReportError(
        `Failed to find reports by status: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Find reports by type
   * @param type Report type to filter by
   * @param limit Maximum number of reports to return
   * @param offset Number of reports to skip for pagination
   * @returns List of reports
   */
  async findByType(
    type: ReportType,
    limit = 20,
    offset = 0,
  ): Promise<ContentReport[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE type = $1
        ORDER BY created_at DESC
        LIMIT $2 OFFSET $3
      `;

      const result = await this.executeQuery<ContentReportAttributes>(query, [
        type,
        limit,
        offset,
      ]);
      return result.rows.map((row) => this.mapResultToModel(row));
    } catch (error) {
      this.logger.error(`Error finding content reports by type ${type}`, error);
      throw new ContentReportError(
        `Failed to find reports by type: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Find high-priority reports (HIGH or CRITICAL severity)
   * @param limit Maximum number of reports to return
   * @param offset Number of reports to skip for pagination
   * @returns List of high-priority reports
   */
  async findHighPriority(limit = 20, offset = 0): Promise<ContentReport[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName} 
        WHERE severity IN ($1, $2) AND status = $3
        ORDER BY 
          CASE 
            WHEN severity = $2 THEN 0 
            ELSE 1 
          END, 
          created_at ASC
        LIMIT $4 OFFSET $5
      `;

      const params = [
        ReportSeverity.HIGH,
        ReportSeverity.CRITICAL,
        ReportStatus.PENDING,
        limit,
        offset,
      ];

      const result = await this.executeQuery<ContentReportAttributes>(
        query,
        params,
      );
      return result.rows.map((row) => this.mapResultToModel(row));
    } catch (error) {
      this.logger.error("Error finding high-priority content reports", error);
      throw new ContentReportError(
        `Failed to find high-priority reports: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Assign a report to a reviewer
   * @param reportId Report ID
   * @param reviewerId User ID of the reviewer
   * @returns The updated report
   */
  async assignToReviewer(
    reportId: string,
    reviewerId: string,
  ): Promise<ContentReport> {
    return this.withTransaction(async () => {
      try {
        const report = await this.findById(reportId);
        if (!report) {
          throw new ContentReportNotFoundError(reportId);
        }

        report.startReview(reviewerId);
        return await this.updateReport(report);
      } catch (error) {
        this.logger.error(
          `Error assigning report ${reportId} to reviewer ${reviewerId}`,
          error,
        );
        if (error instanceof ContentReportNotFoundError) {
          throw error;
        }
        throw new ContentReportError(
          `Failed to assign report to reviewer: ${error instanceof Error ? error.message : String(error)}`,
        );
      }
    });
  }

  /**
   * Update report status to RESOLVED
   * @param reportId Report ID
   * @param resolution Resolution description
   * @returns The updated report
   */
  async resolveReport(
    reportId: string,
    resolution: string,
  ): Promise<ContentReport> {
    return this.withTransaction(async () => {
      try {
        const report = await this.findById(reportId);
        if (!report) {
          throw new ContentReportNotFoundError(reportId);
        }

        report.resolve(resolution);
        return await this.updateReport(report);
      } catch (error) {
        this.logger.error(`Error resolving report ${reportId}`, error);
        if (error instanceof ContentReportNotFoundError) {
          throw error;
        }
        throw new ContentReportError(
          `Failed to resolve report: ${error instanceof Error ? error.message : String(error)}`,
        );
      }
    });
  }

  /**
   * Update report status to DISMISSED
   * @param reportId Report ID
   * @param reason Reason for dismissal
   * @returns The updated report
   */
  async dismissReport(
    reportId: string,
    reason: string,
  ): Promise<ContentReport> {
    return this.withTransaction(async () => {
      try {
        const report = await this.findById(reportId);
        if (!report) {
          throw new ContentReportNotFoundError(reportId);
        }

        report.dismiss(reason);
        return await this.updateReport(report);
      } catch (error) {
        this.logger.error(`Error dismissing report ${reportId}`, error);
        if (error instanceof ContentReportNotFoundError) {
          throw error;
        }
        throw new ContentReportError(
          `Failed to dismiss report: ${error instanceof Error ? error.message : String(error)}`,
        );
      }
    });
  }

  /**
   * Add review notes to a report
   * @param reportId Report ID
   * @param notes Review notes
   * @returns The updated report
   */
  async addReviewNotes(
    reportId: string,
    notes: string,
  ): Promise<ContentReport> {
    try {
      const report = await this.findById(reportId);
      if (!report) {
        throw new ContentReportNotFoundError(reportId);
      }

      report.addReviewNotes(notes);
      return await this.updateReport(report);
    } catch (error) {
      this.logger.error(
        `Error adding review notes to report ${reportId}`,
        error,
      );
      if (error instanceof ContentReportNotFoundError) {
        throw error;
      }
      throw new ContentReportError(
        `Failed to add review notes: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Set report severity
   * @param reportId Report ID
   * @param severity The new severity level
   * @returns The updated report
   */
  async setSeverity(
    reportId: string,
    severity: ReportSeverity,
  ): Promise<ContentReport> {
    try {
      const report = await this.findById(reportId);
      if (!report) {
        throw new ContentReportNotFoundError(reportId);
      }

      report.setSeverity(severity);
      return await this.updateReport(report);
    } catch (error) {
      this.logger.error(`Error setting severity for report ${reportId}`, error);
      if (error instanceof ContentReportNotFoundError) {
        throw error;
      }
      throw new ContentReportError(
        `Failed to set report severity: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Add evidence to a report
   * @param reportId Report ID
   * @param evidenceUrl URL or reference to evidence
   * @returns The updated report
   */
  async addEvidence(
    reportId: string,
    evidenceUrl: string,
  ): Promise<ContentReport> {
    try {
      const report = await this.findById(reportId);
      if (!report) {
        throw new ContentReportNotFoundError(reportId);
      }

      report.addEvidence(evidenceUrl);
      return await this.updateReport(report);
    } catch (error) {
      this.logger.error(`Error adding evidence to report ${reportId}`, error);
      if (error instanceof ContentReportNotFoundError) {
        throw error;
      }
      throw new ContentReportError(
        `Failed to add evidence: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Get report statistics
   * @returns Object containing report statistics
   */
  async getReportStatistics(): Promise<{
    total: number;
    pending: number;
    inReview: number;
    resolved: number;
    dismissed: number;
    byType: Record<ReportType, number>;
    bySeverity: Record<ReportSeverity, number>;
  }> {
    try {
      // Get counts by status
      const statusQuery = `
        SELECT 
          COUNT(*) as total,
          COUNT(CASE WHEN status = $1 THEN 1 END) as pending,
          COUNT(CASE WHEN status = $2 THEN 1 END) as in_review,
          COUNT(CASE WHEN status = $3 THEN 1 END) as resolved,
          COUNT(CASE WHEN status = $4 THEN 1 END) as dismissed
        FROM ${this.tableName}
      `;

      const statusParams = [
        ReportStatus.PENDING,
        ReportStatus.IN_REVIEW,
        ReportStatus.RESOLVED,
        ReportStatus.DISMISSED,
      ];

      interface StatusResult extends Record<string, unknown> {
        total: string;
        pending: string;
        in_review: string;
        resolved: string;
        dismissed: string;
      }

      const statusResult = await this.executeQuery<StatusResult>(
        statusQuery,
        statusParams,
      );

      // Get counts by type
      const typeQuery = `
        SELECT type, COUNT(*) as count
        FROM ${this.tableName}
        GROUP BY type
      `;

      const typeResult = await this.executeQuery<{
        type: ReportType;
        count: string;
      }>(typeQuery);

      // Get counts by severity
      const severityQuery = `
        SELECT severity, COUNT(*) as count
        FROM ${this.tableName}
        GROUP BY severity
      `;

      const severityResult = await this.executeQuery<{
        severity: ReportSeverity;
        count: string;
      }>(severityQuery);

      // Process results
      const byType: Record<ReportType, number> = {} as Record<
        ReportType,
        number
      >;
      Object.values(ReportType).forEach((type) => {
        byType[type] = 0;
      });

      typeResult.rows.forEach((row) => {
        byType[row.type] = parseInt(row.count);
      });

      const bySeverity: Record<ReportSeverity, number> = {} as Record<
        ReportSeverity,
        number
      >;
      Object.values(ReportSeverity).forEach((severity) => {
        bySeverity[severity] = 0;
      });

      severityResult.rows.forEach((row) => {
        bySeverity[row.severity] = parseInt(row.count);
      });

      const stats = statusResult.rows[0];

      return {
        total: parseInt(stats.total) || 0,
        pending: parseInt(stats.pending) || 0,
        inReview: parseInt(stats.in_review) || 0,
        resolved: parseInt(stats.resolved) || 0,
        dismissed: parseInt(stats.dismissed) || 0,
        byType,
        bySeverity,
      };
    } catch (error) {
      this.logger.error("Error getting report statistics", error);
      throw new ContentReportError(
        `Failed to get report statistics: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Map database result to ContentReport model
   * @param row Database result row
   * @returns ContentReport model
   */
  protected mapResultToModel(row: Record<string, unknown>): ContentReport {
    if (!row) return null as unknown as ContentReport;

    let evidence: string[] = [];
    try {
      if (typeof row.evidence === "string") {
        evidence = JSON.parse(row.evidence) as string[];
      } else if (Array.isArray(row.evidence)) {
        evidence = row.evidence.map(String);
      }
    } catch (error) {
      this.logger.error("Error parsing evidence JSON", error);
      evidence = [];
    }

    let metadata: Record<string, unknown> | null = null;
    try {
      if (typeof row.metadata === "string") {
        metadata = JSON.parse(row.metadata) as Record<string, unknown>;
      } else if (row.metadata && typeof row.metadata === "object") {
        metadata = row.metadata as Record<string, unknown>;
      }
    } catch (error) {
      this.logger.error("Error parsing metadata JSON", error);
      metadata = null;
    }

    const report = new ContentReport({
      reporterId: String(row.reporterId || row.reporter_id),
      contentId: String(row.contentId || row.content_id),
      contentType: (row.contentType || row.content_type) as EntityType,
      type: row.type as ReportType,
      contentOwnerId:
        row.contentOwnerId || row.content_owner_id
          ? String(row.contentOwnerId || row.content_owner_id)
          : undefined,
      description: row.description ? String(row.description) : undefined,
      status: row.status as ReportStatus,
      severity: row.severity as ReportSeverity,
      reviewerId:
        row.reviewerId || row.reviewer_id
          ? String(row.reviewerId || row.reviewer_id)
          : undefined,
      resolution: row.resolution ? String(row.resolution) : undefined,
      reviewNotes:
        row.reviewNotes || row.review_notes
          ? String(row.reviewNotes || row.review_notes)
          : undefined,
      evidence,
      metadata,
    });

    report.id = String(row.id);
    report.createdAt = new Date(String(row.createdAt || row.created_at));
    report.updatedAt = new Date(String(row.updatedAt || row.updated_at));

    return report;
  }
}

// Export a singleton instance
export const contentReportRepository = ContentReportRepository.getInstance();



===========================================================
FILE 53: repositories\moderation\ModerationActionRepository.ts
===========================================================

import crypto from "crypto";

import { Logger } from "../../../services/LoggerService";
import {
  ModerationAction,
  ActionType,
  ActionStatus,
} from "../../models/moderation/ModerationAction";
import { EntityType } from "../../models/shared/EntityTypes";
import { BaseRepository } from "../BaseRepository";

export class ModerationActionError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "ModerationActionError";
  }
}

export class ModerationActionNotFoundError extends ModerationActionError {
  constructor(id: string) {
    super(`Moderation action with ID ${id} not found`);
    this.name = "ModerationActionNotFoundError";
  }
}

export class ModerationActionRepository extends BaseRepository<ModerationAction> {
  private static instance: ModerationActionRepository;
  protected logger = new Logger("ModerationActionRepository");
  protected tableName = "moderation_actions";
  protected columns = [
    "id",
    "moderator_id as moderatorId",
    "target_user_id as targetUserId",
    "content_id as contentId",
    "content_type as contentType",
    "report_id as reportId",
    "type",
    "reason",
    "status",
    "expires_at as expiresAt",
    "created_at as createdAt",
    "updated_at as updatedAt",
  ];

  private constructor() {
    super();
  }

  /**
   * Get singleton instance
   */
  public static getInstance(): ModerationActionRepository {
    if (!ModerationActionRepository.instance) {
      ModerationActionRepository.instance = new ModerationActionRepository();
    }
    return ModerationActionRepository.instance;
  }

  /**
   * Create a new moderation action
   * @param action The action to create
   * @returns The created moderation action
   */
  async create(action: ModerationAction): Promise<ModerationAction> {
    try {
      // Validate the action before saving
      if (typeof action.validate === "function") {
        action.validate();
      }

      // Generate ID if not provided
      if (!action.id) {
        action.id = crypto.randomUUID();
      }

      const query = `
        INSERT INTO ${this.tableName} (
          id, moderator_id, target_user_id, content_id, content_type,
          report_id, type, reason, status, expires_at, created_at, updated_at
        ) 
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
        RETURNING ${this.columns.join(", ")}
      `;

      const params = [
        action.id,
        action.moderatorId,
        action.targetUserId,
        action.contentId || null,
        action.contentType || null,
        action.reportId || null,
        action.type,
        action.reason,
        action.status,
        action.expiresAt || null,
        action.createdAt,
        action.updatedAt,
      ];

      const result = await this.executeQuery<Record<string, unknown>>(
        query,
        params,
      );
      return this.mapResultToModel(result.rows[0]);
    } catch (error) {
      this.logger.error("Error creating moderation action", error);
      throw new ModerationActionError(
        `Failed to create moderation action: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Update an existing moderation action
   * @param action The action with updated values
   * @returns The updated action
   * @throws ModerationActionNotFoundError if the action doesn't exist
   */
  async updateAction(action: ModerationAction): Promise<ModerationAction> {
    try {
      // Validate the action before updating
      if (typeof action.validate === "function") {
        action.validate();
      }

      // Check if action exists
      const existingAction = await this.findById(action.id);
      if (!existingAction) {
        throw new ModerationActionNotFoundError(action.id);
      }

      const query = `
        UPDATE ${this.tableName} SET
          moderator_id = $2,
          target_user_id = $3,
          content_id = $4,
          content_type = $5,
          report_id = $6,
          type = $7,
          reason = $8,
          status = $9,
          expires_at = $10,
          updated_at = $11
        WHERE id = $1
        RETURNING ${this.columns.join(", ")}
      `;

      const params = [
        action.id,
        action.moderatorId,
        action.targetUserId,
        action.contentId || null,
        action.contentType || null,
        action.reportId || null,
        action.type,
        action.reason,
        action.status,
        action.expiresAt || null,
        new Date(),
      ];

      const result = await this.executeQuery<Record<string, unknown>>(
        query,
        params,
      );
      return this.mapResultToModel(result.rows[0]);
    } catch (error) {
      this.logger.error("Error updating moderation action", error);
      if (error instanceof ModerationActionNotFoundError) {
        throw error;
      }
      throw new ModerationActionError(
        `Failed to update moderation action: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Find action by ID
   * @param id Action ID
   * @returns The action or null if not found
   */
  async findById(id: string): Promise<ModerationAction | null> {
    try {
      const result = await this.findOneByField("id", id);
      if (!result) {
        return null;
      }

      return this.mapResultToModel(result);
    } catch (error) {
      this.logger.error(`Error finding moderation action by ID ${id}`, error);
      throw new ModerationActionError(
        `Failed to find moderation action: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Find actions by moderator ID
   * @param moderatorId User ID of the moderator
   * @param limit Maximum number of actions to return
   * @param offset Number of actions to skip for pagination
   * @returns List of actions
   */
  async findByModeratorId(
    moderatorId: string,
    limit = 20,
    offset = 0,
  ): Promise<ModerationAction[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE moderator_id = $1
        ORDER BY created_at DESC
        LIMIT $2 OFFSET $3
      `;

      const result = await this.executeQuery<Record<string, unknown>>(query, [
        moderatorId,
        limit,
        offset,
      ]);
      return result.rows.map((row) => this.mapResultToModel(row));
    } catch (error) {
      this.logger.error(
        `Error finding moderation actions by moderator ID ${moderatorId}`,
        error,
      );
      throw new ModerationActionError(
        `Failed to find actions by moderator: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Find actions against a specific user
   * @param userId User ID of the target
   * @param limit Maximum number of actions to return
   * @param offset Number of actions to skip for pagination
   * @returns List of actions
   */
  async findByTargetUserId(
    userId: string,
    limit = 20,
    offset = 0,
  ): Promise<ModerationAction[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE target_user_id = $1
        ORDER BY created_at DESC
        LIMIT $2 OFFSET $3
      `;

      const result = await this.executeQuery<Record<string, unknown>>(query, [
        userId,
        limit,
        offset,
      ]);
      return result.rows.map((row) => this.mapResultToModel(row));
    } catch (error) {
      this.logger.error(
        `Error finding moderation actions by target user ID ${userId}`,
        error,
      );
      throw new ModerationActionError(
        `Failed to find actions by target user: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Find actions by content ID and type
   * @param contentId ID of the content
   * @param contentType Type of the content
   * @param limit Maximum number of actions to return
   * @param offset Number of actions to skip for pagination
   * @returns List of actions
   */
  async findByContent(
    contentId: string,
    contentType: EntityType,
    limit = 20,
    offset = 0,
  ): Promise<ModerationAction[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE content_id = $1 AND content_type = $2
        ORDER BY created_at DESC
        LIMIT $3 OFFSET $4
      `;

      const result = await this.executeQuery<Record<string, unknown>>(query, [
        contentId,
        contentType,
        limit,
        offset,
      ]);
      return result.rows.map((row) => this.mapResultToModel(row));
    } catch (error) {
      this.logger.error(
        `Error finding moderation actions for content ${contentId} of type ${contentType}`,
        error,
      );
      throw new ModerationActionError(
        `Failed to find actions for content: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Find actions by report ID
   * @param reportId ID of the report
   * @param limit Maximum number of actions to return
   * @param offset Number of actions to skip for pagination
   * @returns List of actions
   */
  async findByReportId(
    reportId: string,
    limit = 20,
    offset = 0,
  ): Promise<ModerationAction[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE report_id = $1
        ORDER BY created_at DESC
        LIMIT $2 OFFSET $3
      `;

      const result = await this.executeQuery<Record<string, unknown>>(query, [
        reportId,
        limit,
        offset,
      ]);
      return result.rows.map((row) => this.mapResultToModel(row));
    } catch (error) {
      this.logger.error(
        `Error finding moderation actions by report ID ${reportId}`,
        error,
      );
      throw new ModerationActionError(
        `Failed to find actions by report: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Find actions by type
   * @param type Action type to filter by
   * @param limit Maximum number of actions to return
   * @param offset Number of actions to skip for pagination
   * @returns List of actions
   */
  async findByType(
    type: ActionType,
    limit = 20,
    offset = 0,
  ): Promise<ModerationAction[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE type = $1
        ORDER BY created_at DESC
        LIMIT $2 OFFSET $3
      `;

      const result = await this.executeQuery<Record<string, unknown>>(query, [
        type,
        limit,
        offset,
      ]);
      return result.rows.map((row) => this.mapResultToModel(row));
    } catch (error) {
      this.logger.error(
        `Error finding moderation actions by type ${type}`,
        error,
      );
      throw new ModerationActionError(
        `Failed to find actions by type: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Find actions by status
   * @param status Action status to filter by
   * @param limit Maximum number of actions to return
   * @param offset Number of actions to skip for pagination
   * @returns List of actions
   */
  async findByStatus(
    status: ActionStatus,
    limit = 20,
    offset = 0,
  ): Promise<ModerationAction[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE status = $1
        ORDER BY created_at DESC
        LIMIT $2 OFFSET $3
      `;

      const result = await this.executeQuery<Record<string, unknown>>(query, [
        status,
        limit,
        offset,
      ]);
      return result.rows.map((row) => this.mapResultToModel(row));
    } catch (error) {
      this.logger.error(
        `Error finding moderation actions by status ${status}`,
        error,
      );
      throw new ModerationActionError(
        `Failed to find actions by status: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Find active actions (APPLIED status and not expired)
   * @param limit Maximum number of actions to return
   * @param offset Number of actions to skip for pagination
   * @returns List of active actions
   */
  async findActiveActions(limit = 20, offset = 0): Promise<ModerationAction[]> {
    try {
      const now = new Date();
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE status = $1 AND (expires_at IS NULL OR expires_at > $2)
        ORDER BY created_at DESC
        LIMIT $3 OFFSET $4
      `;

      const result = await this.executeQuery<Record<string, unknown>>(query, [
        ActionStatus.APPLIED,
        now,
        limit,
        offset,
      ]);

      return result.rows.map((row) => this.mapResultToModel(row));
    } catch (error) {
      this.logger.error("Error finding active moderation actions", error);
      throw new ModerationActionError(
        `Failed to find active actions: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Find expired temporary actions that still have APPLIED status
   * @returns List of expired actions
   */
  async findExpiredActions(): Promise<ModerationAction[]> {
    try {
      const now = new Date();
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE status = $1 AND expires_at IS NOT NULL AND expires_at <= $2
        ORDER BY expires_at ASC
      `;

      const result = await this.executeQuery<Record<string, unknown>>(query, [
        ActionStatus.APPLIED,
        now,
      ]);

      return result.rows.map((row) => this.mapResultToModel(row));
    } catch (error) {
      this.logger.error("Error finding expired moderation actions", error);
      throw new ModerationActionError(
        `Failed to find expired actions: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Apply a moderation action
   * @param actionId ID of the action to apply
   * @returns The updated action
   */
  async applyAction(actionId: string): Promise<ModerationAction> {
    return this.withTransaction(async () => {
      try {
        const action = await this.findById(actionId);
        if (!action) {
          throw new ModerationActionNotFoundError(actionId);
        }

        action.apply();
        return await this.updateAction(action);
      } catch (error) {
        this.logger.error(
          `Error applying moderation action ${actionId}`,
          error,
        );
        if (error instanceof ModerationActionNotFoundError) {
          throw error;
        }
        throw new ModerationActionError(
          `Failed to apply action: ${error instanceof Error ? error.message : String(error)}`,
        );
      }
    });
  }

  /**
   * Reverse a moderation action
   * @param actionId ID of the action to reverse
   * @returns The updated action
   */
  async reverseAction(actionId: string): Promise<ModerationAction> {
    return this.withTransaction(async () => {
      try {
        const action = await this.findById(actionId);
        if (!action) {
          throw new ModerationActionNotFoundError(actionId);
        }

        action.reverse();
        return await this.updateAction(action);
      } catch (error) {
        this.logger.error(
          `Error reversing moderation action ${actionId}`,
          error,
        );
        if (error instanceof ModerationActionNotFoundError) {
          throw error;
        }
        throw new ModerationActionError(
          `Failed to reverse action: ${error instanceof Error ? error.message : String(error)}`,
        );
      }
    });
  }

  /**
   * Mark a temporary action as expired
   * @param actionId ID of the action to expire
   * @returns The updated action
   */
  async expireAction(actionId: string): Promise<ModerationAction> {
    return this.withTransaction(async () => {
      try {
        const action = await this.findById(actionId);
        if (!action) {
          throw new ModerationActionNotFoundError(actionId);
        }

        action.expire();
        return await this.updateAction(action);
      } catch (error) {
        this.logger.error(
          `Error expiring moderation action ${actionId}`,
          error,
        );
        if (error instanceof ModerationActionNotFoundError) {
          throw error;
        }
        throw new ModerationActionError(
          `Failed to expire action: ${error instanceof Error ? error.message : String(error)}`,
        );
      }
    });
  }

  /**
   * Update a temporary action's expiration date
   * @param actionId ID of the action
   * @param daysToAdd Number of days to add to current expiration
   * @returns The updated action
   */
  async extendExpiration(
    actionId: string,
    daysToAdd: number,
  ): Promise<ModerationAction> {
    return this.withTransaction(async () => {
      try {
        const action = await this.findById(actionId);
        if (!action) {
          throw new ModerationActionNotFoundError(actionId);
        }

        if (!action.expiresAt) {
          throw new ModerationActionError(
            "Cannot extend expiration for a permanent action",
          );
        }

        const newExpirationDate = new Date(action.expiresAt);
        newExpirationDate.setDate(newExpirationDate.getDate() + daysToAdd);
        action.expiresAt = newExpirationDate;

        return await this.updateAction(action);
      } catch (error) {
        this.logger.error(
          `Error extending expiration for action ${actionId}`,
          error,
        );
        if (
          error instanceof ModerationActionNotFoundError ||
          error instanceof ModerationActionError
        ) {
          throw error;
        }
        throw new ModerationActionError(
          `Failed to extend action expiration: ${error instanceof Error ? error.message : String(error)}`,
        );
      }
    });
  }

  /**
   * Delete a moderation action
   * @param actionId ID of the action to delete
   * @returns True if successful
   */
  async delete(actionId: string): Promise<boolean> {
    try {
      const result = await super.delete(actionId);
      if (!result) {
        throw new ModerationActionNotFoundError(actionId);
      }
      return true;
    } catch (error) {
      this.logger.error(`Error deleting moderation action ${actionId}`, error);
      if (error instanceof ModerationActionNotFoundError) {
        throw error;
      }
      throw new ModerationActionError(
        `Failed to delete action: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Get count of actions by type
   * @returns Object with count by action type
   */
  async getActionCountsByType(): Promise<Record<ActionType, number>> {
    try {
      const query = `
        SELECT type, COUNT(*) as count
        FROM ${this.tableName}
        GROUP BY type
      `;

      const result = await this.executeQuery<{
        type: ActionType;
        count: string;
      }>(query);

      const counts: Record<ActionType, number> = {} as Record<
        ActionType,
        number
      >;

      // Initialize all types with 0
      Object.values(ActionType).forEach((type) => {
        counts[type] = 0;
      });

      // Update counts from query results
      result.rows.forEach((row) => {
        counts[row.type] = parseInt(row.count);
      });

      return counts;
    } catch (error) {
      this.logger.error("Error getting action counts by type", error);
      throw new ModerationActionError(
        `Failed to get action counts: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Map database result to ModerationAction model
   * @param row Database result row
   * @returns ModerationAction model
   */
  protected mapResultToModel(row: Record<string, unknown>): ModerationAction {
    if (!row) return null as unknown as ModerationAction;

    const action = new ModerationAction({
      moderatorId: String(row.moderatorId || row.moderator_id),
      targetUserId: String(row.targetUserId || row.target_user_id),
      type: row.type as ActionType,
      reason: String(row.reason || ""),
    });

    action.id = String(row.id || "");
    action.contentId =
      row.contentId || row.content_id
        ? String(row.contentId || row.content_id)
        : undefined;
    action.contentType =
      row.contentType || row.content_type
        ? (String(row.contentType || row.content_type) as EntityType)
        : undefined;
    action.reportId =
      row.reportId || row.report_id
        ? String(row.reportId || row.report_id)
        : undefined;
    action.status = row.status as ActionStatus;
    action.expiresAt =
      row.expiresAt || row.expires_at
        ? new Date(String(row.expiresAt || row.expires_at))
        : undefined;
    action.createdAt = new Date(String(row.createdAt || row.created_at));
    action.updatedAt = new Date(String(row.updatedAt || row.updated_at));

    return action;
  }
}

// Export a singleton instance
export const moderationActionRepository =
  ModerationActionRepository.getInstance();



===========================================================
FILE 54: repositories\notification\NotificationRepository.ts
===========================================================

import { Logger } from "../../../services/LoggerService";
import { DatabaseConnectionManager } from "../../config";
import { BaseModelInterface } from "../../models/BaseModel";
import { EntityType } from "../../models/shared/EntityTypes";
import {
  Notification,
  NotificationAttributes,
  NotificationType,
} from "../../models/social/Notification";
import { BaseRepository } from "../BaseRepository";

export interface NotificationWithIndex
  extends Notification,
    BaseModelInterface {
  [key: string]: unknown;
}

export class NotificationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "NotificationError";
  }
}

export class NotificationNotFoundError extends NotificationError {
  constructor(id: string) {
    super(`Notification with ID ${id} not found`);
    this.name = "NotificationNotFoundError";
  }
}

export class NotificationRepository extends BaseRepository<NotificationWithIndex> {
  protected logger = new Logger("NotificationRepository");
  protected tableName = "notifications";
  protected columns = [
    "id",
    "type",
    "user_id as userId",
    "actor_id as actorId",
    "entity_id as entityId",
    "entity_type as entityType",
    "content",
    "read",
    "delivered",
    "created_at as createdAt",
    "updated_at as updatedAt",
  ];

  /**
   * Create a new notification
   */
  async create(
    data: Omit<
      NotificationAttributes,
      "id" | "createdAt" | "updatedAt" | "read" | "delivered"
    >,
  ): Promise<Notification> {
    try {
      const notification = new Notification({
        ...data,
        id: "",
        read: false,
        delivered: false,
        createdAt: new Date(),
        updatedAt: new Date(),
      });

      notification.validate();

      const query = `
				INSERT INTO ${this.tableName} (
					type, user_id, actor_id, entity_id, entity_type,
					content, read, delivered, created_at, updated_at
				)
				VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
				RETURNING ${this.columns.join(", ")}
			`;

      const params = [
        notification.type,
        notification.userId,
        notification.actorId,
        notification.entityId,
        notification.entityType,
        notification.content,
        notification.read,
        notification.delivered,
        notification.createdAt,
        notification.updatedAt,
      ];

      const { rows } = await DatabaseConnectionManager.getPool().query(
        query,
        params,
      );
      return this.mapResultToModel(rows[0]);
    } catch (error) {
      this.logger.error("Error creating notification", error);
      throw new NotificationError(
        `Failed to create notification: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Find notifications for a user
   */
  async findByUserId(
    userId: string,
    limit = 20,
    offset = 0,
    unreadOnly = false,
  ): Promise<Notification[]> {
    try {
      let query = `
				SELECT ${this.columns.join(", ")}
				FROM ${this.tableName}
				WHERE user_id = $1
			`;

      const params: unknown[] = [userId];

      if (unreadOnly) {
        query += " AND read = false";
      }

      query += " ORDER BY created_at DESC LIMIT $2 OFFSET $3";
      params.push(limit, offset);

      const { rows } = await DatabaseConnectionManager.getPool().query(
        query,
        params,
      );
      return rows.map((row) => this.mapResultToModel(row));
    } catch (error) {
      this.logger.error("Error finding notifications", error);
      throw new NotificationError(
        `Failed to find notifications: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Mark notification as read
   */
  async markAsRead(id: string, userId: string): Promise<boolean> {
    try {
      const query = `
				UPDATE ${this.tableName}
				SET read = true, updated_at = NOW()
				WHERE id = $1 AND user_id = $2
				RETURNING ${this.columns.join(", ")}
			`;

      const { rows } = await DatabaseConnectionManager.getPool().query(query, [
        id,
        userId,
      ]);
      return rows.length > 0;
    } catch (error) {
      this.logger.error("Error marking notification as read", error);
      throw new NotificationError(
        `Failed to mark notification as read: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Mark all notifications as read for a user
   */
  async markAllAsRead(userId: string): Promise<number> {
    try {
      const query = `
				UPDATE ${this.tableName}
				SET read = true, updated_at = NOW()
				WHERE user_id = $1 AND read = false
				RETURNING id
			`;

      const { rowCount } = await DatabaseConnectionManager.getPool().query(
        query,
        [userId],
      );
      return rowCount ?? 0;
    } catch (error) {
      this.logger.error("Error marking all notifications as read", error);
      throw new NotificationError(
        `Failed to mark all notifications as read: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Mark notification as delivered
   */
  async markAsDelivered(id: string): Promise<boolean> {
    try {
      const query = `
				UPDATE ${this.tableName}
				SET delivered = true, updated_at = NOW()
				WHERE id = $1
				RETURNING ${this.columns.join(", ")}
			`;

      const { rows } = await DatabaseConnectionManager.getPool().query(query, [
        id,
      ]);
      return rows.length > 0;
    } catch (error) {
      this.logger.error("Error marking notification as delivered", error);
      throw new NotificationError(
        `Failed to mark notification as delivered: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Delete notifications for a user
   */
  async deleteByUserId(userId: string): Promise<number> {
    try {
      const query = `
				DELETE FROM ${this.tableName}
				WHERE user_id = $1
				RETURNING id
			`;

      const { rowCount } = await DatabaseConnectionManager.getPool().query(
        query,
        [userId],
      );
      return rowCount ?? 0;
    } catch (error) {
      this.logger.error("Error deleting notifications", error);
      throw new NotificationError(
        `Failed to delete notifications: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Get unread count for a user
   */
  async getUnreadCount(userId: string): Promise<number> {
    try {
      const query = `
				SELECT COUNT(*) as count
				FROM ${this.tableName}
				WHERE user_id = $1 AND read = false
			`;

      const { rows } = await DatabaseConnectionManager.getPool().query(query, [
        userId,
      ]);
      const result = rows[0] as { count: string };
      return parseInt(result.count, 10);
    } catch (error) {
      this.logger.error("Error getting unread count", error);
      throw new NotificationError(
        `Failed to get unread count: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Map database result to Notification model
   */
  protected mapResultToModel(row: Record<string, unknown>): Notification {
    if (!row) return null as unknown as Notification;

    return new Notification({
      id: String(row.id || ""),
      type: String(row.type) as NotificationType,
      userId: String(row.userId || row.user_id || ""),
      actorId:
        row.actorId || row.actor_id
          ? String(row.actorId || row.actor_id)
          : null,
      entityId:
        row.entityId || row.entity_id
          ? String(row.entityId || row.entity_id)
          : null,
      entityType:
        row.entityType || row.entity_type
          ? (String(row.entityType || row.entity_type) as EntityType)
          : null,
      content: row.content ? String(row.content) : null,
      read: Boolean(row.read || false),
      delivered: Boolean(row.delivered || false),
      createdAt: new Date(String(row.createdAt || row.created_at)),
      updatedAt: new Date(String(row.updatedAt || row.updated_at)),
    });
  }
}

// Export a singleton instance
export const notificationRepository = new NotificationRepository();



===========================================================
FILE 55: repositories\social\BookmarkRepository.ts
===========================================================

import { Logger } from "../../../services/LoggerService";
import { DatabaseConnectionManager } from "../../config";
import { BaseModelInterface } from "../../models/BaseModel";
import { EntityType } from "../../models/shared/EntityTypes";
import { Bookmark, BookmarkAttributes } from "../../models/social/Bookmark";
import { BaseRepository } from "../BaseRepository";

export interface BookmarkWithIndex extends Bookmark, BaseModelInterface {
  [key: string]: unknown;
}

export class BookmarkError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "BookmarkError";
  }
}

export class BookmarkNotFoundError extends BookmarkError {
  constructor(id: string) {
    super(`Bookmark with ID ${id} not found`);
    this.name = "BookmarkNotFoundError";
  }
}

export class BookmarkRepository extends BaseRepository<BookmarkWithIndex> {
  protected logger = new Logger("BookmarkRepository");
  protected tableName = "bookmarks";
  protected columns = [
    "id",
    "user_id as userId",
    "entity_id as entityId",
    "entity_type as entityType",
    "collection_id as collectionId",
    "notes",
    "created_at as createdAt",
    "updated_at as updatedAt",
  ];

  /**
   * Create a new bookmark
   */
  async create(
    data: Omit<BookmarkAttributes, "id" | "createdAt" | "updatedAt">,
  ): Promise<Bookmark> {
    try {
      const bookmark = new Bookmark({
        ...data,
        id: "",
        createdAt: new Date(),
        updatedAt: new Date(),
      });

      bookmark.validate();

      const query = `
				INSERT INTO ${this.tableName} (
					user_id, entity_id, entity_type, collection_id, notes,
					created_at, updated_at
				)
				VALUES ($1, $2, $3, $4, $5, $6, $7)
				RETURNING ${this.columns.join(", ")}
			`;

      const params = [
        bookmark.userId,
        bookmark.entityId,
        bookmark.entityType,
        bookmark.collectionId,
        bookmark.notes,
        bookmark.createdAt,
        bookmark.updatedAt,
      ];

      const { rows } = await DatabaseConnectionManager.getPool().query(
        query,
        params,
      );
      return this.mapResultToModel(rows[0]);
    } catch (error) {
      this.logger.error("Error creating bookmark", error);
      throw new BookmarkError(
        `Failed to create bookmark: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Find bookmarks for a user
   */
  async findByUserId(
    userId: string,
    limit = 20,
    offset = 0,
    collectionId?: string,
  ): Promise<Bookmark[]> {
    try {
      let query = `
				SELECT ${this.columns.join(", ")}
				FROM ${this.tableName}
				WHERE user_id = $1
			`;

      const params: unknown[] = [userId];

      if (collectionId) {
        query += " AND collection_id = $2";
        params.push(collectionId);
      }

      query +=
        " ORDER BY created_at DESC LIMIT $" +
        (params.length + 1) +
        " OFFSET $" +
        (params.length + 2);
      params.push(limit, offset);

      const { rows } = await DatabaseConnectionManager.getPool().query(
        query,
        params,
      );
      return rows.map((row) => this.mapResultToModel(row));
    } catch (error) {
      this.logger.error("Error finding bookmarks", error);
      throw new BookmarkError(
        `Failed to find bookmarks: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Find bookmark by ID
   */
  async findById(id: string): Promise<Bookmark | null> {
    try {
      const query = `
				SELECT ${this.columns.join(", ")}
				FROM ${this.tableName}
				WHERE id = $1
			`;

      const { rows } = await DatabaseConnectionManager.getPool().query(query, [
        id,
      ]);
      if (rows.length === 0) return null;

      return this.mapResultToModel(rows[0]);
    } catch (error) {
      this.logger.error("Error finding bookmark", error);
      throw new BookmarkError(
        `Failed to find bookmark: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Find bookmark by entity
   */
  async findByEntity(
    userId: string,
    entityId: string,
    entityType: EntityType,
  ): Promise<Bookmark | null> {
    try {
      const query = `
				SELECT ${this.columns.join(", ")}
				FROM ${this.tableName}
				WHERE user_id = $1 AND entity_id = $2 AND entity_type = $3
			`;

      const { rows } = await DatabaseConnectionManager.getPool().query(query, [
        userId,
        entityId,
        entityType,
      ]);
      if (rows.length === 0) return null;

      return this.mapResultToModel(rows[0]);
    } catch (error) {
      this.logger.error("Error finding bookmark by entity", error);
      throw new BookmarkError(
        `Failed to find bookmark by entity: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Update bookmark notes
   */
  async updateNotes(
    id: string,
    userId: string,
    notes: string | null,
  ): Promise<Bookmark> {
    try {
      const bookmark = await this.findById(id);
      if (!bookmark) {
        throw new BookmarkNotFoundError(id);
      }

      if (!bookmark.belongsToUser(userId)) {
        throw new BookmarkError("User does not own this bookmark");
      }

      bookmark.updateNotes(notes);
      bookmark.validate();

      const query = `
				UPDATE ${this.tableName}
				SET notes = $1, updated_at = NOW()
				WHERE id = $2 AND user_id = $3
				RETURNING ${this.columns.join(", ")}
			`;

      const { rows } = await DatabaseConnectionManager.getPool().query(query, [
        notes,
        id,
        userId,
      ]);
      if (rows.length === 0) {
        throw new BookmarkNotFoundError(id);
      }

      return this.mapResultToModel(rows[0]);
    } catch (error) {
      this.logger.error("Error updating bookmark notes", error);
      throw new BookmarkError(
        `Failed to update bookmark notes: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Move bookmark to collection
   */
  async moveToCollection(
    id: string,
    userId: string,
    collectionId: string | null,
  ): Promise<Bookmark> {
    try {
      const bookmark = await this.findById(id);
      if (!bookmark) {
        throw new BookmarkNotFoundError(id);
      }

      if (!bookmark.belongsToUser(userId)) {
        throw new BookmarkError("User does not own this bookmark");
      }

      bookmark.moveToCollection(collectionId);
      bookmark.validate();

      const query = `
				UPDATE ${this.tableName}
				SET collection_id = $1, updated_at = NOW()
				WHERE id = $2 AND user_id = $3
				RETURNING ${this.columns.join(", ")}
			`;

      const { rows } = await DatabaseConnectionManager.getPool().query(query, [
        collectionId,
        id,
        userId,
      ]);
      if (rows.length === 0) {
        throw new BookmarkNotFoundError(id);
      }

      return this.mapResultToModel(rows[0]);
    } catch (error) {
      this.logger.error("Error moving bookmark to collection", error);
      throw new BookmarkError(
        `Failed to move bookmark to collection: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Delete bookmark
   */
  async deleteBookmark(id: string, userId: string): Promise<boolean> {
    try {
      const bookmark = await this.findById(id);
      if (!bookmark) {
        return false;
      }

      if (!bookmark.belongsToUser(userId)) {
        throw new BookmarkError("User does not own this bookmark");
      }

      const query = `
				DELETE FROM ${this.tableName}
				WHERE id = $1 AND user_id = $2
				RETURNING id
			`;

      const { rowCount } = await DatabaseConnectionManager.getPool().query(
        query,
        [id, userId],
      );
      return (rowCount ?? 0) > 0;
    } catch (error) {
      this.logger.error("Error deleting bookmark", error);
      throw new BookmarkError(
        `Failed to delete bookmark: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Map database result to Bookmark model
   */
  protected mapResultToModel(row: Record<string, unknown>): Bookmark {
    if (!row) return null as unknown as Bookmark;

    return new Bookmark({
      id: String(row.id || ""),
      userId: String(row.userId || row.user_id || ""),
      entityId: String(row.entityId || row.entity_id || ""),
      entityType: String(row.entityType || row.entity_type) as EntityType,
      collectionId:
        row.collectionId || row.collection_id
          ? String(row.collectionId || row.collection_id)
          : null,
      notes: row.notes ? String(row.notes) : null,
      createdAt: new Date(String(row.createdAt || row.created_at)),
      updatedAt: new Date(String(row.updatedAt || row.updated_at)),
    });
  }
}

// Export a singleton instance
export const bookmarkRepository = new BookmarkRepository();



===========================================================
FILE 56: repositories\social\CommentLikeRepository.ts
===========================================================

import { Logger } from "../../../services/LoggerService";
import {
  CommentLike,
  CommentLikeAttributes,
} from "../../models/social/CommentLike";
import { BaseRepository } from "../BaseRepository";

// Custom error class for comment like operations
export class CommentLikeError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "CommentLikeError";
  }
}

export class CommentLikeNotFoundError extends CommentLikeError {
  constructor(id: string) {
    super(`Comment like with ID ${id} not found`);
    this.name = "CommentLikeNotFoundError";
  }
}

export class CommentLikeValidationError extends CommentLikeError {
  constructor(message: string) {
    super(`Validation error: ${message}`);
    this.name = "CommentLikeValidationError";
  }
}

export class CommentLikeRepository extends BaseRepository<CommentLikeAttributes> {
  private static instance: CommentLikeRepository;
  protected logger = new Logger("CommentLikeRepository");
  protected tableName = "comment_likes";
  protected columns = [
    "id",
    "user_id as userId",
    "comment_id as commentId",
    "created_at as createdAt",
    "updated_at as updatedAt",
  ];

  private constructor() {
    super();
  }

  public static getInstance(): CommentLikeRepository {
    if (!CommentLikeRepository.instance) {
      CommentLikeRepository.instance = new CommentLikeRepository();
    }
    return CommentLikeRepository.instance;
  }

  /**
   * Find a like by user ID and comment ID
   */
  async findByUserAndComment(
    userId: string,
    commentId: string,
  ): Promise<CommentLike | null> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE user_id = $1 AND comment_id = $2
      `;

      const result = await this.executeQuery(query, [userId, commentId]);
      if (result.rows.length === 0) return null;

      return this.mapResultToModel(result.rows[0]);
    } catch (error) {
      this.logger.error(
        "Error finding comment like by user and comment",
        error,
      );
      throw new CommentLikeError(
        `Failed to find comment like: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Create a new comment like
   */
  async create(
    data: Omit<CommentLikeAttributes, "id" | "createdAt" | "updatedAt"> & {
      userId: string;
      commentId: string;
    },
  ): Promise<CommentLike> {
    return this.withTransaction(async (client) => {
      try {
        // Create a new CommentLike instance for validation
        const commentLike = new CommentLike({
          ...data,
          id: "",
          createdAt: new Date(),
          updatedAt: new Date(),
        });

        // Validate comment like
        const validationErrors = commentLike.validate();
        if (validationErrors.length > 0) {
          throw new CommentLikeValidationError(validationErrors.join(", "));
        }

        const query = `
          INSERT INTO ${this.tableName} (user_id, comment_id)
          VALUES ($1, $2)
          RETURNING ${this.columns.join(", ")}
        `;

        const { rows } = await client.query(query, [
          data.userId,
          data.commentId,
        ]);

        // After creating the like, increment the comment's like count
        await client.query(
          `
          UPDATE comments
          SET like_count = like_count + 1, updated_at = NOW()
          WHERE id = $1
        `,
          [data.commentId],
        );

        return this.mapResultToModel(rows[0]);
      } catch (error) {
        this.logger.error("Error creating comment like", error);
        throw new CommentLikeError(
          `Failed to create comment like: ${error instanceof Error ? error.message : String(error)}`,
        );
      }
    });
  }

  /**
   * Delete a comment like by user and comment
   */
  async unlike(userId: string, commentId: string): Promise<boolean> {
    try {
      const like = await this.findByUserAndComment(userId, commentId);
      if (!like) return false;

      return this.delete(like.id);
    } catch (error) {
      this.logger.error("Error unliking comment", error);
      throw new CommentLikeError(
        `Failed to unlike comment: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Get all likes for a comment
   */
  async findByCommentId(commentId: string): Promise<CommentLike[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE comment_id = $1
      `;

      const result = await this.executeQuery(query, [commentId]);
      return result.rows.map((row) => this.mapResultToModel(row));
    } catch (error) {
      this.logger.error("Error finding likes by comment ID", error);
      throw new CommentLikeError(
        `Failed to find likes by comment ID: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Get all likes by a user
   */
  async findByUserId(userId: string): Promise<CommentLike[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE user_id = $1
      `;

      const result = await this.executeQuery(query, [userId]);
      return result.rows.map((row) => this.mapResultToModel(row));
    } catch (error) {
      this.logger.error("Error finding likes by user ID", error);
      throw new CommentLikeError(
        `Failed to find likes by user ID: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Check if a user has liked a comment
   */
  async hasLiked(userId: string, commentId: string): Promise<boolean> {
    try {
      const like = await this.findByUserAndComment(userId, commentId);
      return like !== null;
    } catch (error) {
      this.logger.error("Error checking if user has liked comment", error);
      throw new CommentLikeError(
        `Failed to check if user has liked comment: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Get all likes for a comment with pagination
   */
  async getLikesForComment(
    commentId: string,
    limit = 20,
    offset = 0,
  ): Promise<CommentLike[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE comment_id = $1
        ORDER BY created_at DESC
        LIMIT $2 OFFSET $3
      `;

      const result = await this.executeQuery(query, [commentId, limit, offset]);
      return result.rows.map((row) => this.mapResultToModel(row));
    } catch (error) {
      this.logger.error("Error getting likes for comment", error);
      throw new CommentLikeError(
        `Failed to get likes for comment: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Count likes for a comment
   */
  async countLikesForComment(commentId: string): Promise<number> {
    try {
      const query = `
        SELECT COUNT(*) as count
        FROM ${this.tableName}
        WHERE comment_id = $1
      `;

      const result = await this.executeQuery<{ count: string }>(query, [
        commentId,
      ]);
      return parseInt(result.rows[0]?.count || "0", 10);
    } catch (error) {
      this.logger.error("Error counting likes for comment", error);
      throw new CommentLikeError(
        `Failed to count likes for comment: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Get all comment likes by a user with pagination
   */
  async getLikesByUser(
    userId: string,
    limit = 20,
    offset = 0,
  ): Promise<CommentLike[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE user_id = $1
        ORDER BY created_at DESC
        LIMIT $2 OFFSET $3
      `;

      const result = await this.executeQuery(query, [userId, limit, offset]);
      return result.rows.map((row) => this.mapResultToModel(row));
    } catch (error) {
      this.logger.error("Error getting likes by user", error);
      throw new CommentLikeError(
        `Failed to get likes by user: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Count comment likes by a user
   */
  async countLikesByUser(userId: string): Promise<number> {
    try {
      const query = `
        SELECT COUNT(*) as count
        FROM ${this.tableName}
        WHERE user_id = $1
      `;

      const result = await this.executeQuery<{ count: string }>(query, [
        userId,
      ]);
      return parseInt(result.rows[0]?.count || "0", 10);
    } catch (error) {
      this.logger.error("Error counting likes by user", error);
      throw new CommentLikeError(
        `Failed to count likes by user: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Delete a comment like and decrement the like count
   */
  async delete(id: string): Promise<boolean> {
    return this.withTransaction(async (client) => {
      try {
        const like = await this.findById(id);
        if (!like) return false;

        const query = `
          DELETE FROM ${this.tableName}
          WHERE id = $1
          RETURNING id
        `;

        const { rowCount } = await client.query(query, [id]);

        if ((rowCount ?? 0) > 0) {
          // Update comment like count
          const decrementQuery = `
            UPDATE comments
            SET like_count = GREATEST(0, like_count - 1), updated_at = NOW()
            WHERE id = $1
          `;

          await client.query(decrementQuery, [like.commentId]);
        }

        return (rowCount ?? 0) > 0;
      } catch (error) {
        this.logger.error("Error deleting comment like", error);
        throw new CommentLikeError(
          `Failed to delete comment like: ${error instanceof Error ? error.message : String(error)}`,
        );
      }
    });
  }

  /**
   * Toggle like status for a comment
   */
  async toggleLike(
    userId: string,
    commentId: string,
  ): Promise<{ liked: boolean; like?: CommentLike }> {
    try {
      const existingLike = await this.findByUserAndComment(userId, commentId);

      if (existingLike) {
        // Unlike if already liked
        await this.delete(existingLike.id);
        return { liked: false };
      } else {
        // Like if not already liked
        const like = await this.create({ userId, commentId });
        return { liked: true, like };
      }
    } catch (error) {
      this.logger.error("Error toggling like status", error);
      throw new CommentLikeError(
        `Failed to toggle like status: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Find a comment like by ID
   */
  async findById(id: string): Promise<CommentLike | null> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE id = $1
      `;

      const result = await this.executeQuery(query, [id]);
      if (result.rows.length === 0) return null;

      return this.mapResultToModel(result.rows[0]);
    } catch (error) {
      this.logger.error("Error finding comment like by ID", error);
      throw new CommentLikeError(
        `Failed to find comment like by ID: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Helper method to map DB result to CommentLike model
   */
  protected mapResultToModel(row: Record<string, unknown>): CommentLike {
    if (!row) return null as unknown as CommentLike;
    return new CommentLike({
      id: String(row.id || ""),
      userId: String(row.userId || row.user_id || ""),
      commentId: String(row.commentId || row.comment_id || ""),
      createdAt: new Date(String(row.createdAt || row.created_at)),
      updatedAt: new Date(String(row.updatedAt || row.updated_at)),
    });
  }
}

// Export singleton instance
export const commentLikeRepository = CommentLikeRepository.getInstance();



===========================================================
FILE 57: repositories\social\CommentRepository.ts
===========================================================

import { Logger } from "../../../services/LoggerService";
import { BaseModelInterface } from "../../models/BaseModel";
import { ContentStatus } from "../../models/shared/EntityTypes";
import {
  Comment,
  CommentAttributes,
  CommentTargetType,
} from "../../models/social/Comment";
import { BaseRepository } from "../BaseRepository";

export interface CommentWithIndex extends Comment, BaseModelInterface {
  [key: string]: unknown;
}

// Custom error class for comment operations
export class CommentError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "CommentError";
  }
}

export class CommentNotFoundError extends CommentError {
  constructor(id: string) {
    super(`Comment with ID ${id} not found`);
    this.name = "CommentNotFoundError";
  }
}

export class CommentValidationError extends CommentError {
  constructor(message: string) {
    super(`Validation error: ${message}`);
    this.name = "CommentValidationError";
  }
}

export class CommentRepository extends BaseRepository<CommentWithIndex> {
  private static instance: CommentRepository;
  protected logger = new Logger("CommentRepository");
  protected tableName = "comments";
  protected columns = [
    "id",
    "user_id as userId",
    "target_id as targetId",
    "target_type as targetType",
    "parent_id as parentId",
    "content",
    "status",
    "like_count as likeCount",
    "reply_count as replyCount",
    "created_at as createdAt",
    "updated_at as updatedAt",
  ];

  private constructor() {
    super();
  }

  public static getInstance(): CommentRepository {
    if (!CommentRepository.instance) {
      CommentRepository.instance = new CommentRepository();
    }
    return CommentRepository.instance;
  }

  /**
   * Find comments for a specific target
   */
  async findByTarget(
    targetId: string,
    targetType: CommentTargetType,
    parentId: string | null = null,
    limit = 20,
    offset = 0,
    sortBy = "createdAt",
    sortOrder = "DESC",
  ): Promise<Comment[]> {
    try {
      // Validate and sanitize sort column to prevent SQL injection
      const validSortColumns = ["createdAt", "updatedAt", "likeCount"];
      const sortColumn = validSortColumns.includes(sortBy)
        ? this.snakeCase(sortBy)
        : "created_at";

      // Validate sort order
      const order = sortOrder === "ASC" ? "ASC" : "DESC";

      let query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE target_id = $1 AND target_type = $2
      `;

      const params = [targetId, targetType];

      if (parentId === null) {
        query += " AND parent_id IS NULL";
      } else {
        query += ` AND parent_id = $${params.length + 1}`;
        params.push(parentId);
      }

      query += ` ORDER BY ${sortColumn} ${order}`;
      query += ` LIMIT $${params.length + 1} OFFSET $${params.length + 2}`;
      params.push(String(limit), String(offset));

      const result = await this.executeQuery(query, params);
      return result.rows.map((row) => this.mapResultToModel(row));
    } catch (error) {
      this.logger.error("Error finding comments by target", error);
      throw new CommentError(
        `Failed to find comments by target: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Find replies to a comment
   */
  async findReplies(
    commentId: string,
    limit = 20,
    offset = 0,
    sortBy = "createdAt",
    sortOrder = "DESC",
  ): Promise<Comment[]> {
    try {
      // Validate and sanitize sort column to prevent SQL injection
      const validSortColumns = ["createdAt", "updatedAt", "likeCount"];
      const sortColumn = validSortColumns.includes(sortBy)
        ? this.snakeCase(sortBy)
        : "created_at";

      // Validate sort order
      const order = sortOrder === "ASC" ? "ASC" : "DESC";

      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE parent_id = $1
        ORDER BY ${sortColumn} ${order}
        LIMIT $2 OFFSET $3
      `;

      const result = await this.executeQuery(query, [commentId, limit, offset]);
      return result.rows.map((row) => this.mapResultToModel(row));
    } catch (error) {
      this.logger.error("Error finding replies", error);
      throw new CommentError(
        `Failed to find replies: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Count comments for a target
   */
  async countByTarget(
    targetId: string,
    targetType: CommentTargetType,
    parentId: string | null = null,
  ): Promise<number> {
    try {
      let query = `
        SELECT COUNT(*) as count
        FROM ${this.tableName}
        WHERE target_id = $1 AND target_type = $2
      `;

      const params = [targetId, targetType];

      if (parentId === null) {
        query += " AND parent_id IS NULL";
      } else {
        query += ` AND parent_id = $${params.length + 1}`;
        params.push(parentId);
      }

      const result = await this.executeQuery<{ count: string }>(query, params);
      return parseInt(result.rows[0]?.count || "0", 10);
    } catch (error) {
      this.logger.error("Error counting comments by target", error);
      throw new CommentError(
        `Failed to count comments by target: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Find comments by user
   */
  async findByUserId(
    userId: string,
    limit = 20,
    offset = 0,
    targetType?: CommentTargetType,
  ): Promise<Comment[]> {
    try {
      let query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE user_id = $1
      `;

      const params = [userId];

      if (targetType) {
        query += ` AND target_type = $${params.length + 1}`;
        params.push(targetType);
      }

      query += " ORDER BY created_at DESC";
      query += ` LIMIT $${params.length + 1} OFFSET $${params.length + 2}`;
      params.push(String(limit), String(offset));

      const result = await this.executeQuery(query, params);
      return result.rows.map((row) => this.mapResultToModel(row));
    } catch (error) {
      this.logger.error("Error finding comments by user", error);
      throw new CommentError(
        `Failed to find comments by user: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Count comments by user
   */
  async countByUser(
    userId: string,
    targetType?: CommentTargetType,
  ): Promise<number> {
    try {
      let query = `
        SELECT COUNT(*) as count
        FROM ${this.tableName}
        WHERE user_id = $1
      `;

      const params = [userId];

      if (targetType) {
        query += ` AND target_type = $${params.length + 1}`;
        params.push(targetType);
      }

      const result = await this.executeQuery<{ count: string }>(query, params);
      return parseInt(result.rows[0]?.count || "0", 10);
    } catch (error) {
      this.logger.error("Error counting comments by user", error);
      throw new CommentError(
        `Failed to count comments by user: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Create a comment with validation
   */
  async create(
    data: Omit<
      CommentAttributes,
      "id" | "likeCount" | "replyCount" | "createdAt" | "updatedAt"
    >,
  ): Promise<Comment> {
    return this.withTransaction(async (client) => {
      try {
        // Create a new Comment instance for validation
        const comment = new Comment({
          ...data,
          id: "",
          likesCount: 0,
          createdAt: new Date(),
          updatedAt: new Date(),
        });

        // Validate comment
        const validationErrors = comment.validate();
        if (validationErrors.length > 0) {
          throw new CommentValidationError(validationErrors.join(", "));
        }

        // Set default values
        const commentData = {
          ...data,
          likeCount: 0,
          replyCount: 0,
        };

        // Convert camelCase to snake_case for database columns
        const insertData: Record<string, unknown> = {};
        Object.entries(commentData).forEach(([key, value]) => {
          insertData[this.snakeCase(key)] = value;
        });

        const insertColumns = Object.keys(insertData);
        const placeholders = insertColumns.map((_, idx) => `$${idx + 1}`);
        const values = Object.values(insertData);

        const query = `
          INSERT INTO ${this.tableName} (${insertColumns.join(", ")}, created_at, updated_at)
          VALUES (${placeholders.join(", ")}, NOW(), NOW())
          RETURNING ${this.columns.join(", ")}
        `;

        const { rows } = await client.query(query, values);

        // If this is a reply, increment reply count on parent
        if (data.parentId) {
          await this.incrementReplyCount(data.parentId);
        }

        return this.mapResultToModel(rows[0]);
      } catch (error) {
        this.logger.error("Error creating comment", error);
        throw new CommentError(
          `Failed to create comment: ${error instanceof Error ? error.message : String(error)}`,
        );
      }
    });
  }

  /**
   * Update a comment
   */
  async update(
    id: string,
    data: Partial<CommentAttributes>,
  ): Promise<Comment | null> {
    return this.withTransaction(async (client) => {
      try {
        // First check if comment exists
        const existingComment = await this.findById(id);
        if (!existingComment) {
          throw new CommentNotFoundError(id);
        }

        // Create a merged comment for validation
        const updatedComment = new Comment({
          ...existingComment,
          ...data,
        });

        // Validate the updated comment
        const validationErrors = updatedComment.validate();
        if (validationErrors.length > 0) {
          throw new CommentValidationError(validationErrors.join(", "));
        }

        // Only update provided fields
        const updateData: Record<string, unknown> = {};
        Object.entries(data).forEach(([key, value]) => {
          updateData[this.snakeCase(key)] = value;
        });

        // Nothing to update
        if (Object.keys(updateData).length === 0) {
          return updatedComment;
        }

        // Set updated_at
        updateData.updated_at = new Date();

        const updateColumns = Object.keys(updateData);
        const setClause = updateColumns
          .map((col, idx) => `${col} = $${idx + 2}`)
          .join(", ");
        const values = [id, ...Object.values(updateData)];

        const query = `
          UPDATE ${this.tableName}
          SET ${setClause}
          WHERE id = $1
          RETURNING ${this.columns.join(", ")}
        `;

        const { rows } = await client.query(query, values);

        if (rows.length === 0) {
          return null;
        }

        return this.mapResultToModel(rows[0]);
      } catch (error) {
        this.logger.error("Error updating comment", error);
        throw new CommentError(
          `Failed to update comment: ${error instanceof Error ? error.message : String(error)}`,
        );
      }
    });
  }

  /**
   * Delete a comment
   */
  async delete(id: string): Promise<boolean> {
    return this.withTransaction(async (client) => {
      try {
        // First find the comment to check if it exists and get parentId
        const comment = await this.findById(id);
        if (!comment) {
          return false;
        }

        // Delete the comment
        const query = `
          DELETE FROM ${this.tableName}
          WHERE id = $1
          RETURNING id
        `;

        const { rowCount } = await client.query(query, [id]);

        // If this was a reply, decrement reply count on parent
        if (comment.parentId) {
          await this.decrementReplyCount(comment.parentId);
        }

        return (rowCount ?? 0) > 0;
      } catch (error) {
        this.logger.error("Error deleting comment", error);
        throw new CommentError(
          `Failed to delete comment: ${error instanceof Error ? error.message : String(error)}`,
        );
      }
    });
  }

  /**
   * Increment like count for a comment
   */
  async incrementLikeCount(id: string): Promise<Comment | null> {
    try {
      const query = `
        UPDATE ${this.tableName}
        SET like_count = like_count + 1, updated_at = NOW()
        WHERE id = $1
        RETURNING ${this.columns.join(", ")}
      `;

      const result = await this.executeQuery(query, [id]);

      if (result.rowCount === 0) {
        return null;
      }

      return this.mapResultToModel(result.rows[0]);
    } catch (error) {
      this.logger.error("Error incrementing like count", error);
      throw new CommentError(
        `Failed to increment like count: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Decrement like count for a comment
   */
  async decrementLikeCount(id: string): Promise<Comment | null> {
    try {
      const query = `
        UPDATE ${this.tableName}
        SET like_count = GREATEST(like_count - 1, 0), updated_at = NOW()
        WHERE id = $1
        RETURNING ${this.columns.join(", ")}
      `;

      const result = await this.executeQuery(query, [id]);

      if (result.rowCount === 0) {
        return null;
      }

      return this.mapResultToModel(result.rows[0]);
    } catch (error) {
      this.logger.error("Error decrementing like count", error);
      throw new CommentError(
        `Failed to decrement like count: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Increment reply count for a comment
   */
  async incrementReplyCount(id: string): Promise<Comment | null> {
    try {
      const query = `
        UPDATE ${this.tableName}
        SET reply_count = reply_count + 1, updated_at = NOW()
        WHERE id = $1
        RETURNING ${this.columns.join(", ")}
      `;

      const result = await this.executeQuery(query, [id]);

      if (result.rowCount === 0) {
        return null;
      }

      return this.mapResultToModel(result.rows[0]);
    } catch (error) {
      this.logger.error("Error incrementing reply count", error);
      throw new CommentError(
        `Failed to increment reply count: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Decrement reply count for a comment
   */
  async decrementReplyCount(id: string): Promise<Comment | null> {
    try {
      const query = `
        UPDATE ${this.tableName}
        SET reply_count = GREATEST(reply_count - 1, 0), updated_at = NOW()
        WHERE id = $1
        RETURNING ${this.columns.join(", ")}
      `;

      const result = await this.executeQuery(query, [id]);

      if (result.rowCount === 0) {
        return null;
      }

      return this.mapResultToModel(result.rows[0]);
    } catch (error) {
      this.logger.error("Error decrementing reply count", error);
      throw new CommentError(
        `Failed to decrement reply count: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Find a comment by ID
   */
  async findById(id: string): Promise<Comment | null> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE id = $1
      `;

      const result = await this.executeQuery(query, [id]);

      if (result.rowCount === 0) {
        return null;
      }

      return this.mapResultToModel(result.rows[0]);
    } catch (error) {
      this.logger.error("Error finding comment by ID", error);
      throw new CommentError(
        `Failed to find comment by ID: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Helper method to map DB result to Comment model
   */
  protected mapResultToModel(row: Record<string, unknown>): Comment {
    if (!row) return null as unknown as Comment;

    const rawStatus = String(row.status || "");
    const status = Object.values(ContentStatus).includes(
      rawStatus as ContentStatus,
    )
      ? (rawStatus as ContentStatus)
      : ContentStatus.DRAFT;

    return new Comment({
      id: String(row.id || ""),
      userId: String(row.userId || row.user_id || ""),
      postId: String(row.targetId || row.target_id || ""),
      parentId:
        row.parentId || row.parent_id
          ? String(row.parentId || row.parent_id)
          : null,
      content: String(row.content || ""),
      status,
      likesCount: Number(row.likeCount || row.like_count || 0),
      createdAt: new Date(String(row.createdAt || row.created_at)),
      updatedAt: new Date(String(row.updatedAt || row.updated_at)),
    });
  }

  /**
   * Convert camelCase string to snake_case
   */
  private snakeCase(str: string): string {
    return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
  }
}

// Export singleton instance
export const commentRepository = CommentRepository.getInstance();



===========================================================
FILE 58: repositories\social\FollowRepository.ts
===========================================================

import { Logger } from "../../../services/LoggerService";
import { BaseModelInterface } from "../../models/BaseModel";
import { Follow, FollowAttributes } from "../../models/social/Follow";
import { BaseRepository } from "../BaseRepository";

export interface FollowWithIndex extends Follow, BaseModelInterface {
  [key: string]: unknown;
}

/**
 * Interface for user data returned by mutual follower queries
 */
interface UserData {
  id: string;
  username: string;
  displayName: string;
  profileImage: string | null;
  [key: string]: unknown;
}

/**
 * Custom error class for follow operations
 */
export class FollowError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "FollowError";
  }
}

/**
 * Repository class for handling Follow database operations.
 * This class is responsible for:
 * 1. All database operations related to follows
 * 2. Converting between database and model formats
 * 3. Providing specific query methods for follow relationships
 * 4. NOT implementing business logic - that belongs in the Follow model
 */
export class FollowRepository extends BaseRepository<FollowWithIndex> {
  private static instance: FollowRepository;
  protected logger = new Logger("FollowRepository");
  protected tableName = "follows";
  protected columns = [
    "id",
    "follower_id as followerId",
    "following_id as followingId",
    "created_at as createdAt",
    "updated_at as updatedAt",
  ];

  private constructor() {
    super();
  }

  /**
   * Get the singleton instance of FollowRepository
   */
  public static getInstance(): FollowRepository {
    if (!FollowRepository.instance) {
      FollowRepository.instance = new FollowRepository();
    }
    return FollowRepository.instance;
  }

  /**
   * Find a follow relationship by follower and following user IDs
   */
  async findByUserAndTarget(
    followerId: string,
    followingId: string,
  ): Promise<Follow | null> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE follower_id = $1 AND following_id = $2
      `;

      const result = await this.executeQuery<FollowAttributes>(query, [
        followerId,
        followingId,
      ]);
      if (result.rows.length === 0) return null;

      return this.mapResultToModel(result.rows[0]);
    } catch (error) {
      this.logger.error("Error finding follow by user and target", error);
      throw new FollowError(
        `Failed to find follow relationship: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Check if a user is following another user
   */
  async isFollowing(followerId: string, followingId: string): Promise<boolean> {
    try {
      const follow = await this.findByUserAndTarget(followerId, followingId);
      return follow !== null;
    } catch (error) {
      this.logger.error("Error checking follow status", error);
      throw new FollowError(
        `Failed to check follow status: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Get all followers of a specific user
   */
  async getFollowersForUser(
    userId: string,
    limit = 20,
    offset = 0,
  ): Promise<Follow[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE following_id = $1
        ORDER BY created_at DESC
        LIMIT $2 OFFSET $3
      `;

      const result = await this.executeQuery<FollowAttributes>(query, [
        userId,
        String(limit),
        String(offset),
      ]);
      return result.rows.map((row) => this.mapResultToModel(row));
    } catch (error) {
      this.logger.error("Error getting followers for user", error);
      throw new FollowError(
        `Failed to get followers: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Get all users that a specific user is following
   */
  async getFollowingForUser(
    userId: string,
    limit = 20,
    offset = 0,
  ): Promise<Follow[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE follower_id = $1
        ORDER BY created_at DESC
        LIMIT $2 OFFSET $3
      `;

      const result = await this.executeQuery<FollowAttributes>(query, [
        userId,
        String(limit),
        String(offset),
      ]);
      return result.rows.map((row) => this.mapResultToModel(row));
    } catch (error) {
      this.logger.error("Error getting following for user", error);
      throw new FollowError(
        `Failed to get following: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Count followers for a user
   */
  async countFollowers(userId: string): Promise<number> {
    try {
      const query = `
        SELECT COUNT(*) as count
        FROM ${this.tableName}
        WHERE following_id = $1
      `;

      const result = await this.executeQuery<{ count: string }>(query, [
        userId,
      ]);
      return parseInt(result.rows[0]?.count || "0", 10);
    } catch (error) {
      this.logger.error("Error counting followers", error);
      throw new FollowError(
        `Failed to count followers: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Count users that a specific user is following
   */
  async countFollowing(userId: string): Promise<number> {
    try {
      const query = `
        SELECT COUNT(*) as count
        FROM ${this.tableName}
        WHERE follower_id = $1
      `;

      const result = await this.executeQuery<{ count: string }>(query, [
        userId,
      ]);
      return parseInt(result.rows[0]?.count || "0", 10);
    } catch (error) {
      this.logger.error("Error counting following", error);
      throw new FollowError(
        `Failed to count following: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Create a new follow relationship
   */
  async create(
    data: Omit<FollowAttributes, "id" | "createdAt" | "updatedAt"> & {
      followerId: string;
      followingId: string;
    },
  ): Promise<Follow> {
    return this.withTransaction(async (client) => {
      try {
        // Create a new Follow instance for validation
        const follow = new Follow({
          ...data,
          id: "",
          createdAt: new Date(),
          updatedAt: new Date(),
        });

        // Validate follow
        const validationErrors = follow.validate();
        if (validationErrors.length > 0) {
          throw new FollowError(validationErrors.join(", "));
        }

        const query = `
          INSERT INTO ${this.tableName} (follower_id, following_id)
          VALUES ($1, $2)
          RETURNING ${this.columns.join(", ")}
        `;

        const { rows } = await client.query(query, [
          data.followerId,
          data.followingId,
        ]);

        // After creating the follow, increment the follower/following counts
        await client.query(
          `
          UPDATE users
          SET follower_count = CASE WHEN id = $1 THEN follower_count + 1 ELSE follower_count END,
              following_count = CASE WHEN id = $2 THEN following_count + 1 ELSE following_count END,
              updated_at = NOW()
          WHERE id IN ($1, $2)
        `,
          [data.followingId, data.followerId],
        );

        return this.mapResultToModel(rows[0]);
      } catch (error) {
        this.logger.error("Error creating follow", error);
        throw new FollowError(
          `Failed to create follow: ${error instanceof Error ? error.message : String(error)}`,
        );
      }
    });
  }

  /**
   * Delete a follow relationship by follower and following user IDs
   */
  async unfollow(followerId: string, followingId: string): Promise<boolean> {
    return this.withTransaction(async (client) => {
      try {
        const query = `
          DELETE FROM ${this.tableName}
          WHERE follower_id = $1 AND following_id = $2
          RETURNING id
        `;

        const { rowCount } = await client.query(query, [
          followerId,
          followingId,
        ]);
        return (rowCount ?? 0) > 0;
      } catch (error) {
        this.logger.error("Error unfollowing user", error);
        throw new FollowError(
          `Failed to unfollow user: ${error instanceof Error ? error.message : String(error)}`,
        );
      }
    });
  }

  /**
   * Toggle follow status: follow if not following, unfollow if following
   */
  async toggleFollow(
    followerId: string,
    followingId: string,
  ): Promise<boolean> {
    try {
      // Check if already following
      const isFollowing = await this.isFollowing(followerId, followingId);

      if (isFollowing) {
        // Unfollow if already following
        return await this.unfollow(followerId, followingId);
      } else {
        // Follow if not already following
        await this.create({ followerId, followingId });
        return true;
      }
    } catch (error) {
      this.logger.error("Error toggling follow status", error);
      throw new FollowError(
        `Failed to toggle follow status: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Get recent followers of a user
   */
  async getRecentFollowers(userId: string, limit = 10): Promise<Follow[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE following_id = $1
        ORDER BY created_at DESC
        LIMIT $2
      `;

      const result = await this.executeQuery<FollowAttributes>(query, [
        userId,
        String(limit),
      ]);
      return result.rows.map((row) => this.mapResultToModel(row));
    } catch (error) {
      this.logger.error("Error getting recent followers", error);
      throw new FollowError(
        `Failed to get recent followers: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Get users that a specific user recently followed
   */
  async getRecentFollowing(userId: string, limit = 10): Promise<Follow[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE follower_id = $1
        ORDER BY created_at DESC
        LIMIT $2
      `;

      const result = await this.executeQuery<FollowAttributes>(query, [
        userId,
        String(limit),
      ]);
      return result.rows.map((row) => this.mapResultToModel(row));
    } catch (error) {
      this.logger.error("Error getting recent following", error);
      throw new FollowError(
        `Failed to get recent following: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Find mutual followers between two users
   */
  async getMutualFollowers(
    userId: string,
    otherUserId: string,
    limit = 20,
    offset = 0,
  ): Promise<UserData[]> {
    try {
      const query = `
        SELECT u.id, u.username, u.display_name as "displayName", u.profile_image as "profileImage"
        FROM users u
        WHERE EXISTS (
          SELECT 1 FROM ${this.tableName} WHERE follower_id = u.id AND following_id = $1
        )
        AND EXISTS (
          SELECT 1 FROM ${this.tableName} WHERE follower_id = u.id AND following_id = $2
        )
        ORDER BY u.username
        LIMIT $3 OFFSET $4
      `;

      const result = await this.executeQuery<UserData>(query, [
        userId,
        otherUserId,
        String(limit),
        String(offset),
      ]);
      return result.rows;
    } catch (error) {
      this.logger.error("Error finding mutual followers", error);
      throw new FollowError(
        `Failed to find mutual followers: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Count mutual followers between two users
   */
  async countMutualFollowers(
    userId: string,
    otherUserId: string,
  ): Promise<number> {
    try {
      const query = `
        SELECT COUNT(*) as count
        FROM users u
        WHERE EXISTS (
          SELECT 1 FROM ${this.tableName} WHERE follower_id = u.id AND following_id = $1
        )
        AND EXISTS (
          SELECT 1 FROM ${this.tableName} WHERE follower_id = u.id AND following_id = $2
        )
      `;

      const result = await this.executeQuery<{ count: string }>(query, [
        userId,
        otherUserId,
      ]);
      return parseInt(result.rows[0]?.count || "0", 10);
    } catch (error) {
      this.logger.error("Error counting mutual followers", error);
      throw new FollowError(
        `Failed to count mutual followers: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Helper method to map DB result to Follow model
   */
  protected mapResultToModel(row: Record<string, unknown>): Follow {
    if (!row) return null as unknown as Follow;
    return new Follow({
      id: String(row.id || ""),
      followerId: String(row.followerId || row.follower_id || ""),
      followingId: String(row.followingId || row.following_id || ""),
      createdAt: new Date(String(row.createdAt || row.created_at)),
      updatedAt: new Date(String(row.updatedAt || row.updated_at)),
    });
  }
}

// Export singleton instance
export const followRepository = FollowRepository.getInstance();



===========================================================
FILE 59: repositories\social\HashtagRepository.ts
===========================================================

import { Logger } from "../../../services/LoggerService";
import { Hashtag, HashtagCategory } from "../../models/social/Hashtag";
import { BaseRepository } from "../BaseRepository";

/**
 * Custom error classes for hashtag operations
 */
export class HashtagError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "HashtagError";
  }
}

export class HashtagNotFoundError extends HashtagError {
  constructor(identifier: string) {
    super(`Hashtag with identifier ${identifier} not found`);
    this.name = "HashtagNotFoundError";
  }
}

export class HashtagValidationError extends HashtagError {
  constructor(message: string) {
    super(`Validation error: ${message}`);
    this.name = "HashtagValidationError";
  }
}

/**
 * Repository for managing hashtag data
 */
export class HashtagRepository extends BaseRepository<Hashtag> {
  private static instance: HashtagRepository;
  protected tableName = "hashtags";
  protected columns = [
    "id",
    "tag",
    "normalized_tag as normalizedTag",
    "usage_count as usageCount",
    "category",
    "created_at as createdAt",
    "updated_at as updatedAt",
  ];
  protected logger = new Logger("HashtagRepository");

  /**
   * Private constructor to enforce singleton pattern
   */
  private constructor() {
    super();
  }

  /**
   * Get the singleton instance of HashtagRepository
   */
  public static getInstance(): HashtagRepository {
    if (!HashtagRepository.instance) {
      HashtagRepository.instance = new HashtagRepository();
    }
    return HashtagRepository.instance;
  }

  /**
   * Find a hashtag by its tag text
   */
  async findByTag(tag: string): Promise<Hashtag | null> {
    try {
      // Normalize the tag for consistent lookup
      const normalizedTag = this.normalizeTag(tag);

      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE normalized_tag = $1
      `;

      const result = await this.executeQuery<Record<string, unknown>>(query, [
        normalizedTag,
      ]);

      if (result.rows.length === 0) {
        return null;
      }

      return this.mapResultToModel(result.rows[0]);
    } catch (error) {
      this.logger.error("Error finding hashtag by tag", error);
      throw new HashtagError(
        `Failed to find hashtag by tag: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Find or create a hashtag by its tag text
   */
  async findOrCreate(tag: string): Promise<Hashtag> {
    return this.withTransaction(async () => {
      try {
        const existingTag = await this.findByTag(tag);

        if (existingTag) {
          return existingTag;
        }

        // Create a new hashtag if it doesn't exist
        const normalizedTag = this.normalizeTag(tag);

        const cleanTag = tag.startsWith("#") ? tag.substring(1) : tag;

        const newHashtag = new Hashtag({
          tag: cleanTag,
          normalizedTag,
          usageCount: 1,
          category: HashtagCategory.GENERAL,
        });

        // Validate the hashtag
        newHashtag.validate();

        return await this.create(newHashtag);
      } catch (error) {
        this.logger.error("Error finding or creating hashtag", error);
        throw new HashtagError(
          `Failed to find or create hashtag: ${error instanceof Error ? error.message : String(error)}`,
        );
      }
    });
  }

  /**
   * Find trending hashtags
   */
  async findTrending(
    limit: number = 10,
    offset: number = 0,
  ): Promise<Hashtag[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        ORDER BY usage_count DESC
        LIMIT $1 OFFSET $2
      `;

      const result = await this.executeQuery<Record<string, unknown>>(query, [
        limit,
        offset,
      ]);

      return result.rows.map((row) => this.mapResultToModel(row));
    } catch (error) {
      this.logger.error("Error finding trending hashtags", error);
      throw new HashtagError(
        `Failed to find trending hashtags: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Find hashtags by category
   */
  async findByCategory(
    category: HashtagCategory,
    limit: number = 10,
    offset: number = 0,
  ): Promise<Hashtag[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE category = $1
        ORDER BY usage_count DESC
        LIMIT $2 OFFSET $3
      `;

      const result = await this.executeQuery<Record<string, unknown>>(query, [
        category,
        limit,
        offset,
      ]);

      return result.rows.map((row) => this.mapResultToModel(row));
    } catch (error) {
      this.logger.error("Error finding hashtags by category", error);
      throw new HashtagError(
        `Failed to find hashtags by category: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Search hashtags by partial tag text
   */
  async searchByText(
    text: string,
    limit: number = 10,
    offset: number = 0,
  ): Promise<Hashtag[]> {
    try {
      const searchText = `%${text.toLowerCase()}%`;

      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE normalized_tag LIKE $1
        ORDER BY usage_count DESC
        LIMIT $2 OFFSET $3
      `;

      const result = await this.executeQuery<Record<string, unknown>>(query, [
        searchText,
        limit,
        offset,
      ]);

      return result.rows.map((row) => this.mapResultToModel(row));
    } catch (error) {
      this.logger.error("Error searching hashtags by text", error);
      throw new HashtagError(
        `Failed to search hashtags by text: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Increment usage count for a hashtag
   */
  async incrementUsage(
    hashtagId: string,
    count: number = 1,
  ): Promise<Hashtag | null> {
    return this.withTransaction(async () => {
      try {
        // First check if the hashtag exists
        const hashtag = await this.findById(hashtagId);
        if (!hashtag) {
          throw new HashtagNotFoundError(hashtagId);
        }

        const query = `
          UPDATE ${this.tableName}
          SET usage_count = usage_count + $1,
              updated_at = NOW()
          WHERE id = $2
          RETURNING ${this.columns.join(", ")}
        `;

        const result = await this.executeQuery<Record<string, unknown>>(query, [
          count,
          hashtagId,
        ]);

        if (!result.rows.length) {
          return null;
        }

        return this.mapResultToModel(result.rows[0]);
      } catch (error) {
        this.logger.error("Error incrementing hashtag usage", error);
        throw new HashtagError(
          `Failed to increment hashtag usage: ${error instanceof Error ? error.message : String(error)}`,
        );
      }
    });
  }

  /**
   * Update hashtag category
   */
  async updateCategory(
    hashtagId: string,
    category: HashtagCategory,
  ): Promise<Hashtag | null> {
    return this.withTransaction(async () => {
      try {
        // First check if the hashtag exists
        const hashtag = await this.findById(hashtagId);
        if (!hashtag) {
          throw new HashtagNotFoundError(hashtagId);
        }

        const query = `
          UPDATE ${this.tableName}
          SET category = $1,
              updated_at = NOW()
          WHERE id = $2
          RETURNING ${this.columns.join(", ")}
        `;

        const result = await this.executeQuery<Record<string, unknown>>(query, [
          category,
          hashtagId,
        ]);

        if (!result.rows.length) {
          return null;
        }

        return this.mapResultToModel(result.rows[0]);
      } catch (error) {
        this.logger.error("Error updating hashtag category", error);
        throw new HashtagError(
          `Failed to update hashtag category: ${error instanceof Error ? error.message : String(error)}`,
        );
      }
    });
  }

  /**
   * Create a new hashtag
   */
  async create(hashtag: Hashtag): Promise<Hashtag> {
    return this.withTransaction(async () => {
      try {
        // Validate the hashtag
        hashtag.validate();

        const query = `
          INSERT INTO ${this.tableName} (
            id, tag, normalized_tag, usage_count, category, created_at, updated_at
          ) VALUES (
            $1, $2, $3, $4, $5, $6, $7
          ) RETURNING ${this.columns.join(", ")}
        `;

        const values = [
          hashtag.id,
          hashtag.tag,
          hashtag.normalizedTag,
          hashtag.usageCount,
          hashtag.category,
          hashtag.createdAt,
          hashtag.updatedAt,
        ];

        const result = await this.executeQuery<Record<string, unknown>>(
          query,
          values,
        );

        return this.mapResultToModel(result.rows[0]);
      } catch (error) {
        this.logger.error("Error creating hashtag", error);
        throw new HashtagError(
          `Failed to create hashtag: ${error instanceof Error ? error.message : String(error)}`,
        );
      }
    });
  }

  /**
   * Find a hashtag by ID
   */
  async findById(id: string): Promise<Hashtag | null> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE id = $1
      `;

      const result = await this.executeQuery<Record<string, unknown>>(query, [
        id,
      ]);

      if (!result.rows.length) {
        return null;
      }

      return this.mapResultToModel(result.rows[0]);
    } catch (error) {
      this.logger.error("Error finding hashtag by ID", error);
      throw new HashtagError(
        `Failed to find hashtag by ID: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Delete a hashtag
   */
  async delete(id: string): Promise<boolean> {
    return this.withTransaction(async () => {
      try {
        // First check if the hashtag exists
        const hashtag = await this.findById(id);
        if (!hashtag) {
          throw new HashtagNotFoundError(id);
        }

        const query = `
          DELETE FROM ${this.tableName}
          WHERE id = $1
          RETURNING id
        `;

        const result = await this.executeQuery<Record<string, unknown>>(query, [
          id,
        ]);

        return (result.rowCount ?? 0) > 0;
      } catch (error) {
        this.logger.error("Error deleting hashtag", error);
        throw new HashtagError(
          `Failed to delete hashtag: ${error instanceof Error ? error.message : String(error)}`,
        );
      }
    });
  }

  /**
   * Maps database rows to Hashtag instances safely
   */
  protected mapResultRows<R>(
    rows: unknown[],
    mapper: (row: Record<string, unknown>) => R,
  ): R[] {
    if (!rows || !Array.isArray(rows)) return [];
    return rows.map((row) => mapper(row as Record<string, unknown>));
  }

  /**
   * Gets a single result and maps it to a model safely
   */
  protected getSafeResult<R>(
    rows: unknown[],
    mapper: (row: Record<string, unknown>) => R,
  ): R | null {
    if (!rows || !Array.isArray(rows) || rows.length === 0) return null;
    return mapper(rows[0] as Record<string, unknown>);
  }

  /**
   * Maps a database row to a Hashtag model instance
   */
  protected mapResultToModel(row: Record<string, unknown>): Hashtag {
    if (!row) return null as unknown as Hashtag;

    return new Hashtag({
      id: String(row.id),
      tag: String(row.tag),
      normalizedTag: String(row.normalized_tag || row.normalizedTag || ""),
      category: String(row.category || "general") as HashtagCategory,
      usageCount: Number(row.usage_count || row.usageCount || 0),
      createdAt: new Date(String(row.created_at || row.createdAt)),
      updatedAt: new Date(String(row.updated_at || row.updatedAt)),
    });
  }

  /**
   * Helper method to normalize a tag for consistent lookups
   */
  private normalizeTag(tag: string): string {
    // Remove any # prefix if present
    const cleanTag = tag.startsWith("#") ? tag.substring(1) : tag;

    // Lowercase and trim any whitespace
    return cleanTag.toLowerCase().trim();
  }
}

// Export singleton instance
export const hashtagRepository = HashtagRepository.getInstance();



===========================================================
FILE 60: repositories\social\LikeRepository.ts
===========================================================

import { Logger } from "../../../services/LoggerService";
import { Like, LikeAttributes, LikeTargetType } from "../../models/social/Like";
import { BaseRepository } from "../BaseRepository";

/**
 * Custom error classes for like operations
 */
export class LikeError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "LikeError";
  }
}

export class LikeNotFoundError extends LikeError {
  constructor(id: string) {
    super(`Like with ID ${id} not found`);
    this.name = "LikeNotFoundError";
  }
}

export class LikeValidationError extends LikeError {
  constructor(message: string) {
    super(`Validation error: ${message}`);
    this.name = "LikeValidationError";
  }
}

/**
 * Repository for handling Like database operations
 */
export class LikeRepository extends BaseRepository<Like> {
  private static instance: LikeRepository;
  protected logger = new Logger("LikeRepository");
  protected tableName = "likes";
  protected columns = [
    "id",
    "user_id as userId",
    "target_id as targetId",
    "target_type as targetType",
    "created_at as createdAt",
    "updated_at as updatedAt",
  ];

  /**
   * Private constructor to enforce singleton pattern
   */
  private constructor() {
    super();
  }

  /**
   * Get the singleton instance of LikeRepository
   */
  public static getInstance(): LikeRepository {
    if (!LikeRepository.instance) {
      LikeRepository.instance = new LikeRepository();
    }
    return LikeRepository.instance;
  }

  /**
   * Find a like by user ID, target ID, and target type
   */
  async findByUserAndTarget(
    userId: string,
    targetId: string,
    targetType: LikeTargetType,
  ): Promise<Like | null> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE user_id = $1 AND target_id = $2 AND target_type = $3
      `;

      const result = await this.executeQuery<Record<string, unknown>>(query, [
        userId,
        targetId,
        targetType,
      ]);
      if (result.rows.length === 0) return null;

      return this.mapResultToModel(result.rows[0]);
    } catch (error) {
      this.logger.error("Error finding like by user and target", error);
      throw new LikeError(
        `Failed to find like: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Check if a user has liked a target
   */
  async hasLiked(
    userId: string,
    targetId: string,
    targetType: LikeTargetType,
  ): Promise<boolean> {
    try {
      const like = await this.findByUserAndTarget(userId, targetId, targetType);
      return like !== null;
    } catch (error) {
      this.logger.error("Error checking if user has liked target", error);
      throw new LikeError(
        `Failed to check if user has liked target: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Get all likes for a target
   */
  async getLikesForTarget(
    targetId: string,
    targetType: LikeTargetType,
    limit = 20,
    offset = 0,
  ): Promise<Like[]> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE target_id = $1 AND target_type = $2
        ORDER BY created_at DESC
        LIMIT $3 OFFSET $4
      `;

      const result = await this.executeQuery<Record<string, unknown>>(query, [
        targetId,
        targetType,
        limit,
        offset,
      ]);
      return result.rows.map((row) => this.mapResultToModel(row));
    } catch (error) {
      this.logger.error("Error getting likes for target", error);
      throw new LikeError(
        `Failed to get likes for target: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Count likes for a target
   */
  async countLikesForTarget(
    targetId: string,
    targetType: LikeTargetType,
  ): Promise<number> {
    try {
      const query = `
        SELECT COUNT(*) as count
        FROM ${this.tableName}
        WHERE target_id = $1 AND target_type = $2
      `;

      const result = await this.executeQuery<{ count: string }>(query, [
        targetId,
        targetType,
      ]);
      return parseInt(result.rows[0]?.count || "0", 10);
    } catch (error) {
      this.logger.error("Error counting likes for target", error);
      throw new LikeError(
        `Failed to count likes for target: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Get all likes by a user
   */
  async getLikesByUser(
    userId: string,
    targetType?: LikeTargetType,
    limit = 20,
    offset = 0,
  ): Promise<Like[]> {
    try {
      let query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE user_id = $1
      `;

      const params: unknown[] = [userId];

      if (targetType) {
        query += ` AND target_type = $${params.length + 1}`;
        params.push(targetType);
      }

      query +=
        " ORDER BY created_at DESC LIMIT $" +
        (params.length + 1) +
        " OFFSET $" +
        (params.length + 2);
      params.push(limit, offset);

      const result = await this.executeQuery<Record<string, unknown>>(
        query,
        params,
      );
      return result.rows.map((row) => this.mapResultToModel(row));
    } catch (error) {
      this.logger.error("Error getting likes by user", error);
      throw new LikeError(
        `Failed to get likes by user: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Count likes by a user
   */
  async countLikesByUser(
    userId: string,
    targetType?: LikeTargetType,
  ): Promise<number> {
    try {
      let query = `
        SELECT COUNT(*) as count
        FROM ${this.tableName}
        WHERE user_id = $1
      `;

      const params: unknown[] = [userId];

      if (targetType) {
        query += ` AND target_type = $${params.length + 1}`;
        params.push(targetType);
      }

      const result = await this.executeQuery<{ count: string }>(query, params);
      return parseInt(result.rows[0]?.count || "0", 10);
    } catch (error) {
      this.logger.error("Error counting likes by user", error);
      throw new LikeError(
        `Failed to count likes by user: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Create a like
   */
  async create(
    data: Omit<LikeAttributes, "id" | "createdAt" | "updatedAt">,
  ): Promise<Like> {
    return this.withTransaction(async () => {
      try {
        // Check if this like already exists
        const existing = await this.findByUserAndTarget(
          String(data.userId),
          String(data.targetId),
          data.targetType as LikeTargetType,
        );

        if (existing) {
          return existing;
        }

        // Create a Like instance for validation
        const like = new Like({
          userId: String(data.userId),
          targetId: String(data.targetId),
          targetType: data.targetType as LikeTargetType,
        });

        // Validate the like
        like.validate();

        const query = `
          INSERT INTO ${this.tableName} (
            id, user_id, target_id, target_type, created_at, updated_at
          ) VALUES (
            $1, $2, $3, $4, $5, $6
          ) RETURNING ${this.columns.join(", ")}
        `;

        const values = [
          like.id,
          like.userId,
          like.targetId,
          like.targetType,
          like.createdAt,
          like.updatedAt,
        ];

        const result = await this.executeQuery<Record<string, unknown>>(
          query,
          values,
        );
        return this.mapResultToModel(result.rows[0]);
      } catch (error) {
        this.logger.error("Error creating like", error);
        throw new LikeError(
          `Failed to create like: ${error instanceof Error ? error.message : String(error)}`,
        );
      }
    });
  }

  /**
   * Find a like by ID
   */
  async findById(id: string): Promise<Like | null> {
    try {
      const query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
        WHERE id = $1
      `;

      const result = await this.executeQuery<Record<string, unknown>>(query, [
        id,
      ]);
      if (result.rows.length === 0) return null;

      return this.mapResultToModel(result.rows[0]);
    } catch (error) {
      this.logger.error("Error finding like by ID", error);
      throw new LikeError(
        `Failed to find like by ID: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Delete a like
   */
  async delete(id: string): Promise<boolean> {
    return this.withTransaction(async () => {
      try {
        // First check if the like exists
        const like = await this.findById(id);
        if (!like) {
          throw new LikeNotFoundError(id);
        }

        const query = `
          DELETE FROM ${this.tableName}
          WHERE id = $1
          RETURNING id
        `;

        const result = await this.executeQuery<Record<string, unknown>>(query, [
          id,
        ]);
        return (result.rowCount ?? 0) > 0;
      } catch (error) {
        this.logger.error("Error deleting like", error);
        throw new LikeError(
          `Failed to delete like: ${error instanceof Error ? error.message : String(error)}`,
        );
      }
    });
  }

  /**
   * Delete a like by user and target
   */
  async unlike(
    userId: string,
    targetId: string,
    targetType: LikeTargetType,
  ): Promise<boolean> {
    try {
      const like = await this.findByUserAndTarget(userId, targetId, targetType);
      if (!like) return false;

      return this.delete(like.id);
    } catch (error) {
      this.logger.error("Error unliking target", error);
      throw new LikeError(
        `Failed to unlike target: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Toggle like status
   */
  async toggleLike(
    userId: string,
    targetId: string,
    targetType: LikeTargetType,
  ): Promise<{ liked: boolean; like?: Like }> {
    return this.withTransaction(async () => {
      try {
        const existingLike = await this.findByUserAndTarget(
          userId,
          targetId,
          targetType,
        );

        if (existingLike) {
          // Unlike if already liked
          await this.delete(existingLike.id);
          return { liked: false };
        } else {
          // Like if not already liked
          const like = await this.create({ userId, targetId, targetType });
          return { liked: true, like };
        }
      } catch (error) {
        this.logger.error("Error toggling like status", error);
        throw new LikeError(
          `Failed to toggle like status: ${error instanceof Error ? error.message : String(error)}`,
        );
      }
    });
  }

  /**
   * Get recent likes across all targets
   */
  async getRecentLikes(
    limit = 20,
    offset = 0,
    targetType?: LikeTargetType,
  ): Promise<Like[]> {
    try {
      let query = `
        SELECT ${this.columns.join(", ")}
        FROM ${this.tableName}
      `;

      const params: unknown[] = [];

      if (targetType) {
        query += ` WHERE target_type = $${params.length + 1}`;
        params.push(targetType);
      }

      query += ` ORDER BY created_at DESC LIMIT $${params.length + 1} OFFSET $${params.length + 2}`;
      params.push(limit, offset);

      const result = await this.executeQuery<Record<string, unknown>>(
        query,
        params,
      );
      return result.rows.map((row) => this.mapResultToModel(row));
    } catch (error) {
      this.logger.error("Error getting recent likes", error);
      throw new LikeError(
        `Failed to get recent likes: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Map a database row to a Like model
   */
  protected mapResultToModel(row: unknown): Like {
    if (!row) return null as unknown as Like;

    const data = row as Record<string, unknown>;
    return new Like({
      id: String(data.id || ""),
      userId: String(data.userId || data.user_id || ""),
      targetId: String(data.targetId || data.target_id || ""),
      targetType: (data.targetType || data.target_type) as LikeTargetType,
    });
  }
}

// Export singleton instance
export const likeRepository = LikeRepository.getInstance();



===========================================================
FILE 61: repositories\social\NotificationRepository.ts
===========================================================

import { Logger } from "../../../services/LoggerService";
import { DatabaseConnectionManager } from "../../config";
import { BaseModelInterface } from "../../models/BaseModel";
import { EntityType } from "../../models/shared/EntityTypes";
import {
  Notification,
  NotificationType,
} from "../../models/social/Notification";
import { BaseRepository } from "../BaseRepository";

export interface NotificationWithIndex
  extends Notification,
    BaseModelInterface {
  [key: string]: unknown;
}

/**
 * Error class for notification-related errors
 */
export class NotificationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "NotificationError";
  }
}

/**
 * Repository class for managing notifications
 */
export class NotificationRepository extends BaseRepository<NotificationWithIndex> {
  private static instance: NotificationRepository;
  protected logger: Logger;
  protected tableName = "notifications";
  protected columns = [
    "id",
    "type",
    "user_id",
    "actor_id",
    "entity_id",
    "entity_type",
    "content",
    "read",
    "delivered",
    "created_at",
    "updated_at",
  ];

  /**
   * Private constructor for singleton pattern
   */
  private constructor() {
    super();
    this.logger = new Logger("NotificationRepository");
  }

  /**
   * Get the singleton instance
   */
  public static getInstance(): NotificationRepository {
    if (!NotificationRepository.instance) {
      NotificationRepository.instance = new NotificationRepository();
    }
    return NotificationRepository.instance;
  }

  /**
   * Create a new notification
   */
  async create(notification: Notification): Promise<Notification> {
    try {
      notification.validate();

      const query = `
        INSERT INTO notifications (
          id, type, user_id, actor_id, entity_id, entity_type, content, read, delivered, created_at, updated_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
        RETURNING *
      `;

      const values = [
        notification.id,
        notification.type,
        notification.userId,
        notification.actorId,
        notification.entityId,
        notification.entityType,
        notification.content,
        notification.read,
        notification.delivered,
        notification.createdAt,
        notification.updatedAt,
      ];

      const result = await DatabaseConnectionManager.getPool().query(
        query,
        values,
      );
      return this.mapResultToModel(result.rows[0]);
    } catch (error) {
      this.logger.error("Error creating notification", error);
      throw new NotificationError(
        `Failed to create notification: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Find a notification by its primary key
   */
  async findByPk(id: string): Promise<Notification | null> {
    try {
      const query = `
        SELECT * FROM notifications WHERE id = $1
      `;

      const result = await DatabaseConnectionManager.getPool().query(query, [
        id,
      ]);

      if (result.rows.length === 0) {
        return null;
      }

      return this.mapResultToModel(result.rows[0]);
    } catch (error) {
      this.logger.error(`Error finding notification with id ${id}`, error);
      throw new NotificationError(
        `Failed to find notification: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Find notifications by user ID
   */
  async findByUserId(
    userId: string,
    limit = 10,
    offset = 0,
  ): Promise<{ notifications: Notification[]; count: number }> {
    try {
      const query = `
        SELECT * FROM notifications 
        WHERE user_id = $1 
        ORDER BY created_at DESC 
        LIMIT $2 OFFSET $3
      `;

      const countQuery = `
        SELECT COUNT(*) FROM notifications WHERE user_id = $1
      `;

      const [result, countResult] = await Promise.all([
        DatabaseConnectionManager.getPool().query(query, [
          userId,
          limit,
          offset,
        ]),
        DatabaseConnectionManager.getPool().query(countQuery, [userId]),
      ]);

      const count = parseInt(
        (countResult.rows[0] as { count: string })?.count || "0",
        10,
      );
      const notifications = result.rows.map((row: Record<string, unknown>) =>
        this.mapResultToModel(row),
      );

      return {
        notifications,
        count,
      };
    } catch (error) {
      this.logger.error(
        `Error finding notifications for user ${userId}`,
        error,
      );
      throw new NotificationError(
        `Failed to find notifications: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Get unread notifications count for a user
   */
  async getUnreadCount(userId: string): Promise<number> {
    try {
      const query = `
        SELECT COUNT(*) FROM notifications 
        WHERE user_id = $1 AND read = false
      `;

      const result = await DatabaseConnectionManager.getPool().query<{
        count: string;
      }>(query, [userId]);
      return parseInt((result.rows[0] as { count: string })?.count || "0", 10);
    } catch (error) {
      this.logger.error(`Error getting unread count for user ${userId}`, error);
      throw new NotificationError(
        `Failed to get unread count: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Mark a notification as read
   */
  async markAsRead(id: string): Promise<Notification> {
    try {
      const query = `
        UPDATE notifications 
        SET read = true, updated_at = NOW() 
        WHERE id = $1 
        RETURNING *
      `;

      const result = await DatabaseConnectionManager.getPool().query(query, [
        id,
      ]);

      if (result.rows.length === 0) {
        throw new NotificationError(`Notification with id ${id} not found`);
      }

      return this.mapResultToModel(result.rows[0]);
    } catch (error) {
      this.logger.error(`Error marking notification ${id} as read`, error);
      throw new NotificationError(
        `Failed to mark notification as read: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Mark all notifications for a user as read
   */
  async markAllAsRead(userId: string): Promise<number> {
    try {
      const query = `
        UPDATE notifications 
        SET read = true, updated_at = NOW() 
        WHERE user_id = $1 AND read = false 
        RETURNING *
      `;

      const result = await DatabaseConnectionManager.getPool().query(query, [
        userId,
      ]);
      return result.rows.length;
    } catch (error) {
      this.logger.error(
        `Error marking all notifications as read for user ${userId}`,
        error,
      );
      throw new NotificationError(
        `Failed to mark all notifications as read: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Mark a notification as delivered
   */
  async markAsDelivered(id: string): Promise<Notification> {
    try {
      const query = `
        UPDATE notifications 
        SET delivered = true, updated_at = NOW() 
        WHERE id = $1 
        RETURNING *
      `;

      const result = await DatabaseConnectionManager.getPool().query(query, [
        id,
      ]);

      if (result.rows.length === 0) {
        throw new NotificationError(`Notification with id ${id} not found`);
      }

      return this.mapResultToModel(result.rows[0]);
    } catch (error) {
      this.logger.error(`Error marking notification ${id} as delivered`, error);
      throw new NotificationError(
        `Failed to mark notification as delivered: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Delete a notification
   */
  async delete(id: string): Promise<boolean> {
    try {
      const query = `
        DELETE FROM notifications 
        WHERE id = $1 
        RETURNING id
      `;

      const result = await DatabaseConnectionManager.getPool().query(query, [
        id,
      ]);

      if (result.rowCount === 0) {
        return false;
      }

      return true;
    } catch (error) {
      this.logger.error(`Error deleting notification ${id}`, error);
      throw new NotificationError(
        `Failed to delete notification: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Delete all notifications for a user
   */
  async deleteAllForUser(userId: string): Promise<number> {
    try {
      const query = `
        DELETE FROM notifications 
        WHERE user_id = $1 
        RETURNING id
      `;

      const result = await DatabaseConnectionManager.getPool().query(query, [
        userId,
      ]);
      return result.rowCount || 0;
    } catch (error) {
      this.logger.error(
        `Error deleting all notifications for user ${userId}`,
        error,
      );
      throw new NotificationError(
        `Failed to delete all notifications: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Map database result to Notification model
   */
  mapResultToModel(row: Record<string, unknown>): Notification {
    return new Notification({
      id: String(row.id || ""),
      type: String(row.type || "") as NotificationType,
      userId: String(row.user_id || ""),
      actorId: row.actor_id ? String(row.actor_id) : null,
      entityId: row.entity_id ? String(row.entity_id) : null,
      entityType: row.entity_type
        ? (String(row.entity_type) as EntityType)
        : null,
      content: row.content ? String(row.content) : null,
      read: Boolean(row.read),
      delivered: Boolean(row.delivered),
      createdAt: new Date(String(row.created_at || "")),
      updatedAt: new Date(String(row.updated_at || "")),
    });
  }
}

// Export singleton instance
export const notificationRepository = NotificationRepository.getInstance();



===========================================================
FILE 62: repositories\social\PostRepository.ts
===========================================================

import { Logger } from "../../../services/LoggerService";
import { BaseModelInterface } from "../../models/BaseModel";
import {
  Post,
  PostAttributes,
  PostStatus,
  PostType,
  PostVisibility,
} from "../../models/social/Post";
import { BaseRepository } from "../BaseRepository";

export interface PostWithIndex extends Post, BaseModelInterface {
  [key: string]: unknown;
}

/**
 * Error class for post-related errors
 */
export class PostError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "PostError";
  }
}

/**
 * Error class for post not found errors
 */
export class PostNotFoundError extends PostError {
  constructor(id: string) {
    super(`Post with ID ${id} not found`);
    this.name = "PostNotFoundError";
  }
}

/**
 * Error class for post validation errors
 */
export class PostValidationError extends PostError {
  constructor(message: string) {
    super(`Validation error: ${message}`);
    this.name = "PostValidationError";
  }
}

/**
 * Repository class for handling Post database operations
 *
 * Responsibilities:
 * 1. Handle all database operations (CRUD)
 * 2. Convert between database and model formats
 * 3. Manage database connections and transactions
 * 4. NOT implement business logic (that's the model's job)
 */
export class PostRepository extends BaseRepository<PostWithIndex> {
  private static instance: PostRepository;
  protected logger = new Logger("PostRepository");
  protected tableName = "posts";
  protected columns = [
    "id",
    "user_id",
    "content",
    "type",
    "status",
    "visibility",
    "location",
    "media_ids",
    "metadata",
    "like_count",
    "comment_count",
    "share_count",
    "view_count",
    "is_edited",
    "is_pinned",
    "parent_id",
    "original_post_id",
    "scheduled_at",
    "published_at",
    "created_at",
    "updated_at",
  ];

  /**
   * Private constructor to enforce singleton pattern
   */
  private constructor() {
    super();
  }

  /**
   * Get the singleton instance of PostRepository
   */
  public static getInstance(): PostRepository {
    if (!PostRepository.instance) {
      PostRepository.instance = new PostRepository();
    }
    return PostRepository.instance;
  }

  /**
   * Create a new post
   */
  async create(
    data: Omit<PostAttributes, "id" | "createdAt" | "updatedAt">,
  ): Promise<Post> {
    return this.withTransaction(async (client) => {
      try {
        const post = new Post({
          ...data,
          id: "",
          createdAt: new Date(),
          updatedAt: new Date(),
        });

        try {
          post.validate();
        } catch (error) {
          throw new PostValidationError(
            error instanceof Error ? error.message : String(error),
          );
        }

        const attrs = post.getAttributes();
        const insertData: Record<string, unknown> = {};
        Object.entries(attrs).forEach(([key, value]) => {
          insertData[this.snakeCase(key)] = value;
        });

        const columns = Object.keys(insertData);
        const values = Object.values(insertData);
        const placeholders = values.map((_, idx) => `$${idx + 1}`);

        const query = `
					INSERT INTO ${this.tableName} (${columns.join(", ")})
					VALUES (${placeholders.join(", ")})
					RETURNING ${this.columns.join(", ")}
				`;

        const result = await client.query(query, values);
        return this.mapResultToModel(result.rows[0]);
      } catch (error) {
        this.logger.error("Error creating post", error);
        throw new PostError(
          `Failed to create post: ${error instanceof Error ? error.message : String(error)}`,
        );
      }
    });
  }

  /**
   * Find post by ID
   */
  async findById(id: string): Promise<Post | null> {
    try {
      const query = `
				SELECT ${this.columns.join(", ")}
				FROM ${this.tableName}
				WHERE id = $1
			`;

      const result = await this.executeQuery(query, [id]);
      if (result.rows.length === 0) return null;

      return this.mapResultToModel(result.rows[0]);
    } catch (error) {
      this.logger.error("Error finding post by ID", error);
      throw new PostError(
        `Failed to find post: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Find posts by user ID
   */
  async findByUserId(
    userId: string,
    limit = 20,
    offset = 0,
    status?: PostStatus,
  ): Promise<{ posts: Post[]; count: number }> {
    try {
      let query = `
				SELECT ${this.columns.join(", ")}
				FROM ${this.tableName}
				WHERE user_id = $1
			`;

      const params: unknown[] = [userId];

      if (status) {
        query += ` AND status = $${params.length + 1}`;
        params.push(status);
      }

      query += ` ORDER BY created_at DESC LIMIT $${params.length + 1} OFFSET $${params.length + 2}`;
      params.push(limit, offset);

      const countQuery = `
				SELECT COUNT(*) FROM ${this.tableName}
				WHERE user_id = $1 ${status ? "AND status = $2" : ""}
			`;

      const [result, countResult] = await Promise.all([
        this.executeQuery(query, params),
        this.executeQuery(countQuery, status ? [userId, status] : [userId]),
      ]);

      return {
        posts: result.rows.map((row) => this.mapResultToModel(row)),
        count: parseInt(String(countResult.rows[0]?.count || "0"), 10),
      };
    } catch (error) {
      this.logger.error("Error finding posts by user ID", error);
      throw new PostError(
        `Failed to find posts: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Update post
   */
  async update(id: string, data: Partial<PostAttributes>): Promise<Post> {
    return this.withTransaction(async (client) => {
      try {
        const existingPost = await this.findById(id);
        if (!existingPost) {
          throw new PostNotFoundError(id);
        }

        const updatedPost = new Post({
          ...existingPost.getAttributes(),
          ...data,
          updatedAt: new Date(),
        });

        try {
          updatedPost.validate();
        } catch (error) {
          throw new PostValidationError(
            error instanceof Error ? error.message : String(error),
          );
        }

        const attrs = updatedPost.getAttributes();
        const updateData: Record<string, unknown> = {};
        Object.entries(attrs).forEach(([key, value]) => {
          if (key !== "id" && key !== "createdAt") {
            updateData[this.snakeCase(key)] = value;
          }
        });

        const setClause = Object.keys(updateData)
          .map((key, idx) => `${key} = $${idx + 2}`)
          .join(", ");

        const query = `
					UPDATE ${this.tableName}
					SET ${setClause}
					WHERE id = $1
					RETURNING ${this.columns.join(", ")}
				`;

        const result = await client.query(query, [
          id,
          ...Object.values(updateData),
        ]);
        if (result.rows.length === 0) {
          throw new PostNotFoundError(id);
        }

        return this.mapResultToModel(result.rows[0]);
      } catch (error) {
        this.logger.error("Error updating post", error);
        throw new PostError(
          `Failed to update post: ${error instanceof Error ? error.message : String(error)}`,
        );
      }
    });
  }

  /**
   * Delete post
   */
  async delete(id: string): Promise<boolean> {
    try {
      const query = `
				DELETE FROM ${this.tableName}
				WHERE id = $1
				RETURNING id
			`;

      const result = await this.executeQuery(query, [id]);
      return result.rowCount > 0;
    } catch (error) {
      this.logger.error("Error deleting post", error);
      throw new PostError(
        `Failed to delete post: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Find posts by status
   */
  async findByStatus(
    status: PostStatus,
    limit = 20,
    offset = 0,
  ): Promise<{ posts: Post[]; count: number }> {
    try {
      const query = `
				SELECT ${this.columns.join(", ")}
				FROM ${this.tableName}
				WHERE status = $1
				ORDER BY created_at DESC
				LIMIT $2 OFFSET $3
			`;

      const countQuery = `
				SELECT COUNT(*) FROM ${this.tableName}
				WHERE status = $1
			`;

      const [result, countResult] = await Promise.all([
        this.executeQuery(query, [status, limit, offset]),
        this.executeQuery(countQuery, [status]),
      ]);

      return {
        posts: result.rows.map((row) => this.mapResultToModel(row)),
        count: parseInt(String(countResult.rows[0]?.count || "0"), 10),
      };
    } catch (error) {
      this.logger.error("Error finding posts by status", error);
      throw new PostError(
        `Failed to find posts: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Find scheduled posts that are ready to be published
   */
  async findScheduledPosts(): Promise<Post[]> {
    try {
      const query = `
				SELECT ${this.columns.join(", ")}
				FROM ${this.tableName}
				WHERE status = $1
				AND scheduled_at <= NOW()
				ORDER BY scheduled_at ASC
			`;

      const result = await this.executeQuery(query, [PostStatus.DRAFT]);
      return result.rows.map((row) => this.mapResultToModel(row));
    } catch (error) {
      this.logger.error("Error finding scheduled posts", error);
      throw new PostError(
        `Failed to find scheduled posts: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Map database result to Post model
   */
  protected mapResultToModel(row: Record<string, unknown>): Post {
    if (!row) return null as unknown as Post;

    let metadata: Record<string, unknown> = {};
    if (row.metadata) {
      try {
        metadata =
          typeof row.metadata === "string"
            ? (JSON.parse(row.metadata) as Record<string, unknown>)
            : (row.metadata as Record<string, unknown>);
      } catch (error) {
        this.logger.warn("Error parsing post metadata", {
          error: error instanceof Error ? error.message : error,
          metadata: row.metadata,
        });
      }
    }

    return new Post({
      id: String(row.id || ""),
      userId: String(row.user_id || ""),
      content: (row.content as Record<string, unknown>) || {},
      type: String(row.type || "") as PostType,
      status: String(row.status || "") as PostStatus,
      visibility: String(row.visibility || "") as PostVisibility,
      location: row.location
        ? {
            name: String((row.location as Record<string, unknown>).name || ""),
            latitude: Number(
              (row.location as Record<string, unknown>).latitude || 0,
            ),
            longitude: Number(
              (row.location as Record<string, unknown>).longitude || 0,
            ),
          }
        : null,
      mediaIds: Array.isArray(row.media_ids) ? row.media_ids : [],
      metadata,
      likeCount: Number(row.like_count || 0),
      commentCount: Number(row.comment_count || 0),
      shareCount: Number(row.share_count || 0),
      viewCount: Number(row.view_count || 0),
      isEdited: Boolean(row.is_edited),
      isPinned: Boolean(row.is_pinned),
      parentId: row.parent_id ? String(row.parent_id) : null,
      originalPostId: row.original_post_id
        ? String(row.original_post_id)
        : null,
      scheduledAt: row.scheduled_at ? new Date(String(row.scheduled_at)) : null,
      publishedAt: row.published_at ? new Date(String(row.published_at)) : null,
      createdAt: new Date(String(row.created_at)),
      updatedAt: new Date(String(row.updated_at)),
    });
  }

  /**
   * Convert camelCase to snake_case
   */
  private snakeCase(str: string): string {
    return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
  }
}

// Export singleton instance
export const postRepository = PostRepository.getInstance();



===========================================================
FILE 63: transactions\transactionManager.ts
===========================================================

// src/database/transactionManager.ts
import { Pool, PoolClient, QueryResult } from "pg";

import { Logger } from "../../services/LoggerService";
import { DatabaseConnectionManager } from "../config";

export type TransactionCallback<T> = (client: PoolClient) => Promise<T>;

export enum IsolationLevel {
  READ_UNCOMMITTED = "READ UNCOMMITTED",
  READ_COMMITTED = "READ COMMITTED",
  REPEATABLE_READ = "REPEATABLE READ",
  SERIALIZABLE = "SERIALIZABLE",
}

export interface TransactionOptions {
  isolation?: IsolationLevel;
  readOnly?: boolean;
  deferrable?: boolean;
  timeout?: number; // in milliseconds
}

/**
 * TransactionManager provides methods for executing database operations within transactions
 * with proper error handling and connection management.
 */
export class TransactionManager {
  private static logger = new Logger("TransactionManager");

  /**
   * Execute a callback within a transaction with configurable options
   *
   * @param callback Function to execute within the transaction
   * @param options Transaction configuration options
   * @returns Result of the callback
   * @throws Error if transaction fails
   */
  static async execute<T>(
    callback: TransactionCallback<T>,
    options: TransactionOptions = {},
  ): Promise<T> {
    const pool = DatabaseConnectionManager.getPool();
    if (!(pool instanceof Pool)) {
      this.logger.warn(
        "Not using a real PostgreSQL pool - transaction support is limited",
      );
      return callback(pool as unknown as PoolClient);
    }

    const client = await pool.connect();

    try {
      // Set statement timeout if specified
      if (options.timeout) {
        await client.query(`SET statement_timeout = ${options.timeout}`);
      }

      // Start transaction with appropriate isolation level
      let beginStatement = "BEGIN";

      if (options.isolation) {
        beginStatement += ` ISOLATION LEVEL ${options.isolation}`;
      }

      if (options.readOnly) {
        beginStatement += " READ ONLY";
      }

      if (
        options.deferrable &&
        options.isolation === IsolationLevel.SERIALIZABLE
      ) {
        beginStatement += " DEFERRABLE";
      }

      await client.query(beginStatement);

      // Execute the callback within the transaction
      const result = await callback(client);
      await client.query("COMMIT");

      return result;
    } catch (error) {
      try {
        await client.query("ROLLBACK");
        this.logger.error("Transaction rolled back due to error", { error });
      } catch (rollbackError) {
        this.logger.error("Failed to rollback transaction", {
          originalError: error,
          rollbackError,
        });
      }

      throw error;
    } finally {
      // Reset statement timeout to default if it was changed
      if (options.timeout) {
        try {
          await client.query("SET statement_timeout TO DEFAULT");
        } catch (error) {
          this.logger.warn("Failed to reset statement timeout", { error });
        }
      }

      client.release();
    }
  }

  /**
   * Execute multiple operations within a single transaction
   *
   * @param operations Array of operations to perform
   * @param options Transaction configuration options
   * @returns Array of results from each operation
   * @throws Error if any operation fails
   */
  static async multiOperationTransaction<T>(
    operations: Array<TransactionCallback<T>>,
    options: TransactionOptions = {},
  ): Promise<T[]> {
    return this.execute(async (client) => {
      const results: T[] = [];

      for (const operation of operations) {
        try {
          results.push(await operation(client));
        } catch (error) {
          this.logger.error(
            "Operation failed within multi-operation transaction",
            { error },
          );
          throw error;
        }
      }

      return results;
    }, options);
  }

  /**
   * Execute a read-only transaction
   *
   * @param callback Function to execute within the transaction
   * @param isolation Optional isolation level
   * @returns Result of the callback
   * @throws Error if transaction fails
   */
  static async readTransaction<T>(
    callback: TransactionCallback<T>,
    isolation: IsolationLevel = IsolationLevel.READ_COMMITTED,
  ): Promise<T> {
    return this.execute(callback, {
      isolation,
      readOnly: true,
    });
  }

  /**
   * Execute a batch of SQL queries within a transaction
   *
   * @param queries Array of SQL queries to execute
   * @param options Transaction configuration options
   * @returns Array of query results
   * @throws Error if any query fails
   */
  static async executeBatch(
    queries: Array<{ text: string; values?: unknown[] }>,
    options: TransactionOptions = {},
  ): Promise<QueryResult[]> {
    return this.execute(async (client) => {
      const results: QueryResult[] = [];

      for (const query of queries) {
        const result = await client.query(query.text, query.values);
        results.push(result);
      }

      return results;
    }, options);
  }

  /**
   * Create a savepoint within a transaction
   *
   * @param client Active transaction client
   * @param name Savepoint name
   */
  static async createSavepoint(
    client: PoolClient,
    name: string,
  ): Promise<void> {
    await client.query(`SAVEPOINT ${name}`);
  }

  /**
   * Rollback to a savepoint within a transaction
   *
   * @param client Active transaction client
   * @param name Savepoint name
   */
  static async rollbackToSavepoint(
    client: PoolClient,
    name: string,
  ): Promise<void> {
    await client.query(`ROLLBACK TO SAVEPOINT ${name}`);
  }

  /**
   * Release a savepoint within a transaction
   *
   * @param client Active transaction client
   * @param name Savepoint name
   */
  static async releaseSavepoint(
    client: PoolClient,
    name: string,
  ): Promise<void> {
    await client.query(`RELEASE SAVEPOINT ${name}`);
  }
}

export default TransactionManager;



===========================================================
FILE 64: utils\typeGuards.ts
===========================================================

/**
 * Type guard utilities for safely handling database results
 */

/**
 * Type guard to check if a value is a non-null object
 */
export function isRecord(value: unknown): value is Record<string, unknown> {
  return typeof value === "object" && value !== null;
}

/**
 * Safely cast a database row to a record type
 * This function provides runtime validation before the type assertion
 */
export function asRecord<T = unknown>(value: unknown): Record<string, T> {
  if (!isRecord(value)) {
    throw new Error("Expected database result to be an object");
  }
  return value as Record<string, T>;
}

/**
 * Safely access a property on an unknown object with runtime validation
 */
export function getProp<T>(obj: unknown, key: string): T {
  if (!isRecord(obj)) {
    throw new Error(`Expected an object, got ${typeof obj}`);
  }

  if (!(key in obj)) {
    throw new Error(`Property '${key}' not found in object`);
  }

  return obj[key] as T;
}

/**
 * Safely convert query result rows to a properly typed array
 */
export function mapQueryRows<T>(
  rows: unknown[],
  mapper: (row: Record<string, unknown>) => T,
): T[] {
  return rows.map((row) => {
    if (!isRecord(row)) {
      throw new Error("Database row is not an object");
    }
    return mapper(row);
  });
}



