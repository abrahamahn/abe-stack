SHARED DIRECTORY SUMMARY
================================================================================
Total Files: 16
Total Lines: 632
================================================================================

DIRECTORY STRUCTURE:
--------------------------------------------------------------------------------
├── errors
│   └── ApiError.ts
├── BatchedQueue.ts
├── dataTypes.ts
├── dateHelpers.ts
├── DeferredPromise.ts
├── errors.ts
├── fuzzyMatch.test.ts
├── fuzzyMatch.ts
├── Logger.ts
├── PubSubTypes.ts
├── randomId.ts
├── routeHelpers.ts
├── shallowEqual.ts
├── sleep.ts
├── typeHelpers.ts
└── types.ts
================================================================================


================================================================================
File: BatchedQueue.ts
Lines: 54
--------------------------------------------------------------------------------
import { DeferredPromise } from "./DeferredPromise"

type Task<I, O> = {
	input: I
	output: DeferredPromise<O>
}

/** A useful tool for batching computation and working in parallel. */
export class BatchedQueue<I, O> {
	constructor(
		private args: {
			processBatch: (batch: I[]) => Promise<O[]>
			maxParallel: number
			maxBatchSize: number
			delayMs: number
		}
	) {}

	private tasks: Task<I, O>[] = []
	public enqueue(input: I): Promise<O> {
		const output = new DeferredPromise<O>()
		this.tasks.push({ input, output })

		setTimeout(() => void this.flush(), this.args.delayMs)

		return output.promise
	}

	activeBatches = 0

	private flush = async () => {
		if (this.tasks.length === 0) return
		if (this.activeBatches >= this.args.maxParallel) return

		this.activeBatches += 1

		const batch = this.tasks.splice(0, this.args.maxBatchSize)
		const inputs = batch.map((task) => task.input)

		try {
			const outputs = await this.args.processBatch(inputs)
			for (const [i, value] of outputs.entries()) {
				batch[i].output.resolve(value)
			}
		} catch (error) {
			for (const { output } of batch) {
				output.reject(error)
			}
		} finally {
			this.activeBatches -= 1
			void this.flush()
		}
	}
}

================================================================================
File: dataTypes.ts
Lines: 227
--------------------------------------------------------------------------------
// Define a Validator interface to match what's expected
export interface Validator<T> {
	validate(value: unknown): T;
}

// Create a custom validator function
export function createValidator<T>(
	validateFn: (value: unknown) => boolean,
	name: string
): Validator<T> {
	return {
		validate(value: unknown): T {
			if (validateFn(value)) {
				return value as T;
			}
			throw new Error(`Invalid ${name}: ${String(value)}`);
		}
	};
}

// Basic type validators
export const string = (): Validator<string> => 
	createValidator<string>((value) => typeof value === 'string', 'string');

export const number = (): Validator<number> => 
	createValidator<number>((value) => typeof value === 'number' && !isNaN(value), 'number');

export const boolean = (): Validator<boolean> => 
	createValidator<boolean>((value) => typeof value === 'boolean', 'boolean');

// Complex type validators
export function object<T extends Record<string, Validator<unknown>>>(schema: T): Validator<{
	[K in keyof T]: T[K] extends Validator<infer U> ? U : never;
}> {
	return {
		validate(value: unknown): { [K in keyof T]: T[K] extends Validator<infer U> ? U : never } {
			if (typeof value !== 'object' || value === null) {
				throw new Error(`Invalid object: ${String(value)}`);
			}

			const result: Record<string, unknown> = {};
			for (const key in schema) {
				if (Object.prototype.hasOwnProperty.call(schema, key)) {
					try {
						result[key] = schema[key].validate((value as Record<string, unknown>)[key]);
					} catch (error) {
						throw new Error(`Invalid property ${key}: ${(error as Error).message}`);
					}
				}
			}
			return result as { [K in keyof T]: T[K] extends Validator<infer U> ? U : never };
		}
	};
}

export function array<T>(itemValidator: Validator<T>): Validator<T[]> {
	return {
		validate(value: unknown): T[] {
			if (!Array.isArray(value)) {
				throw new Error(`Invalid array: ${String(value)}`);
			}

			return value.map((item, index) => {
				try {
					return itemValidator.validate(item);
				} catch (error) {
					throw new Error(`Invalid item at index ${index}: ${(error as Error).message}`);
				}
			});
		}
	};
}

// Optional and nullable validators
export function optional<T>(validator: Validator<T>): Validator<T | undefined> {
	return {
		validate(value: unknown): T | undefined {
			if (value === undefined) {
				return undefined;
			}
			return validator.validate(value);
		}
	};
}

export function nullable<T>(validator: Validator<T>): Validator<T | null> {
	return {
		validate(value: unknown): T | null {
			if (value === null) {
				return null;
			}
			return validator.validate(value);
		}
	};
}

// Union type validator
export function union<T extends unknown[]>(...validators: { [K in keyof T]: Validator<T[K]> }): Validator<T[number]> {
	return {
		validate(value: unknown): T[number] {
			for (const validator of validators) {
				try {
					return validator.validate(value);
				} catch {
					// Continue to next validator
				}
			}
			throw new Error(`Value does not match any of the expected types: ${String(value)}`);
		}
	};
}

// Literal value validator
export function literal<T extends string | number | boolean>(expectedValue: T): Validator<T> {
	return createValidator<T>(
		(value) => value === expectedValue,
		`literal value ${String(expectedValue)}`
	);
}

// Record validator
export function record<K extends string, V>(
	valueValidator: Validator<V>
): Validator<Record<K, V>> {
	return {
		validate(value: unknown): Record<K, V> {
			if (typeof value !== 'object' || value === null) {
				throw new Error(`Invalid record: ${String(value)}`);
			}

			const result: Record<string, V> = {};
			for (const key in value) {
				if (Object.prototype.hasOwnProperty.call(value, key)) {
					try {
						result[key] = valueValidator.validate((value as Record<string, unknown>)[key]);
					} catch (error) {
						throw new Error(`Invalid value for key ${key}: ${(error as Error).message}`);
					}
				}
			}
			return result as Record<K, V>;
		}
	};
}

// Tuple validator
export function tuple<T extends unknown[]>(...validators: { [K in keyof T]: Validator<T[K]> }): Validator<T> {
	return {
		validate(value: unknown): T {
			if (!Array.isArray(value)) {
				throw new Error(`Invalid tuple: ${String(value)}`);
			}

			if (value.length !== validators.length) {
				throw new Error(`Invalid tuple length: expected ${validators.length}, got ${value.length}`);
			}

			return validators.map((validator, index) => {
				try {
					return validator.validate(value[index]);
				} catch (error) {
					throw new Error(`Invalid tuple item at index ${index}: ${(error as Error).message}`);
				}
			}) as T;
		}
	};
}

// UUID validator
export const uuid = createValidator<string>(
	(value) => typeof value === 'string' && /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(value),
	'UUID'
);

// ISO 8601 datetime validator
export const datetime = createValidator<string>(
	(value) => typeof value === 'string' && /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?Z$/.test(value),
	'ISO 8601 datetime'
);

// Date validator
export const date = (): Validator<string> => 
	createValidator<string>(
		(value) => typeof value === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(value),
		'date in YYYY-MM-DD format'
	);

// Email validator
export const email = createValidator<string>(
	(value) => typeof value === 'string' && /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/.test(value),
	'Email'
);

// URL validator
export const url = (): Validator<string> => 
	createValidator<string>(
		(value) => {
			try {
				new URL(value as string);
				return true;
			} catch {
				return false;
			}
		},
		'URL'
	);

// Regex validator
export function regex(pattern: RegExp): Validator<string> {
	return createValidator<string>(
		(value) => typeof value === 'string' && pattern.test(value),
		`string matching pattern ${pattern}`
	);
}

// Custom validator
export function custom<T>(validateFn: (value: unknown) => boolean): Validator<T> {
	return createValidator<T>(validateFn, 'custom validation');
}

// Enumeration validator (renamed from 'enum' since it's a reserved word)
export function enumValues<T extends string | number>(...values: T[]): Validator<T> {
	return createValidator<T>(
		(value) => values.includes(value as T),
		`one of [${values.join(', ')}]`
	);
}

================================================================================
File: dateHelpers.ts
Lines: 34
--------------------------------------------------------------------------------
export const SecondMs = 1000
export const MinuteMs = 60 * SecondMs
export const HourMs = 60 * MinuteMs
export const DayMs = 24 * HourMs

export const MinuteS = 60
export const HourS = 60 * MinuteS
export const DayS = 24 * MinuteS

export function formatDate(isoDate: string) {
	const now = new Date()
	const target = new Date(isoDate)
	const diffMs = now.getTime() - target.getTime()
	const diffS = Math.floor(diffMs / 1000)
	const diffM = Math.floor(diffS / 60)
	const diffH = Math.floor(diffM / 60)
	const diffD = Math.floor(diffH / 24)

	// Format relative time
	if (diffS < 60) return 'just now'
	if (diffM < 60) return `${diffM} minute${diffM === 1 ? '' : 's'} ago`
	if (diffH < 24) return `${diffH} hour${diffH === 1 ? '' : 's'} ago`
	if (diffD < 7) return `${diffD} day${diffD === 1 ? '' : 's'} ago`

	// For older dates, use a more formal format
	const options: Intl.DateTimeFormatOptions = {
		year: 'numeric',
		month: 'short',
		day: 'numeric',
		hour: '2-digit',
		minute: '2-digit'
	}
	return target.toLocaleDateString(undefined, options)
}

================================================================================
File: DeferredPromise.ts
Lines: 12
--------------------------------------------------------------------------------
export class DeferredPromise<T> {
	public resolve!: (value: T | PromiseLike<T>) => void;
	public reject!: (reason?: unknown) => void;
	public promise: Promise<T>;

	constructor() {
		this.promise = new Promise<T>((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
	}
}

================================================================================
File: errors.ts
Lines: 28
--------------------------------------------------------------------------------
// Reference: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#client_error_responses

// These custom errors should never contain sensitive information in the message.
export class ValidationError extends Error {
	static statusCode = 400
	statusCode = 400
}

export class PermissionError extends Error {
	static statusCode = 403
	statusCode = 403
}

export class NotFoundError extends Error {
	static statusCode = 404
	statusCode = 404
}

export class TransactionConflictError extends Error {
	static statusCode = 409
	statusCode = 409
}

/** The request failed due to failure of a previous request. */
export class BrokenError extends Error {
	static statusCode = 424
	statusCode = 424
}

================================================================================
File: fuzzyMatch.test.ts
Lines: 46
--------------------------------------------------------------------------------
import { strict as assert } from "assert"
import { describe, it } from "@jest/globals"
import { fuzzyMatch } from "./fuzzyMatch"

describe("FuzzyMatch", () => {
	it("Matches a whole string", () => {
		const result = fuzzyMatch("abc", "abc")
		assert.ok(result)
		assert.deepEqual(result, [{ match: "abc" }])
	})

	it("Matches a prefix", () => {
		const result = fuzzyMatch("ab", "abc")
		assert.ok(result)
		assert.deepEqual(result, [{ match: "ab" }, { skip: "c" }])
	})

	it("Matches word gaps", () => {
		const result = fuzzyMatch("sil", "Simon Last")
		assert.ok(result)
		assert.deepEqual(result, [{ match: "Si" }, { skip: "mon " }, { match: "L" }, { skip: "ast" }])
	})

	it("Symbols treated like whitespace", () => {
		const result = fuzzyMatch("ac", "Apple-cinnamon")
		assert.ok(result)
		assert.deepEqual(result, [
			{ match: "A" },
			{ skip: "pple-" },
			{ match: "c" },
			{ skip: "innamon" },
		])
	})

	it("Backtracks when shared prefix", () => {
		const result = fuzzyMatch("im", "Insert image")
		assert.ok(result)
		assert.deepEqual(result, [{ skip: "Insert " }, { match: "im" }, { skip: "age" }])
	})

	it("Harder backtrack", () => {
		const result = fuzzyMatch("abcd", "abc bcd")
		assert.ok(result)
		assert.deepEqual(result, [{ match: "a" }, { skip: "bc " }, { match: "bcd" }])
	})
})

================================================================================
File: fuzzyMatch.ts
Lines: 64
--------------------------------------------------------------------------------
export interface MatchItem {
	text: string;
	matched: boolean;
}

export type FuzzyMatch = MatchItem[];

export function fuzzyMatch(query: string, text: string): FuzzyMatch | null {
	if (!query) return null;

	const result: MatchItem[] = [];
	let currentIndex = 0;
	let queryIndex = 0;

	while (currentIndex < text.length && queryIndex < query.length) {
		const queryChar = query[queryIndex].toLowerCase();
		const textChar = text[currentIndex].toLowerCase();

		if (queryChar === textChar) {
			result.push({
				text: text[currentIndex],
				matched: true,
			});
			queryIndex++;
		} else {
			result.push({
				text: text[currentIndex],
				matched: false,
			});
		}
		currentIndex++;
	}

	// Add remaining text as unmatched
	while (currentIndex < text.length) {
		result.push({
			text: text[currentIndex],
			matched: false,
		});
		currentIndex++;
	}

	// If we haven't matched all query characters, return null
	if (queryIndex < query.length) {
		return null;
	}

	return result;
}

export function fuzzyMatchScore(query: string, text: string): number {
	const match = fuzzyMatch(query, text);
	if (!match) return 0;

	const matchedChars = match.filter(item => item.matched).length;
	const consecutiveMatches = match.reduce((count, item, i) => {
		if (item.matched && i > 0 && match[i - 1].matched) {
			return count + 1;
		}
		return count;
	}, 0);

	return matchedChars + consecutiveMatches;
}

================================================================================
File: Logger.ts
Lines: 6
--------------------------------------------------------------------------------
export interface Logger {
  info(message: string, ...args: unknown[]): void;
  error(message: string, ...args: unknown[]): void;
  warn(message: string, ...args: unknown[]): void;
  debug(message: string, ...args: unknown[]): void;
} 
================================================================================
File: PubSubTypes.ts
Lines: 5
--------------------------------------------------------------------------------
export type ClientPubsubMessage =
	| { type: "subscribe"; key: string }
	| { type: "unsubscribe"; key: string }

export type ServerPubsubMessage = { type: "update"; key: string; value: unknown }

================================================================================
File: randomId.ts
Lines: 24
--------------------------------------------------------------------------------
import crypto from 'crypto'

/**
 * When you pass a seed string, then the uuid will be deterministic.
 */
export function randomId(seed?: string) {
	if (!seed) return crypto.randomUUID()

	// Create a deterministic UUID using the seed
	const hash = crypto.createHash('md5').update(seed).digest()
	
	// Set version (4) and variant bits as per UUID v4 spec
	hash[6] = (hash[6] & 0x0f) | 0x40 // version 4
	hash[8] = (hash[8] & 0x3f) | 0x80 // variant 1

	// Convert to UUID string format
	return [
		hash.subarray(0, 4).toString('hex'),
		hash.subarray(4, 6).toString('hex'),
		hash.subarray(6, 8).toString('hex'),
		hash.subarray(8, 10).toString('hex'),
		hash.subarray(10, 16).toString('hex'),
	].join('-')
}

================================================================================
File: routeHelpers.ts
Lines: 49
--------------------------------------------------------------------------------
export type RootRoute = { type: "root" }
export type DesignRoute = { type: "design"; page?: string }
export type UnknownRoute = { type: "unknown"; url: string }

export type Route = RootRoute | DesignRoute | UnknownRoute

export function parseRoute(url: string): Route {
	const parsed = new URL(url)
	if (parsed.pathname === "/") return { type: "root" }
	if (parsed.pathname === "/design") {
		const page = parsed.searchParams.get("page") || undefined
		return { type: "design", page }
	}
	return { type: "unknown", url }
}

export function formatRoute(route: Route) {
	if (route.type === "root") return "/"
	if (route.type === "design") {
		if (route.page) return "/design?page=" + route.page
		return "/design"
	}
}

// `/thread/:threadId` will return {threadId: string}
export function matchRoutePath(pattern: string, urlPath: string): Record<string, string> | undefined {
	const patternSegments = pattern.split("/")
	const urlSegments = urlPath.split("/")

	if (patternSegments.length !== urlSegments.length) {
		return undefined;
	}

	const params: Record<string, string> = {}

	for (let i = 0; i < patternSegments.length; i++) {
		const patternSegment = patternSegments[i]
		const urlSegment = urlSegments[i]

		if (patternSegment.startsWith(":")) {
			const key = patternSegment.slice(1)
			params[key] = urlSegment
		} else if (patternSegment !== urlSegment) {
			return undefined;
		}
	}

	return params
}

================================================================================
File: shallowEqual.ts
Lines: 18
--------------------------------------------------------------------------------
import { intersection, isArray, isPlainObject } from "lodash"

export function shallowEqual(a: unknown, b: unknown) {
	if (a == b) return true
	if (isArray(a)) {
		if (!isArray(b)) return false
		if (a.length !== b.length) return false
		return a.every((x, i) => b[i] === x)
	}
	if (isPlainObject(a)) {
		if (!isPlainObject(b)) return false
		const keys = Object.keys(a as Record<string, unknown>)
		const sameKeys = intersection(keys, Object.keys(b as Record<string, unknown>))
		if (keys.length !== sameKeys.length) return false
		return keys.every((key) => (a as Record<string, unknown>)[key] == (b as Record<string, unknown>)[key])
	}
	return false
}

================================================================================
File: sleep.ts
Lines: 3
--------------------------------------------------------------------------------
export function sleep(timeMs: number) {
	return new Promise<void>((resolve) => setTimeout(resolve, timeMs))
}

================================================================================
File: typeHelpers.ts
Lines: 3
--------------------------------------------------------------------------------
export type Simplify<T> = { [K in keyof T]: T[K] }

export type Assert<_A extends _B, _B> = _A extends _B ? _A : never;

================================================================================
File: types.ts
Lines: 4
--------------------------------------------------------------------------------
// Define the Validator interface
export interface Validator<T> {
  validate(value: unknown): T;
} 
================================================================================
File: errors\ApiError.ts
Lines: 55
--------------------------------------------------------------------------------
// src/shared/errors/ApiError.ts
export class ApiError extends Error {
    statusCode: number;
    errors?: Record<string, string[]>;
    
    constructor(statusCode: number, message: string, errors?: Record<string, string[]>) {
      super(message);
      this.statusCode = statusCode;
      this.errors = errors;
      this.name = this.constructor.name;
      Error.captureStackTrace(this, this.constructor);
    }
  }
  
  export class BadRequestError extends ApiError {
    constructor(message = 'Bad request', errors?: Record<string, string[]>) {
      super(400, message, errors);
    }
  }
  
  export class UnauthorizedError extends ApiError {
    constructor(message = 'Unauthorized') {
      super(401, message);
    }
  }
  
  export class ForbiddenError extends ApiError {
    constructor(message = 'Forbidden') {
      super(403, message);
    }
  }
  
  export class NotFoundError extends ApiError {
    constructor(message = 'Resource not found') {
      super(404, message);
    }
  }
  
  export class ConflictError extends ApiError {
    constructor(message = 'Conflict', errors?: Record<string, string[]>) {
      super(409, message, errors);
    }
  }
  
  export class InternalServerError extends ApiError {
    constructor(message = 'Internal server error') {
      super(500, message);
    }
  }

  export class TooManyRequestsError extends ApiError {
    constructor(message = 'Too many requests') {
      super(429, message);
    }
  }