CLIENT DIRECTORY SUMMARY
================================================================================
Total Files: 105
Total Lines: 14204
================================================================================

DIRECTORY STRUCTURE:
--------------------------------------------------------------------------------
├── components
│   ├── auth
│   │   ├── AuthContext.tsx
│   │   ├── AuthModal.tsx
│   │   ├── ConfirmEmail.tsx
│   │   ├── index.tsx
│   │   ├── LoginModal.tsx
│   │   ├── RegisterModal.tsx
│   │   ├── ResendVerification.tsx
│   │   └── VerificationModal.tsx
│   ├── layouts
│   │   ├── main-layout.css
│   │   ├── MainLayout.tsx
│   │   ├── page-content.css
│   │   └── PageContent.tsx
│   ├── media
│   │   ├── AudioPlayer.tsx
│   │   ├── ImageGallery.tsx
│   │   ├── MediaGallery.tsx
│   │   ├── mediaPlayer.tsx
│   │   ├── mediaUpload.tsx
│   │   ├── mediaView.tsx
│   │   └── VideoPlayer.tsx
│   ├── pages
│   │   ├── DashboardPage.tsx
│   │   ├── DesignPage.tsx
│   │   ├── ExplorePage.tsx
│   │   ├── HomePage.tsx
│   │   ├── MediaPage.tsx
│   │   ├── NotificationsPage.tsx
│   │   ├── ProfilePage.tsx
│   │   ├── SettingsPage.tsx
│   │   ├── SocialPage.tsx
│   │   └── UploadPage.tsx
│   ├── social
│   │   ├── Comments.tsx
│   │   ├── CommentSection.tsx
│   │   ├── CreatePost.tsx
│   │   ├── CreatePostForm.tsx
│   │   ├── Feed.tsx
│   │   ├── PostCard.tsx
│   │   ├── SocialFeed.tsx
│   │   ├── UserProfile.tsx
│   │   └── UserProfileCard.tsx
│   ├── theme
│   │   ├── index.ts
│   │   └── ThemeContext.tsx
│   ├── ui
│   │   ├── demos
│   │   │   ├── autoindex.ts
│   │   │   ├── BadgeDemo.tsx
│   │   │   ├── ButtonDemo.tsx
│   │   │   ├── CalendarDemo.tsx
│   │   │   ├── ComboBoxDemo.tsx
│   │   │   ├── DropdownDemo.tsx
│   │   │   ├── FileUploadDemo.tsx
│   │   │   ├── FormDemo.tsx
│   │   │   ├── FuzzyStringDemo.tsx
│   │   │   ├── ListBoxDemo.tsx
│   │   │   ├── PopupDemo.tsx
│   │   │   ├── SpinnerDemo.tsx
│   │   │   └── TokenInputDemo.tsx
│   │   ├── Badge.tsx
│   │   ├── button.css
│   │   ├── Button.tsx
│   │   ├── Card.tsx
│   │   ├── ComboBox.tsx
│   │   ├── DropdownMenu.tsx
│   │   ├── FileUpload.tsx
│   │   ├── FuzzyString.tsx
│   │   ├── Input.tsx
│   │   ├── Link.tsx
│   │   ├── ListBox.tsx
│   │   ├── MenuItem.tsx
│   │   ├── OfflineBadge.tsx
│   │   ├── Popup.tsx
│   │   ├── Spinner.tsx
│   │   └── Throttle.tsx
│   ├── Design.tsx
│   ├── Link.tsx
│   └── Root.tsx
├── config
│   └── environment.ts
├── contexts
│   └── SocialContext.tsx
├── helpers
│   ├── cookieHelpers.ts
│   ├── focusHelpers.ts
│   ├── formatters.ts
│   ├── mergeEvents.ts
│   └── passthroughRef.tsx
├── hooks
│   ├── useAsync.ts
│   ├── useCounter.ts
│   ├── useOnline.ts
│   ├── usePopper.ts
│   ├── useRefCurrent.ts
│   ├── useRefPrevious.ts
│   ├── useShortcut.ts
│   └── useSocialInteractions.ts
├── public
│   ├── icons
│   │   ├── apple-touch-icon.png
│   │   ├── favicon.ico
│   │   ├── favicon.svg
│   │   ├── logo192.png
│   │   └── logo512.png
│   ├── favicon.ico
│   ├── manifest.json
│   ├── robots.txt
│   └── service-worker.js
├── services
│   ├── api.ts
│   ├── AuthClient.ts
│   ├── ClientConfig.ts
│   ├── ClientEnvironment.tsx
│   ├── Router.ts
│   ├── social.ts
│   ├── types.ts
│   └── WebsocketPubsubClient.ts
├── test
│   ├── base.e2e.ts
│   └── base.test.ts
├── utils
│   └── styleUtils.ts
├── index.css
├── index.html
├── index.tsx
├── service-worker.js
└── styles.ts
================================================================================


================================================================================
File: index.css
Lines: 226
--------------------------------------------------------------------------------
body,
html {
	margin: 0px;
	padding: 0px;
	font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial,
		sans-serif, "Segoe UI Emoji", "Segoe UI Symbol";
}

body,
input,
button {
	font-size: 18px;
}

*,
*::after,
*::before {
	box-sizing: border-box;
}

/* Define theme variables */
:root {
	/* Light theme (default) */
	--background: #ffffff;
	--background2: rgba(242, 242, 247, 1);
	--background3: rgba(255, 255, 255, 1);
	--surface: #f5f5f5;
	--surface-variant: #e0e0e0;
	--text-primary: #212121;
	--text-secondary: #757575;
	--text-color: rgba(0, 0, 0, 1);
	--text-color2: rgba(61, 61, 66, 0.6);
	--text-color3: rgba(61, 61, 66, 0.3);
	--text-color4: rgba(61, 61, 66, 0.18);
	--accent: #2196f3;
	--blue: #2196f3;
	--green: #4caf50;
	--red: #f44336;
	--yellow: #ffeb3b;
	--purple: #9c27b0;
	--indigo: rgba(89, 87, 214, 1);
	--orange: rgba(255, 148, 0, 1);
	--pink: rgba(255, 46, 84, 1);
	--teal: rgba(89, 199, 250, 1);
	--gray: rgba(143, 143, 148, 1);
	--gray2: rgba(173, 173, 179, 1);
	--gray3: rgba(199, 199, 204, 1);
	--gray4: rgba(209, 209, 214, 1);
	--gray5: rgba(230, 230, 235, 1);
	--gray6: rgba(242, 242, 247, 1);
	--transparent1: rgba(0, 0, 0, 0.1);
	--transparent2: rgba(0, 0, 0, 0.2);
	--transparent3: rgba(0, 0, 18, 0.3);
	--transparent4: rgba(0, 0, 18, 0.4);
	--placeholder: rgba(61, 61, 66, 0.3);
	--separator: rgba(61, 61, 66, 0.29);
	--separator-opaque: rgba(199, 199, 199, 1);
	--hover: rgba(0, 122, 255, 0.3);
	--active: rgba(0, 122, 255, 0.5);
	--shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
	--card-bg: #ffffff;
	--border-color: #e0e0e0;
	--popup-background: var(--background);
}

/* Dark theme */
[data-theme="dark"] {
	--background: #121212;
	--background2: rgb(36, 36, 40);
	--background3: rgb(48, 48, 52);
	--surface: #1e1e1e;
	--surface-variant: #2d2d2d;
	--text-primary: #ffffff;
	--text-secondary: #b0b0b0;
	--text-color: rgba(255, 255, 255, 1);
	--text-color2: rgba(235, 235, 245, 0.6);
	--text-color3: rgba(235, 235, 245, 0.3);
	--text-color4: rgba(235, 235, 245, 0.18);
	--accent: #64b5f6;
	--blue: #64b5f6;
	--green: #81c784;
	--red: #e57373;
	--yellow: #fff176;
	--purple: #ba68c8;
	--indigo: rgba(94, 92, 230, 1);
	--orange: rgba(255, 158, 10, 1);
	--pink: rgba(255, 56, 94, 1);
	--teal: rgba(99, 209, 255, 1);
	--gray: rgba(143, 143, 148, 1);
	--gray2: rgba(99, 99, 102, 1);
	--gray3: rgba(71, 71, 74, 1);
	--gray4: rgba(59, 59, 61, 1);
	--gray5: rgba(43, 43, 46, 1);
	--gray6: rgba(28, 28, 31, 1);
	--transparent1: rgba(255, 255, 255, 0.1);
	--transparent2: rgba(255, 255, 255, 0.2);
	--transparent3: rgba(243, 243, 255, 0.3);
	--transparent4: rgba(243, 243, 255, 0.4);
	--placeholder: rgba(235, 235, 245, 0.3);
	--separator: rgba(84, 84, 89, 0.6);
	--separator-opaque: rgba(56, 56, 59, 1);
	--hover: rgba(10, 133, 255, 0.3);
	--active: rgba(10, 133, 255, 0.5);
	--shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
	--card-bg: #2d2d2d;
	--border-color: #444444;
	--popup-background: var(--background2);
}

/* Apply theme to body */
body {
	background-color: var(--background);
	color: var(--text-primary);
	transition: background-color 0.3s ease, color 0.3s ease;
	margin: 0;
}

html,
body {
	background: var(--background);
	color: var(--text-color);
}

input {
	color: var(--text-color);
}

input::placeholder {
	color: var(--placeholder);
}

a {
	color: var(--blue);
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

.feedback:hover {
	background-color: var(--hover);
}
.feedback:active {
	background-color: var(--active);
}

input,
button {
	background: transparent;
}

/* Spinner animation */
@keyframes rotation {
	from {
		-webkit-transform: rotate(0deg);
	}
	to {
		-webkit-transform: rotate(360deg);
	}
}

.spinner {
	width: 40px;
	height: 40px;
	border: 4px solid var(--transparent1);
	border-top: 4px solid var(--blue);
	border-radius: 50%;
	display: inline-block;
	box-sizing: border-box;
	animation: rotation 1s linear infinite;
	margin: 0 auto;
}

button:focus,
input:focus,
div:focus {
	outline: 2px solid var(--orange);
	outline-offset: -2px;
}

/* Basic styles */
code {
	font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
		monospace;
}

/* Card styles */
.card {
	background-color: var(--card-bg);
	border-radius: 8px;
	padding: 16px;
	box-shadow: var(--shadow);
	border: 1px solid var(--border-color);
}

/* Button styles */
button {
	cursor: pointer;
}

/* Input styles */
input, textarea, select {
	background-color: var(--surface);
	color: var(--text-primary);
	border: 1px solid var(--border-color);
}

/* Scrollbar styles */
::-webkit-scrollbar {
	width: 8px;
	height: 8px;
}

::-webkit-scrollbar-track {
	background: var(--surface);
}

::-webkit-scrollbar-thumb {
	background: var(--transparent2);
	border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
	background: var(--transparent1);
} 
================================================================================
File: index.html
Lines: 12
--------------------------------------------------------------------------------
<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>ABE Stack</title>
	</head>
	<body>
		<div id="root"></div>
		<script type="module" src="./index.tsx"></script>
	</body>
</html> 
================================================================================
File: index.tsx
Lines: 131
--------------------------------------------------------------------------------
import React from 'react';
import { createRoot } from 'react-dom/client';

import './index.css';
import { Root } from './components/Root';
import { createApi } from './services/api';
import { Router } from './services/Router';
import { WebsocketPubsubClient } from './services/WebsocketPubsubClient';

// Function to get the server port
const getServerPort = (): number => {
  // In production, use the same port as the client
  if (process.env.NODE_ENV === 'production') {
    return window.location.port ? parseInt(window.location.port) : 80;
  }
  
  // In development, try to find the server port
  // First, check if we can read the port from localStorage (set by previous successful connections)
  const savedPort = localStorage.getItem('server_port');
  if (savedPort) {
    return parseInt(savedPort);
  }
  
  // Default to 8080 for the server in development
  return 8080;
};

// Create client configuration
const clientConfig = {
  apiUrl: process.env.NODE_ENV === 'production' 
    ? '/api' 
    : `${window.location.protocol}//${window.location.hostname}:${getServerPort()}/api`,
  wsUrl: process.env.NODE_ENV === 'production'
    ? `ws://${window.location.host}/ws`
    : `ws://${window.location.hostname}:${getServerPort()}/ws`,
  production: process.env.NODE_ENV === 'production',
  host: window.location.host
};

// Add a function to test API connectivity and update port if needed
const testApiConnectivity = async () => {
  if (process.env.NODE_ENV === 'production') {
    return; // No need to test in production
  }
  
  // Try to connect to the API
  try {
    const response = await fetch(clientConfig.apiUrl);
    if (response.ok) {
      // Connection successful, save the port
      const port = new URL(clientConfig.apiUrl).port;
      localStorage.setItem('server_port', port);
      return;
    }
  } catch (error) {
    console.warn('Failed to connect to API, trying alternative ports...');
  }
  
  // If connection failed, try alternative ports
  // Try server ports first (8080-8085), then try client ports (3000-3005) in case server is running there
  const alternativePorts = [8080, 8081, 8082, 8083, 8084, 8085, 3000, 3001, 3002, 3003, 3004, 3005];
  
  for (const port of alternativePorts) {
    try {
      const testUrl = `${window.location.protocol}//${window.location.hostname}:${port}/api`;
      const response = await fetch(testUrl);
      
      if (response.ok) {
        // Found a working port, update config and save it
        console.log(`Connected to API on port ${port}`);
        clientConfig.apiUrl = testUrl;
        clientConfig.wsUrl = `ws://${window.location.hostname}:${port}/ws`;
        localStorage.setItem('server_port', port.toString());
        break;
      }
    } catch (error) {
      console.warn(`Failed to connect on port ${port}`);
    }
  }
};

// Initialize services
const router = new Router();
const api = createApi();
const pubsub = new WebsocketPubsubClient({
  config: clientConfig,
  onStart: () => {
    console.log('WebSocket connected');
  },
  onChange: (key, value) => {
    console.log('Data changed:', key, value);
  }
});

// Test API connectivity when the app starts
void testApiConnectivity().then(() => {
  console.log('API connectivity test completed');
});

// Create client environment
const environment = {
  config: clientConfig,
  router,
  api,
  pubsub
};

// Make environment available globally for debugging
interface WindowWithEnvironment extends Window {
  router: typeof router;
  api: typeof api;
  pubsub: typeof pubsub;
  environment: typeof environment;
}

(window as unknown as WindowWithEnvironment).router = router;
(window as unknown as WindowWithEnvironment).api = api;
(window as unknown as WindowWithEnvironment).pubsub = pubsub;
(window as unknown as WindowWithEnvironment).environment = environment;

// Find root element
const rootElement = document.getElementById('root');
if (!rootElement) throw new Error('Failed to find the root element');

// Render the app
const root = createRoot(rootElement);
root.render(
  <React.StrictMode>
    <Root environment={environment} />
  </React.StrictMode>
);
================================================================================
File: service-worker.js
Lines: 87
--------------------------------------------------------------------------------
const ASSETS_CACHE = "app-assets-v1"
const IMAGES_CACHE = "static-simages-v1" // TODO
const cacheWhitelist = [ASSETS_CACHE, IMAGES_CACHE]

// Perform install steps
self.addEventListener("install", function (event) {
	event.waitUntil(
		caches.open(ASSETS_CACHE).then(function (cache) {
			// Fetch and cache these assets on the first install.
			return cache.addAll(["/", "/index.css", "/index.js"])
		})
	)
})

// Delete any old caches.
self.addEventListener("activate", function (event) {
	event.waitUntil(
		caches.keys().then(function (cacheNames) {
			return Promise.all(
				cacheNames.map(function (cacheName) {
					if (cacheWhitelist.indexOf(cacheName) === -1) {
						return caches.delete(cacheName)
					}
				})
			)
		})
	)
})

// TODO: add a request timeout.

// Always fetch when online, only use the cache as an offline fallback.
self.addEventListener("fetch", function (event) {
	event.respondWith(
		// Fetch from the network in case we're online.
		fetch(event.request)
			.then((response) => {
				// Don't cache bad responses.
				if (!response) return response
				if (response.status !== 200) return response
				if (response.type !== "basic") return response

				// Only cache GET requests.
				if (event.request.method !== "GET") return response

				// Only cache responses from the origin.
				// if (!event.request.url.startsWith(self.origin)) return response

				// Only cache the basic website assets.
				// TODO: favicon? fonts?
				const validMimeTypes = ["text/html", "application/javascript", "text/css"]
				const contentType = response.headers.get("Content-Type")
				if (!contentType) return response
				if (!validMimeTypes.some((mimeType) => contentType.includes(mimeType))) return response

				// IMPORTANT: Clone the response. A response is a stream
				// and because we want the browser to consume the response
				// as well as the cache consuming the response, we need
				// to clone it so we have two streams.
				var responseToCache = response.clone()

				// Cache the response for offline.
				caches.open(ASSETS_CACHE).then(function (cache) {
					cache.put(event.request, responseToCache)
				})
				return response
			})
			.catch(function (error) {
				// If we're offline return the cached response.
				return caches.match(event.request).then((cachedResponse) => {
					if (cachedResponse) return cachedResponse

					// Check if request is for an HTML document (or navigation request)
					// appropriate for HTML5 routing used by single page applications.
					if (
						event.request.mode === "navigate" ||
						(event.request.method === "GET" &&
							event.request.headers.get("accept").includes("text/html"))
					) {
						return caches.match("/")
					}

					return Promise.reject(error)
				})
			})
	)
}) 
================================================================================
File: styles.ts
Lines: 593
--------------------------------------------------------------------------------
// Global styles for the application
export const globalStyles = {
  // Base styles
  body: {
    margin: '0px',
    padding: '0px',
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"',
    background: 'var(--background)',
    color: 'var(--text-color)',
  },
  bodyInputButton: {
    fontSize: '18px',
  },
  boxSizing: {
    boxSizing: 'border-box',
  },
  
  // Variables
  variables: {
    light: {
      background: 'rgba(255, 255, 255, 1)',
      background2: 'rgba(242, 242, 247, 1)',
      background3: 'rgba(255, 255, 255, 1)',
      transparent1: 'rgba(0, 0, 18, 0.1)',
      transparent2: 'rgba(0, 0, 18, 0.2)',
      transparent3: 'rgba(0, 0, 18, 0.3)',
      transparent4: 'rgba(0, 0, 18, 0.4)',
      textColor: 'rgba(0, 0, 0, 1)',
      textColor2: 'rgba(61, 61, 66, 0.6)',
      textColor3: 'rgba(61, 61, 66, 0.3)',
      textColor4: 'rgba(61, 61, 66, 0.18)',
      placeholder: 'rgba(61, 61, 66, 0.3)',
      separator: 'rgba(61, 61, 66, 0.29)',
      separatorOpaque: 'rgba(199, 199, 199, 1)',
      hover: 'rgba(0, 122, 255, 0.3)',
      active: 'rgba(0, 122, 255, 0.5)',
      blue: 'rgba(0, 122, 255, 1)',
      green: 'rgba(51, 199, 89, 1)',
      indigo: 'rgba(89, 87, 214, 1)',
      orange: 'rgba(255, 148, 0, 1)',
      pink: 'rgba(255, 46, 84, 1)',
      purple: 'rgba(176, 82, 222, 1)',
      red: 'rgba(255, 59, 48, 1)',
      teal: 'rgba(89, 199, 250, 1)',
      yellow: 'rgba(255, 204, 0, 1)',
      gray: 'rgba(143, 143, 148, 1)',
      gray2: 'rgba(173, 173, 179, 1)',
      gray3: 'rgba(199, 199, 204, 1)',
      gray4: 'rgba(209, 209, 214, 1)',
      gray5: 'rgba(230, 230, 235, 1)',
      gray6: 'rgba(242, 242, 247, 1)',
      popupBackground: 'var(--background)',
      shadow: 'rgba(15, 15, 15, 0.05) 0px 0px 0px 1px, rgba(15, 15, 15, 0.1) 0px 3px 6px, rgba(15, 15, 15, 0.2) 0px 9px 24px',
    },
    dark: {
      background: 'rgba(0, 0, 0, 1)',
      background2: 'rgb(36, 36, 40)',
      background3: 'rgb(48, 48, 52)',
      transparent1: 'rgba(243, 243, 255, 0.1)',
      transparent2: 'rgba(243, 243, 255, 0.2)',
      transparent3: 'rgba(243, 243, 255, 0.3)',
      transparent4: 'rgba(243, 243, 255, 0.4)',
      textColor: 'rgba(255, 255, 255, 1)',
      textColor2: 'rgba(235, 235, 245, 0.6)',
      textColor3: 'rgba(235, 235, 245, 0.3)',
      textColor4: 'rgba(235, 235, 245, 0.18)',
      placeholder: 'rgba(235, 235, 245, 0.3)',
      separator: 'rgba(84, 84, 89, 0.6)',
      separatorOpaque: 'rgba(56, 56, 59, 1)',
      hover: 'rgba(10, 133, 255, 0.3)',
      active: 'rgba(10, 133, 255, 0.5)',
      blue: 'rgba(10, 133, 255, 1)',
      green: 'rgba(48, 209, 89, 1)',
      indigo: 'rgba(94, 92, 230, 1)',
      orange: 'rgba(255, 158, 10, 1)',
      pink: 'rgba(255, 56, 94, 1)',
      purple: 'rgba(191, 89, 242, 1)',
      red: 'rgba(255, 69, 59, 1)',
      teal: 'rgba(99, 209, 255, 1)',
      yellow: 'rgba(255, 214, 10, 1)',
      gray: 'rgba(143, 143, 148, 1)',
      gray2: 'rgba(99, 99, 102, 1)',
      gray3: 'rgba(71, 71, 74, 1)',
      gray4: 'rgba(59, 59, 61, 1)',
      gray5: 'rgba(43, 43, 46, 1)',
      gray6: 'rgba(28, 28, 31, 1)',
      popupBackground: 'var(--background2)',
      shadow: 'rgba(255, 255, 255, 0.2) 0px 0px 0px 1px, rgba(15, 15, 15, 0.1) 0px 3px 6px, rgba(15, 15, 15, 0.2) 0px 9px 24px',
    }
  },
  
  // Form elements
  input: {
    color: 'var(--text-color)',
    background: 'transparent',
  },
  inputPlaceholder: {
    color: 'var(--placeholder)',
  },
  button: {
    background: 'transparent',
  },
  
  // Links
  a: {
    color: 'var(--text-color2)',
  },
  
  // Feedback states
  feedbackHover: {
    backgroundColor: 'var(--hover)',
  },
  feedbackActive: {
    backgroundColor: 'var(--active)',
  },
  
  // Focus states
  focus: {
    outline: '2px solid var(--orange)',
    outlineOffset: '-2px',
  },
  
  // Spinner animation
  spinner: {
    width: '1.25em',
    height: '1.25em',
    border: '0.15em solid var(--text-color2)',
    borderBottomColor: 'transparent',
    borderRadius: '100%',
    display: 'inline-block',
    boxSizing: 'border-box',
    animation: 'rotation 800ms linear infinite',
  },
  keyframes: {
    rotation: {
      from: {
        transform: 'rotate(0deg)',
      },
      to: {
        transform: 'rotate(360deg)',
      },
    },
  },
};

// Image Gallery styles
export const imageGalleryStyles = {
  imageGallery: {
    position: 'relative',
    width: '100%',
    maxWidth: '100%',
    overflow: 'hidden',
    background: 'var(--background3)',
    borderRadius: '8px',
    boxShadow: '0 2px 8px rgba(0, 0, 0, 0.1)',
  },
  galleryMain: {
    position: 'relative',
    width: '100%',
    height: '100%',
    display: 'flex',
    overflow: 'hidden',
  },
  galleryImageContainer: {
    minWidth: '100%',
    height: '100%',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    transition: 'transform 0.3s ease',
  },
  galleryImage: {
    maxWidth: '100%',
    maxHeight: '100%',
    objectFit: 'contain',
    userSelect: 'none',
  },
  galleryNav: {
    position: 'absolute',
    top: '50%',
    transform: 'translateY(-50%)',
    background: 'rgba(0, 0, 0, 0.5)',
    color: 'white',
    border: 'none',
    width: '40px',
    height: '40px',
    borderRadius: '50%',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    cursor: 'pointer',
    opacity: 0.7,
    transition: 'opacity 0.2s',
    zIndex: 10,
  },
  galleryNavHover: {
    opacity: 1,
  },
  galleryPrev: {
    left: '10px',
  },
  galleryNext: {
    right: '10px',
  },
  galleryFullscreen: {
    position: 'absolute',
    top: '10px',
    right: '10px',
    background: 'rgba(0, 0, 0, 0.5)',
    color: 'white',
    border: 'none',
    width: '40px',
    height: '40px',
    borderRadius: '50%',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    cursor: 'pointer',
    opacity: 0.7,
    transition: 'opacity 0.2s',
    zIndex: 10,
  },
  galleryFullscreenHover: {
    opacity: 1,
  },
  galleryThumbnails: {
    display: 'flex',
    padding: '10px',
    overflowX: 'auto',
    scrollbarWidth: 'thin',
  },
  galleryThumbnail: {
    width: '60px',
    height: '60px',
    flexShrink: 0,
    marginRight: '8px',
    borderRadius: '4px',
    overflow: 'hidden',
    opacity: 0.7,
    cursor: 'pointer',
    transition: 'opacity 0.2s',
    border: '2px solid transparent',
  },
  galleryThumbnailHover: {
    opacity: 0.9,
  },
  galleryThumbnailActive: {
    opacity: 1,
    borderColor: 'var(--blue, #1a73e8)',
  },
  galleryThumbnailImg: {
    width: '100%',
    height: '100%',
    objectFit: 'cover',
  },
  galleryIndicators: {
    position: 'absolute',
    bottom: '15px',
    left: '50%',
    transform: 'translateX(-50%)',
    display: 'flex',
    gap: '8px',
    zIndex: 10,
  },
  galleryIndicator: {
    width: '8px',
    height: '8px',
    borderRadius: '50%',
    background: 'white',
    opacity: 0.5,
    border: 'none',
    padding: 0,
    cursor: 'pointer',
    transition: 'opacity 0.2s, transform 0.2s',
  },
  galleryIndicatorActive: {
    opacity: 1,
    transform: 'scale(1.2)',
  },
  imageGalleryFullscreen: {
    width: '100vw !important',
    height: '100vh !important',
    maxWidth: '100vw',
    maxHeight: '100vh',
    background: 'black',
  },
  imageGalleryFullscreenImage: {
    maxHeight: '90vh',
  },
};

// Video Player styles
export const videoPlayerStyles = {
  videoPlayer: {
    position: 'relative',
    width: '100%',
    maxWidth: '100%',
    background: 'var(--background2)',
    borderRadius: '12px',
    overflow: 'hidden',
    boxShadow: '0 4px 12px rgba(0, 0, 0, 0.1)',
  },
  videoContainer: {
    position: 'relative',
    width: '100%',
    background: '#000',
  },
  videoElement: {
    width: '100%',
    display: 'block',
  },
  videoOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    width: '100%',
    height: '100%',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    background: 'rgba(0, 0, 0, 0.3)',
    opacity: 0,
    transition: 'opacity 0.3s',
  },
  videoOverlayVisible: {
    opacity: 1,
  },
  playButton: {
    width: '60px',
    height: '60px',
    borderRadius: '50%',
    background: 'rgba(0, 0, 0, 0.7)',
    border: 'none',
    color: 'white',
    fontSize: '24px',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    cursor: 'pointer',
    transition: 'transform 0.2s, background 0.2s',
  },
  playButtonHover: {
    transform: 'scale(1.1)',
    background: 'rgba(0, 0, 0, 0.8)',
  },
  controls: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    width: '100%',
    padding: '10px',
    background: 'linear-gradient(transparent, rgba(0, 0, 0, 0.7))',
    display: 'flex',
    flexDirection: 'column',
    gap: '10px',
    opacity: 0,
    transition: 'opacity 0.3s',
  },
  controlsVisible: {
    opacity: 1,
  },
  progressContainer: {
    width: '100%',
    height: '5px',
    background: 'rgba(255, 255, 255, 0.3)',
    borderRadius: '3px',
    cursor: 'pointer',
    position: 'relative',
  },
  progressBar: {
    height: '100%',
    background: 'var(--blue, #1a73e8)',
    borderRadius: '3px',
    position: 'absolute',
    top: 0,
    left: 0,
  },
  controlsRow: {
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'space-between',
    color: 'white',
  },
  controlsGroup: {
    display: 'flex',
    alignItems: 'center',
    gap: '15px',
  },
  controlButton: {
    background: 'transparent',
    border: 'none',
    color: 'white',
    cursor: 'pointer',
    width: '30px',
    height: '30px',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    fontSize: '16px',
    opacity: 0.8,
    transition: 'opacity 0.2s',
  },
  controlButtonHover: {
    opacity: 1,
  },
  timeDisplay: {
    fontSize: '14px',
    opacity: 0.9,
  },
  volumeContainer: {
    display: 'flex',
    alignItems: 'center',
    gap: '5px',
  },
  volumeSlider: {
    width: '60px',
    height: '5px',
    WebkitAppearance: 'none',
    background: 'rgba(255, 255, 255, 0.3)',
    borderRadius: '3px',
    outline: 'none',
  },
  volumeSliderThumb: {
    WebkitAppearance: 'none',
    width: '12px',
    height: '12px',
    borderRadius: '50%',
    background: 'white',
    cursor: 'pointer',
  },
  fullscreenButton: {
    marginLeft: '10px',
  },
};

// Social Feed styles
export const socialFeedStyles = {
  socialFeed: {
    width: '100%',
    maxWidth: '600px',
    margin: '0 auto',
  },
  feedHeader: {
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginBottom: '20px',
  },
  feedTitle: {
    fontSize: '1.5rem',
    fontWeight: 600,
    color: 'var(--text-color)',
  },
  feedFilter: {
    display: 'flex',
    gap: '10px',
  },
  filterButton: {
    background: 'var(--background2)',
    border: 'none',
    padding: '8px 15px',
    borderRadius: '20px',
    fontSize: '0.9rem',
    color: 'var(--text-color2)',
    cursor: 'pointer',
    transition: 'background-color 0.2s, color 0.2s',
  },
  filterButtonHover: {
    background: 'var(--hover)',
  },
  filterButtonActive: {
    background: 'var(--blue)',
    color: 'white',
  },
  postList: {
    display: 'flex',
    flexDirection: 'column',
    gap: '20px',
  },
  postCard: {
    background: 'var(--background2)',
    borderRadius: '12px',
    overflow: 'hidden',
    boxShadow: '0 2px 8px rgba(0, 0, 0, 0.1)',
  },
  postHeader: {
    display: 'flex',
    alignItems: 'center',
    padding: '15px',
  },
  postAvatar: {
    width: '40px',
    height: '40px',
    borderRadius: '50%',
    overflow: 'hidden',
    marginRight: '12px',
  },
  postAvatarImg: {
    width: '100%',
    height: '100%',
    objectFit: 'cover',
  },
  postUserInfo: {
    flex: 1,
  },
  postUsername: {
    fontWeight: 600,
    color: 'var(--text-color)',
    margin: 0,
  },
  postTime: {
    fontSize: '0.8rem',
    color: 'var(--text-color2)',
    margin: 0,
  },
  postOptions: {
    color: 'var(--text-color2)',
    background: 'transparent',
    border: 'none',
    cursor: 'pointer',
    padding: '5px',
    borderRadius: '50%',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
  },
  postOptionsHover: {
    background: 'var(--hover)',
  },
  postContent: {
    padding: '0 15px 15px',
    color: 'var(--text-color)',
    whiteSpace: 'pre-wrap',
  },
  postMedia: {
    width: '100%',
    maxHeight: '500px',
    overflow: 'hidden',
    marginBottom: '15px',
  },
  postMediaImg: {
    width: '100%',
    objectFit: 'contain',
  },
  postActions: {
    display: 'flex',
    padding: '10px 15px',
    borderTop: '1px solid var(--border)',
  },
  postAction: {
    display: 'flex',
    alignItems: 'center',
    gap: '5px',
    marginRight: '20px',
    color: 'var(--text-color2)',
    background: 'transparent',
    border: 'none',
    cursor: 'pointer',
    padding: '5px',
    borderRadius: '5px',
    fontSize: '0.9rem',
  },
  postActionHover: {
    background: 'var(--hover)',
  },
  postActionLiked: {
    color: 'var(--red)',
  },
  loadMore: {
    background: 'var(--background2)',
    border: 'none',
    padding: '10px 20px',
    borderRadius: '20px',
    color: 'var(--text-color)',
    cursor: 'pointer',
    margin: '20px auto',
    display: 'block',
    transition: 'background-color 0.2s',
  },
  loadMoreHover: {
    background: 'var(--hover)',
  },
  emptyFeed: {
    textAlign: 'center',
    padding: '40px 0',
    color: 'var(--text-color2)',
  },
  loadingIndicator: {
    textAlign: 'center',
    padding: '20px 0',
    color: 'var(--text-color2)',
  },
}; 
================================================================================
File: components\Design.tsx
Lines: 142
--------------------------------------------------------------------------------
import { useClientEnvironment } from '../services/ClientEnvironment';

export function Design({ page }: { page: string }) {
	const environment = useClientEnvironment();
	
	return (
		<div style={{ padding: '2rem' }}>
			<h1>Design System</h1>
			
			<div style={{ marginBottom: '2rem' }}>
				<button 
					onClick={() => environment.router.navigate('/')}
					style={{
						padding: '8px 16px',
						backgroundColor: 'var(--blue)',
						color: 'white',
						border: 'none',
						borderRadius: '4px',
						cursor: 'pointer'
					}}
				>
					Back to Home
				</button>
			</div>
			
			{renderPage(page)}
		</div>
	);
}

function renderPage(page: string) {
	switch (page) {
		case 'colors':
			return <ColorsPage />;
		case 'typography':
			return <TypographyPage />;
		case 'buttons':
			return <ButtonsPage />;
		default:
			return (
				<div>
					<h2>Design System Pages</h2>
					<ul>
						<li>
							<a href="/design/colors" style={{ color: 'var(--blue)' }}>Colors</a>
						</li>
						<li>
							<a href="/design/typography" style={{ color: 'var(--blue)' }}>Typography</a>
						</li>
						<li>
							<a href="/design/buttons" style={{ color: 'var(--blue)' }}>Buttons</a>
						</li>
					</ul>
				</div>
			);
	}
}

function ColorsPage() {
	return (
		<div>
			<h2>Colors</h2>
			<div style={{ display: 'flex', flexWrap: 'wrap', gap: '1rem' }}>
				{['blue', 'green', 'red', 'orange', 'purple', 'teal'].map(color => (
					<div key={color} style={{ width: '150px' }}>
						<div 
							style={{ 
								height: '100px', 
								backgroundColor: `var(--${color})`,
								borderRadius: '4px',
								marginBottom: '0.5rem'
							}} 
						/>
						<div>{color}</div>
					</div>
				))}
			</div>
		</div>
	);
}

function TypographyPage() {
	return (
		<div>
			<h2>Typography</h2>
			<h1>Heading 1</h1>
			<h2>Heading 2</h2>
			<h3>Heading 3</h3>
			<h4>Heading 4</h4>
			<p>Regular paragraph text</p>
			<p><small>Small text</small></p>
			<p><strong>Bold text</strong></p>
			<p><em>Italic text</em></p>
		</div>
	);
}

function ButtonsPage() {
	return (
		<div>
			<h2>Buttons</h2>
			<div style={{ display: 'flex', gap: '1rem', marginBottom: '1rem' }}>
				<button 
					style={{
						padding: '8px 16px',
						backgroundColor: 'var(--blue)',
						color: 'white',
						border: 'none',
						borderRadius: '4px',
						cursor: 'pointer'
					}}
				>
					Primary
				</button>
				<button 
					style={{
						padding: '8px 16px',
						backgroundColor: 'transparent',
						color: 'var(--blue)',
						border: '1px solid var(--blue)',
						borderRadius: '4px',
						cursor: 'pointer'
					}}
				>
					Secondary
				</button>
				<button 
					style={{
						padding: '8px 16px',
						backgroundColor: 'var(--red)',
						color: 'white',
						border: 'none',
						borderRadius: '4px',
						cursor: 'pointer'
					}}
				>
					Danger
				</button>
			</div>
		</div>
	);
}

================================================================================
File: components\Link.tsx
Lines: 20
--------------------------------------------------------------------------------
import React, { ComponentPropsWithoutRef } from 'react';
import { useNavigate } from 'react-router-dom';

interface LinkProps extends ComponentPropsWithoutRef<'a'> {
	to: string;
}

export function Link({ to, onClick, ...props }: LinkProps) {
	const navigate = useNavigate();

	const handleClick = (event: React.MouseEvent<HTMLAnchorElement>) => {
		event.preventDefault();
		if (onClick) {
			onClick(event);
		}
		void navigate(to);
	};

	return <a {...props} href={to} onClick={handleClick} />;
}

================================================================================
File: components\Root.tsx
Lines: 103
--------------------------------------------------------------------------------
import { Suspense} from 'react';

import { ClientEnvironment, ClientEnvironmentProvider } from '../services/ClientEnvironment';
import { useRoute } from '../services/Router';

import { AuthProvider } from './auth';
import { ConfirmEmail } from './auth/ConfirmEmail';
import { ResendVerification } from './auth/ResendVerification';
import { Design } from './Design';
import MainLayout from './layouts/MainLayout';
import { DashboardPage } from './pages/DashboardPage';
import { ExplorePage } from './pages/ExplorePage';
import { HomePage } from './pages/HomePage';
import { MediaPage } from './pages/MediaPage';
import { NotificationsPage } from './pages/NotificationsPage';
import { ProfilePage } from './pages/ProfilePage';
import { SettingsPage } from './pages/SettingsPage';
import { UploadPage } from './pages/UploadPage';
import { ThemeProvider } from './theme';

type BaseRoute = {
	url: string;
};

type Route = 
	| (BaseRoute & { type: 'root' | 'dashboard' | 'profile' | 'upload' | 'explore' | 'notifications' | 'media' | 'settings' | 'home' | 'social' | 'unknown' })
	| (BaseRoute & { type: 'design'; page: string })
	| (BaseRoute & { type: 'auth'; action: string; token?: string });

export function Root(props: { environment: ClientEnvironment }) {
	return (
		<ClientEnvironmentProvider value={props.environment}>
			<ThemeProvider>
				<AuthProvider>
					<Suspense fallback={<Loading />}>
						<Router />
					</Suspense>
				</AuthProvider>
			</ThemeProvider>
		</ClientEnvironmentProvider>
	);
}

function Loading() {
	return (
		<div style={{ textAlign: 'center', marginTop: '33vh' }}>
			<div className="spinner"></div>
		</div>
	);
}

function Router() {
	const route = useRoute();
	
	// Only design routes and auth routes don't use the main layout
	if (route.type === 'design' || route.type === 'auth') {
		return renderRouteContent(route);
	}
	
	// All other routes, including root, use the main layout
	return (
		<MainLayout>
			{renderRouteContent(route)}
		</MainLayout>
	);
}

function renderRouteContent(route: Route) {
	switch (route.type) {
		case 'root':
			return <HomePage />;
		case 'design':
			return <Design page={route.page} />;
		case 'dashboard':
			return <DashboardPage />;
		case 'profile':
			return <ProfilePage />;
		case 'upload':
			return <UploadPage />;
		case 'explore':
			return <ExplorePage />;
		case 'notifications':
			return <NotificationsPage />;
		case 'media':
			return <MediaPage />;
		case 'settings':
			return <SettingsPage />;
		case 'home':
			return <HomePage />;
		case 'auth':
			// Handle auth routes
			switch (route.action) {
				case 'confirm-email':
					return <ConfirmEmail />;
				case 'resend-confirmation':
					return <ResendVerification />;
				default:
					return <div>Auth page not found</div>;
			}
		default:
			return <div>Page not found</div>;
	}
}

================================================================================
File: components\auth\AuthContext.tsx
Lines: 257
--------------------------------------------------------------------------------
import { createContext, useContext, useState, useEffect, ReactNode } from 'react';

// Define the user type
interface User {
  id: string;
  username: string;
  email: string;
  displayName: string | null;
  firstName: string | null;
  lastName: string | null;
  bio: string | null;
  profileImage: string | null;
  bannerImage: string | null;
  role: string;
  isVerified: boolean;
  createdAt: string;
  updatedAt: string;
}

// Define API response types
interface ApiErrorResponse {
  message: string;
}

interface ApiAuthResponse {
  data: {
    user: User;
    accessToken: string;
    requireTwoFactor?: boolean;
  };
}

// Define the auth context type
interface AuthContextType {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  login: (email: string, password: string) => Promise<void>;
  register: (username: string, firstName: string, lastName: string, email: string, password: string) => Promise<void>;
  logout: () => void;
  error: string | null;
  showVerificationModal: boolean;
  setShowVerificationModal: (show: boolean) => void;
  verificationEmail: string;
  setVerificationEmail: (email: string) => void;
}

// Create the auth context with default values
const AuthContext = createContext<AuthContextType>({
  user: null,
  isAuthenticated: false,
  isLoading: true,
  login: async () => {},
  register: async () => {},
  logout: () => {},
  error: null,
  showVerificationModal: false,
  setShowVerificationModal: () => {},
  verificationEmail: '',
  setVerificationEmail: () => {}
});

// Custom hook to use the auth context
export const useAuth = () => useContext(AuthContext);

interface AuthProviderProps {
  children: ReactNode;
}

export function AuthProvider({ children }: AuthProviderProps) {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showVerificationModal, setShowVerificationModal] = useState(false);
  const [verificationEmail, setVerificationEmail] = useState('');

  // Get the server port
  const getServerPort = (): number => {
    // In production, use the same port as the client
    if (process.env.NODE_ENV === 'production') {
      return window.location.port ? parseInt(window.location.port) : 80;
    }
    
    // In development, try to find the server port
    // First, check if we can read the port from localStorage (set by previous successful connections)
    const savedPort = localStorage.getItem('server_port');
    if (savedPort) {
      return parseInt(savedPort);
    }
    
    // Default to 8080 for the server in development
    return 8080;
  };

  // Get the base API URL
  const getApiUrl = () => {
    // In development, use a direct URL to the server
    if (process.env.NODE_ENV === 'development') {
      return `http://localhost:${getServerPort()}/api`;
    }
    
    // In production, use the current window location
    return `${window.location.protocol}//${window.location.host}/api`;
  };

  // Check if user is already logged in on mount
  useEffect(() => {
    const checkAuth = () => {
      try {
        // Try to get user data from localStorage
        const userData = localStorage.getItem('user');
        if (userData) {
          setUser(JSON.parse(userData) as User);
        }
      } catch (error) {
        console.error('Error checking authentication:', error);
      } finally {
        setIsLoading(false);
      }
    };

    checkAuth();
  }, []);

  // Login function
  const login = async (email: string, password: string) => {
    setIsLoading(true);
    setError(null);
    
    try {
      // In a real app, this would be an API call
      const response = await fetch(`${getApiUrl()}/auth/login`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ email, password })
      });
      
      if (!response.ok) {
        const errorData = await response.json() as ApiErrorResponse;
        throw new Error(errorData.message || 'Login failed');
      }
      
      const data = await response.json() as ApiAuthResponse;
      
      // Check if 2FA is required
      if (data.data && data.data.requireTwoFactor) {
        // Handle 2FA flow (not implemented in this example)
        setError('Two-factor authentication is required but not implemented in this demo');
        throw new Error('Two-factor authentication required');
      }
      
      // Save user data to localStorage
      localStorage.setItem('user', JSON.stringify(data.data.user));
      localStorage.setItem('token', data.data.accessToken);
      
      // Update state
      setUser(data.data.user);
    } catch (error) {
      console.error('Login error:', error);
      setError(error instanceof Error ? error.message : 'Login failed. Please try again.');
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  // Register function
  const register = async (username: string, firstName: string, lastName: string, email: string, password: string) => {
    setIsLoading(true);
    setError(null);
    
    // Validate password length before sending to server
    if (password.length < 8) {
      setError('Password must be at least 8 characters');
      setIsLoading(false);
      throw new Error('Password must be at least 8 characters');
    }
    
    try {
      // In a real app, this would be an API call
      const response = await fetch(`${getApiUrl()}/auth/register`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ 
          username, 
          firstName,
          lastName,
          email, 
          password,
          displayName: `${firstName} ${lastName}`
        })
      });
      
      if (!response.ok) {
        const errorData = await response.json() as ApiErrorResponse;
        throw new Error(errorData.message || 'Registration failed');
      }
      
      const data = await response.json() as ApiAuthResponse;
      
      // Check if the user needs email verification
      if (data.data.user && !data.data.user.isVerified) {
        // Set the verification email and show the verification modal
        setVerificationEmail(email);
        setShowVerificationModal(true);
      }
      
      // Save user data to localStorage
      localStorage.setItem('user', JSON.stringify(data.data.user));
      localStorage.setItem('token', data.data.accessToken);
      
      // Update state
      setUser(data.data.user);
    } catch (error) {
      console.error('Registration error:', error);
      setError(error instanceof Error ? error.message : 'Registration failed. Please try again.');
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  // Logout function
  const logout = () => {
    // Remove user data from localStorage
    localStorage.removeItem('user');
    localStorage.removeItem('token');
    
    // Update state
    setUser(null);
  };

  // Create the context value
  const value = {
    user,
    isAuthenticated: !!user,
    isLoading,
    login,
    register,
    logout,
    error,
    showVerificationModal,
    setShowVerificationModal,
    verificationEmail,
    setVerificationEmail
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
} 
================================================================================
File: components\auth\AuthModal.tsx
Lines: 102
--------------------------------------------------------------------------------
import React, { useState } from 'react';

import { useAuth } from './AuthContext';
import { LoginModal } from './LoginModal';
import { RegisterModal } from './RegisterModal';
import { VerificationModal } from './VerificationModal';

export type AuthModalType = 'login' | 'register' | null;

interface AuthModalProps {
  isOpen: boolean;
  modalType: AuthModalType;
  onClose: () => void;
}

export function AuthModal({ isOpen, modalType, onClose }: AuthModalProps) {
  const [activeModal, setActiveModal] = useState<AuthModalType>(modalType);
  const { 
    login, 
    register, 
    showVerificationModal, 
    setShowVerificationModal, 
    verificationEmail 
  } = useAuth();
  
  // Reset active modal when props change
  React.useEffect(() => {
    setActiveModal(modalType);
  }, [modalType]);
  
  const handleSwitchToLogin = () => {
    setActiveModal('login');
  };
  
  const handleSwitchToRegister = () => {
    setActiveModal('register');
  };
  
  const handleLogin = async (email: string, password: string) => {
    try {
      await login(email, password);
      onClose();
    } catch (error) {
      // Error is handled in the AuthContext
      console.error('Login failed:', error);
    }
  };
  
  const handleRegister = async (username: string, firstName: string, lastName: string, email: string, password: string) => {
    try {
      await register(username, firstName, lastName, email, password);
      // Don't close the modal if verification is needed
      // The verification modal will be shown instead
      if (!showVerificationModal) {
        onClose();
      }
    } catch (error) {
      // Error is handled in the AuthContext
      console.error('Registration failed:', error);
    }
  };
  
  // Void-returning wrappers for event handlers
  const handleLoginWrapper = (email: string, password: string): void => {
    void handleLogin(email, password);
  };
  
  const handleRegisterWrapper = (username: string, firstName: string, lastName: string, email: string, password: string): void => {
    void handleRegister(username, firstName, lastName, email, password);
  };
  
  const handleCloseVerificationModal = () => {
    setShowVerificationModal(false);
    onClose();
  };
  
  if (!isOpen && !showVerificationModal) return null;
  
  return (
    <>
      <LoginModal 
        isOpen={activeModal === 'login' && isOpen} 
        onClose={onClose}
        onSwitchToRegister={handleSwitchToRegister}
        onLogin={handleLoginWrapper}
      />
      
      <RegisterModal 
        isOpen={activeModal === 'register' && isOpen} 
        onClose={onClose}
        onSwitchToLogin={handleSwitchToLogin}
        onRegister={handleRegisterWrapper}
      />
      
      <VerificationModal
        isOpen={showVerificationModal}
        onClose={handleCloseVerificationModal}
        email={verificationEmail}
      />
    </>
  );
} 
================================================================================
File: components\auth\ConfirmEmail.tsx
Lines: 116
--------------------------------------------------------------------------------
import React, { useEffect, useState, useMemo } from 'react';

import { AuthClient } from '../../services/AuthClient';
import { useRouter } from '../../services/Router';
import { Button } from '../ui/Button';
import { Card } from '../ui/Card';
import { Spinner } from '../ui/Spinner';

interface ApiResponse {
  success: boolean;
  error?: string;
}

// Define response type
interface EmailConfirmationResponse {
  status: 'success' | 'error';
  message?: string;
}

/**
 * Email confirmation component
 * Handles email verification using token from URL
 */
export const ConfirmEmail: React.FC = () => {
  const [status, setStatus] = useState<'loading' | 'success' | 'error'>('loading');
  const [message, setMessage] = useState('Verifying your email...');
  const router = useRouter();
  
  // Use useMemo to create the authClient instance
  const authClient = useMemo(() => new AuthClient(), []);

  useEffect(() => {
    const confirmEmail = async () => {
      try {
        // Get token from URL
        const urlParams = new URLSearchParams(window.location.search);
        const token = urlParams.get('token');

        if (!token) {
          setStatus('error');
          setMessage('Invalid verification link. No token provided.');
          return;
        }

        // Call API to verify email
        const response = await authClient.confirmEmail(token) as ApiResponse;
        
        // Convert response to expected type
        const typedResponse: EmailConfirmationResponse = {
          status: response.success ? 'success' : 'error',
          message: response.error
        };
        
        if (typedResponse.status === 'success') {
          setStatus('success');
          setMessage('Your email has been verified successfully!');
          
          // Redirect to login after 3 seconds
          setTimeout(() => {
            router.navigate('/auth/login');
          }, 3000);
        } else {
          setStatus('error');
          setMessage(typedResponse.message || 'Failed to verify email. Please try again.');
        }
      } catch (error) {
        setStatus('error');
        setMessage('An error occurred during verification. Please try again.');
        console.error('Email verification error:', error);
      }
    };

    void confirmEmail();
  }, [router, authClient]);

  return (
    <div className="flex justify-center items-center min-h-screen bg-gray-100">
      <Card className="w-full max-w-md p-8">
        <div className="text-center">
          <h1 className="text-2xl font-bold mb-6">Email Verification</h1>
          
          {status === 'loading' && (
            <div className="flex flex-col items-center">
              <div className="mb-4">
                <Spinner size="lg" />
              </div>
              <p>{message}</p>
            </div>
          )}
          
          {status === 'success' && (
            <div className="text-center">
              <div className="text-green-500 text-5xl mb-4">✓</div>
              <p className="mb-6">{message}</p>
              <p className="text-sm text-gray-500">Redirecting to login page...</p>
            </div>
          )}
          
          {status === 'error' && (
            <div className="text-center">
              <div className="text-red-500 text-5xl mb-4">✗</div>
              <p className="mb-6">{message}</p>
              <Button 
                onClick={() => router.navigate('/auth/login')}
                variant="primary"
                className="w-full"
              >
                Go to Login
              </Button>
            </div>
          )}
        </div>
      </Card>
    </div>
  );
}; 
================================================================================
File: components\auth\index.tsx
Lines: 4
--------------------------------------------------------------------------------
export { AuthProvider, useAuth } from './AuthContext';
export { AuthModal } from './AuthModal';
export type { AuthModalType } from './AuthModal';
export { VerificationModal } from './VerificationModal'; 
================================================================================
File: components\auth\LoginModal.tsx
Lines: 198
--------------------------------------------------------------------------------
import React, { useState } from 'react';

interface LoginModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSwitchToRegister: () => void;
  onLogin: (email: string, password: string) => void;
}

export function LoginModal({ isOpen, onClose, onSwitchToRegister, onLogin }: LoginModalProps) {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState<string | null>(null);
  
  if (!isOpen) return null;
  
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    // Basic validation
    if (!email.trim()) {
      setError('Email is required');
      return;
    }
    
    if (!password.trim()) {
      setError('Password is required');
      return;
    }
    
    // Clear any previous errors
    setError(null);
    
    // Call the login function
    onLogin(email, password);
  };
  
  return (
    <div 
      style={{
        position: 'fixed',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        zIndex: 1000
      }} 
      onClick={onClose}
    >
      <div 
        onClick={e => e.stopPropagation()}
        style={{
          position: 'relative',
          backgroundColor: 'var(--surface)',
          color: 'var(--text-primary)',
          borderRadius: '8px',
          padding: '24px',
          width: '400px',
          maxWidth: '90%',
          maxHeight: '90vh',
          overflowY: 'auto',
          boxShadow: '0 4px 12px rgba(0, 0, 0, 0.15)'
        }}
      >
        <h2 style={{ marginTop: 0, color: 'var(--accent)' }}>Log In</h2>
        
        {error && (
          <div style={{ 
            backgroundColor: 'rgba(255, 0, 0, 0.1)', 
            color: 'red', 
            padding: '10px', 
            borderRadius: '4px',
            marginBottom: '16px'
          }}>
            {error}
          </div>
        )}
        
        <form onSubmit={handleSubmit}>
          <div style={{ marginBottom: '16px' }}>
            <label 
              htmlFor="email" 
              style={{ 
                display: 'block', 
                marginBottom: '6px', 
                fontWeight: 'bold' 
              }}
            >
              Email
            </label>
            <input
              id="email"
              type="email"
              value={email}
              onChange={e => setEmail(e.target.value)}
              style={{
                width: '100%',
                padding: '10px',
                borderRadius: '4px',
                border: '1px solid var(--border-color)',
                fontSize: '16px',
                backgroundColor: 'var(--input-bg)',
                color: 'var(--text-primary)'
              }}
              placeholder="Enter your email"
            />
          </div>
          
          <div style={{ marginBottom: '16px' }}>
            <label 
              htmlFor="password" 
              style={{ 
                display: 'block', 
                marginBottom: '6px', 
                fontWeight: 'bold' 
              }}
            >
              Password
            </label>
            <input
              id="password"
              type="password"
              value={password}
              onChange={e => setPassword(e.target.value)}
              style={{
                width: '100%',
                padding: '10px',
                borderRadius: '4px',
                border: '1px solid var(--border-color)',
                fontSize: '16px',
                backgroundColor: 'var(--input-bg)',
                color: 'var(--text-primary)'
              }}
              placeholder="Enter your password"
            />
          </div>
          
          <button
            type="submit"
            style={{
              width: '100%',
              padding: '12px',
              backgroundColor: 'var(--accent)',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              fontSize: '16px',
              cursor: 'pointer',
              marginBottom: '16px'
            }}
          >
            Log In
          </button>
        </form>
        
        <div style={{ textAlign: 'center' }}>
          <p>
            Don&apos;t have an account?{' '}
            <button
              onClick={onSwitchToRegister}
              style={{
                background: 'none',
                border: 'none',
                color: 'var(--accent)',
                cursor: 'pointer',
                padding: 0,
                fontSize: 'inherit',
                textDecoration: 'underline'
              }}
            >
              Register
            </button>
          </p>
        </div>
        
        <button
          onClick={onClose}
          style={{
            position: 'absolute',
            top: '16px',
            right: '16px',
            background: 'none',
            border: 'none',
            fontSize: '24px',
            cursor: 'pointer',
            color: 'var(--text-secondary)'
          }}
        >
          &times;
        </button>
      </div>
    </div>
  );
} 
================================================================================
File: components\auth\RegisterModal.tsx
Lines: 344
--------------------------------------------------------------------------------
import React, { useState } from 'react';

interface RegisterModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSwitchToLogin: () => void;
  onRegister: (username: string, firstName: string, lastName: string, email: string, password: string) => void;
}

export function RegisterModal({ isOpen, onClose, onSwitchToLogin, onRegister }: RegisterModalProps) {
  const [username, setUsername] = useState('');
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [error, setError] = useState<string | null>(null);
  
  if (!isOpen) return null;
  
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    // Basic validation
    if (!username.trim()) {
      setError('Username is required');
      return;
    }
    
    if (!firstName.trim()) {
      setError('First name is required');
      return;
    }
    
    if (!lastName.trim()) {
      setError('Last name is required');
      return;
    }
    
    if (!email.trim()) {
      setError('Email is required');
      return;
    }
    
    if (!password.trim()) {
      setError('Password is required');
      return;
    }
    
    if (password !== confirmPassword) {
      setError('Passwords do not match');
      return;
    }
    
    // Validate username format
    if (!/^[a-zA-Z0-9_-]+$/.test(username)) {
      setError('Username can only contain letters, numbers, underscores, and hyphens');
      return;
    }
    
    // Clear any previous errors
    setError(null);
    
    // Call the register function
    onRegister(username, firstName, lastName, email, password);
  };
  
  return (
    <div 
      style={{
        position: 'fixed',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        zIndex: 1000
      }} 
      onClick={onClose}
    >
      <div 
        onClick={e => e.stopPropagation()}
        style={{
          position: 'relative',
          backgroundColor: 'var(--surface)',
          color: 'var(--text-primary)',
          borderRadius: '8px',
          padding: '24px',
          width: '400px',
          maxWidth: '90%',
          maxHeight: '90vh',
          overflowY: 'auto',
          boxShadow: '0 4px 12px rgba(0, 0, 0, 0.15)'
        }}
      >
        <h2 style={{ marginTop: 0, color: 'var(--accent)' }}>Create Account</h2>
        
        {error && (
          <div style={{ 
            backgroundColor: 'rgba(255, 0, 0, 0.1)', 
            color: 'red', 
            padding: '10px', 
            borderRadius: '4px',
            marginBottom: '16px'
          }}>
            {error}
          </div>
        )}
        
        <form onSubmit={handleSubmit}>
          <div style={{ marginBottom: '16px' }}>
            <label 
              htmlFor="username" 
              style={{ 
                display: 'block', 
                marginBottom: '6px', 
                fontWeight: 'bold' 
              }}
            >
              Username
            </label>
            <input
              id="username"
              type="text"
              value={username}
              onChange={e => setUsername(e.target.value)}
              style={{
                width: '100%',
                padding: '10px',
                borderRadius: '4px',
                border: '1px solid var(--border-color)',
                fontSize: '16px',
                backgroundColor: 'var(--input-bg)',
                color: 'var(--text-primary)'
              }}
              placeholder="Choose a username"
            />
          </div>
          
          <div style={{ marginBottom: '16px' }}>
            <label 
              htmlFor="firstName" 
              style={{ 
                display: 'block', 
                marginBottom: '6px', 
                fontWeight: 'bold' 
              }}
            >
              First Name
            </label>
            <input
              id="firstName"
              type="text"
              value={firstName}
              onChange={e => setFirstName(e.target.value)}
              style={{
                width: '100%',
                padding: '10px',
                borderRadius: '4px',
                border: '1px solid var(--border-color)',
                fontSize: '16px',
                backgroundColor: 'var(--input-bg)',
                color: 'var(--text-primary)'
              }}
              placeholder="Enter your first name"
            />
          </div>
          
          <div style={{ marginBottom: '16px' }}>
            <label 
              htmlFor="lastName" 
              style={{ 
                display: 'block', 
                marginBottom: '6px', 
                fontWeight: 'bold' 
              }}
            >
              Last Name
            </label>
            <input
              id="lastName"
              type="text"
              value={lastName}
              onChange={e => setLastName(e.target.value)}
              style={{
                width: '100%',
                padding: '10px',
                borderRadius: '4px',
                border: '1px solid var(--border-color)',
                fontSize: '16px',
                backgroundColor: 'var(--input-bg)',
                color: 'var(--text-primary)'
              }}
              placeholder="Enter your last name"
            />
          </div>
          
          <div style={{ marginBottom: '16px' }}>
            <label 
              htmlFor="email" 
              style={{ 
                display: 'block', 
                marginBottom: '6px', 
                fontWeight: 'bold' 
              }}
            >
              Email
            </label>
            <input
              id="email"
              type="email"
              value={email}
              onChange={e => setEmail(e.target.value)}
              style={{
                width: '100%',
                padding: '10px',
                borderRadius: '4px',
                border: '1px solid var(--border-color)',
                fontSize: '16px',
                backgroundColor: 'var(--input-bg)',
                color: 'var(--text-primary)'
              }}
              placeholder="Enter your email"
            />
          </div>
          
          <div style={{ marginBottom: '16px' }}>
            <label 
              htmlFor="password" 
              style={{ 
                display: 'block', 
                marginBottom: '6px', 
                fontWeight: 'bold' 
              }}
            >
              Password
            </label>
            <input
              id="password"
              type="password"
              value={password}
              onChange={e => setPassword(e.target.value)}
              style={{
                width: '100%',
                padding: '10px',
                borderRadius: '4px',
                border: '1px solid var(--border-color)',
                fontSize: '16px',
                backgroundColor: 'var(--input-bg)',
                color: 'var(--text-primary)'
              }}
              placeholder="Create a password"
            />
          </div>
          
          <div style={{ marginBottom: '16px' }}>
            <label 
              htmlFor="confirmPassword" 
              style={{ 
                display: 'block', 
                marginBottom: '6px', 
                fontWeight: 'bold' 
              }}
            >
              Confirm Password
            </label>
            <input
              id="confirmPassword"
              type="password"
              value={confirmPassword}
              onChange={e => setConfirmPassword(e.target.value)}
              style={{
                width: '100%',
                padding: '10px',
                borderRadius: '4px',
                border: '1px solid var(--border-color)',
                fontSize: '16px',
                backgroundColor: 'var(--input-bg)',
                color: 'var(--text-primary)'
              }}
              placeholder="Confirm your password"
            />
          </div>
          
          <button
            type="submit"
            style={{
              width: '100%',
              padding: '12px',
              backgroundColor: 'var(--accent)',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              fontSize: '16px',
              cursor: 'pointer',
              marginBottom: '16px'
            }}
          >
            Create Account
          </button>
        </form>
        
        <div style={{ textAlign: 'center' }}>
          <p>
            Already have an account?{' '}
            <button
              onClick={onSwitchToLogin}
              style={{
                background: 'none',
                border: 'none',
                color: 'var(--accent)',
                cursor: 'pointer',
                padding: 0,
                fontSize: 'inherit',
                textDecoration: 'underline'
              }}
            >
              Log In
            </button>
          </p>
        </div>
        
        <button
          onClick={onClose}
          style={{
            position: 'absolute',
            top: '16px',
            right: '16px',
            background: 'none',
            border: 'none',
            fontSize: '24px',
            cursor: 'pointer',
            color: 'var(--text-secondary)'
          }}
        >
          &times;
        </button>
      </div>
    </div>
  );
} 
================================================================================
File: components\auth\ResendVerification.tsx
Lines: 170
--------------------------------------------------------------------------------
import React, { useState } from 'react';

import { AuthClient } from '../../services/AuthClient';
import { Button } from '../ui/Button';
import { Card } from '../ui/Card';
import { Input } from '../ui/Input';
import { Spinner } from '../ui/Spinner';

// Define response type
interface VerificationResponse {
  status: 'success' | 'error';
  message?: string;
}

interface ApiResponse {
  success: boolean;
  error?: string;
}

// Define error response type
interface ApiError {
  response?: {
    status: number;
    data?: {
      message?: string;
    };
  };
  message: string;
}

/**
 * ResendVerification component
 * Allows users to request a new verification email
 */
export const ResendVerification: React.FC = () => {
  const [email, setEmail] = useState('');
  const [status, setStatus] = useState<'idle' | 'loading' | 'success' | 'error'>('idle');
  const [message, setMessage] = useState('');
  const [countdown, setCountdown] = useState(0);
  const authClient = new AuthClient();

  const handleSubmitAsync = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!email) {
      setStatus('error');
      setMessage('Please enter your email address');
      return;
    }

    try {
      setStatus('loading');
      setMessage('Sending verification email...');
      
      const response = await authClient.resendConfirmationEmail(email) as ApiResponse;
      const typedResponse: VerificationResponse = {
        status: response.success ? 'success' : 'error'
      };
      
      if (typedResponse.status === 'success') {
        setStatus('success');
        setMessage('Verification email sent! Please check your inbox.');
        
        // Start countdown for rate limiting (60 seconds)
        setCountdown(60);
        const timer = setInterval(() => {
          setCountdown(prev => {
            if (prev <= 1) {
              clearInterval(timer);
              return 0;
            }
            return prev - 1;
          });
        }, 1000);
      } else {
        setStatus('error');
        setMessage(response.error || 'Failed to send verification email. Please try again.');
      }
    } catch (error) {
      const err = error as ApiError;
      setStatus('error');
      
      // Handle rate limiting error
      if (err.response?.status === 429) {
        setMessage('Please wait before requesting another email.');
        
        // Extract time from error message if available
        const timeMatch = err.response?.data?.message?.match(/(\d+)/);
        if (timeMatch && timeMatch[1]) {
          const seconds = parseInt(timeMatch[1], 10);
          setCountdown(seconds);
          
          const timer = setInterval(() => {
            setCountdown(prev => {
              if (prev <= 1) {
                clearInterval(timer);
                return 0;
              }
              return prev - 1;
            });
          }, 1000);
        }
      } else {
        setMessage('An error occurred. Please try again later.');
      }
      
      console.error('Resend verification error:', err);
    }
  };
  
  // Wrapper function that returns void
  const handleSubmit = (e: React.FormEvent): void => {
    void handleSubmitAsync(e);
  };

  return (
    <div className="flex justify-center items-center min-h-screen bg-gray-100">
      <Card className="w-full max-w-md p-8">
        <div className="text-center mb-6">
          <h1 className="text-2xl font-bold">Resend Verification Email</h1>
          <p className="text-gray-600 mt-2">
            Enter your email address to receive a new verification link
          </p>
        </div>
        
        <form onSubmit={handleSubmit}>
          <div className="mb-4">
            <Input
              type="email"
              placeholder="Email address"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              disabled={status === 'loading' || countdown > 0}
              required
            />
          </div>
          
          {status === 'error' && (
            <div className="mb-4 p-3 bg-red-100 text-red-700 rounded">
              {message}
            </div>
          )}
          
          {status === 'success' && (
            <div className="mb-4 p-3 bg-green-100 text-green-700 rounded">
              {message}
            </div>
          )}
          
          <Button
            type="submit"
            variant="primary"
            className="w-full"
            disabled={status === 'loading' || countdown > 0}
          >
            {status === 'loading' ? (
              <div className="mr-2">
                <Spinner size="sm" />
              </div>
            ) : countdown > 0 ? (
              `Resend (${countdown}s)`
            ) : (
              'Send Verification Email'
            )}
          </Button>
        </form>
      </Card>
    </div>
  );
}; 
================================================================================
File: components\auth\VerificationModal.tsx
Lines: 207
--------------------------------------------------------------------------------
import { useState } from 'react';

import { AuthClient } from '../../services/AuthClient';

// Define response type
interface VerificationResponse {
  success: boolean;
  message?: string;
}

// Define error response type
interface ApiError {
  response?: {
    status: number;
    data?: {
      message?: string;
    };
  };
  message: string;
}

interface VerificationModalProps {
  isOpen: boolean;
  onClose: () => void;
  email: string;
}

export function VerificationModal({ isOpen, onClose, email }: VerificationModalProps) {
  const [isResending, setIsResending] = useState(false);
  const [resendStatus, setResendStatus] = useState<'idle' | 'success' | 'error'>('idle');
  const [message, setMessage] = useState('');
  const [countdown, setCountdown] = useState(0);
  const authClient = new AuthClient();

  if (!isOpen) return null;

  const handleResendEmailAsync = async () => {
    if (isResending || countdown > 0) return;

    setIsResending(true);
    setResendStatus('idle');
    setMessage('');

    try {
      const response = await authClient.resendConfirmationEmail(email) as VerificationResponse;

      if (response.success) {
        setResendStatus('success');
        setMessage('Verification email sent! Please check your inbox.');
        
        // Start countdown for rate limiting (60 seconds)
        setCountdown(60);
        const timer = setInterval(() => {
          setCountdown(prev => {
            if (prev <= 1) {
              clearInterval(timer);
              return 0;
            }
            return prev - 1;
          });
        }, 1000);
      } else {
        setResendStatus('error');
        setMessage(response.message || 'Failed to send verification email. Please try again.');
      }
    } catch (error) {
      const err = error as ApiError;
      setResendStatus('error');
      
      // Handle rate limiting error
      if (err.response?.status === 429) {
        setMessage('Please wait before requesting another email.');
        
        // Extract time from error message if available
        const timeMatch = err.response?.data?.message?.match(/(\d+)/);
        if (timeMatch && timeMatch[1]) {
          const seconds = parseInt(timeMatch[1], 10);
          setCountdown(seconds);
          
          const timer = setInterval(() => {
            setCountdown(prev => {
              if (prev <= 1) {
                clearInterval(timer);
                return 0;
              }
              return prev - 1;
            });
          }, 1000);
        }
      } else {
        setMessage('An error occurred. Please try again later.');
      }
      
      console.error('Resend verification error:', err);
    } finally {
      setIsResending(false);
    }
  };
  
  // Wrapper function that returns void
  const handleResendEmail = (): void => {
    void handleResendEmailAsync();
  };

  return (
    <div 
      style={{
        position: 'fixed',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        zIndex: 1000
      }} 
      onClick={onClose}
    >
      <div 
        onClick={e => e.stopPropagation()}
        style={{
          position: 'relative',
          backgroundColor: 'var(--surface)',
          color: 'var(--text-primary)',
          borderRadius: '8px',
          padding: '24px',
          width: '400px',
          maxWidth: '90%',
          maxHeight: '90vh',
          overflowY: 'auto',
          boxShadow: '0 4px 12px rgba(0, 0, 0, 0.15)'
        }}
      >
        <h2 style={{ marginTop: 0, color: 'var(--accent)' }}>Verify Your Email</h2>
        
        <div style={{ marginBottom: '20px' }}>
          <p>
            We&apos;ve sent a verification email to <strong>{email}</strong>. 
            Please check your inbox and click the verification link to activate your account.
          </p>
          <p>
            If you don&apos;t see the email, please check your spam folder.
          </p>
        </div>
        
        {resendStatus === 'success' && (
          <div style={{ 
            backgroundColor: 'rgba(0, 255, 0, 0.1)', 
            color: 'green', 
            padding: '10px', 
            borderRadius: '4px',
            marginBottom: '16px'
          }}>
            {message}
          </div>
        )}
        
        {resendStatus === 'error' && (
          <div style={{ 
            backgroundColor: 'rgba(255, 0, 0, 0.1)', 
            color: 'red', 
            padding: '10px', 
            borderRadius: '4px',
            marginBottom: '16px'
          }}>
            {message}
          </div>
        )}
        
        <div style={{ display: 'flex', justifyContent: 'space-between', marginTop: '20px' }}>
          <button
            onClick={onClose}
            style={{
              padding: '10px 16px',
              borderRadius: '4px',
              border: '1px solid var(--border-color)',
              backgroundColor: 'transparent',
              color: 'var(--text-primary)',
              cursor: 'pointer',
              fontSize: '14px'
            }}
          >
            Close
          </button>
          
          <button
            onClick={handleResendEmail}
            disabled={isResending || countdown > 0}
            style={{
              padding: '10px 16px',
              borderRadius: '4px',
              border: 'none',
              backgroundColor: isResending || countdown > 0 ? 'var(--accent-disabled)' : 'var(--accent)',
              color: 'white',
              cursor: isResending || countdown > 0 ? 'not-allowed' : 'pointer',
              fontSize: '14px'
            }}
          >
            {isResending ? 'Sending...' : countdown > 0 ? `Resend (${countdown}s)` : 'Resend Email'}
          </button>
        </div>
      </div>
    </div>
  );
} 
================================================================================
File: components\layouts\main-layout.css
Lines: 308
--------------------------------------------------------------------------------
.main-layout {
  height: 100vh;
  display: flex;
  flex-direction: column;
  background-color: var(--background);
  color: var(--text-primary);
  width: 100%;
  min-height: 100vh;
  position: relative;
  overflow: hidden;
}

.top-bar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0 20px;
  height: 60px;
  min-height: 60px;
  max-height: 60px;
  width: 100%;
  background-color: var(--surface);
  border-bottom: 1px solid var(--border-color);
  position: sticky;
  top: 0;
  z-index: 100;
  flex-shrink: 0;
}

.logo {
  font-size: 1.5rem;
  font-weight: bold;
  color: var(--accent);
  white-space: nowrap;
  cursor: pointer;
  transition: transform 0.2s ease, opacity 0.2s ease;
  padding: 8px;
  border-radius: 4px;
}

.logo:hover {
  transform: scale(1.05);
  opacity: 0.9;
}

.logo:active {
  transform: scale(0.98);
}

.top-bar-actions {
  display: flex;
  align-items: center;
  gap: 12px;
  flex-shrink: 0;
}

.theme-toggle-btn {
  background: none;
  border: none;
  font-size: 1.2rem;
  cursor: pointer;
  padding: 0.5rem;
  border-radius: 50%;
  transition: background-color 0.2s;
  margin-right: 1rem;
}

.theme-toggle-btn:hover {
  background-color: var(--hover-bg);
}

.theme-toggle-btn.system-theme {
  opacity: 0.7;
  cursor: default;
  position: relative;
}

.theme-toggle-btn.system-theme:hover {
  background-color: transparent;
}

.theme-toggle-btn.system-theme::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 50%;
  transform: translateX(-50%);
  width: 5px;
  height: 5px;
  background-color: var(--accent);
  border-radius: 50%;
}

.user-profile {
  display: flex;
  align-items: center;
  gap: 10px;
  flex-shrink: 0;
}

.username {
  font-weight: 500;
  white-space: nowrap;
}

.content-area {
  display: flex;
  flex-grow: 1;
  overflow: hidden;
  height: calc(100vh - 110px); /* Subtract header and footer heights */
}

.left-panel {
  width: 240px;
  min-width: 240px;
  background-color: var(--surface);
  border-right: 1px solid var(--border-color);
  overflow-y: auto;
  flex-shrink: 0;
}

.main-nav {
  display: flex;
  flex-direction: column;
  padding: 16px;
}

.main-nav a {
  padding: 12px 16px;
  margin-bottom: 4px;
  border-radius: 8px;
  color: var(--text-primary);
  text-decoration: none;
  transition: background-color 0.2s;
  white-space: nowrap;
}

.main-nav a:hover {
  background-color: var(--transparent1);
  text-decoration: none;
}

.main-nav a.active {
  background-color: var(--transparent2);
  font-weight: 500;
}

.main-content {
  flex-grow: 1;
  overflow-y: auto;
  padding: 20px;
  width: calc(100% - 240px); /* Adjust based on left panel width */
}

.right-panel {
  width: 280px;
  min-width: 280px;
  background-color: var(--surface);
  border-left: 1px solid var(--border-color);
  padding: 16px;
  overflow-y: auto;
  flex-shrink: 0;
}

.bottom-bar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0 20px;
  height: 50px;
  min-height: 50px;
  max-height: 50px;
  width: 100%;
  background-color: var(--surface);
  border-top: 1px solid var(--border-color);
  color: var(--text-secondary);
  font-size: 0.9rem;
  flex-shrink: 0;
}

.layout-controls {
  display: flex;
  gap: 10px;
  flex-shrink: 0;
}

.layout-controls button {
  background: none;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  padding: 4px 8px;
  font-size: 0.8rem;
  cursor: pointer;
  color: var(--text-secondary);
  transition: background-color 0.2s;
  white-space: nowrap;
}

.layout-controls button:hover {
  background-color: var(--transparent1);
}

/* Mobile Menu Toggle Button */
.mobile-menu-toggle {
  display: none;
  flex-direction: column;
  justify-content: space-between;
  width: 30px;
  height: 21px;
  background: transparent;
  border: none;
  cursor: pointer;
  padding: 0;
  margin-right: 15px;
}

.mobile-menu-toggle span {
  display: block;
  height: 3px;
  width: 100%;
  background-color: var(--text-primary);
  border-radius: 3px;
  transition: all 0.3s ease;
}

/* Mobile Navigation Header */
.mobile-nav-header {
  display: flex;
  justify-content: flex-end;
  padding: 10px;
  border-bottom: 1px solid var(--border-color);
  margin-bottom: 10px;
}

.close-mobile-nav {
  background: none;
  border: none;
  font-size: 24px;
  color: var(--text-primary);
  cursor: pointer;
}

/* Mobile Overlay */
.mobile-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5);
  z-index: 80;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .mobile-menu-toggle {
    display: flex;
  }
  
  .left-panel {
    width: 280px;
    min-width: 280px;
    position: fixed;
    top: 0;
    left: 0;
    height: 100vh;
    z-index: 100;
    transform: translateX(-100%);
    transition: transform 0.3s ease;
  }
  
  .left-panel.mobile {
    transform: translateX(0);
    box-shadow: 2px 0 10px rgba(0, 0, 0, 0.2);
  }
  
  .main-content {
    width: 100%;
    padding: 15px;
  }
  
  .right-panel {
    display: none;
  }
}

@media (max-width: 576px) {
  .top-bar {
    padding: 0 10px;
  }
  
  .main-content {
    padding: 10px;
  }
  
  .bottom-bar {
    padding: 0 10px;
    justify-content: center;
  }
  
  .logo {
    font-size: 1.2rem;
  }
  
  .theme-toggle-btn {
    margin-right: 0.5rem;
  }
} 
================================================================================
File: components\layouts\MainLayout.tsx
Lines: 219
--------------------------------------------------------------------------------
import React, { useState, useEffect } from 'react';

import { AuthModal, AuthModalType, useAuth } from '../auth';
import { useTheme } from '../theme';
import { Button } from '../ui/Button';
import { Link } from '../ui/Link';
import './main-layout.css';

export default function MainLayout({ children }: { children: React.ReactNode }) {
  const [showSidebar, setShowSidebar] = useState(true);
  const [showRightPanel, setShowRightPanel] = useState(false);
  const [showTopbar, setShowTopbar] = useState(true);
  const [showBottomBar, setShowBottomBar] = useState(true);
  const [isMobile, setIsMobile] = useState(false);
  const [authModal, setAuthModal] = useState<{ show: boolean, type: AuthModalType }>({ show: false, type: 'login' });
  
  const { isAuthenticated, user, logout } = useAuth();
  const { theme, toggleTheme, isUsingSystemTheme } = useTheme();

  // Check if viewport is mobile size
  useEffect(() => {
    const checkIfMobile = () => {
      setIsMobile(window.innerWidth <= 768);
      // Auto-hide sidebar on mobile
      if (window.innerWidth <= 768) {
        setShowSidebar(false);
      } else {
        setShowSidebar(true);
      }
    };

    // Initial check
    checkIfMobile();
    
    // Add event listener
    window.addEventListener('resize', checkIfMobile);
    
    // Cleanup
    return () => window.removeEventListener('resize', checkIfMobile);
  }, []);

  const openLoginModal = () => {
    setAuthModal({ show: true, type: 'login' });
  };

  const openRegisterModal = () => {
    setAuthModal({ show: true, type: 'register' });
  };

  const closeAuthModal = () => {
    setAuthModal({ show: false, type: authModal.type });
  };

  const handleLogout = () => {
    logout();
  };

  // Get the appropriate theme icon
  const getThemeIcon = () => {
    if (isUsingSystemTheme) {
      return '🖥️';
    } else {
      return theme === 'light' ? '🌙' : '☀️';
    }
  };

  // Handle theme button click
  const handleThemeButtonClick = () => {
    if (!isUsingSystemTheme) {
      toggleTheme();
    }
  };

  // Toggle sidebar for mobile
  const toggleMobileSidebar = () => {
    setShowSidebar(!showSidebar);
  };

  return (
    <div className="main-layout">
      {showTopbar && (
        <div className="top-bar">
          {isMobile && (
            <button 
              className="mobile-menu-toggle" 
              onClick={toggleMobileSidebar}
              aria-label={showSidebar ? "Close menu" : "Open menu"}
            >
              <span></span>
              <span></span>
              <span></span>
            </button>
          )}
          <Link 
            to="/" 
            style={{ 
              textDecoration: 'none',
              display: 'flex',
              alignItems: 'center'
            }}
          >
            <div className="logo">ABE Stack</div>
          </Link>
          <div className="top-bar-actions">
            <button 
              className={`theme-toggle-btn ${isUsingSystemTheme ? 'system-theme' : ''}`}
              onClick={handleThemeButtonClick}
              aria-label={isUsingSystemTheme 
                ? "Using system theme preference" 
                : `Switch to ${theme === 'light' ? 'dark' : 'light'} mode`}
              title={isUsingSystemTheme 
                ? "Using system theme preference (change in settings)" 
                : `Switch to ${theme === 'light' ? 'dark' : 'light'} mode`}
            >
              {getThemeIcon()}
            </button>
            {isAuthenticated ? (
              <div className="user-profile">
                <div 
                  style={{ 
                    width: '32px', 
                    height: '32px', 
                    borderRadius: '50%', 
                    backgroundColor: 'var(--accent)', 
                    display: 'flex', 
                    alignItems: 'center', 
                    justifyContent: 'center',
                    color: 'white',
                    fontWeight: 'bold'
                  }}
                >
                  {user?.displayName?.charAt(0) || 'U'}
                </div>
                {!isMobile && <span className="username">{user?.displayName || 'User'}</span>}
                <Button onClick={handleLogout}>Logout</Button>
              </div>
            ) : (
              <>
                <Button onClick={openLoginModal}>Log In</Button>
                <Button onClick={openRegisterModal}>Register</Button>
              </>
            )}
          </div>
        </div>
      )}

      <div className="content-area">
        {showSidebar && (
          <div className={`left-panel ${isMobile ? 'mobile' : ''}`}>
            <nav className="main-nav">
              {isMobile && (
                <div className="mobile-nav-header">
                  <button 
                    className="close-mobile-nav" 
                    onClick={() => setShowSidebar(false)}
                    aria-label="Close menu"
                  >
                    &times;
                  </button>
                </div>
              )}
              <Link to="/" onClick={isMobile ? () => setShowSidebar(false) : undefined}>Home</Link>
              <Link to="/dashboard" onClick={isMobile ? () => setShowSidebar(false) : undefined}>Dashboard</Link>
              <Link to="/profile" onClick={isMobile ? () => setShowSidebar(false) : undefined}>Profile</Link>
              <Link to="/upload" onClick={isMobile ? () => setShowSidebar(false) : undefined}>Upload</Link>
              <Link to="/explore" onClick={isMobile ? () => setShowSidebar(false) : undefined}>Explore</Link>
              <Link to="/notifications" onClick={isMobile ? () => setShowSidebar(false) : undefined}>Notifications</Link>
              <Link to="/media" onClick={isMobile ? () => setShowSidebar(false) : undefined}>Media</Link>
              <Link to="/settings" onClick={isMobile ? () => setShowSidebar(false) : undefined}>Settings</Link>
            </nav>
          </div>
        )}

        <div className="main-content">
          {children}
        </div>

        {showRightPanel && (
          <div className="right-panel">
            <h3>Additional Info</h3>
            <p>This panel can contain contextual information, notifications, or other supplementary content.</p>
          </div>
        )}
      </div>

      {showBottomBar && (
        <div className="bottom-bar">
          <div>© 2023 ABE Stack</div>
          {!isMobile && (
            <div className="layout-controls">
              <button onClick={() => setShowSidebar(!showSidebar)}>
                {showSidebar ? 'Hide' : 'Show'} Left Panel
              </button>
              <button onClick={() => setShowRightPanel(!showRightPanel)}>
                {showRightPanel ? 'Hide' : 'Show'} Right Panel
              </button>
              <button onClick={() => setShowTopbar(!showTopbar)}>
                {showTopbar ? 'Hide' : 'Show'} Top Bar
              </button>
              <button onClick={() => setShowBottomBar(!showBottomBar)}>
                Hide Bottom Bar
              </button>
            </div>
          )}
        </div>
      )}

      {isMobile && showSidebar && (
        <div className="mobile-overlay" onClick={() => setShowSidebar(false)}></div>
      )}

      <AuthModal 
        isOpen={authModal.show} 
        modalType={authModal.type} 
        onClose={closeAuthModal} 
      />
    </div>
  );
} 
================================================================================
File: components\layouts\page-content.css
Lines: 58
--------------------------------------------------------------------------------
.page-content {
  padding: 20px;
  width: 100%;
  max-width: 100%;
  box-sizing: border-box;
}

.page-title {
  margin: 0 0 10px 0;
  font-size: 2rem;
  color: var(--text-primary);
  font-weight: 600;
}

.page-description {
  margin: 0 0 20px 0;
  color: var(--text-secondary);
  font-size: 1.1rem;
  max-width: 800px;
}

.page-content-body {
  margin-top: 20px;
}

.page-content-body.no-header {
  margin-top: 0;
}

/* Ensure consistent content width */
.page-content-body > * {
  max-width: 100%;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .page-content {
    padding: 15px;
  }
  
  .page-title {
    font-size: 1.75rem;
  }
  
  .page-description {
    font-size: 1rem;
  }
}

@media (max-width: 576px) {
  .page-content {
    padding: 10px;
  }
  
  .page-title {
    font-size: 1.5rem;
  }
} 
================================================================================
File: components\layouts\PageContent.tsx
Lines: 20
--------------------------------------------------------------------------------
import { ReactNode } from 'react';
import './page-content.css';

interface PageContentProps {
  children: ReactNode;
  title?: string;
  description?: string;
}

export function PageContent({ children, title, description }: PageContentProps) {
  return (
    <div className="page-content">
      {title && <h1 className="page-title">{title}</h1>}
      {description && <p className="page-description">{description}</p>}
      <div className={`page-content-body ${!title && !description ? 'no-header' : ''}`}>
        {children}
      </div>
    </div>
  );
} 
================================================================================
File: components\media\AudioPlayer.tsx
Lines: 308
--------------------------------------------------------------------------------
import React, { useState, useRef, useEffect, useCallback } from 'react';

import { formatDuration } from '../../helpers/formatters';

interface AudioPlayerProps {
  trackUrl: string;
  trackTitle: string;
  artistName: string;
  coverArtUrl?: string;
  autoplay?: boolean;
  onEnded?: () => void;
  onPlay?: () => void;
  onPause?: () => void;
}

const AudioPlayer: React.FC<AudioPlayerProps> = ({
  trackUrl,
  trackTitle,
  artistName,
  coverArtUrl,
  autoplay = false,
  onEnded,
  onPlay,
  onPause,
}) => {
  const [isPlaying, setIsPlaying] = useState(false);
  const [duration, setDuration] = useState(0);
  const [currentTime, setCurrentTime] = useState(0);
  const [volume, setVolume] = useState(0.8);
  
  const audioRef = useRef<HTMLAudioElement>(null);
  const progressRef = useRef<HTMLDivElement>(null);
    
  const playAudio = useCallback(() => {
    if (audioRef.current) {
      audioRef.current.play().then(() => {
        setIsPlaying(true);
        if (onPlay) onPlay();
      }).catch(error => {
        console.error('Play failed:', error);
      });
    }
  }, [onPlay]);
  
  const pauseAudio = useCallback(() => {
    if (audioRef.current) {
      audioRef.current.pause();
      setIsPlaying(false);
      if (onPause) onPause();
    }
  }, [onPause]);
  
  useEffect(() => {
    if (audioRef.current) {
      const audio = audioRef.current;
      
      const handleLoadedMetadata = () => {
        setDuration(audio.duration);
      };
      
      const handleTimeUpdate = () => {
        setCurrentTime(audio.currentTime);
      };
      
      const handleEnded = () => {
        setIsPlaying(false);
        if (onEnded) onEnded();
      };
      
      // Add event listeners
      audio.addEventListener('loadedmetadata', handleLoadedMetadata);
      audio.addEventListener('timeupdate', handleTimeUpdate);
      audio.addEventListener('ended', handleEnded);
      
      // Set volume
      audio.volume = volume;
      
      // Handle autoplay
      if (autoplay) {
        playAudio();
      }
      
      // Clean up
      return () => {
        audio.removeEventListener('loadedmetadata', handleLoadedMetadata);
        audio.removeEventListener('timeupdate', handleTimeUpdate);
        audio.removeEventListener('ended', handleEnded);
      };
    }
  }, [trackUrl, autoplay, playAudio, pauseAudio, volume, onEnded]);
  
  const togglePlay = () => {
    if (isPlaying) {
      pauseAudio();
    } else {
      playAudio();
    }
  };
  
  const handleProgressClick = (e: React.MouseEvent<HTMLDivElement>) => {
    if (progressRef.current && audioRef.current) {
      const progressRect = progressRef.current.getBoundingClientRect();
      const clickPosition = e.clientX - progressRect.left;
      const percentageClicked = clickPosition / progressRect.width;
      const newTime = duration * percentageClicked;
      
      audioRef.current.currentTime = newTime;
      setCurrentTime(newTime);
    }
  };
  
  const handleVolumeChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newVolume = parseFloat(e.target.value);
    setVolume(newVolume);
    
    if (audioRef.current) {
      audioRef.current.volume = newVolume;
    }
  };
  
  return (
    <div style={styles.audioPlayer}>
      <audio ref={audioRef} src={trackUrl} preload="metadata" />
      
      <div className="player-container">
        {coverArtUrl && (
          <div className="cover-art">
            <img src={coverArtUrl} alt={`${trackTitle} by ${artistName}`} />
          </div>
        )}
        
        <div className="player-controls">
          <div className="track-info">
            <h3 className="track-title">{trackTitle}</h3>
            <p className="artist-name">{artistName}</p>
          </div>
          
          <div className="controls">
            <button className="skip-back" aria-label="Skip back 15 seconds" onClick={() => {
              if (audioRef.current) {
                audioRef.current.currentTime = Math.max(0, currentTime - 15);
              }
            }}>
              ⏪
            </button>
            
            <button className="play-pause" aria-label={isPlaying ? 'Pause' : 'Play'} onClick={togglePlay}>
              {isPlaying ? '⏸️' : '▶️'}
            </button>
            
            <button className="skip-forward" aria-label="Skip forward 15 seconds" onClick={() => {
              if (audioRef.current) {
                audioRef.current.currentTime = Math.min(duration, currentTime + 15);
              }
            }}>
              ⏩
            </button>
          </div>
          
          <div className="progress-container">
            <div className="time-display">{formatDuration(currentTime)}</div>
            
            <div 
              className="progress-bar" 
              ref={progressRef}
              onClick={handleProgressClick}
            >
              <div 
                className="progress-fill" 
                style={{ width: `${(currentTime / duration) * 100}%` }}
              ></div>
            </div>
            
            <div className="time-display">{formatDuration(duration)}</div>
          </div>
          
          <div className="volume-control">
            <span className="volume-icon">🔊</span>
            <input 
              type="range" 
              min="0" 
              max="1" 
              step="0.01" 
              value={volume} 
              onChange={handleVolumeChange} 
              className="volume-slider"
            />
          </div>
        </div>
      </div>
    </div>
  );
};

const styles = {
  audioPlayer: {
    width: '100%',
    maxWidth: '600px',
    background: 'var(--background2)',
    borderRadius: '12px',
    padding: '20px',
    boxShadow: '0 4px 12px rgba(0, 0, 0, 0.1)',
    margin: '20px auto'
  },
  playerContainer: {
    display: 'flex',
    alignItems: 'center'
  },
  coverArt: {
    width: '100px',
    height: '100px',
    marginRight: '20px',
    flexShrink: 0
  },
  coverArtImg: {
    width: '100%',
    height: '100%',
    objectFit: 'cover',
    borderRadius: '8px'
  },
  playerControls: {
    flexGrow: 1
  },
  trackTitle: {
    margin: '0 0 5px 0',
    fontSize: '18px',
    color: 'var(--text-color)'
  },
  artistName: {
    margin: 0,
    fontSize: '14px',
    color: 'var(--text-color2)'
  },
  controls: {
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    margin: '15px 0'
  },
  controlsButton: {
    background: 'transparent',
    border: 'none',
    cursor: 'pointer',
    fontSize: '24px',
    padding: '5px 15px',
    borderRadius: '50%',
    transition: 'background-color 0.2s'
  },
  controlsButtonHover: {
    backgroundColor: 'var(--hover)'
  },
  playPause: {
    margin: '0 15px'
  },
  progressContainer: {
    display: 'flex',
    alignItems: 'center',
    marginBottom: '15px'
  },
  timeDisplay: {
    fontSize: '12px',
    color: 'var(--text-color2)',
    width: '45px'
  },
  progressBar: {
    flexGrow: 1,
    height: '6px',
    backgroundColor: 'var(--transparent2)',
    borderRadius: '3px',
    margin: '0 10px',
    cursor: 'pointer',
    position: 'relative'
  },
  progressFill: {
    position: 'absolute',
    top: 0,
    left: 0,
    height: '100%',
    backgroundColor: 'var(--blue)',
    borderRadius: '3px'
  },
  volumeControl: {
    display: 'flex',
    alignItems: 'center'
  },
  volumeIcon: {
    marginRight: '10px',
    fontSize: '16px'
  },
  volumeSlider: {
    '-webkit-appearance': 'none',
    width: '100px',
    height: '4px',
    background: 'var(--transparent2)',
    borderRadius: '2px',
    outline: 'none'
  },
  volumeSliderThumb: {
    '-webkit-appearance': 'none',
    width: '12px',
    height: '12px',
    borderRadius: '50%',
    background: 'var(--blue)',
    cursor: 'pointer'
  }
};

export default AudioPlayer; 
================================================================================
File: components\media\ImageGallery.tsx
Lines: 332
--------------------------------------------------------------------------------
import React, { useState, useRef, useEffect, useCallback } from 'react';

import { imageGalleryStyles } from '../../styles';
import { mergeStyles, conditionalStyle as _conditionalStyle } from '../../utils/styleUtils';

// Define interface for document with vendor prefixed fullscreen properties
interface DocumentWithFullscreen extends Document {
  webkitFullscreenElement?: Element | null;
  mozFullScreenElement?: Element | null;
  webkitExitFullscreen?: () => Promise<void>;
  mozCancelFullScreen?: () => Promise<void>;
}

interface ElementWithFullscreen extends HTMLElement {
  webkitRequestFullscreen?: () => Promise<void>;
  mozRequestFullScreen?: () => Promise<void>;
}

interface ImageItem {
  src: string;
  width: number;
  height: number;
  alt?: string;
}

interface ImageGalleryProps {
  images: ImageItem[];
  aspectRatio?: number; // width/height ratio, default 1:1 (square)
  showThumbnails?: boolean;
  showNavigation?: boolean; 
  initialIndex?: number;
  autoPlay?: boolean;
  autoPlayInterval?: number; // in milliseconds
  onImageChange?: (index: number) => void;
  onClick?: (index: number) => void;
}

const ImageGallery: React.FC<ImageGalleryProps> = ({
  images,
  aspectRatio = 1,
  showThumbnails = true,
  showNavigation = true,
  initialIndex = 0,
  autoPlay = false,
  autoPlayInterval = 3000,
  onImageChange,
  onClick,
}) => {
  const [currentIndex, setCurrentIndex] = useState(initialIndex);
  const [touchStartX, setTouchStartX] = useState(0);
  const [isSwiping, setIsSwiping] = useState(false);
  const [swipeDistance, setSwipeDistance] = useState(0);
  const [isFullscreen, setIsFullscreen] = useState(false);
  
  const galleryRef = useRef<HTMLDivElement>(null);
  const autoPlayRef = useRef<NodeJS.Timeout | null>(null);
  
  const isSingleImage = images.length === 1;
  
  // Reset current index if images change
  useEffect(() => {
    setCurrentIndex(initialIndex < images.length ? initialIndex : 0);
  }, [images, initialIndex]);
  
  const goToNextImage = useCallback(() => {
    setCurrentIndex((prevIndex) => {
      const nextIndex = (prevIndex + 1) % images.length;
      if (onImageChange) onImageChange(nextIndex);
      return nextIndex;
    });
  }, [images.length, onImageChange]);
  
  // Handle autoplay
  useEffect(() => {
    if (autoPlayRef.current) {
      clearInterval(autoPlayRef.current);
      autoPlayRef.current = null;
    }
    
    if (autoPlay && images.length > 1) {
      autoPlayRef.current = setInterval(() => {
        goToNextImage();
      }, autoPlayInterval);
    }
    
    return () => {
      if (autoPlayRef.current) {
        clearInterval(autoPlayRef.current);
      }
    };
  }, [autoPlay, autoPlayInterval, currentIndex, images.length, goToNextImage]);
  
  // Handle fullscreen changes
  useEffect(() => {
    const handleFullscreenChange = () => {
      setIsFullscreen(
        Boolean(
          document.fullscreenElement ||
          (document as DocumentWithFullscreen).webkitFullscreenElement ||
          (document as DocumentWithFullscreen).mozFullScreenElement
        )
      );
    };
    
    document.addEventListener('fullscreenchange', handleFullscreenChange);
    document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
    document.addEventListener('mozfullscreenchange', handleFullscreenChange);
    
    return () => {
      document.removeEventListener('fullscreenchange', handleFullscreenChange);
      document.removeEventListener('webkitfullscreenchange', handleFullscreenChange);
      document.removeEventListener('mozfullscreenchange', handleFullscreenChange);
    };
  }, []);
  
  const goToPrevImage = () => {
    setCurrentIndex((prevIndex) => {
      const nextIndex = (prevIndex - 1 + images.length) % images.length;
      if (onImageChange) onImageChange(nextIndex);
      return nextIndex;
    });
  };
  
  const handleThumbnailClick = (index: number) => {
    setCurrentIndex(index);
    if (onImageChange) onImageChange(index);
  };
  
  const handleTouchStart = (e: React.TouchEvent) => {
    setTouchStartX(e.touches[0].clientX);
    setIsSwiping(true);
    setSwipeDistance(0);
  };
  
  const handleTouchMove = (e: React.TouchEvent) => {
    if (!isSwiping) return;
    
    const currentX = e.touches[0].clientX;
    const distance = currentX - touchStartX;
    setSwipeDistance(distance);
  };
  
  const handleTouchEnd = () => {
    if (!isSwiping) return;
    
    if (swipeDistance > 50) {
      goToPrevImage();
    } else if (swipeDistance < -50) {
      goToNextImage();
    }
    
    setIsSwiping(false);
    setSwipeDistance(0);
  };
  
  const handleImageClick = () => {
    if (onClick) {
      onClick(currentIndex);
    } else if (images.length > 1 && !isFullscreen) {
      goToNextImage();
    }
  };
  
  const toggleFullscreen = () => {
    if (!galleryRef.current) return;
    
    if (isFullscreen) {
      if (document.exitFullscreen) {
        void document.exitFullscreen();
      } else if ((document as DocumentWithFullscreen).webkitExitFullscreen) {
        void (document as DocumentWithFullscreen).webkitExitFullscreen?.();
      } else if ((document as DocumentWithFullscreen).mozCancelFullScreen) {
        void (document as DocumentWithFullscreen).mozCancelFullScreen?.();
      }
    } else {
      if (galleryRef.current.requestFullscreen) {
        void galleryRef.current.requestFullscreen();
      } else if ((galleryRef.current as ElementWithFullscreen).webkitRequestFullscreen) {
        void (galleryRef.current as ElementWithFullscreen).webkitRequestFullscreen?.();
      } else if ((galleryRef.current as ElementWithFullscreen).mozRequestFullScreen) {
        void (galleryRef.current as ElementWithFullscreen).mozRequestFullScreen?.();
      }
    }
  };
  
  // If no images, return nothing
  if (!images.length) return null;
  
  return (
    <div style={{ position: 'relative', width: '100%', maxWidth: '100%' }}>
      <div 
        ref={galleryRef}
        style={mergeStyles(
          imageGalleryStyles.imageGallery as React.CSSProperties,
          { aspectRatio: aspectRatio.toString() },
          isFullscreen ? imageGalleryStyles.imageGalleryFullscreen as React.CSSProperties : {}
        )}
      >
        <div 
          style={imageGalleryStyles.galleryMain as React.CSSProperties}
          onTouchStart={handleTouchStart}
          onTouchMove={handleTouchMove}
          onTouchEnd={handleTouchEnd}
        >
          {images.map((image, index) => (
            <div 
              key={index}
              style={mergeStyles(
                imageGalleryStyles.galleryImageContainer as React.CSSProperties,
                {
                  transform: isSwiping
                    ? `translateX(calc(-${currentIndex * 100}% + ${swipeDistance}px))`
                    : `translateX(-${currentIndex * 100}%)`,
                }
              )}
            >
              <img
                src={image.src}
                alt={image.alt || `Image ${index + 1}`}
                style={mergeStyles(
                  imageGalleryStyles.galleryImage as React.CSSProperties,
                  isFullscreen ? imageGalleryStyles.imageGalleryFullscreenImage as React.CSSProperties : {}
                )}
                onClick={handleImageClick}
              />
            </div>
          ))}
          
          {!isSingleImage && showNavigation && (
            <>
              <button
                style={mergeStyles(
                  imageGalleryStyles.galleryNav as React.CSSProperties,
                  imageGalleryStyles.galleryPrev as React.CSSProperties
                )}
                onClick={goToPrevImage}
                aria-label="Previous image"
                onMouseOver={(e) => {
                  e.currentTarget.style.opacity = '1';
                }}
                onMouseOut={(e) => {
                  e.currentTarget.style.opacity = '0.7';
                }}
              >
                ◀
              </button>
              <button
                style={mergeStyles(
                  imageGalleryStyles.galleryNav as React.CSSProperties,
                  imageGalleryStyles.galleryNext as React.CSSProperties
                )}
                onClick={goToNextImage}
                aria-label="Next image"
                onMouseOver={(e) => {
                  e.currentTarget.style.opacity = '1';
                }}
                onMouseOut={(e) => {
                  e.currentTarget.style.opacity = '0.7';
                }}
              >
                ▶
              </button>
            </>
          )}
          
          <button
            style={imageGalleryStyles.galleryFullscreen as React.CSSProperties}
            onClick={toggleFullscreen}
            aria-label={isFullscreen ? "Exit fullscreen" : "Enter fullscreen"}
            onMouseOver={(e) => {
              e.currentTarget.style.opacity = '1';
            }}
            onMouseOut={(e) => {
              e.currentTarget.style.opacity = '0.7';
            }}
          >
            {isFullscreen ? '↙️' : '↗️'}
          </button>
        </div>
        
        {!isSingleImage && showThumbnails && (
          <div style={imageGalleryStyles.galleryThumbnails as React.CSSProperties}>
            {images.map((image, index) => (
              <div
                key={index}
                style={mergeStyles(
                  imageGalleryStyles.galleryThumbnail as React.CSSProperties,
                  index === currentIndex ? imageGalleryStyles.galleryThumbnailActive as React.CSSProperties : {}
                )}
                onClick={() => handleThumbnailClick(index)}
                onMouseOver={(e) => {
                  if (index !== currentIndex) {
                    e.currentTarget.style.opacity = '0.9';
                  }
                }}
                onMouseOut={(e) => {
                  if (index !== currentIndex) {
                    e.currentTarget.style.opacity = '0.7';
                  }
                }}
              >
                <img
                  src={image.src}
                  alt={`Thumbnail ${index + 1}`}
                  style={imageGalleryStyles.galleryThumbnailImg as React.CSSProperties}
                />
              </div>
            ))}
          </div>
        )}
        
        {!isSingleImage && (
          <div style={imageGalleryStyles.galleryIndicators as React.CSSProperties}>
            {images.map((_, index) => (
              <button
                key={index}
                style={mergeStyles(
                  imageGalleryStyles.galleryIndicator as React.CSSProperties,
                  index === currentIndex ? imageGalleryStyles.galleryIndicatorActive as React.CSSProperties : {}
                )}
                onClick={() => handleThumbnailClick(index)}
                aria-label={`Go to image ${index + 1}`}
              />
            ))}
          </div>
        )}
      </div>
    </div>
  );
};

export default ImageGallery; 
================================================================================
File: components\media\MediaGallery.tsx
Lines: 360
--------------------------------------------------------------------------------
import React, { useState, useEffect, useRef, useCallback } from 'react';

interface MediaItem {
  id: string;
  src: string;
  type: 'image' | 'video' | 'audio';
  title?: string;
  thumbnail?: string;
  description?: string;
  duration?: number;
}

interface MediaGalleryProps {
  items: MediaItem[];
  columns?: number;
  gap?: number;
  className?: string;
}

export const MediaGallery: React.FC<MediaGalleryProps> = ({
  items,
  columns = 3,
  gap = 16,
  className,
}) => {
  const [selectedItem, setSelectedItem] = useState<MediaItem | null>(null);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [isPlaying, setIsPlaying] = useState(false);
  const [volume, setVolume] = useState(1);
  const [isMuted, setIsMuted] = useState(false);
  const [_isFullscreen, setIsFullscreen] = useState(false);
  const videoRef = useRef<HTMLVideoElement>(null);
  const audioRef = useRef<HTMLAudioElement>(null);
  const mediaRef = selectedItem?.type === 'video' ? videoRef : audioRef;

  const styles = {
    gallery: {
      display: 'grid',
      gridTemplateColumns: `repeat(${columns}, 1fr)`,
      gap: `${gap}px`,
      padding: '16px',
      ...(className && { className }),
    },
    item: {
      position: 'relative' as const,
      aspectRatio: '1',
      cursor: 'pointer',
      overflow: 'hidden',
      borderRadius: '8px',
      backgroundColor: '#f5f5f5',
      transition: 'transform 0.2s ease',
      '&:hover': {
        transform: 'scale(1.02)',
      },
    },
    thumbnail: {
      width: '100%',
      height: '100%',
      objectFit: 'cover' as const,
    },
    overlay: {
      position: 'absolute' as const,
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: 'rgba(0, 0, 0, 0.5)',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      opacity: 0,
      transition: 'opacity 0.2s ease',
      '&:hover': {
        opacity: 1,
      },
    },
    title: {
      color: 'white',
      fontSize: '1rem',
      fontWeight: 500,
      textAlign: 'center' as const,
      padding: '8px',
    },
    modal: {
      position: 'fixed' as const,
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: 'rgba(0, 0, 0, 0.9)',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      zIndex: 1000,
    },
    modalContent: {
      position: 'relative' as const,
      maxWidth: '90vw',
      maxHeight: '90vh',
      backgroundColor: '#fff',
      borderRadius: '8px',
      overflow: 'hidden',
    },
    closeButton: {
      position: 'absolute' as const,
      top: '16px',
      right: '16px',
      backgroundColor: 'rgba(0, 0, 0, 0.5)',
      color: 'white',
      border: 'none',
      borderRadius: '50%',
      width: '32px',
      height: '32px',
      cursor: 'pointer',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      transition: 'background-color 0.2s',
      '&:hover': {
        backgroundColor: 'rgba(0, 0, 0, 0.7)',
      },
    },
    media: {
      maxWidth: '100%',
      maxHeight: '90vh',
      objectFit: 'contain' as const,
    },
    controls: {
      position: 'absolute' as const,
      bottom: 0,
      left: 0,
      right: 0,
      padding: '16px',
      backgroundColor: 'rgba(0, 0, 0, 0.7)',
      display: 'flex',
      alignItems: 'center',
      gap: '16px',
    },
    playButton: {
      backgroundColor: 'transparent',
      border: 'none',
      color: 'white',
      cursor: 'pointer',
      padding: '8px',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
    },
    timeSlider: {
      flex: 1,
      height: '4px',
      backgroundColor: 'rgba(255, 255, 255, 0.3)',
      borderRadius: '2px',
      cursor: 'pointer',
      '&:hover': {
        backgroundColor: 'rgba(255, 255, 255, 0.5)',
      },
    },
    timeFill: {
      height: '100%',
      backgroundColor: '#2196f3',
      borderRadius: '2px',
      width: `${(currentTime / duration) * 100}%`,
    },
    volumeControl: {
      display: 'flex',
      alignItems: 'center',
      gap: '8px',
    },
    volumeSlider: {
      width: '100px',
      height: '4px',
      backgroundColor: 'rgba(255, 255, 255, 0.3)',
      borderRadius: '2px',
      cursor: 'pointer',
      '&:hover': {
        backgroundColor: 'rgba(255, 255, 255, 0.5)',
      },
    },
    volumeFill: {
      height: '100%',
      backgroundColor: '#2196f3',
      borderRadius: '2px',
      width: `${volume * 100}%`,
    },
    timeDisplay: {
      color: 'white',
      fontSize: '0.875rem',
      minWidth: '100px',
    },
  };

  useEffect(() => {
    if (selectedItem) {
      setIsPlaying(false);
      setCurrentTime(0);
      setDuration(0);
      setVolume(1);
      setIsMuted(false);
      setIsFullscreen(false);
    }
  }, [selectedItem]);

  const handleTimeUpdate = useCallback(() => {
    if (mediaRef.current) {
      setCurrentTime(mediaRef.current.currentTime);
    }
  }, [mediaRef]);

  const handleLoadedMetadata = useCallback(() => {
    if (mediaRef.current) {
      setDuration(mediaRef.current.duration);
    }
  }, [mediaRef]);

  const handleEnded = useCallback(() => {
    setIsPlaying(false);
    setCurrentTime(0);
  }, []);

  useEffect(() => {
    const currentMedia = mediaRef.current;
    
    if (currentMedia) {
      currentMedia.addEventListener('timeupdate', handleTimeUpdate);
      currentMedia.addEventListener('loadedmetadata', handleLoadedMetadata);
      currentMedia.addEventListener('ended', handleEnded);
    }

    return () => {
      if (currentMedia) {
        currentMedia.removeEventListener('timeupdate', handleTimeUpdate);
        currentMedia.removeEventListener('loadedmetadata', handleLoadedMetadata);
        currentMedia.removeEventListener('ended', handleEnded);
      }
    };
  }, [mediaRef, handleTimeUpdate, handleLoadedMetadata, handleEnded]);

  const togglePlay = () => {
    if (mediaRef.current) {
      if (isPlaying) {
        void mediaRef.current.pause();
      } else {
        void mediaRef.current.play();
      }
      setIsPlaying(!isPlaying);
    }
  };

  const toggleMute = () => {
    if (mediaRef.current) {
      mediaRef.current.muted = !isMuted;
      setIsMuted(!isMuted);
    }
  };

  const formatTime = (time: number): string => {
    const minutes = Math.floor(time / 60);
    const seconds = Math.floor(time % 60);
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
  };

  return (
    <>
      <div style={styles.gallery}>
        {items.map((item) => (
          <div
            key={item.id}
            style={styles.item}
            onClick={() => setSelectedItem(item)}
          >
            <img
              src={item.thumbnail || item.src}
              alt={item.title || ''}
              style={styles.thumbnail}
            />
            <div style={styles.overlay}>
              <h3 style={styles.title}>{item.title}</h3>
            </div>
          </div>
        ))}
      </div>

      {selectedItem && (
        <div style={styles.modal} onClick={() => setSelectedItem(null)}>
          <div style={styles.modalContent} onClick={(e) => e.stopPropagation()}>
            <button
              style={styles.closeButton}
              onClick={() => setSelectedItem(null)}
            >
              ×
            </button>
            
            {selectedItem.type === 'image' ? (
              <img
                src={selectedItem.src}
                alt={selectedItem.title || ''}
                style={styles.media}
              />
            ) : selectedItem.type === 'video' ? (
              <video
                ref={videoRef}
                src={selectedItem.src}
                style={styles.media}
                onTimeUpdate={handleTimeUpdate}
                onLoadedMetadata={handleLoadedMetadata}
                onEnded={handleEnded}
              />
            ) : (
              <audio
                ref={audioRef}
                src={selectedItem.src}
                onTimeUpdate={handleTimeUpdate}
                onLoadedMetadata={handleLoadedMetadata}
                onEnded={handleEnded}
              />
            )}

            {(selectedItem.type === 'video' || selectedItem.type === 'audio') && (
              <div style={styles.controls}>
                <button
                  style={styles.playButton}
                  onClick={togglePlay}
                >
                  {isPlaying ? '⏸' : '▶'}
                </button>
                
                <div style={styles.timeSlider}>
                  <div style={styles.timeFill} />
                </div>
                
                <div style={styles.timeDisplay}>
                  {formatTime(currentTime)} / {formatTime(duration)}
                </div>
                
                <div style={styles.volumeControl}>
                  <button
                    style={styles.playButton}
                    onClick={toggleMute}
                  >
                    {isMuted ? '🔇' : '🔊'}
                  </button>
                  <div style={styles.volumeSlider}>
                    <div
                      style={{
                        ...styles.volumeFill,
                        width: `${volume * 100}%`,
                      }}
                    />
                  </div>
                </div>
              </div>
            )}
          </div>
        </div>
      )}
    </>
  );
}; 
================================================================================
File: components\media\mediaPlayer.tsx
Lines: 246
--------------------------------------------------------------------------------
import React, { useEffect, useRef, useState } from 'react';
import 'plyr/dist/plyr.css';

// Define interfaces for the player types
interface PlyrInstance {
  on(event: string, callback: (...args: unknown[]) => void): void;
  destroy(): void;
  currentTime?: number;
}

interface HlsInstance {
  loadSource(src: string): void;
  attachMedia(media: HTMLMediaElement): void;
  on(event: string, callback: (...args: unknown[]) => void): void;
  startLoad(): void;
  recoverMediaError(): void;
  destroy(): void;
}

// Dynamic imports for the actual implementations
const loadPlyr = () => import('plyr').then(m => m.default);
const loadHls = () => import('hls.js').then(m => {
  const Hls = m.default;
  return { Hls, Events: m.Events };
});

interface MediaPlayerProps {
  src: string;
  type: 'video' | 'audio';
  poster?: string;
  title?: string;
  autoplay?: boolean;
  muted?: boolean;
  crossOrigin?: 'anonymous' | 'use-credentials';
  onReady?: () => void;
  onPlay?: () => void;
  onPause?: () => void;
  onEnded?: () => void;
  onTimeUpdate?: (currentTime: number) => void;
  onError?: (error: unknown) => void;
  className?: string;
}

interface HlsError {
  type: string;
  fatal: boolean;
  details: string;
}

export const MediaPlayer: React.FC<MediaPlayerProps> = ({
  src,
  type,
  poster,
  title,
  autoplay = false,
  muted = false,
  crossOrigin = 'anonymous',
  onReady,
  onPlay,
  onPause,
  onEnded,
  onTimeUpdate,
  onError,
  className
}: MediaPlayerProps) => {
  const mediaRef = useRef<HTMLVideoElement | HTMLAudioElement>(null);
  const playerRef = useRef<PlyrInstance | null>(null);
  const hlsRef = useRef<HlsInstance | null>(null);
  
  const [_isReady, setIsReady] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!mediaRef.current) return;

    // Initialize Plyr
    void loadPlyr().then(PlyrConstructor => {
      if (!mediaRef.current) return;
      
      playerRef.current = new PlyrConstructor(mediaRef.current, {
        controls: [
          'play-large',
          'play',
          'progress',
          'current-time',
          'mute',
          'volume',
          'captions',
          'settings',
          'pip',
          'airplay',
          'fullscreen'
        ],
        settings: ['quality', 'speed', 'loop'],
        quality: {
          default: 720,
          options: [1080, 720, 480, 360, 240]
        },
        speed: {
          selected: 1,
          options: [0.5, 0.75, 1, 1.25, 1.5, 2]
        }
      });

      // Set up event listeners
      playerRef.current.on('ready', () => {
        setIsReady(true);
        onReady?.();
      });

      playerRef.current.on('play', () => onPlay?.());
      playerRef.current.on('pause', () => onPause?.());
      playerRef.current.on('ended', () => onEnded?.());
      playerRef.current.on('timeupdate', () => {
        onTimeUpdate?.(playerRef.current?.currentTime || 0);
      });
      playerRef.current.on('error', (error: unknown) => {
        setError(error instanceof Error ? error.message : 'Unknown error');
        onError?.(error);
      });
    });

    return () => {
      if (hlsRef.current) {
        hlsRef.current.destroy();
      }
      if (playerRef.current) {
        playerRef.current.destroy();
      }
    };
  }, [onEnded, onError, onPause, onPlay, onReady, onTimeUpdate]);

  useEffect(() => {
    if (!mediaRef.current || !src) return;

    const setupHLS = async () => {
      const { Hls, Events } = await loadHls();
      if (Hls.isSupported()) {
        hlsRef.current = new Hls({
          maxLoadingDelay: 4,
          maxMaxBufferLength: 30,
          lowLatencyMode: true
        });

        if (mediaRef.current && hlsRef.current) {
          hlsRef.current.loadSource(src);
          hlsRef.current.attachMedia(mediaRef.current);

          hlsRef.current.on(Events.MANIFEST_PARSED, () => {
            if (autoplay && mediaRef.current) {
              mediaRef.current.play().catch(() => {
                // Autoplay failed, do nothing
              });
            }
          });

          hlsRef.current.on(Events.ERROR, (...args: unknown[]) => {
            const data = args[1] as HlsError;
            if (data.fatal) {
              switch (data.type) {
                case 'networkError':
                  hlsRef.current?.startLoad();
                  break;
                case 'mediaError':
                  hlsRef.current?.recoverMediaError();
                  break;
                default:
                  setError('Fatal HLS error');
                  onError?.(data);
                  break;
              }
            }
          });
        }
      } else if (mediaRef.current?.canPlayType('application/vnd.apple.mpegurl')) {
        // Native HLS support (Safari)
        mediaRef.current.src = src;
      }
    };

    // Clean up previous instances
    if (hlsRef.current) {
      hlsRef.current.destroy();
      hlsRef.current = null;
    }

    // Set up new source
    if (src.includes('.m3u8')) {
      void setupHLS();
    } else {
      mediaRef.current.src = src;
    }
  }, [src, autoplay, onError]);

  const containerStyle: React.CSSProperties = {
    position: 'relative',
    width: '100%',
    maxWidth: '100%',
    backgroundColor: '#000',
    aspectRatio: type === 'video' ? '16/9' : 'auto'
  };

  const mediaStyle: React.CSSProperties = {
    width: '100%',
    height: type === 'video' ? '100%' : 'auto'
  };

  const errorStyle: React.CSSProperties = {
    position: 'absolute',
    top: '50%',
    left: '50%',
    transform: 'translate(-50%, -50%)',
    color: '#fff',
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    padding: '1rem',
    borderRadius: '4px',
    textAlign: 'center'
  };

  return (
    <div style={containerStyle} className={className}>
      {type === 'video' ? (
        <video
          ref={mediaRef as React.LegacyRef<HTMLVideoElement>}
          poster={poster}
          muted={muted}
          crossOrigin={crossOrigin}
          style={mediaStyle}
          title={title}
        >
          {error && <div style={errorStyle}>{error}</div>}
        </video>
      ) : (
        <audio
          ref={mediaRef as React.LegacyRef<HTMLAudioElement>}
          muted={muted}
          crossOrigin={crossOrigin}
          style={mediaStyle}
          title={title}
        >
          {error && <div style={errorStyle}>{error}</div>}
        </audio>
      )}
    </div>
  );
};
================================================================================
File: components\media\mediaUpload.tsx
Lines: 332
--------------------------------------------------------------------------------
// src/client/components/media/MediaUpload.tsx
import React, { useCallback, useState } from 'react';

interface MediaUploadProps {
  onUpload: (file: File) => Promise<void>;
  acceptedTypes?: string[];
  maxSize?: number; // in bytes
  className?: string;
}

export const MediaUpload: React.FC<MediaUploadProps> = ({
  onUpload,
  acceptedTypes = ['image/*', 'audio/*', 'video/*'],
  maxSize = 100 * 1024 * 1024, // 100MB default
  className,
}) => {
  const [isDragging, setIsDragging] = useState(false);
  const [isUploading, setIsUploading] = useState(false);
  const [progress, setProgress] = useState(0);
  const [error, setError] = useState<string | null>(null);
  const [preview, setPreview] = useState<string | null>(null);

  const handleDragEnter = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(true);
  }, []);

  const handleDragLeave = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(false);
  }, []);

  const handleDragOver = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
  }, []);

  const validateFile = useCallback((file: File): string | null => {
    if (file.size > maxSize) {
      return `File size exceeds ${maxSize / (1024 * 1024)}MB limit`;
    }

    if (!acceptedTypes.some(type => {
      if (type.endsWith('/*')) {
        const baseType = type.slice(0, -2);
        return file.type.startsWith(baseType);
      }
      return file.type === type;
    })) {
      return 'File type not accepted';
    }

    return null;
  }, [maxSize, acceptedTypes]);

  const createPreview = (file: File) => {
    const reader = new FileReader();
    reader.onload = () => {
      setPreview(reader.result as string);
    };
    reader.readAsDataURL(file);
  };

  const handleUpload = useCallback(async (file: File) => {
    try {
      setIsUploading(true);
      setProgress(0);
      await onUpload(file);
      setProgress(100);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Upload failed');
    } finally {
      setIsUploading(false);
    }
  }, [onUpload]);

  const handleDrop = useCallback(async (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(false);

    const file = e.dataTransfer.files[0];
    if (!file) return;

    const validationError = validateFile(file);
    if (validationError) {
      setError(validationError);
      return;
    }

    setError(null);
    createPreview(file);
    await handleUpload(file);
  }, [validateFile, handleUpload]);

  const handleFileSelect = useCallback(async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    const validationError = validateFile(file);
    if (validationError) {
      setError(validationError);
      return;
    }

    setError(null);
    createPreview(file);
    await handleUpload(file);
  }, [validateFile, handleUpload]);

  const getMediaIcon = () => {
    if (!preview) return (
      <svg className="media-upload-icon" viewBox="0 0 24 24">
        <path fill="currentColor" d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z"/>
      </svg>
    );
    
    const type = preview.split(';')[0].split('/')[0];
    switch (type) {
      case 'image':
        return (
          <svg className="media-upload-icon" viewBox="0 0 24 24">
            <path fill="currentColor" d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/>
          </svg>
        );
      case 'audio':
        return (
          <svg className="media-upload-icon" viewBox="0 0 24 24">
            <path fill="currentColor" d="M12 3v18c-4.97 0-9-4.03-9-9s4.03-9 9-9zm0-2c-6.07 0-11 4.93-11 11s4.93 11 11 11 11-4.93 11-11S18.07 1 12 1zm-1 14h2V7h-2v8z"/>
          </svg>
        );
      case 'video':
        return (
          <svg className="media-upload-icon" viewBox="0 0 24 24">
            <path fill="currentColor" d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"/>
          </svg>
        );
      default:
        return (
          <svg className="media-upload-icon" viewBox="0 0 24 24">
            <path fill="currentColor" d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z"/>
          </svg>
        );
    }
  };

  const styles = {
    upload: {
      border: '2px dashed #ccc',
      borderRadius: '8px',
      padding: '24px',
      textAlign: 'center' as const,
      backgroundColor: '#fff',
      transition: 'all 0.2s ease',
      position: 'relative' as const,
      ...(isDragging && {
        borderColor: '#2196f3',
        backgroundColor: 'rgba(33, 150, 243, 0.05)',
      }),
    },
    input: {
      display: 'none',
    },
    content: {
      display: 'flex',
      flexDirection: 'column' as const,
      alignItems: 'center',
      gap: '16px',
    },
    icon: {
      width: '48px',
      height: '48px',
      color: '#666',
    },
    title: {
      margin: 0,
      fontSize: '1.25rem',
      fontWeight: 500,
      color: '#333',
    },
    text: {
      margin: 0,
      color: '#666',
    },
    button: {
      display: 'inline-block',
      padding: '8px 16px',
      backgroundColor: '#2196f3',
      color: 'white',
      borderRadius: '4px',
      cursor: 'pointer',
      transition: 'background-color 0.2s',
    },
    buttonHover: {
      backgroundColor: '#1976d2',
    },
    hint: {
      margin: 0,
      fontSize: '0.875rem',
      color: '#666',
    },
    error: {
      margin: 0,
      color: '#d32f2f',
    },
    progress: {
      width: '100%',
      maxWidth: '200px',
    },
    progressBar: {
      width: '100%',
      height: '4px',
      backgroundColor: '#e0e0e0',
      borderRadius: '2px',
      overflow: 'hidden',
    },
    progressFill: {
      height: '100%',
      backgroundColor: '#2196f3',
      transition: 'width 0.2s ease',
      width: `${progress}%`,
    },
    progressText: {
      margin: '4px 0 0',
      fontSize: '0.875rem',
      color: '#666',
    },
    preview: {
      marginTop: '16px',
      maxWidth: '100%',
      maxHeight: '200px',
      overflow: 'hidden',
      borderRadius: '4px',
    },
    previewImage: {
      maxWidth: '100%',
      maxHeight: '200px',
      objectFit: 'contain' as const,
    },
    previewVideo: {
      maxWidth: '100%',
      maxHeight: '200px',
    },
    previewAudio: {
      width: '100%',
      maxWidth: '300px',
    },
  };

  return (
    <div
      style={styles.upload}
      className={className}
      onDragEnter={handleDragEnter}
      onDragLeave={handleDragLeave}
      onDragOver={handleDragOver}
      onDrop={handleDrop as (e: React.DragEvent) => void}
    >
      <input
        type="file"
        accept={acceptedTypes.join(',')}
        onChange={handleFileSelect as (e: React.ChangeEvent<HTMLInputElement>) => void}
        style={styles.input}
        id="media-upload-input"
      />
      
      <div style={styles.content}>
        {getMediaIcon()}
        
        <h3 style={styles.title}>
          {isUploading ? 'Uploading...' : 'Drag & drop media here'}
        </h3>
        
        <p style={styles.text}>
          or
        </p>
        
        <label 
          htmlFor="media-upload-input" 
          style={styles.button}
          onMouseEnter={(e) => e.currentTarget.style.backgroundColor = '#1976d2'}
          onMouseLeave={(e) => e.currentTarget.style.backgroundColor = '#2196f3'}
        >
          Select File
        </label>
        
        <p style={styles.hint}>
          Supported formats: {acceptedTypes.join(', ')}
        </p>
        
        {error && (
          <p style={styles.error}>
            {error}
          </p>
        )}
        
        {isUploading && (
          <div style={styles.progress}>
            <div style={styles.progressBar}>
              <div style={styles.progressFill} />
            </div>
            <p style={styles.progressText}>
              {progress}%
            </p>
          </div>
        )}
      </div>
      
      {preview && !isUploading && (
        <div style={styles.preview}>
          {preview.startsWith('data:image/') ? (
            <img
              src={preview}
              alt="Preview"
              style={styles.previewImage}
            />
          ) : preview.startsWith('data:video/') ? (
            <video
              src={preview}
              controls
              style={styles.previewVideo}
            />
          ) : preview.startsWith('data:audio/') ? (
            <audio src={preview} controls style={styles.previewAudio} />
          ) : null}
        </div>
      )}
    </div>
  );
};
================================================================================
File: components\media\mediaView.tsx
Lines: 67
--------------------------------------------------------------------------------
interface MediaViewProps {
  filename: string;
  type?: 'audio' | 'video' | 'image';
  controls?: boolean;
  autoPlay?: boolean;
  width?: string | number;
  height?: string | number;
}

export function MediaView({
  filename,
  type,
  controls = true,
  autoPlay = false,
  width = '100%',
  height = 'auto'
}: MediaViewProps) {
  // Construct media URL
  const mediaUrl = `/api/stream?filename=${encodeURIComponent(filename)}`;
  
  // Automatically detect type from filename extension if not provided
  const detectType = (): 'audio' | 'video' | 'image' => {
    const ext = filename.split('.').pop()?.toLowerCase();
    
    if (['mp3', 'wav', 'ogg', 'm4a', 'flac'].includes(ext || '')) return 'audio';
    if (['mp4', 'webm', 'mov', 'avi'].includes(ext || '')) return 'video';
    if (['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg'].includes(ext || '')) return 'image';
    
    return 'video'; // Default fallback
  };
  
  const mediaType = type || detectType();
  
  if (mediaType === 'audio') {
    return (
      <audio
        src={mediaUrl}
        controls={controls}
        autoPlay={autoPlay}
        style={{ width }}
      />
    );
  }
  
  if (mediaType === 'video') {
    return (
      <video
        src={mediaUrl}
        controls={controls}
        autoPlay={autoPlay}
        style={{ width, height }}
      />
    );
  }
  
  if (mediaType === 'image') {
    return (
      <img
        src={mediaUrl}
        alt={filename}
        style={{ width, height }}
      />
    );
  }
  
  return <div>Unsupported media type</div>;
}
================================================================================
File: components\media\VideoPlayer.tsx
Lines: 452
--------------------------------------------------------------------------------
import React, { useState, useRef, useEffect } from 'react';

import { formatDuration } from '../../helpers/formatters';
import { videoPlayerStyles } from '../../styles';
import { mergeStyles } from '../../utils/styleUtils';

// Define interface for document with vendor-specific fullscreen properties
interface DocumentWithFullscreen extends Document {
  webkitFullscreenElement?: Element | null;
  mozFullScreenElement?: Element | null;
  webkitExitFullscreen?: () => Promise<void>;
  mozCancelFullScreen?: () => Promise<void>;
}

// Define interface for element with vendor-specific fullscreen methods
interface ElementWithFullscreen extends HTMLDivElement {
  webkitRequestFullscreen?: () => Promise<void>;
  mozRequestFullScreen?: () => Promise<void>;
}

interface VideoSource {
  src: string;
  quality: string;
  type: string;
}

interface VideoPlayerProps {
  sources: VideoSource[];
  poster?: string;
  title?: string;
  autoplay?: boolean;
  loop?: boolean;
  muted?: boolean;
  controls?: boolean;
  width?: number | string;
  height?: number | string;
  onPlay?: () => void;
  onPause?: () => void;
  onEnded?: () => void;
  onTimeUpdate?: (currentTime: number) => void;
  onQualityChange?: (quality: string) => void;
}

const VideoPlayer: React.FC<VideoPlayerProps> = ({
  sources,
  poster,
  title,
  autoplay = false,
  loop = false,
  muted = false,
  controls = true,
  width = '100%',
  height = 'auto',
  onPlay,
  onPause,
  onEnded,
  onTimeUpdate,
  onQualityChange,
}) => {
  const [playing, setPlaying] = useState(autoplay);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [volume, setVolume] = useState(muted ? 0 : 1);
  const [showControls, setShowControls] = useState(false);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [selectedQuality, setSelectedQuality] = useState<string>(sources[0]?.quality || 'auto');
  const [showQualityMenu, setShowQualityMenu] = useState(false);
  
  const videoRef = useRef<HTMLVideoElement>(null);
  const playerRef = useRef<HTMLDivElement>(null);
  const progressRef = useRef<HTMLDivElement>(null);
  
  // Sort sources by quality (high to low)
  const sortedSources = [...sources].sort((a, b) => {
    // Extract numeric value from quality string (e.g., '720p' -> 720)
    const qualityA = parseInt(a.quality.replace(/[^\d]/g, ''), 10) || 0;
    const qualityB = parseInt(b.quality.replace(/[^\d]/g, ''), 10) || 0;
    return qualityB - qualityA;
  });
  
  // Get active source based on selected quality
  const activeSource = sortedSources.find(source => source.quality === selectedQuality) || sortedSources[0];
  
  useEffect(() => {
    const video = videoRef.current;
    if (!video) return;
    
    const handleTimeUpdate = () => {
      setCurrentTime(video.currentTime);
      if (onTimeUpdate) onTimeUpdate(video.currentTime);
    };
    
    const handleLoadedMetadata = () => {
      setDuration(video.duration);
    };
    
    const handlePlay = () => {
      setPlaying(true);
      if (onPlay) onPlay();
    };
    
    const handlePause = () => {
      setPlaying(false);
      if (onPause) onPause();
    };
    
    const handleEnded = () => {
      setPlaying(false);
      if (onEnded) onEnded();
    };
    
    // Set up event listeners
    video.addEventListener('timeupdate', handleTimeUpdate);
    video.addEventListener('loadedmetadata', handleLoadedMetadata);
    video.addEventListener('play', handlePlay);
    video.addEventListener('pause', handlePause);
    video.addEventListener('ended', handleEnded);
    
    // Set initial volume
    video.volume = volume;
    
    // Clean up event listeners
    return () => {
      video.removeEventListener('timeupdate', handleTimeUpdate);
      video.removeEventListener('loadedmetadata', handleLoadedMetadata);
      video.removeEventListener('play', handlePlay);
      video.removeEventListener('pause', handlePause);
      video.removeEventListener('ended', handleEnded);
    };
  }, [onPlay, onPause, onEnded, onTimeUpdate, volume]);
  
  // Handle fullscreen
  useEffect(() => {
    const handleFullscreenChange = () => {
      const doc = document as DocumentWithFullscreen;
      setIsFullscreen(Boolean(
        document.fullscreenElement ||
        doc.webkitFullscreenElement ||
        doc.mozFullScreenElement
      ));
    };
    
    document.addEventListener('fullscreenchange', handleFullscreenChange);
    document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
    document.addEventListener('mozfullscreenchange', handleFullscreenChange);
    
    return () => {
      document.removeEventListener('fullscreenchange', handleFullscreenChange);
      document.removeEventListener('webkitfullscreenchange', handleFullscreenChange);
      document.removeEventListener('mozfullscreenchange', handleFullscreenChange);
    };
  }, []);
  
  const togglePlay = () => {
    if (!videoRef.current) return;
    
    if (playing) {
      videoRef.current.pause();
    } else {
      void videoRef.current.play();
    }
  };
  
  const seekTo = (e: React.MouseEvent<HTMLDivElement>) => {
    if (!progressRef.current || !videoRef.current) return;
    
    const progressRect = progressRef.current.getBoundingClientRect();
    const clickPosition = e.clientX - progressRect.left;
    const seekPercentage = clickPosition / progressRect.width;
    const seekTime = duration * seekPercentage;
    
    videoRef.current.currentTime = seekTime;
    setCurrentTime(seekTime);
  };
  
  const changeVolume = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newVolume = parseFloat(e.target.value);
    setVolume(newVolume);
    
    if (videoRef.current) {
      videoRef.current.volume = newVolume;
      videoRef.current.muted = newVolume === 0;
    }
  };
  
  const toggleMute = () => {
    if (!videoRef.current) return;
    
    if (volume === 0) {
      // Unmute and restore last volume
      const newVolume = 0.5;
      setVolume(newVolume);
      videoRef.current.volume = newVolume;
      videoRef.current.muted = false;
    } else {
      // Mute
      setVolume(0);
      videoRef.current.volume = 0;
      videoRef.current.muted = true;
    }
  };
  
  const toggleFullscreen = () => {
    if (!playerRef.current) return;
    
    if (isFullscreen) {
      const doc = document as DocumentWithFullscreen;
      if (document.exitFullscreen) {
        void document.exitFullscreen();
      } else if (doc.webkitExitFullscreen) {
        void doc.webkitExitFullscreen();
      } else if (doc.mozCancelFullScreen) {
        void doc.mozCancelFullScreen();
      }
    } else {
      const element = playerRef.current as ElementWithFullscreen;
      if (element.requestFullscreen) {
        void element.requestFullscreen();
      } else if (element.webkitRequestFullscreen) {
        void element.webkitRequestFullscreen();
      } else if (element.mozRequestFullScreen) {
        void element.mozRequestFullScreen();
      }
    }
  };
  
  const changeQuality = (quality: string) => {
    // Remember current playback time
    const currentPlaybackTime = videoRef.current?.currentTime || 0;
    const isPlaying = !videoRef.current?.paused;
    
    setSelectedQuality(quality);
    setShowQualityMenu(false);
    
    if (onQualityChange) {
      onQualityChange(quality);
    }
    
    // Let the video load and then restore playback state
    setTimeout(() => {
      if (videoRef.current) {
        videoRef.current.currentTime = currentPlaybackTime;
        if (isPlaying) {
          void videoRef.current.play();
        }
      }
    }, 0);
  };
  
  // Format buffered time for the progress bar
  const getBufferedTime = () => {
    if (!videoRef.current) return 0;
    
    const video = videoRef.current;
    if (video.buffered.length === 0) return 0;
    
    // Return the end time of the last buffered range
    return video.buffered.end(video.buffered.length - 1);
  };
  
  return (
    <div 
      style={mergeStyles(
        videoPlayerStyles.videoPlayer as React.CSSProperties,
        { width, height }
      )}
      ref={playerRef}
      onMouseEnter={() => setShowControls(true)}
      onMouseLeave={() => setShowControls(false)}
    >
      <div style={videoPlayerStyles.videoContainer as React.CSSProperties}>
        <video
          ref={videoRef}
          style={videoPlayerStyles.videoElement as React.CSSProperties}
          poster={poster}
          autoPlay={autoplay}
          loop={loop}
          muted={muted}
          playsInline
        >
          <source src={activeSource.src} type={activeSource.type} />
          Your browser does not support the video tag.
        </video>
        
        <div 
          style={mergeStyles(
            videoPlayerStyles.videoOverlay as React.CSSProperties,
            (showControls || !playing) ? videoPlayerStyles.videoOverlayVisible as React.CSSProperties : {}
          )}
          onClick={togglePlay}
        >
          {!playing && (
            <button 
              style={videoPlayerStyles.playButton as React.CSSProperties}
              onClick={togglePlay}
              onMouseOver={(e) => {
                Object.assign(e.currentTarget.style, {
                  transform: 'scale(1.1)',
                  background: 'rgba(0, 0, 0, 0.8)'
                });
              }}
              onMouseOut={(e) => {
                Object.assign(e.currentTarget.style, {
                  transform: 'scale(1)',
                  background: 'rgba(0, 0, 0, 0.7)'
                });
              }}
            >
              ▶
            </button>
          )}
        </div>
        
        {controls && (
          <div 
            style={mergeStyles(
              videoPlayerStyles.controls as React.CSSProperties,
              (showControls || !playing) ? videoPlayerStyles.controlsVisible as React.CSSProperties : {}
            )}
            onClick={(e) => e.stopPropagation()}
          >
            <div 
              style={videoPlayerStyles.progressContainer as React.CSSProperties}
              ref={progressRef}
              onClick={seekTo}
            >
              <div 
                style={mergeStyles(
                  videoPlayerStyles.progressBar as React.CSSProperties,
                  { width: `${(currentTime / duration) * 100}%` }
                )}
              />
              <div 
                style={mergeStyles(
                  videoPlayerStyles.progressBar as React.CSSProperties,
                  { 
                    width: `${(getBufferedTime() / duration) * 100}%`,
                    opacity: 0.3 
                  }
                )}
              />
            </div>
            
            <div style={videoPlayerStyles.controlsRow as React.CSSProperties}>
              <div style={videoPlayerStyles.controlsGroup as React.CSSProperties}>
                <button 
                  style={videoPlayerStyles.controlButton as React.CSSProperties}
                  onClick={togglePlay}
                  onMouseOver={(e) => { e.currentTarget.style.opacity = '1'; }}
                  onMouseOut={(e) => { e.currentTarget.style.opacity = '0.8'; }}
                >
                  {playing ? '⏸' : '▶'}
                </button>
                
                <div style={videoPlayerStyles.volumeContainer as React.CSSProperties}>
                  <button 
                    style={videoPlayerStyles.controlButton as React.CSSProperties}
                    onClick={toggleMute}
                    onMouseOver={(e) => { e.currentTarget.style.opacity = '1'; }}
                    onMouseOut={(e) => { e.currentTarget.style.opacity = '0.8'; }}
                  >
                    {volume === 0 ? '🔇' : volume < 0.5 ? '🔉' : '🔊'}
                  </button>
                  <input
                    type="range"
                    min="0"
                    max="1"
                    step="0.1"
                    value={volume}
                    onChange={changeVolume}
                    style={videoPlayerStyles.volumeSlider as React.CSSProperties}
                  />
                </div>
                
                <span style={videoPlayerStyles.timeDisplay as React.CSSProperties}>
                  {formatDuration(currentTime)} / {formatDuration(duration)}
                </span>
              </div>
              
              <div style={videoPlayerStyles.controlsGroup as React.CSSProperties}>
                {sources.length > 1 && (
                  <div style={{ position: 'relative' }}>
                    <button 
                      style={videoPlayerStyles.controlButton as React.CSSProperties}
                      onClick={() => setShowQualityMenu(!showQualityMenu)}
                      onMouseOver={(e) => { e.currentTarget.style.opacity = '1'; }}
                      onMouseOut={(e) => { e.currentTarget.style.opacity = '0.8'; }}
                    >
                      {selectedQuality} ⚙️
                    </button>
                    
                    {showQualityMenu && (
                      <div style={{
                        position: 'absolute',
                        bottom: '40px',
                        right: '0',
                        background: 'rgba(0, 0, 0, 0.8)',
                        borderRadius: '4px',
                        padding: '8px',
                        zIndex: 10
                      }}>
                        {sortedSources.map((source) => (
                          <div 
                            key={source.quality}
                            style={{
                              padding: '5px 10px',
                              cursor: 'pointer',
                              color: source.quality === selectedQuality ? 'var(--blue, #1a73e8)' : 'white',
                              fontWeight: source.quality === selectedQuality ? 'bold' : 'normal'
                            }}
                            onClick={() => changeQuality(source.quality)}
                          >
                            {source.quality}
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                )}
                
                <button 
                  style={mergeStyles(
                    videoPlayerStyles.controlButton as React.CSSProperties,
                    videoPlayerStyles.fullscreenButton as React.CSSProperties
                  )}
                  onClick={toggleFullscreen}
                  onMouseOver={(e) => { e.currentTarget.style.opacity = '1'; }}
                  onMouseOut={(e) => { e.currentTarget.style.opacity = '0.8'; }}
                >
                  {isFullscreen ? '↙️' : '↗️'}
                </button>
              </div>
            </div>
          </div>
        )}
      </div>
      
      {title && (
        <div style={{
          padding: '10px',
          fontSize: '1rem',
          fontWeight: 'bold',
          color: 'var(--text-color)'
        }}>
          {title}
        </div>
      )}
    </div>
  );
};

export default VideoPlayer; 
================================================================================
File: components\pages\DashboardPage.tsx
Lines: 174
--------------------------------------------------------------------------------
import { PageContent } from '../layouts/PageContent';

// Dashboard page styles
const styles = {
  grid: {
    display: 'grid',
    gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))',
    gap: '20px',
    marginTop: '20px'
  },
  card: {
    backgroundColor: 'var(--card-bg)',
    borderRadius: '8px',
    padding: '20px',
    boxShadow: 'var(--shadow)',
    border: '1px solid var(--border-color)'
  },
  statsGrid: {
    display: 'grid',
    gridTemplateColumns: '1fr 1fr',
    gap: '15px'
  },
  statLabel: {
    fontSize: '14px',
    color: 'var(--text-secondary)'
  },
  statValue: {
    fontSize: '24px',
    fontWeight: 'bold',
    color: 'var(--text-primary)'
  },
  activityItem: {
    padding: '10px',
    backgroundColor: 'var(--surface)',
    borderRadius: '4px'
  },
  activityTitle: {
    fontWeight: 'bold',
    color: 'var(--text-primary)'
  },
  activityTime: {
    fontSize: '14px',
    color: 'var(--text-secondary)',
    marginTop: '5px'
  },
  actionButton: {
    padding: '10px',
    backgroundColor: 'var(--blue)',
    color: 'white',
    border: 'none',
    borderRadius: '4px',
    cursor: 'pointer',
    textAlign: 'left' as const
  },
  actionButtonOutline: {
    padding: '10px',
    backgroundColor: 'var(--card-bg)',
    color: 'var(--blue)',
    border: '1px solid var(--blue)',
    borderRadius: '4px',
    cursor: 'pointer',
    textAlign: 'left' as const
  },
  eventItem: {
    padding: '10px',
    borderLeft: '3px solid',
    backgroundColor: 'var(--surface)'
  },
  eventTitle: {
    fontWeight: 'bold',
    color: 'var(--text-primary)'
  },
  eventTime: {
    fontSize: '14px',
    marginTop: '5px',
    color: 'var(--text-primary)'
  },
  flexColumn: {
    display: 'flex',
    flexDirection: 'column' as const,
    gap: '10px'
  },
  sectionTitle: {
    margin: '0 0 15px 0'
  }
};

export function DashboardPage() {
  return (
    <PageContent
      title="Dashboard"
      description="Welcome to your personalized dashboard."
    >
      <div style={styles.grid}>
        {/* Stats Card */}
        <div style={styles.card}>
          <h3 style={styles.sectionTitle}>Statistics</h3>
          <div style={styles.statsGrid}>
            <div>
              <div style={styles.statLabel}>Views</div>
              <div style={styles.statValue}>1,254</div>
            </div>
            <div>
              <div style={styles.statLabel}>Likes</div>
              <div style={styles.statValue}>423</div>
            </div>
            <div>
              <div style={styles.statLabel}>Comments</div>
              <div style={styles.statValue}>97</div>
            </div>
            <div>
              <div style={styles.statLabel}>Shares</div>
              <div style={styles.statValue}>56</div>
            </div>
          </div>
        </div>
        
        {/* Recent Activity Card */}
        <div style={styles.card}>
          <h3 style={styles.sectionTitle}>Recent Activity</h3>
          <div style={styles.flexColumn}>
            <div style={styles.activityItem}>
              <div style={styles.activityTitle}>New comment on your post</div>
              <div style={styles.activityTime}>2 minutes ago</div>
            </div>
            <div style={styles.activityItem}>
              <div style={styles.activityTitle}>Your post was featured</div>
              <div style={styles.activityTime}>1 hour ago</div>
            </div>
            <div style={styles.activityItem}>
              <div style={styles.activityTitle}>New follower: JaneDoe</div>
              <div style={styles.activityTime}>3 hours ago</div>
            </div>
          </div>
        </div>
        
        {/* Quick Actions Card */}
        <div style={styles.card}>
          <h3 style={styles.sectionTitle}>Quick Actions</h3>
          <div style={styles.flexColumn}>
            <button style={styles.actionButton}>
              Create New Post
            </button>
            <button style={styles.actionButtonOutline}>
              Upload Media
            </button>
            <button style={styles.actionButtonOutline}>
              Edit Profile
            </button>
          </div>
        </div>
        
        {/* Upcoming Events Card */}
        <div style={styles.card}>
          <h3 style={styles.sectionTitle}>Upcoming Events</h3>
          <div style={styles.flexColumn}>
            <div style={{...styles.eventItem, borderLeftColor: 'var(--blue)'}}>
              <div style={styles.eventTitle}>Team Meeting</div>
              <div style={styles.eventTime}>Tomorrow, 10:00 AM</div>
            </div>
            <div style={{...styles.eventItem, borderLeftColor: 'var(--green)'}}>
              <div style={styles.eventTitle}>Project Deadline</div>
              <div style={styles.eventTime}>Friday, 5:00 PM</div>
            </div>
            <div style={{...styles.eventItem, borderLeftColor: 'var(--purple)'}}>
              <div style={styles.eventTitle}>Webinar: New Features</div>
              <div style={styles.eventTime}>Next Monday, 2:00 PM</div>
            </div>
          </div>
        </div>
      </div>
    </PageContent>
  );
} 
================================================================================
File: components\pages\DesignPage.tsx
Lines: 107
--------------------------------------------------------------------------------
import { PageContent } from '../layouts/PageContent';

export function DesignPage() {
  return (
    <PageContent
      title="Design System"
      description="This page showcases the design system components available in the ABE Stack."
    >
      <div style={{ marginTop: '20px' }}>
        <h2>Color Palette</h2>
        <div style={{ display: 'flex', gap: '10px', flexWrap: 'wrap', marginTop: '10px' }}>
          <div style={{ width: '100px', height: '100px', backgroundColor: 'var(--blue)', display: 'flex', alignItems: 'center', justifyContent: 'center', color: 'white', borderRadius: '4px' }}>Blue</div>
          <div style={{ width: '100px', height: '100px', backgroundColor: 'var(--green)', display: 'flex', alignItems: 'center', justifyContent: 'center', color: 'white', borderRadius: '4px' }}>Green</div>
          <div style={{ width: '100px', height: '100px', backgroundColor: 'var(--red)', display: 'flex', alignItems: 'center', justifyContent: 'center', color: 'white', borderRadius: '4px' }}>Red</div>
          <div style={{ width: '100px', height: '100px', backgroundColor: 'var(--yellow)', display: 'flex', alignItems: 'center', justifyContent: 'center', color: 'black', borderRadius: '4px' }}>Yellow</div>
          <div style={{ width: '100px', height: '100px', backgroundColor: 'var(--purple)', display: 'flex', alignItems: 'center', justifyContent: 'center', color: 'white', borderRadius: '4px' }}>Purple</div>
        </div>
      </div>
      
      <div style={{ marginTop: '30px' }}>
        <h2>Typography</h2>
        <div style={{ marginTop: '10px' }}>
          <h1 style={{ margin: '10px 0' }}>Heading 1</h1>
          <h2 style={{ margin: '10px 0' }}>Heading 2</h2>
          <h3 style={{ margin: '10px 0' }}>Heading 3</h3>
          <h4 style={{ margin: '10px 0' }}>Heading 4</h4>
          <p style={{ margin: '10px 0' }}>Regular paragraph text</p>
          <p style={{ margin: '10px 0', fontWeight: 'bold' }}>Bold text</p>
          <p style={{ margin: '10px 0', fontStyle: 'italic' }}>Italic text</p>
        </div>
      </div>
      
      <div style={{ marginTop: '30px' }}>
        <h2>Buttons</h2>
        <div style={{ display: 'flex', gap: '10px', flexWrap: 'wrap', marginTop: '10px' }}>
          <button style={{ padding: '8px 16px', backgroundColor: 'var(--blue)', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer' }}>Primary</button>
          <button style={{ padding: '8px 16px', backgroundColor: 'white', color: 'var(--blue)', border: '1px solid var(--blue)', borderRadius: '4px', cursor: 'pointer' }}>Secondary</button>
          <button style={{ padding: '8px 16px', backgroundColor: 'var(--green)', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer' }}>Success</button>
          <button style={{ padding: '8px 16px', backgroundColor: 'var(--red)', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer' }}>Danger</button>
          <button style={{ padding: '8px 16px', backgroundColor: 'var(--yellow)', color: 'black', border: 'none', borderRadius: '4px', cursor: 'pointer' }}>Warning</button>
          <button style={{ padding: '8px 16px', backgroundColor: '#ccc', color: '#666', border: 'none', borderRadius: '4px', cursor: 'not-allowed' }}>Disabled</button>
        </div>
      </div>
      
      <div style={{ marginTop: '30px' }}>
        <h2>Form Elements</h2>
        <div style={{ display: 'flex', flexDirection: 'column', gap: '15px', marginTop: '10px', maxWidth: '400px' }}>
          <div>
            <label style={{ display: 'block', marginBottom: '5px' }}>Text Input</label>
            <input type="text" placeholder="Enter text" style={{ width: '100%', padding: '8px', borderRadius: '4px', border: '1px solid #ccc' }} />
          </div>
          <div>
            <label style={{ display: 'block', marginBottom: '5px' }}>Select</label>
            <select style={{ width: '100%', padding: '8px', borderRadius: '4px', border: '1px solid #ccc' }}>
              <option>Option 1</option>
              <option>Option 2</option>
              <option>Option 3</option>
            </select>
          </div>
          <div>
            <label style={{ display: 'block', marginBottom: '5px' }}>Textarea</label>
            <textarea placeholder="Enter longer text" style={{ width: '100%', padding: '8px', borderRadius: '4px', border: '1px solid #ccc', minHeight: '100px' }}></textarea>
          </div>
          <div>
            <label style={{ display: 'flex', alignItems: 'center', gap: '8px', cursor: 'pointer' }}>
              <input type="checkbox" />
              <span>Checkbox option</span>
            </label>
          </div>
          <div style={{ display: 'flex', flexDirection: 'column', gap: '8px' }}>
            <label style={{ display: 'flex', alignItems: 'center', gap: '8px', cursor: 'pointer' }}>
              <input type="radio" name="radioGroup" />
              <span>Radio option 1</span>
            </label>
            <label style={{ display: 'flex', alignItems: 'center', gap: '8px', cursor: 'pointer' }}>
              <input type="radio" name="radioGroup" />
              <span>Radio option 2</span>
            </label>
          </div>
        </div>
      </div>
      
      <div style={{ marginTop: '30px' }}>
        <h2>Cards</h2>
        <div style={{ display: 'flex', gap: '20px', flexWrap: 'wrap', marginTop: '10px' }}>
          <div style={{ width: '250px', border: '1px solid #ddd', borderRadius: '8px', overflow: 'hidden' }}>
            <div style={{ height: '150px', backgroundColor: 'var(--blue)', display: 'flex', alignItems: 'center', justifyContent: 'center', color: 'white' }}>Image Placeholder</div>
            <div style={{ padding: '15px' }}>
              <h3 style={{ marginTop: 0 }}>Card Title</h3>
              <p>This is a basic card with an image, title, and description.</p>
              <button style={{ padding: '6px 12px', backgroundColor: 'var(--blue)', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer', marginTop: '10px' }}>Action</button>
            </div>
          </div>
          
          <div style={{ width: '250px', border: '1px solid #ddd', borderRadius: '8px', padding: '15px' }}>
            <h3 style={{ marginTop: 0 }}>Simple Card</h3>
            <p>This is a simpler card without an image, just text content.</p>
            <div style={{ display: 'flex', gap: '10px', marginTop: '10px' }}>
              <button style={{ padding: '6px 12px', backgroundColor: 'white', color: 'var(--blue)', border: '1px solid var(--blue)', borderRadius: '4px', cursor: 'pointer' }}>Cancel</button>
              <button style={{ padding: '6px 12px', backgroundColor: 'var(--blue)', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer' }}>Confirm</button>
            </div>
          </div>
        </div>
      </div>
    </PageContent>
  );
} 
================================================================================
File: components\pages\ExplorePage.tsx
Lines: 279
--------------------------------------------------------------------------------
import { useState } from 'react';

import { PageContent } from '../layouts/PageContent';

// Explore page styles
const styles = {
  categories: {
    marginTop: '20px',
    borderBottom: '1px solid var(--border-color)',
    paddingBottom: '10px'
  },
  categoryButtons: {
    display: 'flex',
    gap: '10px',
    overflowX: 'auto' as const,
    paddingBottom: '5px'
  },
  categoryButton: {
    padding: '8px 16px',
    borderRadius: '20px',
    cursor: 'pointer',
    whiteSpace: 'nowrap' as const
  },
  categoryButtonActive: {
    backgroundColor: 'var(--blue)',
    color: 'white',
    border: 'none'
  },
  categoryButtonInactive: {
    backgroundColor: 'transparent',
    color: 'var(--blue)',
    border: '1px solid var(--blue)'
  },
  searchContainer: {
    marginTop: '20px',
    display: 'flex',
    gap: '10px'
  },
  searchInput: {
    flex: 1,
    padding: '10px 15px',
    borderRadius: '4px',
    border: '1px solid var(--border-color)',
    fontSize: '16px',
    backgroundColor: 'var(--surface)',
    color: 'var(--text-primary)'
  },
  searchButton: {
    padding: '10px 20px',
    backgroundColor: 'var(--blue)',
    color: 'white',
    border: 'none',
    borderRadius: '4px',
    cursor: 'pointer'
  },
  contentSection: {
    marginTop: '30px'
  },
  contentTitle: {
    color: 'var(--text-primary)'
  },
  contentGrid: {
    display: 'grid',
    gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))',
    gap: '20px',
    marginTop: '15px'
  },
  contentCard: {
    border: '1px solid var(--border-color)',
    borderRadius: '8px',
    overflow: 'hidden',
    transition: 'transform 0.2s ease, box-shadow 0.2s ease',
    cursor: 'pointer',
    backgroundColor: 'var(--card-bg)',
    boxShadow: 'var(--shadow)'
  },
  contentCardHover: {
    transform: 'translateY(-5px)',
    boxShadow: '0 5px 15px rgba(0, 0, 0, 0.2)'
  },
  contentImage: {
    height: '160px',
    backgroundColor: 'var(--blue)',
    position: 'relative' as const
  },
  contentViews: {
    position: 'absolute' as const,
    bottom: '10px',
    right: '10px',
    backgroundColor: 'rgba(0, 0, 0, 0.6)',
    color: 'white',
    padding: '3px 8px',
    borderRadius: '4px',
    fontSize: '12px'
  },
  contentDetails: {
    padding: '15px'
  },
  contentItemTitle: {
    margin: '0 0 5px 0',
    fontSize: '18px',
    color: 'var(--text-primary)'
  },
  contentAuthor: {
    color: 'var(--text-secondary)',
    fontSize: '14px',
    marginBottom: '10px'
  },
  contentFooter: {
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center'
  },
  contentLikes: {
    display: 'flex',
    alignItems: 'center',
    gap: '5px',
    color: 'var(--text-secondary)',
    fontSize: '14px'
  },
  pagination: {
    marginTop: '30px',
    display: 'flex',
    justifyContent: 'center',
    gap: '5px'
  },
  paginationButton: {
    width: '40px',
    height: '40px',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    border: '1px solid var(--border-color)',
    borderRadius: '4px',
    backgroundColor: 'var(--card-bg)',
    cursor: 'pointer',
    color: 'var(--text-primary)'
  },
  paginationButtonActive: {
    border: 'none',
    backgroundColor: 'var(--blue)',
    color: 'white'
  }
};

export function ExplorePage() {
  const [activeCategory, setActiveCategory] = useState('all');
  const [hoveredCard, setHoveredCard] = useState<number | null>(null);
  
  const categories = [
    { id: 'all', name: 'All' },
    { id: 'trending', name: 'Trending' },
    { id: 'new', name: 'New' },
    { id: 'popular', name: 'Popular' },
    { id: 'following', name: 'Following' }
  ];
  
  // Mock content items
  const contentItems = [
    { id: 1, title: 'Getting Started with React', author: 'Jane Smith', views: '1.2K', likes: 245, category: 'popular' },
    { id: 2, title: 'Advanced TypeScript Patterns', author: 'John Doe', views: '856', likes: 178, category: 'trending' },
    { id: 3, title: 'Building Responsive UIs', author: 'Alice Johnson', views: '3.4K', likes: 412, category: 'popular' },
    { id: 4, title: 'State Management in 2023', author: 'Bob Wilson', views: '921', likes: 156, category: 'new' },
    { id: 5, title: 'API Design Best Practices', author: 'Carol Taylor', views: '1.8K', likes: 267, category: 'trending' },
    { id: 6, title: 'Performance Optimization Tips', author: 'Dave Martin', views: '2.3K', likes: 389, category: 'popular' },
    { id: 7, title: 'Intro to Web Components', author: 'Eve Anderson', views: '745', likes: 132, category: 'new' },
    { id: 8, title: 'Accessibility for Developers', author: 'Frank Thomas', views: '1.5K', likes: 203, category: 'trending' }
  ];
  
  const filteredItems = activeCategory === 'all' 
    ? contentItems 
    : contentItems.filter(item => item.category === activeCategory);
  
  return (
    <PageContent
      title="Explore Content"
      description="Discover trending and popular content from creators."
    >
      {/* Categories */}
      <div style={styles.categories}>
        <div style={styles.categoryButtons}>
          {categories.map(category => (
            <button
              key={category.id}
              onClick={() => setActiveCategory(category.id)}
              style={{
                ...styles.categoryButton,
                ...(activeCategory === category.id ? styles.categoryButtonActive : styles.categoryButtonInactive)
              }}
            >
              {category.name}
            </button>
          ))}
        </div>
      </div>
      
      {/* Search Bar */}
      <div style={styles.searchContainer}>
        <input
          type="text"
          placeholder="Search content..."
          style={styles.searchInput}
        />
        <button style={styles.searchButton}>
          Search
        </button>
      </div>
      
      {/* Content Grid */}
      <div style={styles.contentSection}>
        <h2 style={styles.contentTitle}>
          {activeCategory === 'all' ? 'All Content' : categories.find(c => c.id === activeCategory)?.name}
        </h2>
        <div style={styles.contentGrid}>
          {filteredItems.map(item => (
            <div 
              key={item.id} 
              style={{
                ...styles.contentCard,
                ...(hoveredCard === item.id ? styles.contentCardHover : {})
              }}
              onMouseEnter={() => setHoveredCard(item.id)}
              onMouseLeave={() => setHoveredCard(null)}
            >
              <div style={styles.contentImage}>
                <div style={styles.contentViews}>
                  {item.views} views
                </div>
              </div>
              <div style={styles.contentDetails}>
                <h3 style={styles.contentItemTitle}>{item.title}</h3>
                <div style={styles.contentAuthor}>by {item.author}</div>
                <div style={styles.contentFooter}>
                  <div style={styles.contentLikes}>
                    <span>❤️ {item.likes}</span>
                  </div>
                  <div style={{ 
                    backgroundColor: item.category === 'trending' ? '#ffecb3' : 
                                    item.category === 'new' ? '#e3f2fd' : 
                                    item.category === 'popular' ? '#e8f5e9' : '#f5f5f5',
                    padding: '3px 8px',
                    borderRadius: '4px',
                    fontSize: '12px',
                    color: item.category === 'trending' ? '#ff6f00' : 
                           item.category === 'new' ? '#0277bd' : 
                           item.category === 'popular' ? '#2e7d32' : '#616161'
                  }}>
                    {item.category}
                  </div>
                </div>
              </div>
            </div>
          ))}
        </div>
      </div>
      
      {/* Pagination */}
      <div style={styles.pagination}>
        <button style={styles.paginationButton}>
          &lt;
        </button>
        {[1, 2, 3, 4, 5].map(page => (
          <button 
            key={page}
            style={{
              ...styles.paginationButton,
              ...(page === 1 ? styles.paginationButtonActive : {})
            }}
          >
            {page}
          </button>
        ))}
        <button style={styles.paginationButton}>
          &gt;
        </button>
      </div>
    </PageContent>
  );
} 
================================================================================
File: components\pages\HomePage.tsx
Lines: 265
--------------------------------------------------------------------------------
import { useClientEnvironment } from '../../services/ClientEnvironment';
import { PageContent } from '../layouts/PageContent';

export function HomePage() {
  const environment = useClientEnvironment();
  
  // Function to handle navigation using the custom router
  const handleNavigate = (path: string) => {
    environment.router.navigate(path);
  };
  
  return (
    <PageContent 
      title="Welcome to ABE Stack" 
      description="A modern, full-stack TypeScript boilerplate for building web applications"
    >
      <div style={{ maxWidth: '800px', margin: '0 auto' }}>
        {/* Credit Banner */}
        <div style={{
          backgroundColor: 'var(--accent)',
          color: 'white',
          padding: '15px 20px',
          borderRadius: '8px',
          marginBottom: '30px',
          boxShadow: 'var(--shadow)',
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          textAlign: 'center'
        }}>
          <h2 style={{ margin: '0 0 10px 0', fontSize: '1.4rem' }}>
            Built on Chet Stack
          </h2>
          <p style={{ margin: '0 0 10px 0', fontSize: '1.1rem', lineHeight: '1.5' }}>
            ABE Stack is proudly built upon the excellent foundation provided by 
            <a href="https://github.com/ccorcos/chet-stack" target="_blank" rel="noopener noreferrer" 
              style={{ color: 'white', textDecoration: 'underline', fontWeight: 'bold', marginLeft: '5px' }}>
              Chet Stack
            </a> by Chet Corcos.
          </p>
          <a href="https://github.com/ccorcos/chet-stack" target="_blank" rel="noopener noreferrer"
            style={{
              backgroundColor: 'white',
              color: 'var(--accent)',
              padding: '8px 16px',
              borderRadius: '4px',
              textDecoration: 'none',
              fontWeight: 'bold',
              marginTop: '5px'
            }}>
            Visit Chet Stack Repository
          </a>
        </div>

        <section style={{ marginBottom: '40px' }}>
          <h2 style={{ borderBottom: '1px solid var(--border-color)', paddingBottom: '10px', marginBottom: '20px' }}>
            What is ABE Stack?
          </h2>
          <p style={{ fontSize: '1.1rem', lineHeight: '1.6', marginBottom: '20px' }}>
            <strong>ABE Stack</strong> (Authentication, Backend, and Everything) is a comprehensive boilerplate designed to accelerate web application development. 
            It extends the powerful foundation of Chet Stack with additional features, UI components, and ready-to-use patterns.
          </p>
          <p style={{ fontSize: '1.1rem', lineHeight: '1.6', marginBottom: '20px' }}>
            Whether you&apos;re building a social platform, content management system, or any modern web application, ABE Stack provides the essential building blocks 
            so you can focus on your unique business logic rather than reinventing the wheel.
          </p>
        </section>

        <section style={{ marginBottom: '40px' }}>
          <h2 style={{ borderBottom: '1px solid var(--border-color)', paddingBottom: '10px', marginBottom: '20px' }}>
            Core Architecture
          </h2>
          <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))', gap: '20px' }}>
            <FeatureCard 
              title="Full-Stack TypeScript" 
              description="End-to-end type safety with TypeScript on both client and server. The shared type definitions between frontend and backend eliminate type mismatches and provide excellent developer experience."
            />
            <FeatureCard 
              title="Vite + React" 
              description="Lightning-fast development with Vite and modern React patterns. Enjoy hot module replacement, optimized builds, and a component-based architecture using React hooks and context."
            />
            <FeatureCard 
              title="PostgreSQL + Migrations" 
              description="Robust database integration with PostgreSQL, including a migration system, query builders, and type-safe database access patterns inherited from Chet Stack."
            />
            <FeatureCard 
              title="WebSocket Integration" 
              description="Real-time communication between client and server using WebSockets. This enables live updates, notifications, and collaborative features without complex setup."
            />
          </div>
        </section>

        <section style={{ marginBottom: '40px' }}>
          <h2 style={{ borderBottom: '1px solid var(--border-color)', paddingBottom: '10px', marginBottom: '20px' }}>
            Extended Features
          </h2>
          <p style={{ fontSize: '1.1rem', lineHeight: '1.6', marginBottom: '20px' }}>
            While Chet Stack provides an excellent foundation, ABE Stack extends it with additional features and components:
          </p>
          <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))', gap: '20px', marginBottom: '20px' }}>
            <FeatureCard 
              title="Authentication System" 
              description="Complete user authentication flow with registration, login, profile management, and secure session handling."
            />
            <FeatureCard 
              title="Responsive UI Components" 
              description="A library of pre-built, responsive UI components that work across all device sizes, from mobile to desktop."
            />
            <FeatureCard 
              title="Theme System" 
              description="Built-in theme support with light/dark modes, system preference detection, and user customization options."
            />
            <FeatureCard 
              title="Notifications Framework" 
              description="Real-time notification system with different notification types, read status tracking, and user preferences."
            />
          </div>
          <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))', gap: '20px' }}>
            <FeatureCard 
              title="Media Management" 
              description="Infrastructure for handling images, videos, and other media types with upload, storage, and delivery capabilities."
            />
            <FeatureCard 
              title="Social Components" 
              description="Building blocks for social features like profiles, connections, activity feeds, and interactions."
            />
            <FeatureCard 
              title="Layout System" 
              description="Flexible layout components with responsive behavior, including sidebar, content areas, and navigation elements."
            />
            <FeatureCard 
              title="Form Handling" 
              description="Comprehensive form components with validation, error handling, and submission management."
            />
          </div>
        </section>

        <section style={{ marginBottom: '40px' }}>
          <h2 style={{ borderBottom: '1px solid var(--border-color)', paddingBottom: '10px', marginBottom: '20px' }}>
            Technical Details
          </h2>
          <div style={{ backgroundColor: 'var(--card-bg)', padding: '20px', borderRadius: '8px', border: '1px solid var(--border-color)' }}>
            <h3 style={{ margin: '0 0 15px 0', color: 'var(--accent)' }}>Chet Stack Foundation</h3>
            <p style={{ fontSize: '1.05rem', lineHeight: '1.6', marginBottom: '15px' }}>
              The core architecture of ABE Stack is built on Chet Stack, which provides:
            </p>
            <ul style={{ paddingLeft: '20px', fontSize: '1.05rem', lineHeight: '1.6', marginBottom: '20px' }}>
              <li style={{ marginBottom: '8px' }}>Type-safe database access patterns</li>
              <li style={{ marginBottom: '8px' }}>Migration system for database schema evolution</li>
              <li style={{ marginBottom: '8px' }}>WebSocket infrastructure for real-time communication</li>
              <li style={{ marginBottom: '8px' }}>Client-side routing with code splitting</li>
              <li style={{ marginBottom: '8px' }}>Development tooling and production optimization</li>
            </ul>
            
            <h3 style={{ margin: '0 0 15px 0', color: 'var(--accent)' }}>ABE Stack Extensions</h3>
            <p style={{ fontSize: '1.05rem', lineHeight: '1.6', marginBottom: '15px' }}>
              ABE Stack extends this foundation with:
            </p>
            <ul style={{ paddingLeft: '20px', fontSize: '1.05rem', lineHeight: '1.6' }}>
              <li style={{ marginBottom: '8px' }}>Comprehensive UI component library</li>
              <li style={{ marginBottom: '8px' }}>Authentication and user management</li>
              <li style={{ marginBottom: '8px' }}>Theme system with light/dark mode support</li>
              <li style={{ marginBottom: '8px' }}>Responsive design patterns for all device sizes</li>
              <li style={{ marginBottom: '8px' }}>Media handling capabilities</li>
              <li style={{ marginBottom: '8px' }}>Social features and interaction patterns</li>
            </ul>
          </div>
        </section>

        <section style={{ marginBottom: '40px' }}>
          <h2 style={{ borderBottom: '1px solid var(--border-color)', paddingBottom: '10px', marginBottom: '20px' }}>
            Explore the Stack
          </h2>
          <p style={{ fontSize: '1.1rem', lineHeight: '1.6', marginBottom: '20px' }}>
            The best way to understand ABE Stack is to explore its features. Use the navigation menu to check out different sections:
          </p>
          <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(200px, 1fr))', gap: '15px' }}>
            <ExploreCard title="Dashboard" _path="/dashboard" description="Overview of application capabilities" onClick={() => handleNavigate('/dashboard')} />
            <ExploreCard title="Profile" _path="/profile" description="User profile management" onClick={() => handleNavigate('/profile')} />
            <ExploreCard title="Explore" _path="/explore" description="Content discovery interface" onClick={() => handleNavigate('/explore')} />
            <ExploreCard title="Notifications" _path="/notifications" description="Notification system demo" onClick={() => handleNavigate('/notifications')} />
            <ExploreCard title="Settings" _path="/settings" description="Application preferences" onClick={() => handleNavigate('/settings')} />
          </div>
        </section>

        <section style={{ marginBottom: '40px' }}>
          <h2 style={{ borderBottom: '1px solid var(--border-color)', paddingBottom: '10px', marginBottom: '20px' }}>
            Getting Started
          </h2>
          <p style={{ fontSize: '1.1rem', lineHeight: '1.6', marginBottom: '20px' }}>
            To use ABE Stack for your own project:
          </p>
          <ol style={{ paddingLeft: '25px', fontSize: '1.05rem', lineHeight: '1.6' }}>
            <li style={{ marginBottom: '10px' }}>Clone the repository</li>
            <li style={{ marginBottom: '10px' }}>Install dependencies with <code style={{ backgroundColor: 'var(--code-bg)', padding: '2px 5px', borderRadius: '3px' }}>npm install</code></li>
            <li style={{ marginBottom: '10px' }}>Set up your PostgreSQL database</li>
            <li style={{ marginBottom: '10px' }}>Configure environment variables</li>
            <li style={{ marginBottom: '10px' }}>Run migrations with <code style={{ backgroundColor: 'var(--code-bg)', padding: '2px 5px', borderRadius: '3px' }}>npm run migrate</code></li>
            <li style={{ marginBottom: '10px' }}>Start development server with <code style={{ backgroundColor: 'var(--code-bg)', padding: '2px 5px', borderRadius: '3px' }}>npm run dev</code></li>
          </ol>
        </section>

        <footer style={{ 
          borderTop: '1px solid var(--border-color)', 
          paddingTop: '20px', 
          marginTop: '40px',
          textAlign: 'center', 
          color: 'var(--text-secondary)', 
          fontSize: '0.9rem' 
        }}>
          <p style={{ marginBottom: '10px' }}>
            ABE Stack is built upon <a href="https://github.com/ccorcos/chet-stack" target="_blank" rel="noopener noreferrer" style={{ color: 'var(--accent)', textDecoration: 'none', fontWeight: 'bold' }}>Chet Stack</a> by Chet Corcos.
          </p>
          <p>
            We are grateful for the excellent foundation provided by Chet Stack, which made this extended boilerplate possible.
          </p>
        </footer>
      </div>
    </PageContent>
  );
}

// Feature card component for displaying features in a grid
function FeatureCard({ title, description }: { title: string; description: string }) {
  return (
    <div style={{
      backgroundColor: 'var(--card-bg)',
      borderRadius: '8px',
      padding: '20px',
      boxShadow: 'var(--shadow)',
      border: '1px solid var(--border-color)',
      transition: 'transform 0.2s ease, box-shadow 0.2s ease',
      height: '100%',
    }}>
      <h3 style={{ marginTop: 0, marginBottom: '10px', color: 'var(--accent)' }}>{title}</h3>
      <p style={{ margin: 0, color: 'var(--text-secondary)', lineHeight: '1.5' }}>{description}</p>
    </div>
  );
}

// Explore card component for navigation links
function ExploreCard({ title, _path: _path, description, onClick }: { title: string; _path: string; description: string; onClick: () => void }) {
  return (
    <div 
      onClick={onClick}
      style={{
        backgroundColor: 'var(--card-bg)',
        borderRadius: '8px',
        padding: '15px',
        boxShadow: 'var(--shadow)',
        border: '1px solid var(--border-color)',
        transition: 'transform 0.2s ease, box-shadow 0.2s ease',
        height: '100%',
        cursor: 'pointer',
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        textAlign: 'center',
      }}
    >
      <h3 style={{ marginTop: 0, marginBottom: '8px', color: 'var(--accent)' }}>{title}</h3>
      <p style={{ margin: 0, color: 'var(--text-secondary)', fontSize: '0.9rem' }}>{description}</p>
    </div>
  );
} 
================================================================================
File: components\pages\MediaPage.tsx
Lines: 39
--------------------------------------------------------------------------------
import { PageContent } from '../layouts/PageContent';

export function MediaPage() {
  return (
    <PageContent
      title="Media Page"
      description="This page demonstrates the multimedia capabilities of the ABE Stack."
    >
      <div style={{ marginTop: '20px' }}>
        <h2>Media Features</h2>
        <ul>
          <li>Video streaming with HLS/DASH support</li>
          <li>Audio playback with waveform visualization</li>
          <li>Image galleries with lazy loading</li>
          <li>File uploads with progress tracking</li>
          <li>Media metadata extraction</li>
          <li>Responsive media players</li>
        </ul>
      </div>
      
      {/* Example media player placeholder */}
      <div 
        style={{ 
          width: '100%', 
          maxWidth: '640px', 
          height: '360px', 
          backgroundColor: '#222', 
          display: 'flex', 
          alignItems: 'center', 
          justifyContent: 'center',
          marginTop: '20px',
          borderRadius: '8px'
        }}
      >
        <p style={{ color: 'white' }}>Media Player Placeholder</p>
      </div>
    </PageContent>
  );
} 
================================================================================
File: components\pages\NotificationsPage.tsx
Lines: 231
--------------------------------------------------------------------------------
import { useState } from 'react';

import { PageContent } from '../layouts/PageContent';

// Notifications page styles
const styles = {
  tabs: {
    marginTop: '20px',
    borderBottom: '1px solid var(--border-color)'
  },
  tabButtons: {
    display: 'flex',
    gap: '10px',
    overflowX: 'auto' as const
  },
  tabButton: {
    padding: '10px 15px',
    backgroundColor: 'transparent',
    border: 'none',
    cursor: 'pointer',
    textTransform: 'capitalize' as const,
    color: 'var(--text-primary)'
  },
  tabButtonActive: {
    color: 'var(--blue)',
    borderBottom: '2px solid var(--blue)',
    fontWeight: 'bold'
  },
  container: {
    marginTop: '20px'
  },
  empty: {
    padding: '40px 20px',
    textAlign: 'center' as const,
    backgroundColor: 'var(--surface)',
    borderRadius: '8px',
    color: 'var(--text-secondary)'
  },
  list: {
    display: 'flex',
    flexDirection: 'column' as const,
    gap: '10px'
  },
  item: {
    padding: '15px',
    borderRadius: '8px',
    border: '1px solid var(--border-color)',
    display: 'flex',
    alignItems: 'center',
    gap: '15px'
  },
  itemUnread: {
    backgroundColor: 'rgba(0, 120, 255, 0.05)'
  },
  itemRead: {
    backgroundColor: 'var(--card-bg)'
  },
  icon: {
    width: '40px',
    height: '40px',
    borderRadius: '50%',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    fontSize: '18px'
  },
  iconUnread: {
    backgroundColor: 'var(--blue)',
    color: 'white'
  },
  iconRead: {
    backgroundColor: 'var(--surface)',
    color: 'var(--text-secondary)'
  },
  content: {
    flex: 1
  },
  text: {
    color: 'var(--text-primary)'
  },
  textUnread: {
    fontWeight: 'bold'
  },
  username: {
    fontWeight: 'bold',
    color: 'var(--text-primary)'
  },
  time: {
    fontSize: '14px',
    color: 'var(--text-secondary)',
    marginTop: '5px'
  },
  menuButton: {
    backgroundColor: 'transparent',
    border: 'none',
    cursor: 'pointer',
    color: 'var(--text-secondary)',
    padding: '5px',
    borderRadius: '50%',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center'
  },
  actions: {
    marginTop: '30px',
    display: 'flex',
    justifyContent: 'space-between'
  },
  actionButton: {
    padding: '10px 20px',
    backgroundColor: 'var(--card-bg)',
    borderRadius: '4px',
    cursor: 'pointer'
  },
  actionPrimary: {
    color: 'var(--blue)',
    border: '1px solid var(--blue)'
  },
  actionSecondary: {
    color: 'var(--text-secondary)',
    border: '1px solid var(--border-color)'
  }
};

export function NotificationsPage() {
  const [activeTab, setActiveTab] = useState('all');
  
  // Mock notifications data
  const notifications = [
    { id: 1, type: 'comment', user: 'Jane Smith', content: 'commented on your post', time: '2 minutes ago', read: false },
    { id: 2, type: 'like', user: 'John Doe', content: 'liked your photo', time: '15 minutes ago', read: false },
    { id: 3, type: 'follow', user: 'Alice Johnson', content: 'started following you', time: '1 hour ago', read: false },
    { id: 4, type: 'mention', user: 'Bob Wilson', content: 'mentioned you in a comment', time: '3 hours ago', read: true },
    { id: 5, type: 'system', user: 'ABE Stack', content: 'Your account was successfully verified', time: '1 day ago', read: true },
    { id: 6, type: 'comment', user: 'Carol Taylor', content: 'replied to your comment', time: '2 days ago', read: true },
  ];
  
  const filteredNotifications = activeTab === 'all' 
    ? notifications 
    : activeTab === 'unread' 
      ? notifications.filter(n => !n.read) 
      : notifications.filter(n => n.type === activeTab);
  
  const getNotificationIcon = (type: string) => {
    switch(type) {
      case 'comment': return '💬';
      case 'like': return '❤️';
      case 'follow': return '👤';
      case 'mention': return '@️';
      case 'system': return '🔔';
      default: return '📣';
    }
  };
  
  return (
    <PageContent
      title="Notifications"
      description="Stay updated with your latest activity and interactions."
    >
      {/* Tabs */}
      <div style={styles.tabs}>
        <div style={styles.tabButtons}>
          {['all', 'unread', 'comment', 'like', 'follow', 'mention'].map(tab => (
            <button
              key={tab}
              onClick={() => setActiveTab(tab)}
              style={{
                ...styles.tabButton,
                ...(activeTab === tab ? styles.tabButtonActive : {})
              }}
            >
              {tab}
            </button>
          ))}
        </div>
      </div>
      
      {/* Notifications List */}
      <div style={styles.container}>
        {filteredNotifications.length === 0 ? (
          <div style={styles.empty}>
            No notifications to display
          </div>
        ) : (
          <div style={styles.list}>
            {filteredNotifications.map(notification => (
              <div 
                key={notification.id}
                style={{
                  ...styles.item,
                  ...(notification.read ? styles.itemRead : styles.itemUnread)
                }}
              >
                <div style={{
                  ...styles.icon,
                  ...(notification.read ? styles.iconRead : styles.iconUnread)
                }}>
                  {getNotificationIcon(notification.type)}
                </div>
                <div style={styles.content}>
                  <div style={{
                    ...styles.text,
                    ...(notification.read ? {} : styles.textUnread)
                  }}>
                    <span style={styles.username}>{notification.user}</span> {notification.content}
                  </div>
                  <div style={styles.time}>
                    {notification.time}
                  </div>
                </div>
                <button style={styles.menuButton}>
                  •••
                </button>
              </div>
            ))}
          </div>
        )}
      </div>
      
      {/* Actions */}
      <div style={styles.actions}>
        <button style={{...styles.actionButton, ...styles.actionPrimary}}>
          Mark all as read
        </button>
        <button style={{...styles.actionButton, ...styles.actionSecondary}}>
          Notification settings
        </button>
      </div>
    </PageContent>
  );
} 
================================================================================
File: components\pages\ProfilePage.tsx
Lines: 260
--------------------------------------------------------------------------------
import React, { useState, useEffect } from 'react';

import { socialService } from '../../services/social';
import { PageContent } from '../layouts/PageContent';
import { CommentSection } from '../social/CommentSection';
import { PostCard } from '../social/PostCard';

interface User {
  id: string;
  username: string;
  displayName: string;
  avatar: string;
  bio: string;
  followersCount: number;
  followingCount: number;
  postsCount: number;
  isFollowing: boolean;
}

interface Post {
  id: string;
  userId: string;
  username: string;
  userAvatar: string;
  content: string;
  media?: {
    type: 'image' | 'video' | 'audio';
    url: string;
    thumbnail?: string;
  };
  likesCount: number;
  commentsCount: number;
  sharesCount: number;
  isLiked: boolean;
  createdAt: string;
}

export function ProfilePage() {
  const [user, setUser] = useState<User | null>(null);
  const [posts, setPosts] = useState<Post[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isFollowing, setIsFollowing] = useState(false);
  const [followersCount, setFollowersCount] = useState(0);
  const [activeCommentPostId, setActiveCommentPostId] = useState<string | null>(null);
  const [activeTab, setActiveTab] = useState<'posts' | 'media'>('posts');
  
  // Get userId from URL
  // Extract userId from the current URL path
  const currentUrl = window.location.pathname;
  const userId = currentUrl.startsWith('/profile/') 
    ? currentUrl.substring('/profile/'.length) 
    : 'current'; // Default to 'current' if no userId in URL
  
  // Define fetch functions with useCallback to avoid dependency issues
  const fetchUserProfile = React.useCallback(async () => {
    setIsLoading(true);
    try {
      const userData = await socialService.getUserProfile(userId);
      setUser(userData);
      setIsFollowing(userData.isFollowing);
      setFollowersCount(userData.followersCount);
    } catch (error) {
      console.error('Error fetching user profile:', error);
    } finally {
      setIsLoading(false);
    }
  }, [userId]);
  
  const fetchUserPosts = React.useCallback(async () => {
    try {
      const response = await socialService.getFeed('profile', userId);
      setPosts(response.posts);
    } catch (error) {
      console.error('Error fetching user posts:', error);
    }
  }, [userId]);
  
  useEffect(() => {
    void fetchUserProfile();
    void fetchUserPosts();
  }, [fetchUserProfile, fetchUserPosts]);
  
  const handleFollowToggle = async () => {
    if (!user) return;
    
    try {
      if (isFollowing) {
        await socialService.unfollowUser(user.id);
        setIsFollowing(false);
        setFollowersCount(prev => prev - 1);
      } else {
        await socialService.followUser(user.id);
        setIsFollowing(true);
        setFollowersCount(prev => prev + 1);
      }
    } catch (error) {
      console.error('Error toggling follow:', error);
    }
  };
  
  const handleCommentClick = (postId: string) => {
    setActiveCommentPostId(postId);
  };
  
  // Void-returning wrapper for handleFollowToggle
  const handleFollowToggleWrapper = () => {
    void handleFollowToggle();
  };
  
  const handleRefresh = () => {
    void fetchUserPosts();
  };
  
  const filteredPosts = activeTab === 'posts' 
    ? posts 
    : posts.filter(post => post.media);
  
  if (isLoading) {
    return (
      <PageContent title="Profile" description="Loading user profile...">
        <div style={{ textAlign: 'center', padding: '40px' }}>
          Loading profile...
        </div>
      </PageContent>
    );
  }
  
  if (!user) {
    return (
      <PageContent title="Profile Not Found" description="User profile not found">
        <div style={{ textAlign: 'center', padding: '40px' }}>
          User not found
        </div>
      </PageContent>
    );
  }
  
  return (
    <PageContent
      title={`${user.displayName}'s Profile`}
      description={`View ${user.displayName}'s profile and posts`}
    >
      <div style={{ maxWidth: '800px', margin: '0 auto', padding: '20px 0' }}>
        <div style={{ 
          backgroundColor: 'white',
          borderRadius: '8px',
          border: '1px solid #e0e0e0',
          padding: '24px',
          marginBottom: '24px'
        }}>
          <div style={{ display: 'flex', alignItems: 'center' }}>
            <img 
              src={user.avatar || '/default-avatar.png'} 
              alt={user.displayName} 
              style={{ 
                width: '120px', 
                height: '120px', 
                borderRadius: '50%', 
                marginRight: '24px',
                objectFit: 'cover'
              }} 
            />
            <div style={{ flex: 1 }}>
              <h2 style={{ margin: '0 0 8px 0' }}>{user.displayName}</h2>
              <div style={{ color: '#666', marginBottom: '12px' }}>@{user.username}</div>
              <div style={{ marginBottom: '16px' }}>{user.bio}</div>
              <div style={{ display: 'flex', gap: '24px', color: '#666' }}>
                <div><strong>{user.postsCount}</strong> posts</div>
                <div><strong>{followersCount}</strong> followers</div>
                <div><strong>{user.followingCount}</strong> following</div>
              </div>
            </div>
            <div>
              <button 
                onClick={handleFollowToggleWrapper}
                style={{ 
                  padding: '10px 20px',
                  backgroundColor: isFollowing ? 'white' : 'var(--accent)',
                  color: isFollowing ? 'var(--accent)' : 'white',
                  border: isFollowing ? '1px solid var(--accent)' : 'none',
                  borderRadius: '20px',
                  cursor: 'pointer',
                  fontWeight: 'bold'
                }}
              >
                {isFollowing ? 'Unfollow' : 'Follow'}
              </button>
            </div>
          </div>
        </div>
        
        <div style={{ 
          display: 'flex',
          borderBottom: '1px solid #e0e0e0',
          marginBottom: '24px'
        }}>
          <button 
            onClick={() => setActiveTab('posts')}
            style={{ 
              padding: '12px 24px',
              backgroundColor: 'transparent',
              border: 'none',
              borderBottom: activeTab === 'posts' ? '2px solid var(--accent)' : 'none',
              color: activeTab === 'posts' ? 'var(--accent)' : 'inherit',
              fontWeight: activeTab === 'posts' ? 'bold' : 'normal',
              cursor: 'pointer'
            }}
          >
            Posts
          </button>
          <button 
            onClick={() => setActiveTab('media')}
            style={{ 
              padding: '12px 24px',
              backgroundColor: 'transparent',
              border: 'none',
              borderBottom: activeTab === 'media' ? '2px solid var(--accent)' : 'none',
              color: activeTab === 'media' ? 'var(--accent)' : 'inherit',
              fontWeight: activeTab === 'media' ? 'bold' : 'normal',
              cursor: 'pointer'
            }}
          >
            Media
          </button>
        </div>
        
        {filteredPosts.length === 0 ? (
          <div style={{ 
            textAlign: 'center', 
            padding: '40px', 
            backgroundColor: 'white',
            borderRadius: '8px',
            border: '1px solid #e0e0e0'
          }}>
            <h3>No {activeTab} yet</h3>
            <p>{activeTab === 'posts' ? 'User has not created any posts yet.' : 'User has not shared any media yet.'}</p>
          </div>
        ) : (
          <>
            {filteredPosts.map(post => (
              <PostCard 
                key={post.id} 
                post={post} 
                onCommentClick={handleCommentClick}
                onRefresh={handleRefresh}
              />
            ))}
          </>
        )}
      </div>
      
      {activeCommentPostId && (
        <CommentSection 
          postId={activeCommentPostId} 
          onClose={() => setActiveCommentPostId(null)} 
        />
      )}
    </PageContent>
  );
} 
================================================================================
File: components\pages\SettingsPage.tsx
Lines: 214
--------------------------------------------------------------------------------
import { PageContent } from '../layouts/PageContent';
import { useTheme } from '../theme';

export function SettingsPage() {
  const { theme, toggleTheme, useSystemTheme: enableSystemTheme, isUsingSystemTheme, setTheme } = useTheme();

  // Function to disable system theme
  const disableSystemTheme = () => {
    // Keep current theme but disable system theme
    setTheme(theme);
  };
  
  // Handler for system theme toggle
  const handleSystemThemeToggle = () => {
    if (isUsingSystemTheme) {
      disableSystemTheme();
    } else {
      enableSystemTheme();
    }
  };

  // Define styles as a TypeScript object
  const styles = {
    container: {
      maxWidth: '800px',
      margin: '0 auto',
    },
    section: {
      backgroundColor: 'var(--card-bg)',
      borderRadius: '8px',
      padding: '20px',
      marginBottom: '24px',
      boxShadow: 'var(--shadow)',
      border: '1px solid var(--border-color)',
    },
    sectionTitle: {
      marginTop: 0,
      marginBottom: '16px',
      color: 'var(--text-primary)',
      fontSize: '1.2rem',
      fontWeight: 600,
      borderBottom: '1px solid var(--border-color)',
      paddingBottom: '8px',
    },
    option: {
      marginBottom: '16px',
    },
    optionLast: {
      marginBottom: 0,
    },
    optionLabel: {
      display: 'block',
      marginBottom: '8px',
      fontWeight: 500,
      color: 'var(--text-primary)',
    },
    toggleContainer: {
      display: 'flex',
      alignItems: 'center',
      gap: '12px',
    },
    themeLabel: {
      color: 'var(--text-secondary)',
      fontSize: '0.9rem',
    },
    systemNote: {
      color: 'var(--text-secondary)',
      fontSize: '0.8rem',
      fontStyle: 'italic',
      marginLeft: '4px',
    },
    // Toggle Switch styles
    switch: {
      position: 'relative' as const,
      display: 'inline-block',
      width: '60px',
      height: '34px',
    },
    switchInput: {
      opacity: 0,
      width: 0,
      height: 0,
    },
    slider: {
      position: 'absolute' as const,
      cursor: 'pointer',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: 'var(--surface-variant)',
      transition: '.4s',
      borderRadius: '34px',
    },
    sliderBefore: {
      position: 'absolute' as const,
      content: '""',
      height: '26px',
      width: '26px',
      left: '4px',
      bottom: '4px',
      backgroundColor: 'white',
      transition: '.4s',
      borderRadius: '50%',
    },
    sliderChecked: {
      backgroundColor: 'var(--accent)',
    },
    sliderBeforeChecked: {
      transform: 'translateX(26px)',
    },
    sliderDisabled: {
      opacity: 0.6,
      cursor: 'not-allowed',
    },
    sliderBeforeDisabled: {
      backgroundColor: '#f0f0f0',
    },
  };

  return (
    <PageContent 
      title="Settings" 
      description="Customize your application preferences"
    >
      <div style={styles.container}>
        <div style={styles.section}>
          <h2 style={styles.sectionTitle}>Appearance</h2>
          <div style={styles.option}>
            <label htmlFor="system-theme" style={styles.optionLabel}>Use System Theme</label>
            <div style={styles.toggleContainer}>
              <label style={styles.switch}>
                <input 
                  type="checkbox" 
                  id="system-theme"
                  checked={isUsingSystemTheme}
                  onChange={handleSystemThemeToggle}
                  style={styles.switchInput}
                />
                <span 
                  style={{
                    ...styles.slider,
                    ...(isUsingSystemTheme ? styles.sliderChecked : {}),
                  }}
                >
                  <span style={{
                    ...styles.sliderBefore,
                    ...(isUsingSystemTheme ? styles.sliderBeforeChecked : {}),
                  }}></span>
                </span>
              </label>
              <span style={styles.themeLabel}>Follow system light/dark preference</span>
            </div>
          </div>
          
          <div style={styles.option}>
            <label htmlFor="theme-toggle" style={styles.optionLabel}>Theme</label>
            <div style={styles.toggleContainer}>
              <span style={styles.themeLabel}>Light</span>
              <label style={styles.switch}>
                <input 
                  type="checkbox" 
                  id="theme-toggle"
                  checked={theme === 'dark'}
                  onChange={toggleTheme}
                  disabled={isUsingSystemTheme}
                  style={styles.switchInput}
                />
                <span 
                  style={{
                    ...styles.slider,
                    ...(theme === 'dark' ? styles.sliderChecked : {}),
                    ...(isUsingSystemTheme ? styles.sliderDisabled : {}),
                  }}
                >
                  <span style={{
                    ...styles.sliderBefore,
                    ...(theme === 'dark' ? styles.sliderBeforeChecked : {}),
                    ...(isUsingSystemTheme ? styles.sliderBeforeDisabled : {}),
                  }}></span>
                </span>
              </label>
              <span style={styles.themeLabel}>Dark</span>
              {isUsingSystemTheme && (
                <span style={styles.systemNote}>(Controlled by system)</span>
              )}
            </div>
          </div>
        </div>

        <div style={styles.section}>
          <h2 style={styles.sectionTitle}>Account</h2>
          <div style={{...styles.option, ...styles.optionLast}}>
            <p>Account settings will be available soon.</p>
          </div>
        </div>

        <div style={styles.section}>
          <h2 style={styles.sectionTitle}>Notifications</h2>
          <div style={{...styles.option, ...styles.optionLast}}>
            <p>Notification settings will be available soon.</p>
          </div>
        </div>

        <div style={styles.section}>
          <h2 style={styles.sectionTitle}>Privacy</h2>
          <div style={{...styles.option, ...styles.optionLast}}>
            <p>Privacy settings will be available soon.</p>
          </div>
        </div>
      </div>
    </PageContent>
  );
} 
================================================================================
File: components\pages\SocialPage.tsx
Lines: 243
--------------------------------------------------------------------------------
import { useState, useEffect, useCallback } from 'react';

import { socialService } from '../../services/social';
import { PageContent } from '../layouts/PageContent';
import { CommentSection } from '../social/CommentSection';
import { CreatePostForm } from '../social/CreatePostForm';
import { PostCard } from '../social/PostCard';
import { UserProfileCard } from '../social/UserProfileCard';

interface User {
  id: string;
  username: string;
  displayName: string;
  avatar: string;
  bio: string;
  followersCount: number;
  followingCount: number;
  postsCount: number;
  isFollowing: boolean;
}

interface Post {
  id: string;
  userId: string;
  username: string;
  userAvatar: string;
  content: string;
  media?: {
    type: 'image' | 'video' | 'audio';
    url: string;
    thumbnail?: string;
  };
  likesCount: number;
  commentsCount: number;
  sharesCount: number;
  isLiked: boolean;
  createdAt: string;
}

export function SocialPage() {
  const [posts, setPosts] = useState<Post[]>([]);
  const [suggestedUsers, setSuggestedUsers] = useState<User[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [hasMore, setHasMore] = useState(false);
  const [offset, setOffset] = useState(0);
  const [activeCommentPostId, setActiveCommentPostId] = useState<string | null>(null);

    
  const fetchFeed = useCallback(async () => {
    setIsLoading(true);
    try {
      const response = await socialService.getFeed('home', undefined, offset);
      if (offset === 0) {
        setPosts(response.posts);
      } else {
        setPosts(prev => [...prev, ...response.posts]);
      }
      setHasMore(response.hasMore);
    } catch (error) {
      console.error('Error fetching feed:', error);
    } finally {
      setIsLoading(false);
    }
  }, [offset]);
  
  const fetchSuggestedUsers = useCallback(() => {
    try {
      // This is a mock implementation - in a real app, you'd have an API endpoint for this
      // For now, we'll create some dummy users
      const dummyUsers: User[] = [
        {
          id: '1',
          username: 'johndoe',
          displayName: 'John Doe',
          avatar: 'https://randomuser.me/api/portraits/men/1.jpg',
          bio: 'Software developer and tech enthusiast',
          followersCount: 245,
          followingCount: 123,
          postsCount: 42,
          isFollowing: false
        },
        {
          id: '2',
          username: 'janedoe',
          displayName: 'Jane Doe',
          avatar: 'https://randomuser.me/api/portraits/women/1.jpg',
          bio: 'UX Designer | Coffee lover',
          followersCount: 532,
          followingCount: 231,
          postsCount: 87,
          isFollowing: false
        },
        {
          id: '3',
          username: 'alexsmith',
          displayName: 'Alex Smith',
          avatar: 'https://randomuser.me/api/portraits/men/2.jpg',
          bio: 'Photographer and traveler',
          followersCount: 1245,
          followingCount: 342,
          postsCount: 156,
          isFollowing: false
        }
      ];
      
      setSuggestedUsers(dummyUsers);
    } catch (error) {
      console.error('Error fetching suggested users:', error);
    }
  }, []);
  
  
  useEffect(() => {
    void fetchFeed();
    void fetchSuggestedUsers();
  }, [fetchFeed, fetchSuggestedUsers]);

  
  const handleLoadMore = () => {
    setOffset(prev => prev + 10);
    void fetchFeed();
  };
  
  const handleRefresh = () => {
    setOffset(0);
    void fetchFeed();
    void fetchSuggestedUsers();
  };
  
  const handleCommentClick = (postId: string) => {
    setActiveCommentPostId(postId);
  };
  
  return (
    <PageContent
      title="Social Feed"
      description="Connect with friends and share your thoughts."
    >
      <div style={{ 
        display: 'grid',
        gridTemplateColumns: '1fr 300px',
        gap: '24px',
        maxWidth: '1200px',
        margin: '0 auto',
        padding: '20px 0'
      }}>
        <div>
          <CreatePostForm onPostCreated={handleRefresh} />
          
          {posts.length === 0 && !isLoading ? (
            <div style={{ 
              textAlign: 'center', 
              padding: '40px', 
              backgroundColor: 'white',
              borderRadius: '8px',
              border: '1px solid #e0e0e0'
            }}>
              <h3>No posts yet</h3>
              <p>Create a post or follow users to see their posts in your feed.</p>
            </div>
          ) : (
            <>
              {posts.map(post => (
                <PostCard 
                  key={post.id} 
                  post={post} 
                  onCommentClick={handleCommentClick}
                  onRefresh={handleRefresh}
                />
              ))}
              
              {hasMore && (
                <div style={{ textAlign: 'center', marginTop: '24px', marginBottom: '24px' }}>
                  <button 
                    onClick={handleLoadMore}
                    disabled={isLoading}
                    style={{ 
                      padding: '10px 24px',
                      backgroundColor: 'var(--accent)',
                      color: 'white',
                      border: 'none',
                      borderRadius: '20px',
                      cursor: 'pointer',
                      opacity: isLoading ? 0.7 : 1
                    }}
                  >
                    {isLoading ? 'Loading...' : 'Load More'}
                  </button>
                </div>
              )}
            </>
          )}
        </div>
        
        <div>
          <div style={{ 
            backgroundColor: 'white',
            borderRadius: '8px',
            border: '1px solid #e0e0e0',
            padding: '16px',
            marginBottom: '24px'
          }}>
            <h3 style={{ marginTop: 0, marginBottom: '16px' }}>Suggested Users</h3>
            {suggestedUsers.map(user => (
              <UserProfileCard 
                key={user.id} 
                user={user} 
              />
            ))}
          </div>
          
          <div style={{ 
            backgroundColor: 'white',
            borderRadius: '8px',
            border: '1px solid #e0e0e0',
            padding: '16px'
          }}>
            <h3 style={{ marginTop: 0, marginBottom: '16px' }}>About</h3>
            <p>
              This social feed demonstrates the integration of server-side social features with the client-side UI.
            </p>
            <p>
              Features include:
            </p>
            <ul>
              <li>Creating posts with text and media</li>
              <li>Liking and commenting on posts</li>
              <li>Following other users</li>
              <li>Real-time updates</li>
            </ul>
          </div>
        </div>
      </div>
      
      {activeCommentPostId && (
        <CommentSection 
          postId={activeCommentPostId} 
          onClose={() => setActiveCommentPostId(null)} 
        />
      )}
    </PageContent>
  );
} 
================================================================================
File: components\pages\UploadPage.tsx
Lines: 167
--------------------------------------------------------------------------------
import React, { useState } from 'react';

import { PageContent } from '../layouts/PageContent';

export function UploadPage() {
  const [uploadProgress, setUploadProgress] = useState(0);
  const [isUploading, setIsUploading] = useState(false);
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  
  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files.length > 0) {
      setSelectedFile(e.target.files[0]);
    }
  };
  
  const simulateUpload = () => {
    if (!selectedFile) return;
    
    setIsUploading(true);
    setUploadProgress(0);
    
    const interval = setInterval(() => {
      setUploadProgress(prev => {
        const newProgress = prev + 5;
        if (newProgress >= 100) {
          clearInterval(interval);
          setTimeout(() => {
            setIsUploading(false);
            setSelectedFile(null);
            // Reset file input
            const fileInput = document.getElementById('file-upload') as HTMLInputElement;
            if (fileInput) fileInput.value = '';
          }, 500);
          return 100;
        }
        return newProgress;
      });
    }, 200);
  };
  
  return (
    <PageContent
      title="Upload Media"
      description="Share your videos, images, or audio files with your audience."
    >
      <div style={{ maxWidth: '800px', margin: '30px auto', border: '1px solid #ddd', borderRadius: '8px', padding: '20px' }}>
        <h2>Upload New Media</h2>
        
        <div style={{ marginTop: '20px' }}>
          <div 
            style={{ 
              border: '2px dashed #ccc', 
              borderRadius: '8px', 
              padding: '40px 20px', 
              textAlign: 'center',
              backgroundColor: '#f9f9f9',
              cursor: 'pointer'
            }}
            onClick={() => document.getElementById('file-upload')?.click()}
          >
            <input 
              type="file" 
              id="file-upload" 
              style={{ display: 'none' }} 
              onChange={handleFileChange}
              accept="image/*,video/*,audio/*"
            />
            <div style={{ fontSize: '48px', marginBottom: '10px' }}>📁</div>
            <p>Click to select or drag and drop your file here</p>
            <p style={{ fontSize: '14px', color: '#666' }}>Supports images, videos, and audio files</p>
          </div>
        </div>
        
        {selectedFile && (
          <div style={{ marginTop: '20px' }}>
            <h3>Selected File</h3>
            <div style={{ display: 'flex', alignItems: 'center', gap: '10px', padding: '10px', border: '1px solid #eee', borderRadius: '4px' }}>
              <div style={{ fontSize: '24px' }}>
                {selectedFile.type.startsWith('image/') ? '🖼️' : 
                 selectedFile.type.startsWith('video/') ? '🎬' : 
                 selectedFile.type.startsWith('audio/') ? '🎵' : '📄'}
              </div>
              <div style={{ flexGrow: 1 }}>
                <div>{selectedFile.name}</div>
                <div style={{ fontSize: '14px', color: '#666' }}>
                  {(selectedFile.size / 1024 / 1024).toFixed(2)} MB • {selectedFile.type}
                </div>
              </div>
            </div>
          </div>
        )}
        
        {isUploading && (
          <div style={{ marginTop: '20px' }}>
            <h3>Uploading...</h3>
            <div style={{ height: '8px', backgroundColor: '#eee', borderRadius: '4px', overflow: 'hidden' }}>
              <div 
                style={{ 
                  height: '100%', 
                  width: `${uploadProgress}%`, 
                  backgroundColor: 'var(--blue)',
                  transition: 'width 0.2s ease-in-out'
                }} 
              />
            </div>
            <div style={{ textAlign: 'center', marginTop: '5px' }}>{uploadProgress}%</div>
          </div>
        )}
        
        <div style={{ marginTop: '20px' }}>
          <button 
            onClick={simulateUpload}
            disabled={!selectedFile || isUploading}
            style={{
              padding: '8px 16px',
              backgroundColor: !selectedFile || isUploading ? '#ccc' : 'var(--blue)',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              cursor: !selectedFile || isUploading ? 'not-allowed' : 'pointer'
            }}
          >
            {isUploading ? 'Uploading...' : 'Upload File'}
          </button>
        </div>
      </div>
      
      <div style={{ maxWidth: '800px', margin: '30px auto' }}>
        <h2>Upload History</h2>
        <table style={{ width: '100%', borderCollapse: 'collapse' }}>
          <thead>
            <tr style={{ borderBottom: '1px solid #ddd' }}>
              <th style={{ textAlign: 'left', padding: '10px' }}>File</th>
              <th style={{ textAlign: 'left', padding: '10px' }}>Type</th>
              <th style={{ textAlign: 'left', padding: '10px' }}>Size</th>
              <th style={{ textAlign: 'left', padding: '10px' }}>Date</th>
              <th style={{ textAlign: 'left', padding: '10px' }}>Status</th>
            </tr>
          </thead>
          <tbody>
            <tr style={{ borderBottom: '1px solid #ddd' }}>
              <td style={{ padding: '10px' }}>vacation.mp4</td>
              <td style={{ padding: '10px' }}>Video</td>
              <td style={{ padding: '10px' }}>24.5 MB</td>
              <td style={{ padding: '10px' }}>2023-03-15</td>
              <td style={{ padding: '10px' }}><span style={{ color: 'green' }}>Completed</span></td>
            </tr>
            <tr style={{ borderBottom: '1px solid #ddd' }}>
              <td style={{ padding: '10px' }}>profile-pic.jpg</td>
              <td style={{ padding: '10px' }}>Image</td>
              <td style={{ padding: '10px' }}>1.2 MB</td>
              <td style={{ padding: '10px' }}>2023-03-10</td>
              <td style={{ padding: '10px' }}><span style={{ color: 'green' }}>Completed</span></td>
            </tr>
            <tr style={{ borderBottom: '1px solid #ddd' }}>
              <td style={{ padding: '10px' }}>podcast-episode.mp3</td>
              <td style={{ padding: '10px' }}>Audio</td>
              <td style={{ padding: '10px' }}>18.7 MB</td>
              <td style={{ padding: '10px' }}>2023-03-05</td>
              <td style={{ padding: '10px' }}><span style={{ color: 'green' }}>Completed</span></td>
            </tr>
          </tbody>
        </table>
      </div>
    </PageContent>
  );
} 
================================================================================
File: components\social\Comments.tsx
Lines: 422
--------------------------------------------------------------------------------
import React, { useState, useEffect, useRef, useCallback } from 'react';

interface Comment {
  id: string;
  userId: string;
  username: string;
  userAvatar: string;
  content: string;
  likesCount: number;
  isLiked: boolean;
  createdAt: string;
  replies?: Comment[];
}

// Define API response interfaces
interface CommentsResponse {
  comments: Comment[];
  hasMore: boolean;
}

interface CommentResponse extends Comment {
  // Extends the Comment interface for single comment responses
}

interface CommentsProps {
  postId: string;
  onLoadMore?: () => Promise<void>;
  className?: string;
}

export const Comments: React.FC<CommentsProps> = ({
  postId,
  onLoadMore,
  className,
}) => {
  const [comments, setComments] = useState<Comment[]>([]);
  const [newComment, setNewComment] = useState('');
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [hasMore, setHasMore] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const observer = useRef<IntersectionObserver | null>(null);
  const lastCommentRef = useRef<HTMLDivElement>(null);
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  const fetchComments = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);
      // TODO: Replace with actual API call
      const response = await fetch(`/api/posts/${postId}/comments`);
      if (!response.ok) throw new Error('Failed to fetch comments');
      const data = await response.json() as CommentsResponse;
      setComments(data.comments);
      setHasMore(data.hasMore);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load comments');
    } finally {
      setIsLoading(false);
    }
  }, [postId]);

  useEffect(() => {
    void fetchComments();
  }, [fetchComments]);

  const loadMore = useCallback(async () => {
    if (!hasMore || isLoading) return;
    
    try {
      setIsLoading(true);
      await onLoadMore?.();
      // TODO: Replace with actual API call
      const response = await fetch(`/api/posts/${postId}/comments?offset=${comments.length}`);
      if (!response.ok) throw new Error('Failed to fetch more comments');
      const data = await response.json() as CommentsResponse;
      setComments(prev => [...prev, ...data.comments]);
      setHasMore(data.hasMore);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load more comments');
    } finally {
      setIsLoading(false);
    }
  }, [hasMore, isLoading, onLoadMore, postId, comments.length]);

  useEffect(() => {
    observer.current = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting && hasMore && !isLoading) {
          void loadMore();
        }
      },
      { threshold: 0.5 }
    );

    if (lastCommentRef.current) {
      observer.current.observe(lastCommentRef.current);
    }

    return () => {
      if (observer.current) {
        observer.current.disconnect();
      }
    };
  }, [hasMore, isLoading, loadMore]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!newComment.trim()) return;

    try {
      setIsSubmitting(true);
      setError(null);
      // TODO: Replace with actual API call
      const response = await fetch(`/api/posts/${postId}/comments`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ content: newComment.trim() }),
      });
      
      if (!response.ok) throw new Error('Failed to post comment');
      
      const comment = await response.json() as CommentResponse;
      setComments(prev => [comment, ...prev]);
      setNewComment('');
      if (textareaRef.current) {
        textareaRef.current.style.height = 'auto';
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to post comment');
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleLike = async (commentId: string) => {
    try {
      // TODO: Replace with actual API call
      const response = await fetch(`/api/comments/${commentId}/like`, {
        method: 'POST',
      });
      if (!response.ok) throw new Error('Failed to like comment');
      
      setComments(prev => prev.map(comment => 
        comment.id === commentId
          ? { ...comment, isLiked: !comment.isLiked, likesCount: comment.isLiked ? comment.likesCount - 1 : comment.likesCount + 1 }
          : comment
      ));
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to like comment');
    }
  };

  // Void-returning wrapper for handleSubmit
  const handleSubmitWrapper = (e: React.FormEvent) => {
    void handleSubmit(e);
  };

  // Void-returning wrapper for handleLike
  const handleLikeWrapper = (commentId: string) => {
    void handleLike(commentId);
  };

  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    const now = new Date();
    const diff = now.getTime() - date.getTime();
    
    if (diff < 60000) return 'just now';
    if (diff < 3600000) return `${Math.floor(diff / 60000)}m ago`;
    if (diff < 86400000) return `${Math.floor(diff / 3600000)}h ago`;
    return date.toLocaleDateString();
  };

  const styles = {
    container: {
      display: 'flex',
      flexDirection: 'column' as const,
      gap: '16px',
    },
    comment: {
      display: 'flex',
      gap: '12px',
      padding: '12px',
      backgroundColor: '#f8f9fa',
      borderRadius: '8px',
    },
    avatar: {
      width: '40px',
      height: '40px',
      borderRadius: '50%',
      objectFit: 'cover' as const,
    },
    content: {
      flex: 1,
    },
    header: {
      display: 'flex',
      alignItems: 'center',
      gap: '8px',
      marginBottom: '4px',
    },
    username: {
      fontSize: '14px',
      fontWeight: 600,
      color: '#1a1a1a',
    },
    timestamp: {
      fontSize: '12px',
      color: '#666',
    },
    text: {
      fontSize: '14px',
      lineHeight: '1.5',
      color: '#333',
      margin: '0 0 8px',
    },
    actions: {
      display: 'flex',
      gap: '16px',
    },
    actionButton: {
      display: 'flex',
      alignItems: 'center',
      gap: '4px',
      background: 'none',
      border: 'none',
      color: '#666',
      cursor: 'pointer',
      padding: '4px 8px',
      borderRadius: '4px',
      fontSize: '14px',
      transition: 'background-color 0.2s',
      '&:hover': {
        backgroundColor: '#e9ecef',
      },
    },
    actionButtonLiked: {
      color: '#e91e63',
    },
    form: {
      display: 'flex',
      gap: '12px',
      marginBottom: '16px',
    },
    textarea: {
      flex: 1,
      minHeight: '40px',
      maxHeight: '120px',
      padding: '8px 12px',
      border: '1px solid #ddd',
      borderRadius: '20px',
      fontSize: '14px',
      lineHeight: '1.5',
      resize: 'none' as const,
      fontFamily: 'inherit',
      '&:focus': {
        outline: 'none',
        borderColor: '#2196f3',
      },
    },
    submitButton: {
      padding: '8px 16px',
      backgroundColor: '#2196f3',
      color: '#fff',
      border: 'none',
      borderRadius: '20px',
      fontSize: '14px',
      fontWeight: 500,
      cursor: 'pointer',
      transition: 'background-color 0.2s',
      '&:hover': {
        backgroundColor: '#1976d2',
      },
      '&:disabled': {
        backgroundColor: '#ccc',
        cursor: 'not-allowed',
      },
    },
    loading: {
      textAlign: 'center' as const,
      padding: '16px',
      color: '#666',
    },
    error: {
      color: '#d32f2f',
      textAlign: 'center' as const,
      padding: '16px',
    },
    replies: {
      marginLeft: '52px',
      borderLeft: '2px solid #e9ecef',
      paddingLeft: '12px',
    },
  };

  if (error) {
    return <div style={styles.error}>{error}</div>;
  }

  return (
    <div style={styles.container} className={className}>
      <form onSubmit={handleSubmitWrapper} style={styles.form}>
        <textarea
          ref={textareaRef}
          value={newComment}
          onChange={(e) => {
            setNewComment(e.target.value);
            e.target.style.height = 'auto';
            e.target.style.height = `${e.target.scrollHeight}px`;
          }}
          placeholder="Write a comment..."
          style={styles.textarea}
        />
        <button
          type="submit"
          style={{
            ...styles.submitButton,
            ...(isSubmitting && { opacity: 0.7 }),
          }}
          disabled={isSubmitting || !newComment.trim()}
          onMouseEnter={(e) => e.currentTarget.style.backgroundColor = '#1976d2'}
          onMouseLeave={(e) => e.currentTarget.style.backgroundColor = '#2196f3'}
        >
          {isSubmitting ? 'Posting...' : 'Post'}
        </button>
      </form>

      {comments.map((comment, index) => (
        <div
          key={comment.id}
          ref={index === comments.length - 1 ? lastCommentRef : undefined}
          style={styles.comment}
        >
          <img
            src={comment.userAvatar}
            alt={comment.username}
            style={styles.avatar}
          />
          <div style={styles.content}>
            <div style={styles.header}>
              <span style={styles.username}>{comment.username}</span>
              <span style={styles.timestamp}>{formatDate(comment.createdAt)}</span>
            </div>
            <p style={styles.text}>{comment.content}</p>
            <div style={styles.actions}>
              <button
                style={{
                  ...styles.actionButton,
                  ...(comment.isLiked && styles.actionButtonLiked),
                }}
                onClick={() => handleLikeWrapper(comment.id)}
                onMouseEnter={(e) => e.currentTarget.style.backgroundColor = '#e9ecef'}
                onMouseLeave={(e) => e.currentTarget.style.backgroundColor = 'transparent'}
              >
                {comment.isLiked ? '❤️' : '🤍'}
                <span>{comment.likesCount}</span>
              </button>
              <button
                style={styles.actionButton}
                onMouseEnter={(e) => e.currentTarget.style.backgroundColor = '#e9ecef'}
                onMouseLeave={(e) => e.currentTarget.style.backgroundColor = 'transparent'}
              >
                💬 Reply
              </button>
            </div>
            
            {comment.replies && comment.replies.length > 0 && (
              <div style={styles.replies}>
                {comment.replies.map(reply => (
                  <div key={reply.id} style={styles.comment}>
                    <img
                      src={reply.userAvatar}
                      alt={reply.username}
                      style={styles.avatar}
                    />
                    <div style={styles.content}>
                      <div style={styles.header}>
                        <span style={styles.username}>{reply.username}</span>
                        <span style={styles.timestamp}>{formatDate(reply.createdAt)}</span>
                      </div>
                      <p style={styles.text}>{reply.content}</p>
                      <div style={styles.actions}>
                        <button
                          style={{
                            ...styles.actionButton,
                            ...(reply.isLiked && styles.actionButtonLiked),
                          }}
                          onClick={() => handleLikeWrapper(reply.id)}
                          onMouseEnter={(e) => e.currentTarget.style.backgroundColor = '#e9ecef'}
                          onMouseLeave={(e) => e.currentTarget.style.backgroundColor = 'transparent'}
                        >
                          {reply.isLiked ? '❤️' : '🤍'}
                          <span>{reply.likesCount}</span>
                        </button>
                        <button
                          style={styles.actionButton}
                          onMouseEnter={(e) => e.currentTarget.style.backgroundColor = '#e9ecef'}
                          onMouseLeave={(e) => e.currentTarget.style.backgroundColor = 'transparent'}
                        >
                          💬 Reply
                        </button>
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
        </div>
      ))}
      
      {isLoading && (
        <div style={styles.loading}>
          Loading more comments...
        </div>
      )}
    </div>
  );
}; 
================================================================================
File: components\social\CommentSection.tsx
Lines: 269
--------------------------------------------------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

import { formatDate } from '../../../shared/dateHelpers';
import { socialService } from '../../services/social';

interface Comment {
  id: string;
  userId: string;
  username: string;
  userAvatar: string;
  content: string;
  likesCount: number;
  isLiked: boolean;
  createdAt: string;
  replies?: Comment[];
}

interface CommentSectionProps {
  postId: string;
  onClose: () => void;
}

export const CommentSection: React.FC<CommentSectionProps> = ({ postId, onClose }) => {
  const [comments, setComments] = useState<Comment[]>([]);
  const [newComment, setNewComment] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [hasMore, setHasMore] = useState(false);
  const [offset, setOffset] = useState(0);

  const fetchComments = useCallback(async () => {
    setIsLoading(true);
    try {
      const response = await socialService.getComments(postId, offset);
      if (offset === 0) {
        setComments(response.comments);
      } else {
        setComments(prev => [...prev, ...response.comments]);
      }
      setHasMore(response.hasMore);
    } catch (error) {
      console.error('Error fetching comments:', error);
    } finally {
      setIsLoading(false);
    }
  }, [postId, offset]);

  useEffect(() => {
    void fetchComments();
  }, [fetchComments]);

  const handleLoadMore = () => {
    setOffset(prev => prev + 10);
    void fetchComments();
  };

  const handleSubmitComment = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!newComment.trim() || isLoading) return;

    setIsLoading(true);
    try {
      const comment = await socialService.createComment(postId, newComment);
      setComments(prev => [comment, ...prev]);
      setNewComment('');
    } catch (error) {
      console.error('Error creating comment:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleLikeComment = async (commentId: string, isLiked: boolean) => {
    try {
      if (isLiked) {
        await socialService.unlikeComment(commentId);
      } else {
        await socialService.likeComment(commentId);
      }

      setComments(prev => 
        prev.map(comment => 
          comment.id === commentId 
            ? { 
                ...comment, 
                isLiked: !isLiked, 
                likesCount: isLiked ? comment.likesCount - 1 : comment.likesCount + 1 
              } 
            : comment
        )
      );
    } catch (error) {
      console.error('Error toggling comment like:', error);
    }
  };

  // Create void-returning wrapper functions for event handlers
  const handleLikeCommentWrapper = (commentId: string, isLiked: boolean) => {
    void handleLikeComment(commentId, isLiked);
  };

  const handleSubmitCommentWrapper = (e: React.FormEvent) => {
    void handleSubmitComment(e);
  };

  return (
    <div style={{ 
      position: 'fixed',
      top: 0,
      right: 0,
      bottom: 0,
      width: '400px',
      backgroundColor: 'white',
      boxShadow: '-2px 0 10px rgba(0,0,0,0.1)',
      zIndex: 1000,
      display: 'flex',
      flexDirection: 'column'
    }}>
      <div style={{ 
        padding: '16px',
        borderBottom: '1px solid #e0e0e0',
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center'
      }}>
        <h3 style={{ margin: 0 }}>Comments</h3>
        <button 
          onClick={onClose}
          style={{ 
            background: 'none',
            border: 'none',
            fontSize: '1.5rem',
            cursor: 'pointer'
          }}
        >
          ×
        </button>
      </div>

      <div style={{ 
        flex: 1,
        overflowY: 'auto',
        padding: '16px'
      }}>
        {comments.length === 0 && !isLoading ? (
          <div style={{ textAlign: 'center', padding: '20px', color: '#666' }}>
            No comments yet. Be the first to comment!
          </div>
        ) : (
          <>
            {comments.map(comment => (
              <div 
                key={comment.id} 
                style={{ 
                  marginBottom: '16px',
                  padding: '12px',
                  backgroundColor: '#f9f9f9',
                  borderRadius: '8px'
                }}
              >
                <div style={{ display: 'flex', alignItems: 'center', marginBottom: '8px' }}>
                  <img 
                    src={comment.userAvatar || '/default-avatar.png'} 
                    alt={comment.username} 
                    style={{ 
                      width: '32px', 
                      height: '32px', 
                      borderRadius: '50%', 
                      marginRight: '8px',
                      objectFit: 'cover'
                    }} 
                  />
                  <div>
                    <div style={{ fontWeight: 'bold', fontSize: '0.9rem' }}>{comment.username}</div>
                    <div style={{ fontSize: '0.7rem', color: '#666' }}>
                      {formatDate(comment.createdAt)}
                    </div>
                  </div>
                </div>
                
                <div style={{ marginBottom: '8px' }}>
                  {comment.content}
                </div>
                
                <div style={{ display: 'flex', alignItems: 'center' }}>
                  <button 
                    onClick={() => handleLikeCommentWrapper(comment.id, comment.isLiked)}
                    style={{ 
                      background: 'none',
                      border: 'none',
                      display: 'flex',
                      alignItems: 'center',
                      color: comment.isLiked ? 'var(--accent)' : 'inherit',
                      fontWeight: comment.isLiked ? 'bold' : 'normal',
                      cursor: 'pointer',
                      fontSize: '0.8rem'
                    }}
                  >
                    <span style={{ marginRight: '4px' }}>
                      {comment.isLiked ? '❤️' : '🤍'}
                    </span>
                    {comment.likesCount}
                  </button>
                </div>
              </div>
            ))}
            
            {hasMore && (
              <div style={{ textAlign: 'center', marginTop: '16px' }}>
                <button 
                  onClick={handleLoadMore}
                  disabled={isLoading}
                  style={{ 
                    padding: '8px 16px',
                    backgroundColor: 'var(--accent)',
                    color: 'white',
                    border: 'none',
                    borderRadius: '4px',
                    cursor: 'pointer',
                    opacity: isLoading ? 0.7 : 1
                  }}
                >
                  {isLoading ? 'Loading...' : 'Load More'}
                </button>
              </div>
            )}
          </>
        )}
      </div>

      <form 
        onSubmit={handleSubmitCommentWrapper}
        style={{ 
          padding: '16px',
          borderTop: '1px solid #e0e0e0',
          display: 'flex'
        }}
      >
        <input 
          type="text"
          value={newComment}
          onChange={(e) => setNewComment(e.target.value)}
          placeholder="Write a comment..."
          style={{ 
            flex: 1,
            padding: '8px 12px',
            border: '1px solid #e0e0e0',
            borderRadius: '20px',
            marginRight: '8px'
          }}
        />
        <button 
          type="submit"
          disabled={!newComment.trim() || isLoading}
          style={{ 
            padding: '8px 16px',
            backgroundColor: 'var(--accent)',
            color: 'white',
            border: 'none',
            borderRadius: '20px',
            cursor: 'pointer',
            opacity: !newComment.trim() || isLoading ? 0.7 : 1
          }}
        >
          {isLoading ? '...' : 'Post'}
        </button>
      </form>
    </div>
  );
}; 
================================================================================
File: components\social\CreatePost.tsx
Lines: 188
--------------------------------------------------------------------------------
import React, { useState, useRef } from 'react';

import { MediaUpload } from '../media/mediaUpload';

interface CreatePostProps {
  onSubmit: (post: {
    content: string;
    media?: File;
  }) => Promise<void>;
  className?: string;
}

export const CreatePost: React.FC<CreatePostProps> = ({
  onSubmit,
  className,
}) => {
  const [content, setContent] = useState('');
  const [media, setMedia] = useState<File | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!content.trim() && !media) return;

    try {
      setIsSubmitting(true);
      setError(null);
      await onSubmit({
        content: content.trim(),
        media: media || undefined,
      });
      setContent('');
      setMedia(null);
      if (textareaRef.current) {
        textareaRef.current.style.height = 'auto';
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to create post');
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleContentChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setContent(e.target.value);
    e.target.style.height = 'auto';
    e.target.style.height = `${e.target.scrollHeight}px`;
  };

  const handleMediaUpload = async (file: File): Promise<void> => {
    setMedia(file);
    return Promise.resolve();
  };

  // Void-returning wrapper for handleSubmit
  const handleSubmitWrapper = (e: React.FormEvent) => {
    void handleSubmit(e);
  };

  const styles = {
    container: {
      backgroundColor: '#fff',
      borderRadius: '8px',
      boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
      padding: '16px',
    },
    form: {
      display: 'flex',
      flexDirection: 'column' as const,
      gap: '16px',
    },
    textarea: {
      width: '100%',
      minHeight: '100px',
      padding: '12px',
      border: '1px solid #ddd',
      borderRadius: '4px',
      fontSize: '16px',
      lineHeight: '1.5',
      resize: 'none' as const,
      fontFamily: 'inherit',
      '&:focus': {
        outline: 'none',
        borderColor: '#2196f3',
      },
    },
    mediaPreview: {
      marginTop: '16px',
      maxWidth: '100%',
      maxHeight: '300px',
      borderRadius: '4px',
      overflow: 'hidden',
    },
    mediaImage: {
      maxWidth: '100%',
      maxHeight: '300px',
      objectFit: 'contain' as const,
    },
    actions: {
      display: 'flex',
      justifyContent: 'space-between',
      alignItems: 'center',
    },
    submitButton: {
      padding: '8px 24px',
      backgroundColor: '#2196f3',
      color: '#fff',
      border: 'none',
      borderRadius: '20px',
      fontSize: '16px',
      fontWeight: 500,
      cursor: 'pointer',
      transition: 'background-color 0.2s',
      '&:hover': {
        backgroundColor: '#1976d2',
      },
      '&:disabled': {
        backgroundColor: '#ccc',
        cursor: 'not-allowed',
      },
    },
    error: {
      color: '#d32f2f',
      fontSize: '14px',
      marginTop: '8px',
    },
  };

  return (
    <div style={styles.container} className={className}>
      <form onSubmit={handleSubmitWrapper} style={styles.form}>
        <textarea
          ref={textareaRef}
          value={content}
          onChange={handleContentChange}
          placeholder="What's on your mind?"
          style={styles.textarea}
        />
        
        {media && (
          <div style={styles.mediaPreview}>
            {media.type.startsWith('image/') ? (
              <img
                src={URL.createObjectURL(media)}
                alt="Preview"
                style={styles.mediaImage}
              />
            ) : (
              <MediaUpload
                onUpload={handleMediaUpload}
                acceptedTypes={[media.type]}
                maxSize={media.size}
              />
            )}
          </div>
        )}
        
        <div style={styles.actions}>
          <MediaUpload
            onUpload={handleMediaUpload}
            acceptedTypes={['image/*', 'video/*', 'audio/*']}
            maxSize={100 * 1024 * 1024} // 100MB
          />
          <button
            type="submit"
            style={{
              ...styles.submitButton,
              ...(isSubmitting && { opacity: 0.7 }),
            }}
            disabled={isSubmitting || (!content.trim() && !media)}
            onMouseEnter={(e) => e.currentTarget.style.backgroundColor = '#1976d2'}
            onMouseLeave={(e) => e.currentTarget.style.backgroundColor = '#2196f3'}
          >
            {isSubmitting ? 'Posting...' : 'Post'}
          </button>
        </div>
        
        {error && (
          <div style={styles.error}>
            {error}
          </div>
        )}
      </form>
    </div>
  );
}; 
================================================================================
File: components\social\CreatePostForm.tsx
Lines: 205
--------------------------------------------------------------------------------
import React, { useState, useRef } from 'react';

import { socialService } from '../../services/social';

interface CreatePostFormProps {
  onPostCreated: () => void;
}

export const CreatePostForm: React.FC<CreatePostFormProps> = ({ onPostCreated }) => {
  const [content, setContent] = useState('');
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [previewUrl, setPreviewUrl] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files.length > 0) {
      const file = e.target.files[0];
      setSelectedFile(file);
      
      // Create preview URL for images
      if (file.type.startsWith('image/')) {
        const reader = new FileReader();
        reader.onloadend = () => {
          setPreviewUrl(reader.result as string);
        };
        reader.readAsDataURL(file);
      } else {
        setPreviewUrl(null);
      }
    }
  };

  const handleRemoveFile = () => {
    setSelectedFile(null);
    setPreviewUrl(null);
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if ((!content.trim() && !selectedFile) || isLoading) return;

    setIsLoading(true);
    try {
      await socialService.createPost(content, selectedFile || undefined);
      setContent('');
      setSelectedFile(null);
      setPreviewUrl(null);
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
      onPostCreated();
    } catch (error) {
      console.error('Error creating post:', error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div style={{ 
      border: '1px solid #e0e0e0', 
      borderRadius: '8px', 
      padding: '16px', 
      marginBottom: '24px',
      backgroundColor: 'white',
      boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
    }}>
      <form onSubmit={handleSubmit as (e: React.FormEvent) => void}>
        <textarea 
          value={content}
          onChange={(e) => setContent(e.target.value)}
          placeholder="What's on your mind?"
          style={{ 
            width: '100%',
            minHeight: '100px',
            padding: '12px',
            border: '1px solid #e0e0e0',
            borderRadius: '8px',
            resize: 'vertical',
            marginBottom: '12px'
          }}
        />
        
        {previewUrl && (
          <div style={{ position: 'relative', marginBottom: '12px' }}>
            <img 
              src={previewUrl} 
              alt="Preview" 
              style={{ 
                maxWidth: '100%', 
                maxHeight: '300px', 
                borderRadius: '8px',
                objectFit: 'cover'
              }} 
            />
            <button 
              type="button"
              onClick={handleRemoveFile}
              style={{ 
                position: 'absolute',
                top: '8px',
                right: '8px',
                width: '24px',
                height: '24px',
                borderRadius: '50%',
                backgroundColor: 'rgba(0,0,0,0.5)',
                color: 'white',
                border: 'none',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                cursor: 'pointer'
              }}
            >
              ×
            </button>
          </div>
        )}
        
        {selectedFile && !previewUrl && (
          <div style={{ 
            display: 'flex',
            alignItems: 'center',
            backgroundColor: '#f5f5f5',
            padding: '8px 12px',
            borderRadius: '4px',
            marginBottom: '12px'
          }}>
            <div style={{ flex: 1 }}>
              <div style={{ fontWeight: 'bold' }}>{selectedFile.name}</div>
              <div style={{ fontSize: '0.8rem', color: '#666' }}>
                {(selectedFile.size / 1024 / 1024).toFixed(2)} MB
              </div>
            </div>
            <button 
              type="button"
              onClick={handleRemoveFile}
              style={{ 
                background: 'none',
                border: 'none',
                color: '#666',
                cursor: 'pointer',
                fontSize: '1.2rem'
              }}
            >
              ×
            </button>
          </div>
        )}
        
        <div style={{ 
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center'
        }}>
          <div>
            <input 
              type="file"
              id="file-input"
              ref={fileInputRef}
              onChange={handleFileChange}
              accept="image/*,video/*,audio/*"
              style={{ display: 'none' }}
            />
            <button 
              type="button"
              onClick={() => fileInputRef.current?.click()}
              style={{ 
                background: 'none',
                border: 'none',
                color: 'var(--accent)',
                cursor: 'pointer',
                display: 'flex',
                alignItems: 'center'
              }}
            >
              <span style={{ marginRight: '4px' }}>📎</span>
              Add Media
            </button>
          </div>
          
          <button 
            type="submit"
            disabled={(!content.trim() && !selectedFile) || isLoading}
            style={{ 
              padding: '8px 24px',
              backgroundColor: 'var(--accent)',
              color: 'white',
              border: 'none',
              borderRadius: '20px',
              cursor: 'pointer',
              opacity: (!content.trim() && !selectedFile) || isLoading ? 0.7 : 1
            }}
          >
            {isLoading ? 'Posting...' : 'Post'}
          </button>
        </div>
      </form>
    </div>
  );
}; 
================================================================================
File: components\social\Feed.tsx
Lines: 312
--------------------------------------------------------------------------------
import React, { useState, useEffect, useRef, useCallback } from 'react';

import { MediaPlayer } from '../media/mediaPlayer';

interface Post {
  id: string;
  userId: string;
  username: string;
  userAvatar: string;
  content: string;
  media?: {
    type: 'image' | 'video' | 'audio';
    url: string;
    thumbnail?: string;
  };
  likesCount: number;
  commentsCount: number;
  sharesCount: number;
  isLiked: boolean;
  createdAt: string;
}

// Add API response type definitions
interface FeedResponse {
  posts: Post[];
  hasMore: boolean;
}

interface FeedProps {
  type: 'home' | 'profile' | 'explore';
  userId?: string;
  onLoadMore?: () => Promise<void>;
  className?: string;
}

export const Feed: React.FC<FeedProps> = ({
  type,
  userId,
  onLoadMore,
  className,
}) => {
  const [posts, setPosts] = useState<Post[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [hasMore, setHasMore] = useState(true);
  const observer = useRef<IntersectionObserver | null>(null);
  const lastPostRef = useRef<HTMLDivElement>(null);

  const fetchPosts = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);
      // TODO: Replace with actual API call
      const response = await fetch(`/api/feed?type=${type}${userId ? `&userId=${userId}` : ''}`);
      if (!response.ok) throw new Error('Failed to fetch posts');
      const data = await response.json() as FeedResponse;
      setPosts(data.posts);
      setHasMore(data.hasMore);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load posts');
    } finally {
      setIsLoading(false);
    }
  }, [type, userId]);

  const loadMore = useCallback(async () => {
    if (!hasMore || isLoading) return;
    
    try {
      setIsLoading(true);
      await onLoadMore?.();
      // TODO: Replace with actual API call
      const response = await fetch(`/api/feed?type=${type}${userId ? `&userId=${userId}` : ''}&offset=${posts.length}`);
      if (!response.ok) throw new Error('Failed to fetch more posts');
      const data = await response.json() as FeedResponse;
      setPosts(prev => [...prev, ...data.posts]);
      setHasMore(data.hasMore);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load more posts');
    } finally {
      setIsLoading(false);
    }
  }, [hasMore, isLoading, onLoadMore, posts.length, type, userId]);

  useEffect(() => {
    void fetchPosts();
  }, [fetchPosts, type, userId]);

  useEffect(() => {
    observer.current = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting && hasMore && !isLoading) {
          void loadMore();
        }
      },
      { threshold: 0.5 }
    );

    if (lastPostRef.current) {
      observer.current.observe(lastPostRef.current);
    }

    return () => {
      if (observer.current) {
        observer.current.disconnect();
      }
    };
  }, [loadMore, hasMore, isLoading]);

  const handleLike = async (postId: string) => {
    try {
      // TODO: Replace with actual API call
      const response = await fetch(`/api/posts/${postId}/like`, {
        method: 'POST',
      });
      if (!response.ok) throw new Error('Failed to like post');
      
      setPosts(prev => prev.map(post => 
        post.id === postId
          ? { ...post, isLiked: !post.isLiked, likesCount: post.isLiked ? post.likesCount - 1 : post.likesCount + 1 }
          : post
      ));
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to like post');
    }
  };

  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    const now = new Date();
    const diff = now.getTime() - date.getTime();
    
    if (diff < 60000) return 'just now';
    if (diff < 3600000) return `${Math.floor(diff / 60000)}m ago`;
    if (diff < 86400000) return `${Math.floor(diff / 3600000)}h ago`;
    return date.toLocaleDateString();
  };

  const styles = {
    container: {
      display: 'flex',
      flexDirection: 'column' as const,
      gap: '16px',
      maxWidth: '600px',
      margin: '0 auto',
      padding: '16px',
    },
    post: {
      backgroundColor: '#fff',
      borderRadius: '8px',
      boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
      overflow: 'hidden',
    },
    postHeader: {
      display: 'flex',
      alignItems: 'center',
      padding: '12px',
      gap: '12px',
    },
    avatar: {
      width: '40px',
      height: '40px',
      borderRadius: '50%',
      objectFit: 'cover' as const,
    },
    userInfo: {
      flex: 1,
    },
    username: {
      fontSize: '16px',
      fontWeight: 600,
      color: '#1a1a1a',
      margin: 0,
    },
    timestamp: {
      fontSize: '14px',
      color: '#666',
      margin: '4px 0 0',
    },
    content: {
      padding: '0 12px 12px',
      fontSize: '16px',
      lineHeight: '1.5',
      color: '#333',
    },
    media: {
      width: '100%',
      maxHeight: '600px',
      objectFit: 'cover' as const,
    },
    actions: {
      display: 'flex',
      padding: '12px',
      gap: '16px',
      borderTop: '1px solid #eee',
    },
    actionButton: {
      display: 'flex',
      alignItems: 'center',
      gap: '8px',
      background: 'none',
      border: 'none',
      color: '#666',
      cursor: 'pointer',
      padding: '4px 8px',
      borderRadius: '4px',
      transition: 'background-color 0.2s',
      '&:hover': {
        backgroundColor: '#f5f5f5',
      },
    },
    actionButtonLiked: {
      color: '#e91e63',
    },
    actionCount: {
      fontSize: '14px',
    },
    loading: {
      textAlign: 'center' as const,
      padding: '24px',
      color: '#666',
    },
    error: {
      color: '#d32f2f',
      textAlign: 'center' as const,
      padding: '16px',
    },
  };

  if (error) {
    return <div style={styles.error}>{error}</div>;
  }

  return (
    <div style={styles.container} className={className}>
      {posts.map((post, index) => (
        <div
          key={post.id}
          ref={index === posts.length - 1 ? lastPostRef : undefined}
          style={styles.post}
        >
          <div style={styles.postHeader}>
            <img
              src={post.userAvatar}
              alt={post.username}
              style={styles.avatar}
            />
            <div style={styles.userInfo}>
              <p style={styles.username}>{post.username}</p>
              <p style={styles.timestamp}>{formatDate(post.createdAt)}</p>
            </div>
          </div>
          
          <p style={styles.content}>{post.content}</p>
          
          {post.media && (
            post.media.type === 'image' ? (
              <img
                src={post.media.url}
                alt="Post media"
                style={styles.media}
              />
            ) : (
              <MediaPlayer
                src={post.media.url}
                type={post.media.type}
                poster={post.media.thumbnail}
              />
            )
          )}
          
          <div style={styles.actions}>
            <button
              style={{
                ...styles.actionButton,
                ...(post.isLiked && styles.actionButtonLiked),
              }}
              onClick={() => void handleLike(post.id)}
              onMouseEnter={(e) => e.currentTarget.style.backgroundColor = '#f5f5f5'}
              onMouseLeave={(e) => e.currentTarget.style.backgroundColor = 'transparent'}
            >
              {post.isLiked ? '❤️' : '🤍'}
              <span style={styles.actionCount}>{post.likesCount}</span>
            </button>
            <button
              style={styles.actionButton}
              onMouseEnter={(e) => e.currentTarget.style.backgroundColor = '#f5f5f5'}
              onMouseLeave={(e) => e.currentTarget.style.backgroundColor = 'transparent'}
            >
              💬
              <span style={styles.actionCount}>{post.commentsCount}</span>
            </button>
            <button
              style={styles.actionButton}
              onMouseEnter={(e) => e.currentTarget.style.backgroundColor = '#f5f5f5'}
              onMouseLeave={(e) => e.currentTarget.style.backgroundColor = 'transparent'}
            >
              🔄
              <span style={styles.actionCount}>{post.sharesCount}</span>
            </button>
          </div>
        </div>
      ))}
      
      {isLoading && (
        <div style={styles.loading}>
          Loading more posts...
        </div>
      )}
    </div>
  );
}; 
================================================================================
File: components\social\PostCard.tsx
Lines: 212
--------------------------------------------------------------------------------
import React, { useState } from 'react';

import { formatDate } from '../../../shared/dateHelpers';
import { socialService } from '../../services/social';

interface Post {
  id: string;
  userId: string;
  username: string;
  userAvatar: string;
  content: string;
  media?: {
    type: 'image' | 'video' | 'audio';
    url: string;
    thumbnail?: string;
  };
  likesCount: number;
  commentsCount: number;
  sharesCount: number;
  isLiked: boolean;
  createdAt: string;
}

interface PostCardProps {
  post: Post;
  onCommentClick: (postId: string) => void;
  onRefresh: () => void;
}

export const PostCard: React.FC<PostCardProps> = ({ post, onCommentClick, onRefresh }) => {
  const [isLiked, setIsLiked] = useState(post.isLiked);
  const [likesCount, setLikesCount] = useState(post.likesCount);
  const [isLoading, setIsLoading] = useState(false);

  const handleLikeToggle = async () => {
    if (isLoading) return;
    
    setIsLoading(true);
    try {
      if (isLiked) {
        await socialService.unlikePost(post.id);
        setIsLiked(false);
        setLikesCount(prev => prev - 1);
      } else {
        await socialService.likePost(post.id);
        setIsLiked(true);
        setLikesCount(prev => prev + 1);
      }
    } catch (error) {
      console.error('Error toggling like:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleShare = async () => {
    if (isLoading) return;
    
    setIsLoading(true);
    try {
      await socialService.sharePost(post.id);
      onRefresh();
    } catch (error) {
      console.error('Error sharing post:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const renderMedia = () => {
    if (!post.media) return null;

    switch (post.media.type) {
      case 'image':
        return (
          <div style={{ marginTop: '12px' }}>
            <img 
              src={post.media.url} 
              alt="Post media" 
              style={{ 
                maxWidth: '100%', 
                borderRadius: '8px',
                maxHeight: '400px',
                objectFit: 'cover'
              }} 
            />
          </div>
        );
      case 'video':
        return (
          <div style={{ marginTop: '12px' }}>
            <video 
              src={post.media.url} 
              controls 
              poster={post.media.thumbnail} 
              style={{ 
                maxWidth: '100%', 
                borderRadius: '8px',
                maxHeight: '400px'
              }} 
            />
          </div>
        );
      case 'audio':
        return (
          <div style={{ marginTop: '12px' }}>
            <audio src={post.media.url} controls style={{ width: '100%' }} />
          </div>
        );
      default:
        return null;
    }
  };

  return (
    <div style={{ 
      border: '1px solid #e0e0e0', 
      borderRadius: '8px', 
      padding: '16px', 
      marginBottom: '16px',
      backgroundColor: 'white',
      boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
    }}>
      <div style={{ display: 'flex', alignItems: 'center', marginBottom: '12px' }}>
        <img 
          src={post.userAvatar || '/default-avatar.png'} 
          alt={post.username} 
          style={{ 
            width: '40px', 
            height: '40px', 
            borderRadius: '50%', 
            marginRight: '12px',
            objectFit: 'cover'
          }} 
        />
        <div>
          <div style={{ fontWeight: 'bold' }}>{post.username}</div>
          <div style={{ fontSize: '0.8rem', color: '#666' }}>
            {formatDate(post.createdAt)}
          </div>
        </div>
      </div>
      
      <div style={{ marginBottom: '12px' }}>
        {post.content}
      </div>
      
      {renderMedia()}
      
      <div style={{ 
        display: 'flex', 
        justifyContent: 'space-between', 
        marginTop: '16px',
        padding: '8px 0',
        borderTop: '1px solid #f0f0f0'
      }}>
        <div style={{ display: 'flex', alignItems: 'center' }}>
          <button 
            onClick={() => void handleLikeToggle()}
            style={{ 
              background: 'none',
              border: 'none',
              display: 'flex',
              alignItems: 'center',
              color: isLiked ? 'var(--accent)' : 'inherit',
              fontWeight: isLiked ? 'bold' : 'normal',
              cursor: 'pointer'
            }}
          >
            <span style={{ marginRight: '4px' }}>
              {isLiked ? '❤️' : '🤍'}
            </span>
            {likesCount}
          </button>
        </div>
        
        <div>
          <button 
            onClick={() => onCommentClick(post.id)}
            style={{ 
              background: 'none',
              border: 'none',
              display: 'flex',
              alignItems: 'center',
              cursor: 'pointer',
              marginRight: '16px'
            }}
          >
            <span style={{ marginRight: '4px' }}>💬</span>
            {post.commentsCount}
          </button>
        </div>
        
        <div>
          <button 
            onClick={() => void handleShare()}
            style={{ 
              background: 'none',
              border: 'none',
              display: 'flex',
              alignItems: 'center',
              cursor: 'pointer'
            }}
          >
            <span style={{ marginRight: '4px' }}>🔄</span>
            {post.sharesCount}
          </button>
        </div>
      </div>
    </div>
  );
}; 
================================================================================
File: components\social\SocialFeed.tsx
Lines: 599
--------------------------------------------------------------------------------
import React, { useState, useEffect } from 'react';

import { formatRelativeTime } from '../../helpers/formatters';
import { socialFeedStyles } from '../../styles';
import { mergeStyles } from '../../utils/styleUtils';
import AudioPlayer from '../media/AudioPlayer';
import ImageGallery from '../media/ImageGallery';
import VideoPlayer from '../media/VideoPlayer';

// Types for different media content
interface TrackData {
  id: string;
  title: string;
  artist: string;
  coverArt: string;
  audioUrl: string;
}

interface ImageData {
  src: string;
  width: number;
  height: number;
  alt?: string;
}

interface VideoData {
  sources: Array<{
    src: string;
    quality: string;
    type: string;
  }>;
  poster?: string;
  title?: string;
  duration?: number;
}

interface PostData {
  id: string;
  userId: string;
  username: string;
  userAvatar: string;
  content: string;
  mediaType?: 'image' | 'video' | 'audio' | 'carousel';
  track?: TrackData;
  image?: ImageData;
  video?: VideoData;
  carousel?: ImageData[];
  likesCount: number;
  commentsCount: number;
  sharesCount: number;
  viewsCount?: number;
  isLiked: boolean;
  tags?: string[];
  location?: string;
  createdAt: string;
}

interface SocialFeedProps {
  initialPosts?: PostData[];
  onLikePost?: (postId: string, isLiked: boolean) => void;
  onCommentPost?: (postId: string, comment: string) => void;
  onSharePost?: (postId: string) => void;
  onViewPost?: (postId: string) => void;
}

const SocialFeed: React.FC<SocialFeedProps> = ({
  initialPosts = [],
  onLikePost,
  onCommentPost,
  onSharePost,
  onViewPost,
}) => {
  const [posts, setPosts] = useState<PostData[]>(initialPosts);
  const [newComment, setNewComment] = useState<string>('');
  const [activePostId, setActivePostId] = useState<string | null>(null);
  const [expandedCaption, setExpandedCaption] = useState<string | null>(null);
  
  useEffect(() => {
    // In a real app, you would fetch posts from an API
    if (initialPosts.length === 0) {
      // Mock data for demonstration
      const mockPosts: PostData[] = [
        {
          id: '1',
          userId: 'user1',
          username: 'JohnDoe',
          userAvatar: '/images/avatars/user1.jpg',
          content: 'Check out this awesome new track I discovered! #newmusic #recommended',
          mediaType: 'audio',
          track: {
            id: 'track1',
            title: 'Awesome Track',
            artist: 'Amazing Artist',
            coverArt: '/images/covers/track1.jpg',
            audioUrl: '/audio/track1.mp3',
          },
          likesCount: 42,
          commentsCount: 7,
          sharesCount: 3,
          isLiked: false,
          tags: ['newmusic', 'recommended'],
          createdAt: new Date(Date.now() - 3600000).toISOString(), // 1 hour ago
        },
        {
          id: '2',
          userId: 'user2',
          username: 'TravelLover',
          userAvatar: '/images/avatars/user2.jpg',
          content: 'Amazing view from my hotel this morning! #travel #vacation #sunrise',
          mediaType: 'image',
          image: {
            src: '/images/posts/travel1.jpg',
            width: 1080,
            height: 1350,
            alt: 'Sunrise view from hotel balcony',
          },
          likesCount: 128,
          commentsCount: 14,
          sharesCount: 5,
          isLiked: true,
          location: 'Bali, Indonesia',
          tags: ['travel', 'vacation', 'sunrise'],
          createdAt: new Date(Date.now() - 86400000).toISOString(), // 1 day ago
        },
        {
          id: '3',
          userId: 'user3',
          username: 'FoodieChef',
          userAvatar: '/images/avatars/user3.jpg',
          content: 'Made this delicious pasta dish yesterday! Swipe to see the process 👨‍🍳 #homemade #cooking #pasta',
          mediaType: 'carousel',
          carousel: [
            {
              src: '/images/posts/food1.jpg',
              width: 1080,
              height: 1080,
              alt: 'Finished pasta dish',
            },
            {
              src: '/images/posts/food2.jpg',
              width: 1080,
              height: 1080,
              alt: 'Cooking process',
            },
            {
              src: '/images/posts/food3.jpg',
              width: 1080,
              height: 1080,
              alt: 'Ingredients',
            },
          ],
          likesCount: 89,
          commentsCount: 9,
          sharesCount: 2,
          isLiked: false,
          tags: ['homemade', 'cooking', 'pasta'],
          createdAt: new Date(Date.now() - 172800000).toISOString(), // 2 days ago
        },
        {
          id: '4',
          userId: 'user4',
          username: 'FilmCreator',
          userAvatar: '/images/avatars/user4.jpg',
          content: 'Just finished editing my latest short film! Check it out and let me know what you think 🎬 #shortfilm #filmmaker #cinematography',
          mediaType: 'video',
          video: {
            sources: [
              {
                src: '/videos/film1.mp4',
                quality: '720p',
                type: 'video/mp4',
              },
              {
                src: '/videos/film1-480p.mp4',
                quality: '480p',
                type: 'video/mp4',
              },
            ],
            poster: '/images/posts/film1-poster.jpg',
            title: 'My Short Film',
          },
          likesCount: 215,
          commentsCount: 32,
          sharesCount: 18,
          viewsCount: 1240,
          isLiked: false,
          tags: ['shortfilm', 'filmmaker', 'cinematography'],
          createdAt: new Date(Date.now() - 259200000).toISOString(), // 3 days ago
        },
      ];
      
      setPosts(mockPosts);
    }
  }, [initialPosts]);
  
  const handleLike = (postId: string) => {
    setPosts(prevPosts => prevPosts.map(post => {
      if (post.id === postId) {
        const newIsLiked = !post.isLiked;
        const likeDelta = newIsLiked ? 1 : -1;
        
        if (onLikePost) {
          onLikePost(postId, newIsLiked);
        }
        
        return {
          ...post,
          isLiked: newIsLiked,
          likesCount: post.likesCount + likeDelta,
        };
      }
      return post;
    }));
  };
  
  const handleComment = (postId: string) => {
    if (!newComment.trim()) return;
    
    if (onCommentPost) {
      onCommentPost(postId, newComment);
    }
    
    setPosts(prevPosts => prevPosts.map(post => {
      if (post.id === postId) {
        return {
          ...post,
          commentsCount: post.commentsCount + 1,
        };
      }
      return post;
    }));
    
    setNewComment('');
    setActivePostId(null);
  };
  
  const handleShare = (postId: string) => {
    if (onSharePost) {
      onSharePost(postId);
    }
    
    setPosts(prevPosts => prevPosts.map(post => {
      if (post.id === postId) {
        return {
          ...post,
          sharesCount: post.sharesCount + 1,
        };
      }
      return post;
    }));
  };
  
  const handleView = (postId: string) => {
    if (onViewPost) {
      onViewPost(postId);
    }
  };
  
  const toggleCaption = (postId: string) => {
    setExpandedCaption(expandedCaption === postId ? null : postId);
  };
  
  const renderTags = (tags?: string[]) => {
    if (!tags || tags.length === 0) return null;
    
    return (
      <div className="post-tags">
        {tags.map(tag => (
          <a 
            key={tag} 
            href={`/tag/${tag}`} 
            className="tag"
            onClick={(e) => {
              e.preventDefault();
              // Handle tag click
            }}
          >
            #{tag}
          </a>
        ))}
      </div>
    );
  };
  
  const renderMediaContent = (post: PostData) => {
    switch (post.mediaType) {
      case 'audio':
        if (!post.track) return null;
        return (
          <div className="post-media post-audio">
            <AudioPlayer 
              trackUrl={post.track.audioUrl}
              trackTitle={post.track.title}
              artistName={post.track.artist}
              coverArtUrl={post.track.coverArt}
              onPlay={() => handleView(post.id)}
            />
          </div>
        );
        
      case 'image':
        if (!post.image) return null;
        return (
          <div className="post-media post-image">
            <ImageGallery 
              images={[post.image]} 
              showThumbnails={false}
              showNavigation={false}
              aspectRatio={post.image.width / post.image.height}
              onClick={() => handleView(post.id)}
            />
          </div>
        );
        
      case 'video':
        if (!post.video) return null;
        return (
          <div className="post-media post-video">
            <VideoPlayer 
              sources={post.video.sources}
              poster={post.video.poster}
              title={post.video.title}
              onPlay={() => handleView(post.id)}
            />
            {post.viewsCount !== undefined && (
              <div className="view-count">
                {post.viewsCount.toLocaleString()} views
              </div>
            )}
          </div>
        );
        
      case 'carousel':
        if (!post.carousel || post.carousel.length === 0) return null;
        return (
          <div className="post-media post-carousel">
            <ImageGallery 
              images={post.carousel} 
              showThumbnails={false}
              aspectRatio={post.carousel[0].width / post.carousel[0].height}
              onClick={() => handleView(post.id)}
            />
          </div>
        );
        
      default:
        return null;
    }
  };
  
  return (
    <div style={socialFeedStyles.socialFeed as React.CSSProperties}>
      <div style={socialFeedStyles.feedHeader as React.CSSProperties}>
        <h2 style={socialFeedStyles.feedTitle as React.CSSProperties}>Feed</h2>
        <div style={socialFeedStyles.feedFilter as React.CSSProperties}>
          <button 
            style={mergeStyles(
              socialFeedStyles.filterButton as React.CSSProperties,
              socialFeedStyles.filterButtonActive as React.CSSProperties
            )}
          >
            For You
          </button>
          <button 
            style={socialFeedStyles.filterButton as React.CSSProperties}
            onMouseOver={(e) => {
              e.currentTarget.style.background = 'var(--hover)';
            }}
            onMouseOut={(e) => {
              e.currentTarget.style.background = 'var(--background2)';
            }}
          >
            Following
          </button>
          <button 
            style={socialFeedStyles.filterButton as React.CSSProperties}
            onMouseOver={(e) => {
              e.currentTarget.style.background = 'var(--hover)';
            }}
            onMouseOut={(e) => {
              e.currentTarget.style.background = 'var(--background2)';
            }}
          >
            Popular
          </button>
        </div>
      </div>
      
      {posts.length === 0 ? (
        <div style={socialFeedStyles.emptyFeed as React.CSSProperties}>
          No posts to display
        </div>
      ) : (
        <div style={socialFeedStyles.postList as React.CSSProperties}>
          {posts.map(post => (
            <div key={post.id} style={socialFeedStyles.postCard as React.CSSProperties}>
              <div style={socialFeedStyles.postHeader as React.CSSProperties}>
                <div style={socialFeedStyles.postAvatar as React.CSSProperties}>
                  <img 
                    src={post.userAvatar} 
                    alt={`${post.username}'s avatar`} 
                    style={socialFeedStyles.postAvatarImg as React.CSSProperties}
                  />
                </div>
                <div style={socialFeedStyles.postUserInfo as React.CSSProperties}>
                  <h3 style={socialFeedStyles.postUsername as React.CSSProperties}>{post.username}</h3>
                  <p style={socialFeedStyles.postTime as React.CSSProperties}>
                    {formatRelativeTime(new Date(post.createdAt))}
                    {post.location && ` • ${post.location}`}
                  </p>
                </div>
                <button 
                  style={socialFeedStyles.postOptions as React.CSSProperties}
                  onMouseOver={(e) => {
                    e.currentTarget.style.background = 'var(--hover)';
                  }}
                  onMouseOut={(e) => {
                    e.currentTarget.style.background = 'transparent';
                  }}
                >
                  ⋮
                </button>
              </div>
              
              {post.mediaType && (
                <div style={socialFeedStyles.postMedia as React.CSSProperties}>
                  {renderMediaContent(post)}
                </div>
              )}
              
              <div style={socialFeedStyles.postContent as React.CSSProperties}>
                {post.content.length > 150 && expandedCaption !== post.id ? (
                  <>
                    {post.content.substring(0, 150)}...{' '}
                    <button 
                      onClick={() => toggleCaption(post.id)}
                      style={{ 
                        background: 'transparent', 
                        border: 'none', 
                        color: 'var(--text-color2)',
                        cursor: 'pointer',
                        padding: 0
                      }}
                    >
                      more
                    </button>
                  </>
                ) : (
                  <>
                    {post.content}
                    {post.content.length > 150 && (
                      <button 
                        onClick={() => toggleCaption(post.id)}
                        style={{ 
                          background: 'transparent', 
                          border: 'none', 
                          color: 'var(--text-color2)',
                          cursor: 'pointer',
                          padding: 0,
                          marginLeft: '5px'
                        }}
                      >
                        less
                      </button>
                    )}
                  </>
                )}
                
                {post.tags && post.tags.length > 0 && (
                  <div style={{ marginTop: '8px' }}>
                    {renderTags(post.tags)}
                  </div>
                )}
              </div>
              
              <div style={socialFeedStyles.postActions as React.CSSProperties}>
                <button 
                  style={mergeStyles(
                    socialFeedStyles.postAction as React.CSSProperties,
                    post.isLiked ? socialFeedStyles.postActionLiked as React.CSSProperties : {}
                  )}
                  onClick={() => handleLike(post.id)}
                  onMouseOver={(e) => {
                    if (!post.isLiked) {
                      e.currentTarget.style.background = 'var(--hover)';
                    }
                  }}
                  onMouseOut={(e) => {
                    if (!post.isLiked) {
                      e.currentTarget.style.background = 'transparent';
                    }
                  }}
                >
                  {post.isLiked ? '❤️' : '🤍'} {post.likesCount}
                </button>
                
                <button 
                  style={socialFeedStyles.postAction as React.CSSProperties}
                  onClick={() => setActivePostId(activePostId === post.id ? null : post.id)}
                  onMouseOver={(e) => {
                    e.currentTarget.style.background = 'var(--hover)';
                  }}
                  onMouseOut={(e) => {
                    e.currentTarget.style.background = 'transparent';
                  }}
                >
                  💬 {post.commentsCount}
                </button>
                
                <button 
                  style={socialFeedStyles.postAction as React.CSSProperties}
                  onClick={() => handleShare(post.id)}
                  onMouseOver={(e) => {
                    e.currentTarget.style.background = 'var(--hover)';
                  }}
                  onMouseOut={(e) => {
                    e.currentTarget.style.background = 'transparent';
                  }}
                >
                  🔄 {post.sharesCount}
                </button>
                
                {post.viewsCount && (
                  <span style={{ 
                    marginLeft: 'auto', 
                    color: 'var(--text-color2)',
                    fontSize: '0.9rem'
                  }}>
                    👁️ {post.viewsCount}
                  </span>
                )}
              </div>
              
              {activePostId === post.id && (
                <div style={{ 
                  padding: '10px 15px',
                  display: 'flex',
                  gap: '10px',
                  borderTop: '1px solid var(--separator)'
                }}>
                  <input
                    type="text"
                    placeholder="Add a comment..."
                    value={newComment}
                    onChange={(e) => setNewComment(e.target.value)}
                    style={{ 
                      flex: 1,
                      padding: '8px 12px',
                      borderRadius: '20px',
                      border: '1px solid var(--separator)',
                      background: 'var(--background3)'
                    }}
                    onKeyPress={(e) => {
                      if (e.key === 'Enter') {
                        handleComment(post.id);
                      }
                    }}
                  />
                  <button
                    onClick={() => handleComment(post.id)}
                    disabled={!newComment.trim()}
                    style={{ 
                      padding: '8px 15px',
                      borderRadius: '20px',
                      border: 'none',
                      background: newComment.trim() ? 'var(--blue)' : 'var(--gray4)',
                      color: newComment.trim() ? 'white' : 'var(--text-color3)',
                      cursor: newComment.trim() ? 'pointer' : 'not-allowed'
                    }}
                  >
                    Post
                  </button>
                </div>
              )}
            </div>
          ))}
        </div>
      )}
      
      <button 
        style={socialFeedStyles.loadMore as React.CSSProperties}
        onClick={() => {
          // In a real app, this would load more posts
          console.log('Load more posts');
        }}
        onMouseOver={(e) => {
          e.currentTarget.style.background = 'var(--hover)';
        }}
        onMouseOut={(e) => {
          e.currentTarget.style.background = 'var(--background2)';
        }}
      >
        Load More
      </button>
    </div>
  );
};

export default SocialFeed; 
================================================================================
File: components\social\UserProfile.tsx
Lines: 203
--------------------------------------------------------------------------------
import React, { useState, useEffect, useCallback } from 'react';

interface User {
  id: string;
  username: string;
  displayName: string;
  avatar: string;
  bio: string;
  followersCount: number;
  followingCount: number;
  postsCount: number;
  isFollowing: boolean;
}

interface UserProfileProps {
  userId: string;
  onFollow?: (userId: string) => Promise<void>;
  onUnfollow?: (userId: string) => Promise<void>;
  className?: string;
}

export const UserProfile: React.FC<UserProfileProps> = ({
  userId,
  onFollow,
  onUnfollow,
  className,
}) => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchUserProfile = useCallback(async () => {
    try {
      setIsLoading(true);
      // TODO: Replace with actual API call
      const response = await fetch(`/api/users/${userId}`);
      if (!response.ok) throw new Error('Failed to fetch user profile');
      const data = await response.json() as User;
      setUser(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load profile');
    } finally {
      setIsLoading(false);
    }
  }, [userId]);
  
  useEffect(() => {
    void fetchUserProfile();
  }, [fetchUserProfile]);

  const handleFollowToggle = async () => {
    if (!user) return;
    
    try {
      if (user.isFollowing) {
        await onUnfollow?.(userId);
        setUser(prev => prev ? { ...prev, isFollowing: false, followersCount: prev.followersCount - 1 } : null);
      } else {
        await onFollow?.(userId);
        setUser(prev => prev ? { ...prev, isFollowing: true, followersCount: prev.followersCount + 1 } : null);
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to update follow status');
    }
  };

  const styles = {
    container: {
      padding: '24px',
      backgroundColor: '#fff',
      borderRadius: '8px',
      boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
    },
    header: {
      display: 'flex',
      alignItems: 'center',
      gap: '24px',
      marginBottom: '24px',
    },
    avatar: {
      width: '120px',
      height: '120px',
      borderRadius: '50%',
      objectFit: 'cover' as const,
    },
    info: {
      flex: 1,
    },
    name: {
      fontSize: '24px',
      fontWeight: 600,
      margin: '0 0 8px',
      color: '#1a1a1a',
    },
    username: {
      fontSize: '16px',
      color: '#666',
      margin: '0 0 16px',
    },
    bio: {
      fontSize: '16px',
      lineHeight: '1.5',
      color: '#333',
      margin: '0 0 16px',
    },
    stats: {
      display: 'flex',
      gap: '24px',
      marginBottom: '24px',
    },
    stat: {
      display: 'flex',
      flexDirection: 'column' as const,
      alignItems: 'center',
    },
    statValue: {
      fontSize: '20px',
      fontWeight: 600,
      color: '#1a1a1a',
    },
    statLabel: {
      fontSize: '14px',
      color: '#666',
    },
    followButton: {
      padding: '8px 24px',
      borderRadius: '20px',
      border: 'none',
      fontSize: '16px',
      fontWeight: 500,
      cursor: 'pointer',
      transition: 'background-color 0.2s',
      backgroundColor: user?.isFollowing ? '#e0e0e0' : '#2196f3',
      color: user?.isFollowing ? '#333' : '#fff',
      '&:hover': {
        backgroundColor: user?.isFollowing ? '#d0d0d0' : '#1976d2',
      },
    },
    loading: {
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center',
      minHeight: '200px',
    },
    error: {
      color: '#d32f2f',
      textAlign: 'center' as const,
      padding: '16px',
    },
  };

  if (isLoading) {
    return <div style={styles.loading}>Loading...</div>;
  }

  if (error) {
    return <div style={styles.error}>{error}</div>;
  }

  if (!user) {
    return <div style={styles.error}>User not found</div>;
  }

  return (
    <div style={styles.container} className={className}>
      <div style={styles.header}>
        <img
          src={user.avatar}
          alt={user.displayName}
          style={styles.avatar}
        />
        <div style={styles.info}>
          <h1 style={styles.name}>{user.displayName}</h1>
          <p style={styles.username}>@{user.username}</p>
          <p style={styles.bio}>{user.bio}</p>
          <button
            style={styles.followButton}
            onClick={() => void handleFollowToggle()}
            onMouseEnter={(e) => e.currentTarget.style.backgroundColor = user.isFollowing ? '#d0d0d0' : '#1976d2'}
            onMouseLeave={(e) => e.currentTarget.style.backgroundColor = user.isFollowing ? '#e0e0e0' : '#2196f3'}
          >
            {user.isFollowing ? 'Following' : 'Follow'}
          </button>
        </div>
      </div>
      
      <div style={styles.stats}>
        <div style={styles.stat}>
          <span style={styles.statValue}>{user.postsCount}</span>
          <span style={styles.statLabel}>Posts</span>
        </div>
        <div style={styles.stat}>
          <span style={styles.statValue}>{user.followersCount}</span>
          <span style={styles.statLabel}>Followers</span>
        </div>
        <div style={styles.stat}>
          <span style={styles.statValue}>{user.followingCount}</span>
          <span style={styles.statLabel}>Following</span>
        </div>
      </div>
    </div>
  );
}; 
================================================================================
File: components\social\UserProfileCard.tsx
Lines: 116
--------------------------------------------------------------------------------
import React, { useState } from 'react';

import { useClientEnvironment } from '../../services/ClientEnvironment';
import { socialService } from '../../services/social';

interface User {
  id: string;
  username: string;
  displayName: string;
  avatar: string;
  bio: string;
  followersCount: number;
  followingCount: number;
  postsCount: number;
  isFollowing: boolean;
}

interface UserProfileCardProps {
  user: User;
}

export const UserProfileCard: React.FC<UserProfileCardProps> = ({ user }) => {
  const environment = useClientEnvironment();
  const [isFollowing, setIsFollowing] = useState(user.isFollowing);
  const [followersCount, setFollowersCount] = useState(user.followersCount);
  const [isLoading, setIsLoading] = useState(false);

  const handleFollowToggle = async () => {
    if (isLoading) return;
    
    setIsLoading(true);
    try {
      if (isFollowing) {
        await socialService.unfollowUser(user.id);
        setIsFollowing(false);
        setFollowersCount(prev => prev - 1);
      } else {
        await socialService.followUser(user.id);
        setIsFollowing(true);
        setFollowersCount(prev => prev + 1);
      }
    } catch (error) {
      console.error('Error toggling follow:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const navigateToProfile = () => {
    environment.router.navigate(`/profile/${user.id}`);
  };

  return (
    <div style={{ 
      border: '1px solid #e0e0e0', 
      borderRadius: '8px', 
      padding: '16px', 
      marginBottom: '16px',
      backgroundColor: 'white',
      boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
    }}>
      <div style={{ display: 'flex', alignItems: 'center' }}>
        <img 
          src={user.avatar || '/default-avatar.png'} 
          alt={user.displayName} 
          style={{ 
            width: '80px', 
            height: '80px', 
            borderRadius: '50%', 
            marginRight: '16px',
            objectFit: 'cover',
            cursor: 'pointer'
          }} 
          onClick={navigateToProfile}
        />
        <div style={{ flex: 1 }}>
          <div 
            style={{ 
              fontWeight: 'bold', 
              fontSize: '1.2rem',
              cursor: 'pointer'
            }}
            onClick={navigateToProfile}
          >
            {user.displayName}
          </div>
          <div style={{ color: '#666', marginBottom: '8px' }}>@{user.username}</div>
          <div style={{ marginBottom: '12px' }}>{user.bio}</div>
          <div style={{ display: 'flex', gap: '16px', color: '#666', fontSize: '0.9rem' }}>
            <div><strong>{user.postsCount}</strong> posts</div>
            <div><strong>{followersCount}</strong> followers</div>
            <div><strong>{user.followingCount}</strong> following</div>
          </div>
        </div>
        <div>
          <button 
            onClick={() => void handleFollowToggle()}
            disabled={isLoading}
            style={{ 
              padding: '8px 16px',
              backgroundColor: isFollowing ? 'white' : 'var(--accent)',
              color: isFollowing ? 'var(--accent)' : 'white',
              border: isFollowing ? '1px solid var(--accent)' : 'none',
              borderRadius: '20px',
              cursor: 'pointer',
              fontWeight: 'bold',
              opacity: isLoading ? 0.7 : 1
            }}
          >
            {isLoading ? '...' : isFollowing ? 'Unfollow' : 'Follow'}
          </button>
        </div>
      </div>
    </div>
  );
}; 
================================================================================
File: components\theme\index.ts
Lines: 1
--------------------------------------------------------------------------------
export { ThemeProvider, useTheme } from './ThemeContext'; 
================================================================================
File: components\theme\ThemeContext.tsx
Lines: 128
--------------------------------------------------------------------------------
import { createContext, useContext, useState, useEffect, ReactNode } from 'react';

type ThemeMode = 'light' | 'dark';

interface ThemeContextType {
  theme: ThemeMode;
  toggleTheme: () => void;
  setTheme: (theme: ThemeMode) => void;
  useSystemTheme: () => void;
  isUsingSystemTheme: boolean;
}

const ThemeContext = createContext<ThemeContextType>({
  theme: 'light',
  toggleTheme: () => {},
  setTheme: () => {},
  useSystemTheme: () => {},
  isUsingSystemTheme: false
});

export const useTheme = () => useContext(ThemeContext);

interface ThemeProviderProps {
  children: ReactNode;
}

// Helper function to get system preference
const getSystemThemePreference = (): ThemeMode => {
  if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
    return 'dark';
  }
  return 'light';
};

export function ThemeProvider({ children }: ThemeProviderProps) {
  // Track if we're using system theme
  const [isUsingSystemTheme, setIsUsingSystemTheme] = useState<boolean>(() => {
    return localStorage.getItem('useSystemTheme') === 'true';
  });
  
  // Initialize theme from localStorage or system preference
  const [theme, setThemeState] = useState<ThemeMode>(() => {
    // Check if we should use system theme
    if (localStorage.getItem('useSystemTheme') === 'true') {
      return getSystemThemePreference();
    }
    
    // Check if theme is stored in localStorage
    const savedTheme = localStorage.getItem('theme') as ThemeMode;
    if (savedTheme && (savedTheme === 'light' || savedTheme === 'dark')) {
      return savedTheme;
    }
    
    // Default to system preference
    setIsUsingSystemTheme(true);
    return getSystemThemePreference();
  });
  
  // Listen for system theme changes
  useEffect(() => {
    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
    
    const handleChange = (e: MediaQueryListEvent) => {
      if (isUsingSystemTheme) {
        setThemeState(e.matches ? 'dark' : 'light');
      }
    };
    
    // Modern browsers
    if (mediaQuery.addEventListener) {
      mediaQuery.addEventListener('change', handleChange);
    } else {
      // Fallback for older browsers
      mediaQuery.addListener(handleChange);
    }
    
    return () => {
      if (mediaQuery.removeEventListener) {
        mediaQuery.removeEventListener('change', handleChange);
      } else {
        mediaQuery.removeListener(handleChange);
      }
    };
  }, [isUsingSystemTheme]);
  
  // Apply theme to document when it changes
  useEffect(() => {
    document.documentElement.setAttribute('data-theme', theme);
    
    // Only save to localStorage if not using system theme
    if (!isUsingSystemTheme) {
      localStorage.setItem('theme', theme);
    }
  }, [theme, isUsingSystemTheme]);
  
  // Toggle between light and dark mode
  const toggleTheme = () => {
    setIsUsingSystemTheme(false);
    localStorage.setItem('useSystemTheme', 'false');
    setThemeState(prevTheme => (prevTheme === 'light' ? 'dark' : 'light'));
  };
  
  // Set theme directly
  const setTheme = (newTheme: ThemeMode) => {
    setIsUsingSystemTheme(false);
    localStorage.setItem('useSystemTheme', 'false');
    setThemeState(newTheme);
  };
  
  // Use system theme
  const useSystemTheme = () => {
    setIsUsingSystemTheme(true);
    localStorage.setItem('useSystemTheme', 'true');
    setThemeState(getSystemThemePreference());
  };
  
  return (
    <ThemeContext.Provider value={{ 
      theme, 
      toggleTheme, 
      setTheme, 
      useSystemTheme,
      isUsingSystemTheme 
    }}>
      {children}
    </ThemeContext.Provider>
  );
} 
================================================================================
File: components\ui\Badge.tsx
Lines: 27
--------------------------------------------------------------------------------
import React from "react"

export function Badge(props: {
	children: React.ReactNode
	style?: React.CSSProperties
	onClick?: React.MouseEventHandler
	onKeyDown?: React.KeyboardEventHandler
	tabIndex?: 0 | -1
}) {
	return (
		<div
			style={{
				display: "inline-block",
				fontSize: "0.8em",
				padding: "0.2em 0.4em",
				borderRadius: "0.2em",
				backgroundColor: "var(--gray3)",
				...props.style,
			}}
			tabIndex={props.tabIndex}
			onClick={props.onClick}
			onKeyDown={props.onKeyDown}
		>
			{props.children}
		</div>
	)
}

================================================================================
File: components\ui\button.css
Lines: 86
--------------------------------------------------------------------------------
.btn {
  font-family: inherit;
  font-weight: 500;
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.2s, color 0.2s, border-color 0.2s, box-shadow 0.2s;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  text-decoration: none;
  border: 1px solid transparent;
  outline: none;
}

.btn:focus {
  box-shadow: 0 0 0 3px var(--transparent1);
}

/* Button variants */
.btn-primary {
  background-color: var(--accent);
  color: white;
  border-color: var(--accent);
}

.btn-primary:hover {
  background-color: var(--blue);
  border-color: var(--blue);
}

.btn-primary:active {
  background-color: var(--blue);
  border-color: var(--blue);
}

.btn-secondary {
  background-color: transparent;
  color: var(--text-primary);
  border-color: var(--border-color);
}

.btn-secondary:hover {
  background-color: var(--transparent1);
  border-color: var(--text-secondary);
}

.btn-secondary:active {
  background-color: var(--transparent2);
  border-color: var(--text-secondary);
}

.btn-text {
  background-color: transparent;
  color: var(--accent);
  border-color: transparent;
  padding: 0;
}

.btn-text:hover {
  color: var(--blue);
  text-decoration: underline;
}

.btn-text:active {
  color: var(--blue);
}

/* Button sizes */
.btn-small {
  font-size: 0.875rem;
  padding: 0.25rem 0.5rem;
  height: 32px;
}

.btn-medium {
  font-size: 1rem;
  padding: 0.5rem 1rem;
  height: 40px;
}

.btn-large {
  font-size: 1.125rem;
  padding: 0.75rem 1.5rem;
  height: 48px;
} 
================================================================================
File: components\ui\Button.tsx
Lines: 19
--------------------------------------------------------------------------------
import { forwardRef, ComponentPropsWithoutRef } from 'react';
import './button.css';

interface ButtonProps extends ComponentPropsWithoutRef<'button'> {
	variant?: 'primary' | 'secondary' | 'text';
	size?: 'small' | 'medium' | 'large';
}

const Button = forwardRef<HTMLButtonElement, ButtonProps>((props, ref) => {
	const { variant = 'primary', size = 'medium', className = '', ...rest } = props;
	const buttonClass = `btn btn-${variant} btn-${size} ${className}`;
	
	return <button ref={ref} className={buttonClass} {...rest} />;
});

Button.displayName = 'Button';

export { Button };
export default Button;

================================================================================
File: components\ui\Card.tsx
Lines: 17
--------------------------------------------------------------------------------
import React from 'react';

interface CardProps extends React.HTMLAttributes<HTMLDivElement> {
  children: React.ReactNode;
  className?: string;
}

export const Card: React.FC<CardProps> = ({ children, className = '', ...props }) => {
  return (
    <div 
      className={`bg-white shadow-md rounded-lg overflow-hidden ${className}`}
      {...props}
    >
      {children}
    </div>
  );
}; 
================================================================================
File: components\ui\ComboBox.tsx
Lines: 233
--------------------------------------------------------------------------------
import React, { useEffect, useLayoutEffect, useMemo, useRef, useState } from "react"

import { fuzzyMatch } from "../../../shared/fuzzyMatch"
import { useRefPrevious } from "../../hooks/useRefPrevious"
import { isShortcut } from "../../hooks/useShortcut"

import { Button } from "./Button"
import { FuzzyString } from "./FuzzyString"
import { Input } from "./Input"
import { MenuItem } from "./MenuItem"
import { Popup, PopupFrame } from "./Popup"

interface ComboBoxProps<T> {
	items: T[];
	renderItem: (item: T) => React.ReactNode;
	onSelect: (item: T) => void;
	value?: T;
	placeholder?: string;
	onChange?: (value: T) => void;
}

export function ComboBox<T>({ items, renderItem, onSelect, value, placeholder, onChange }: ComboBoxProps<T>) {
	const [open, setOpen] = useState(false)
	const [search, setSearch] = useState("")
	const buttonRef = useRef<HTMLButtonElement>(null)
	const [hoveredIndex, setHoveredIndex] = useState<number | null>(null)

	const filteredItems = items.filter((item) => {
		const renderedItem = renderItem(item);
		if (typeof renderedItem === 'string') {
			return renderedItem.toLowerCase().includes(search.toLowerCase());
		}
		return true; // Skip filtering for non-string items
	});

	useEffect(() => {
		const handleClickOutside = (event: MouseEvent) => {
			if (buttonRef.current && !buttonRef.current.contains(event.target as Node)) {
				setOpen(false)
			}
		}

		document.addEventListener("mousedown", handleClickOutside)
		return () => {
			document.removeEventListener("mousedown", handleClickOutside)
		}
	}, [])

	const handleSelect = (item: T) => {
		onSelect(item);
		onChange?.(item);
		setOpen(false);
		setSearch("");
	};

	return (
		<div>
			<Button ref={buttonRef} onClick={() => setOpen(!open)}>
				{value ? renderItem(value) : placeholder || "Select..."}
			</Button>
			{open && buttonRef.current && (
				<Popup open={open} anchor={buttonRef.current} onDismiss={() => setOpen(false)}>
					<div style={{ padding: "0.5rem", backgroundColor: "white", borderRadius: "0.25rem", boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)" }}>
						<div style={{ marginBottom: "0.5rem" }}>
							<Input
								value={search}
								onChange={(e: React.ChangeEvent<HTMLInputElement>) => setSearch(e.target.value)}
								placeholder="Search..."
							/>
						</div>
						<div style={{ maxHeight: "200px", overflowY: "auto" }}>
							{filteredItems.map((item, index) => (
								<div
									key={index}
									onClick={() => handleSelect(item)}
									onMouseEnter={() => setHoveredIndex(index)}
									onMouseLeave={() => setHoveredIndex(null)}
									style={{
										padding: "0.5rem",
										cursor: "pointer",
										backgroundColor: value === item || hoveredIndex === index ? "#e2e8f0" : "transparent",
										transition: "background-color 0.2s ease",
									}}
								>
									{renderItem(item)}
								</div>
							))}
						</div>
					</div>
				</Popup>
			)}
		</div>
	)
}

export function ComboBoxSelect(props: {
	items: string[]
	placeholder: string
	value: string | undefined
	onChange: (value: string) => void
}) {
	const [open, setOpen] = React.useState(false)
	const buttonRef = useRef<HTMLButtonElement>(null)
	const prevOpen = useRefPrevious(open)

	useLayoutEffect(() => {
		if (prevOpen.current && !open) {
			buttonRef.current?.focus()
		}
	}, [prevOpen, open])

	if (open) {
		return (
			<ComboBoxSearch
				autoFocus
				items={props.items}
				value={props.value}
				onChange={(newValue: string) => {
					props.onChange(newValue)
					setOpen(false)
				}}
				onDismiss={() => {
					setOpen(false)
				}}
			/>
		)
	}

	return (
		<Button ref={buttonRef} onClick={() => setOpen(true)} style={{ textAlign: "left" }}>
			{props.value || <span style={{ color: "var(--text-color2" }}>{props.placeholder} </span>}{" "}
			<span style={{ fontSize: "0.7rem", verticalAlign: "middle" }}>▼</span>
		</Button>
	)
}

export function ComboBoxSearch(props: {
	items: string[]
	value: string | undefined
	onChange: (value: string) => void
	onDismiss?: () => void
	autoFocus?: boolean
	notice?: React.ReactNode
}) {
	const inputRef = useRef<HTMLInputElement>(null)
	const [focused, setFocused] = useState(false)

	useEffect(() => {
		if (props.autoFocus) inputRef.current?.focus()
	}, [props.autoFocus])

	const [text, setText] = useState("")

	const filteredItems = useMemo(() => {
		return props.items
			.map((str) => ({ value: str, match: fuzzyMatch(text, str) || undefined }))
			.filter(({ match }) => Boolean(match))
	}, [text, props.items])

	const [selectedIndex, setSelectedIndex] = useState(0)

	const handleKeydown = (event: React.KeyboardEvent) => {
		if (isShortcut("down", event.nativeEvent)) {
			event.preventDefault()
			setSelectedIndex((i) => {
				if (i >= filteredItems.length - 1) return filteredItems.length - 1
				else return i + 1
			})
			return
		}
		if (isShortcut("up", event.nativeEvent)) {
			event.preventDefault()
			setSelectedIndex((i) => {
				if (i === 0) return i
				else return i - 1
			})
			return
		}
		if (isShortcut("enter", event.nativeEvent)) {
			event.preventDefault()
			if (filteredItems[selectedIndex]) {
				props.onChange(filteredItems[selectedIndex].value)
			}
			return
		}
		if (isShortcut("escape", event.nativeEvent)) {
			event.preventDefault()
			props.onDismiss?.()
			return
		}
	}

	// TODO: filter selected on key change to maintain selectedIndex position?
	return (
		<>
			<Input
				ref={inputRef}
				onFocus={() => setFocused(true)}
				onBlur={() => {
					setFocused(false)
					props.onDismiss?.()
				}}
				value={text}
				onChange={(e) => {
					setText(e.target.value)
					setSelectedIndex(0)
				}}
				onKeyDown={handleKeydown}
			/>

			<Popup
				open={focused && filteredItems.length > 0}
				anchor={inputRef.current}
				onDismiss={props.onDismiss}
			>
				<PopupFrame>
					{props.notice}
					{filteredItems.map((item, i) => (
						<MenuItem
							key={item.value}
							selected={selectedIndex === i}
							onClick={() => props.onChange(item.value)}
							onMouseDown={(e) => e.preventDefault()}
							onMouseEnter={() => setSelectedIndex(i)}
						>
							<FuzzyString match={item.match} />
						</MenuItem>
					))}
				</PopupFrame>
			</Popup>
		</>
	)
}

================================================================================
File: components\ui\DropdownMenu.tsx
Lines: 101
--------------------------------------------------------------------------------
import React, { CSSProperties } from 'react';

import { usePopper } from '../../hooks/usePopper';

interface DropdownMenuProps {
	style?: CSSProperties;
	items: Array<{
		label: string;
		onClick: () => void;
	}>;
	onClose: () => void;
}

export function DropdownMenu({ style, items, onClose }: DropdownMenuProps) {
	const [referenceElement, _setReferenceElement] = React.useState<HTMLElement | null>(null);
	const [popperElement, setPopperElement] = React.useState<HTMLElement | null>(null);
	const [selectedIndex, setSelectedIndex] = React.useState(0);
	const [hoveredIndex, setHoveredIndex] = React.useState<number | null>(null);

	const popperInstance = usePopper(referenceElement, popperElement, {
		placement: 'bottom-start',
		modifiers: [
			{
				name: 'offset',
				options: {
					offset: [0, 4],
				},
			},
		],
	}) as unknown as { styles: { popper: CSSProperties }; attributes: { popper: Record<string, string> } };

	// Default empty styles and attributes if they don't exist
	const styles = popperInstance.styles || {};
	const attributes = popperInstance.attributes || {};

	React.useEffect(() => {
		const handleClickOutside = (event: MouseEvent) => {
			if (
				popperElement &&
				!popperElement.contains(event.target as Node) &&
				referenceElement &&
				!referenceElement.contains(event.target as Node)
			) {
				onClose();
			}
		};

		document.addEventListener('mousedown', handleClickOutside);
		return () => {
			document.removeEventListener('mousedown', handleClickOutside);
		};
	}, [popperElement, referenceElement, onClose]);

	const handleKeyDown = (event: React.KeyboardEvent) => {
		switch (event.key) {
			case 'ArrowDown':
				event.preventDefault();
				setSelectedIndex((i) => (i + 1) % items.length);
				break;
			case 'ArrowUp':
				event.preventDefault();
				setSelectedIndex((i) => (i - 1 + items.length) % items.length);
				break;
			case 'Enter':
				event.preventDefault();
				items[selectedIndex].onClick();
				onClose();
				break;
			case 'Escape':
				event.preventDefault();
				onClose();
				break;
		}
	};

	return (
		<div style={style} onKeyDown={handleKeyDown}>
			<div ref={setPopperElement} style={styles.popper} {...attributes.popper}>
				{items.map((item, i) => (
					<div
						key={i}
						onClick={() => {
							item.onClick();
							onClose();
						}}
						onMouseEnter={() => setHoveredIndex(i)}
						onMouseLeave={() => setHoveredIndex(null)}
						style={{
							padding: '0.5rem 1rem',
							cursor: 'pointer',
							backgroundColor: i === selectedIndex || i === hoveredIndex ? '#e2e8f0' : 'transparent',
							transition: 'background-color 0.2s ease',
						}}
					>
						{item.label}
					</div>
				))}
			</div>
		</div>
	);
}

================================================================================
File: components\ui\FileUpload.tsx
Lines: 311
--------------------------------------------------------------------------------
import React, { ComponentPropsWithoutRef, DragEvent, ChangeEvent, useState, useRef } from 'react';

import { DeferredPromise } from "../../../shared/DeferredPromise"
import { randomId } from "../../../shared/randomId"
import { passthroughRef } from "../../helpers/passthroughRef"

interface Upload {
	id: string
	file: File
	promise: DeferredPromise<void>
	uploaded?: boolean
}

interface FileUploadProps extends ComponentPropsWithoutRef<'div'> {
	onFileSelect: (file: File) => void;
	accept?: string;
	multiple?: boolean;
}

export function FileUpload({
	onFileSelect,
	accept,
	multiple,
	...props
}: FileUploadProps) {
	const [isDragging, setIsDragging] = useState(false)
	const fileInputRef = useRef<HTMLInputElement>(null)

	const handleDragOver = (event: DragEvent<HTMLDivElement>) => {
		event.preventDefault();
		setIsDragging(true);
	};

	const handleDragLeave = (event: DragEvent<HTMLDivElement>) => {
		event.preventDefault();
		setIsDragging(false);
	};

	const handleDrop = (event: DragEvent<HTMLDivElement>) => {
		event.preventDefault();
		setIsDragging(false);

		const files = Array.from(event.dataTransfer.files);
		if (files.length > 0) {
			onFileSelect(files[0]);
		}
	};

	const handleClick = () => {
		fileInputRef.current?.click();
	};

	const handleFileChange = (event: ChangeEvent<HTMLInputElement>) => {
		const files = event.target.files;
		if (files && files.length > 0) {
			onFileSelect(files[0]);
		}
	};

	return (
		<div
			onDragOver={handleDragOver}
			onDragLeave={handleDragLeave}
			onDrop={handleDrop}
			onClick={handleClick}
			style={{
				border: `2px dashed ${isDragging ? '#3b82f6' : '#e2e8f0'}`,
				borderRadius: '0.5rem',
				padding: '2rem',
				textAlign: 'center',
				cursor: 'pointer',
				backgroundColor: isDragging ? 'rgba(59, 130, 246, 0.1)' : 'transparent',
				transition: 'all 0.2s ease',
				...props.style,
			}}
			{...props}
		>
			<input
				ref={fileInputRef}
				type="file"
				accept={accept}
				multiple={multiple}
				onChange={handleFileChange}
				style={{ display: 'none' }}
			/>
			{isDragging ? 'Drop files here' : 'Click or drag files here to upload'}
		</div>
	);
}

export default FileUpload;

export function useFileUpload(
	onUpload: (
		file: File,
		onProgress: (progress: number) => void
	) => Promise<void>
) {
	const [uploads, setUploads] = useState<Upload[]>([]);

	const handleDrop = async (event: DragEvent<HTMLDivElement>) => {
		event.preventDefault();
		const files = Array.from(event.dataTransfer.files);
		for (const file of files) {
			const upload: Upload = {
				id: randomId(),
				file,
				promise: new DeferredPromise(),
			};
			setUploads((uploads) => [...uploads, upload]);
			try {
				await onUpload(file, (_progress) => {
					// Update progress
				});
				upload.uploaded = true;
				upload.promise.resolve();
			} catch (error) {
				upload.promise.reject(error);
			}
		}
	};

	return {
		uploads,
		handleDrop,
	};
}

interface UploadPreviewProps extends Upload {}

export function UploadPreview({ file, uploaded }: UploadPreviewProps) {
	const [preview, setPreview] = useState<string | null>(null);

	React.useEffect(() => {
		const reader = new FileReader();
		reader.onloadend = () => {
			setPreview(reader.result as string);
		};
		reader.readAsDataURL(file);
	}, [file]);

	return (
		<div
			style={{
				display: 'flex',
				alignItems: 'center',
				gap: '1rem',
				padding: '0.5rem',
				borderRadius: '0.25rem',
				backgroundColor: '#f8fafc',
			}}
		>
			{preview && (
				<img
					src={preview}
					alt={file.name}
					style={{
						width: '2rem',
						height: '2rem',
						objectFit: 'cover',
						borderRadius: '0.25rem',
					}}
				/>
			)}
			<div style={{ flex: 1 }}>{file.name}</div>
			<div>{uploaded ? "✅" : "❌"}</div>
		</div>
	);
}

export const FileUploadDropZone = passthroughRef(
	(
		props: ComponentPropsWithoutRef<"div"> & {
			selected?: boolean
		}
	) => {
		const [isDragging, setIsDragging] = useState(false)

		const handleDragEnter = (e: React.DragEvent<HTMLDivElement>) => {
			e.preventDefault()
			setIsDragging(true)
		}

		const handleDragExit = (e: React.DragEvent<HTMLDivElement>) => {
			e.preventDefault()
			setIsDragging(false)
		}

		const handleDragOver = (e: React.DragEvent<HTMLDivElement>) => {
			e.preventDefault()
		}

		const handleDrop = (e: React.DragEvent<HTMLDivElement>) => {
			setIsDragging(false)
			props.onDrop?.(e)
		}

		return (
			<div
				{...props}
				onDragEnter={handleDragEnter}
				onDragExit={handleDragExit}
				onDragOver={handleDragOver}
				onDrop={handleDrop}
				style={{
					border: isDragging ? "3px dashed var(--blue)" : "3px solid transparent",
					...props.style,
				}}
			/>
		)
	}
)

export async function uploadFile(file: File, url: string, onProgress: (progress: number) => void) {
	const xhr = new XMLHttpRequest()
	xhr.open("PUT", url, true)

	// Update progress
	xhr.upload.addEventListener("progress", (event) => {
		if (!event.lengthComputable) return
		const progress = Math.round((event.loaded / event.total) * 100)
		onProgress(progress)
	})

	const deferred = new DeferredPromise<void>()

	// Handle errors
	xhr.onerror = (error) => {
		deferred.reject(error)
	}

	xhr.onreadystatechange = () => {
		if (xhr.readyState === XMLHttpRequest.DONE) {
			if (xhr.status === 200) {
				deferred.resolve()
			} else {
				const error = new Error(`UploadError: ${xhr.status} ${xhr.statusText}`)
				deferred.reject(error)
			}
		}
	}

	xhr.send(file)

	return deferred.promise
}

const MB = 1024 * 1024

export async function _renderPreview(file: File) {
	const deferred = new DeferredPromise<string | undefined>()

	if (file.type.startsWith("image/") && file.size <= 10 * MB) {
		const reader = new FileReader()
		reader.onload = (e) => {
			const preview = e.target?.result as string
			deferred.resolve(preview)
		}
		reader.readAsDataURL(file)
	} else {
		deferred.resolve(undefined)
	}

	return deferred.promise
}

export function FileUploadArea(
	props: ComponentPropsWithoutRef<"div"> & {
		onFileSelect: (files: FileList) => void
		accept?: string
		multiple?: boolean
	}
): React.ReactElement {
	const fileInputRef = useRef<HTMLInputElement>(null);

	const handleClick = () => {
		fileInputRef.current?.click();
	};

	const handleFileChange = (event: ChangeEvent<HTMLInputElement>) => {
		const files = event.target.files;
		if (files) {
			props.onFileSelect(files);
		}
	};

	return (
		<div
			onClick={handleClick}
			style={{
				border: "2px dashed var(--border-color)",
				borderRadius: "0.5rem",
				padding: "2rem",
				textAlign: "center",
				cursor: "pointer",
				...props.style,
			}}
			{...props}
		>
			<input
				ref={fileInputRef}
				type="file"
				accept={props.accept}
				multiple={props.multiple}
				onChange={handleFileChange}
				style={{ display: "none" }}
			/>
			Click to select files
		</div>
	);
}

================================================================================
File: components\ui\FuzzyString.tsx
Lines: 28
--------------------------------------------------------------------------------
import { FuzzyMatch } from "../../../shared/fuzzyMatch"

interface FuzzyStringProps {
	match?: FuzzyMatch;
	text?: string;
}

export function FuzzyString({ match, text }: FuzzyStringProps) {
	if (!match) {
		return <span>{text}</span>;
	}

	return (
		<span>
			{match.map((item, i) => (
				<span
					key={i}
					style={{
						fontWeight: item.matched ? 'bold' : 'normal',
						color: item.matched ? '#3b82f6' : 'inherit',
					}}
				>
					{item.text}
				</span>
			))}
		</span>
	);
}

================================================================================
File: components\ui\Input.tsx
Lines: 25
--------------------------------------------------------------------------------
import { forwardRef, ComponentPropsWithoutRef } from 'react';

interface InputProps extends ComponentPropsWithoutRef<'input'> {}

export const Input = forwardRef<HTMLInputElement, InputProps>((props, ref) => {
	return (
		<input
			ref={ref}
			{...props}
			style={{
				padding: '0.5rem',
				border: '1px solid #e2e8f0',
				borderRadius: '0.25rem',
				outline: 'none',
				width: '100%',
				...props.style,
			}}
		/>
	);
});

Input.displayName = 'Input';

// Also export as default for backward compatibility
export default Input;

================================================================================
File: components\ui\Link.tsx
Lines: 88
--------------------------------------------------------------------------------
import React from 'react';

import { useClientEnvironment } from '../../services/ClientEnvironment';
import { useRoute, Route } from '../../services/Router';

interface LinkProps extends React.AnchorHTMLAttributes<HTMLAnchorElement> {
  to: string;
  activeStyle?: React.CSSProperties;
  activeClass?: string;
}

export function Link({ to, activeStyle, activeClass, style, className, onClick, ...props }: LinkProps) {
  const environment = useClientEnvironment();
  const route = useRoute();
  
  // Determine if this link is active based on the current route
  const isActive = isLinkActive(route, to);
  
  const handleClick = (event: React.MouseEvent<HTMLAnchorElement>) => {
    event.preventDefault();
    if (onClick) {
      onClick(event);
    }
    environment.router.navigate(to);
  };

  return (
    <a 
      {...props} 
      href={to} 
      onClick={handleClick}
      style={{
        ...style,
        ...(isActive ? activeStyle : {})
      }}
      className={`${className || ''} ${isActive ? activeClass || '' : ''}`}
    />
  );
}

// Helper function to determine if a link is active based on the current route
function isLinkActive(route: Route, to: string): boolean {
  if (to === '/' && route.type === 'root') {
    return true;
  }
  
  if (to === '/home' && route.type === 'home') {
    return true;
  }
  
  if (to === '/media' && route.type === 'media') {
    return true;
  }
  
  if (to === '/social' && route.type === 'social') {
    return true;
  }
  
  if (to === '/settings' && route.type === 'settings') {
    return true;
  }
  
  if (to === '/dashboard' && route.type === 'dashboard') {
    return true;
  }
  
  if (to === '/profile' && route.type === 'profile') {
    return true;
  }
  
  if (to === '/upload' && route.type === 'upload') {
    return true;
  }
  
  if (to === '/explore' && route.type === 'explore') {
    return true;
  }
  
  if (to === '/notifications' && route.type === 'notifications') {
    return true;
  }
  
  if (to.startsWith('/design/') && route.type === 'design') {
    return to.slice('/design/'.length) === route.page;
  }
  
  return false;
} 
================================================================================
File: components\ui\ListBox.tsx
Lines: 79
--------------------------------------------------------------------------------
import React, { ComponentPropsWithoutRef } from 'react';

interface ListBoxProps<T> {
	items: T[];
	selectedIndex: number;
	onSelectIndex: (index: number) => void;
	children: (item: T, props: ListItemProps) => React.ReactNode;
	autoFocus?: boolean;
}

interface ListItemProps extends ComponentPropsWithoutRef<'div'> {
	selected?: boolean;
}

export function ListBox<T>({
	items,
	selectedIndex,
	onSelectIndex,
	children,
	autoFocus,
}: ListBoxProps<T>) {
	const containerRef = React.useRef<HTMLDivElement>(null);

	React.useEffect(() => {
		if (autoFocus) {
			containerRef.current?.focus();
		}
	}, [autoFocus]);

	const handleKeyDown = (event: React.KeyboardEvent) => {
		switch (event.key) {
			case 'ArrowDown':
				event.preventDefault();
				onSelectIndex((selectedIndex + 1) % items.length);
				break;
			case 'ArrowUp':
				event.preventDefault();
				onSelectIndex((selectedIndex - 1 + items.length) % items.length);
				break;
			case 'Enter':
				event.preventDefault();
				// Handle selection
				break;
		}
	};

	return (
		<div
			ref={containerRef}
			tabIndex={0}
			onKeyDown={handleKeyDown}
			style={{
				outline: 'none',
			}}
		>
			{items.map((item, index) =>
				children(item, {
					key: index,
					onClick: () => onSelectIndex(index),
					selected: index === selectedIndex,
				})
			)}
		</div>
	);
}

export function ListItem({ selected, style, ...props }: ListItemProps) {
	return (
		<div
			{...props}
			style={{
				cursor: 'pointer',
				backgroundColor: selected ? '#e2e8f0' : 'transparent',
				transition: 'background-color 0.2s ease',
				...style,
			}}
		/>
	);
}

================================================================================
File: components\ui\MenuItem.tsx
Lines: 31
--------------------------------------------------------------------------------
import React, { ComponentPropsWithoutRef } from 'react';

interface MenuItemProps extends ComponentPropsWithoutRef<'div'> {
	selected?: boolean;
	onSubmit?: () => void;
}

export function MenuItem({ selected, onSubmit, style, ...props }: MenuItemProps) {
	const handleKeyDown = (event: React.KeyboardEvent) => {
		if (event.key === 'Enter' && onSubmit) {
			event.preventDefault();
			onSubmit();
		}
	};

	return (
		<div
			role="menuitem"
			tabIndex={0}
			onKeyDown={handleKeyDown}
			style={{
				padding: '0.5rem 1rem',
				cursor: 'pointer',
				backgroundColor: selected ? '#e2e8f0' : 'transparent',
				transition: 'background-color 0.2s ease',
				...style,
			}}
			{...props}
		/>
	);
}

================================================================================
File: components\ui\OfflineBadge.tsx
Lines: 12
--------------------------------------------------------------------------------
import { useOnline } from "../../hooks/useOnline"

import { Badge } from "./Badge"

export function OfflineBadge() {
	const online = useOnline()
	return (
		<Badge style={{ backgroundColor: online ? undefined : "var(--orange)" }}>
			{online ? "Online" : <strong>Offline</strong>}
		</Badge>
	)
}

================================================================================
File: components\ui\Popup.tsx
Lines: 93
--------------------------------------------------------------------------------
import React, { useLayoutEffect, useMemo } from "react"
import { createPortal } from "react-dom"

import { passthroughRef } from "../../helpers/passthroughRef"
import { Placement, createPopper } from "../../hooks/usePopper"
import { useShortcut } from "../../hooks/useShortcut"

export function Popup(props: {
	open: boolean
	anchor: HTMLElement | undefined | null
	placement?: Placement
	children?: React.ReactNode
	onDismiss?: () => void
}) {
	// Create the overlay div.
	const container = useMemo(() => {
		const div = document.createElement("div")
		document.body.appendChild(div)
		return div
	}, [])

	useMemo(() => {
		container.style.visibility = props.open ? "visible" : "hidden"
	}, [container.style, props.open])

	// Cleanup
	useLayoutEffect(() => {
		return () => {
			document.body.removeChild(container)
		}
	}, [container])

	// Render the popup
	useLayoutEffect(() => {
		if (!props.anchor) return
		if (!props.open) return

		const popupDiv = (
			props.onDismiss ? container.children[1] : container.children[0]
		) as HTMLElement

		const popper = createPopper(props.anchor, popupDiv, {
			placement: props.placement || "bottom-start",
			modifiers: [
				{
					name: "offset",
					options: {
						offset: [0, 8],
					},
				},
			],
		})
		return () => {
			popper.destroy()
		}
	}, [container.children, props.onDismiss, props.placement, props.anchor, props.open])

	const { onDismiss } = props

	useShortcut("escape", () => onDismiss?.())

	// Render the portal
	if (!props.open) return false
	else
		return createPortal(
			<>
				{onDismiss && (
					<div
						style={{ position: "fixed", top: 0, left: 0, right: 0, bottom: 0 }}
						onClick={() => onDismiss()}
					/>
				)}
				{props.children}
			</>,
			container
		)
}

export const PopupFrame = passthroughRef((props: React.HTMLProps<HTMLDivElement>) => {
	return (
		<div
			{...props}
			className="popup"
			style={{
				background: "var(--popup-background)",
				boxShadow: "var(--shadow)",
				padding: 4,
				borderRadius: 4,
				...props.style,
			}}
		/>
	)
})

================================================================================
File: components\ui\Spinner.tsx
Lines: 4
--------------------------------------------------------------------------------
/** Consider using <Loading/> instead. */
export function Spinner(props: { size?: string }) {
	return <span style={{ height: props.size, width: props.size }} className="spinner"></span>
}

================================================================================
File: components\ui\Throttle.tsx
Lines: 52
--------------------------------------------------------------------------------
import React, { useEffect, useRef, useState } from "react"

// TODO: I don't think this thing works very well.

/**
 * Don't show the spinner unless we have a very slow request.
 * If we show the spinner, hold it for a moment.
 * Hold previous children while we wait for the spinner.
 */
export function Throttle(props: {
	showSpinner: boolean
	showDelay?: number
	showHold?: number
	spinner: React.ReactNode
	children: React.ReactNode
}) {
	const showDelay = typeof props.showDelay === "number" ? props.showDelay : 300
	const showHold = typeof props.showHold === "number" ? props.showHold : 300

	const [showSpinner, setShowSpinner] = useState(false)

	useEffect(() => {
		let canceled = false

		if (props.showSpinner && !showSpinner) {
			setTimeout(() => {
				if (canceled) return
				setShowSpinner(true)
			}, showDelay)
		}

		if (!props.showSpinner && showSpinner) {
			setTimeout(() => {
				if (canceled) return
				setShowSpinner(false)
			}, showHold)
		}

		return () => {
			canceled = true
		}
	}, [showDelay, showHold, showSpinner, props.showSpinner])

	const prevChildrenRef = useRef(props.children)
	const prevChildren = prevChildrenRef.current
	prevChildrenRef.current = props.children

	// If we're blocking the spinner, show previous children.
	if (props.showSpinner && !showSpinner) return prevChildren
	if (showSpinner) return props.spinner
	return props.children
}

================================================================================
File: components\ui\demos\autoindex.ts
Lines: 29
--------------------------------------------------------------------------------
/* WARNING: this file is generated! */

import * as BadgeDemo from "./BadgeDemo"
import * as ButtonDemo from "./ButtonDemo"
import * as CalendarDemo from "./CalendarDemo"
import * as ComboBoxDemo from "./ComboBoxDemo"
import * as DropdownDemo from "./DropdownDemo"
import * as FileUploadDemo from "./FileUploadDemo"
import * as FormDemo from "./FormDemo"
import * as FuzzyStringDemo from "./FuzzyStringDemo"
import * as ListBoxDemo from "./ListBoxDemo"
import * as PopupDemo from "./PopupDemo"
import * as SpinnerDemo from "./SpinnerDemo"
import * as TokenInputDemo from "./TokenInputDemo"

export {
	BadgeDemo,
	ButtonDemo,
	CalendarDemo,
	ComboBoxDemo,
	DropdownDemo,
	FileUploadDemo,
	FormDemo,
	FuzzyStringDemo,
	ListBoxDemo,
	PopupDemo,
	SpinnerDemo,
	TokenInputDemo,
}

================================================================================
File: components\ui\demos\BadgeDemo.tsx
Lines: 11
--------------------------------------------------------------------------------
import { Badge } from "../Badge"

export function BadgeDemo() {
	return (
		<div style={{ display: "flex", gap: 4, padding: 12 }}>
			<Badge>Hello</Badge>
			<Badge style={{ background: "LightCoral", color: "white" }}>World</Badge>
			<Badge style={{ background: "PowderBlue" }}>Yay!</Badge>
		</div>
	)
}

================================================================================
File: components\ui\demos\ButtonDemo.tsx
Lines: 17
--------------------------------------------------------------------------------
import { Button } from "../Button"

export function ButtonDemo() {
	return (
		<div>
			<div style={{ marginBottom: 8 }}>
				<Button>Default Button</Button>
			</div>
			<div style={{ marginBottom: 8 }}>
				<Button variant="primary">Primary Button</Button>
			</div>
			<div style={{ marginBottom: 8 }}>
				<Button variant="text">Naked Button</Button>
			</div>
		</div>
	)
}

================================================================================
File: components\ui\demos\CalendarDemo.tsx
Lines: 26
--------------------------------------------------------------------------------
import { useMemo, useState } from "react"

// TODO: this is very much a work in progress!
export function CalendarDemo() {
	const initialDatetime = useMemo(() => {
		const tomorrow = new Date()
		tomorrow.setDate(tomorrow.getDate() + 1)
		tomorrow.setHours(9, 0, 0, 0)

		const tzOffset = tomorrow.getTimezoneOffset() * 60000
		const localISOTime = new Date(tomorrow.getTime() - tzOffset)
		return localISOTime.toISOString().slice(0, "YYYY-MM-DDTHH:MM".length)
	}, [])

	const [datetime, setDatetime] = useState(initialDatetime)

	return (
		<div>
			<input
				type="datetime-local"
				value={datetime}
				onChange={(event) => setDatetime(event.target.value)}
			/>
		</div>
	)
}

================================================================================
File: components\ui\demos\ComboBoxDemo.tsx
Lines: 44
--------------------------------------------------------------------------------
import { useState } from "react"

import { ComboBox } from "../ComboBox"

const items = [
	"Apple",
	"Banana",
	"Cherry",
	"Date",
	"Elderberry",
	"Fig",
	"Grape",
	"Honeydew",
	"Kiwi",
	"Lemon",
	"Mango",
	"Orange",
	"Papaya",
	"Quince",
	"Raspberry",
	"Strawberry",
	"Tangerine",
	"Ugli fruit",
	"Watermelon",
]

export function ComboBoxDemo() {
	const [value, setValue] = useState<string>()

	return (
		<div>
			<div style={{ marginBottom: 8 }}>
				<ComboBox
					items={items}
					renderItem={(item) => item}
					onSelect={setValue}
					value={value}
					placeholder="Select a fruit..."
				/>
			</div>
			<div>Selected value: {value || "None"}</div>
		</div>
	)
}

================================================================================
File: components\ui\demos\DropdownDemo.tsx
Lines: 27
--------------------------------------------------------------------------------
import React, { useState } from "react"

import { Button } from "../Button"
import { DropdownMenu } from "../DropdownMenu"

export function DropdownDemo() {
	const [open, setOpen] = useState(false)
	const buttonRef = React.useRef<HTMLButtonElement>(null)

	return (
		<div>
			<Button ref={buttonRef} onClick={() => setOpen(true)}>
				Open Dropdown
			</Button>
			{open && (
				<DropdownMenu
					onClose={() => setOpen(false)}
					items={[
						{ label: "Item 1", onClick: () => console.log("Item 1") },
						{ label: "Item 2", onClick: () => console.log("Item 2") },
						{ label: "Item 3", onClick: () => console.log("Item 3") },
					]}
				/>
			)}
		</div>
	)
}

================================================================================
File: components\ui\demos\FileUploadDemo.tsx
Lines: 23
--------------------------------------------------------------------------------
import { sleep } from "../../../../shared/sleep"
import { FileUploadDropZone, UploadPreview, useFileUpload } from "../FileUpload"

export function FileUploadDemo() {
	const { uploads, handleDrop } = useFileUpload(async (_upload, onProgress) => {
		for (let i = 0; i < 100; i += Math.round(Math.random() * 10)) {
			await sleep(100)
			onProgress(i)
		}
	})

	return (
		<FileUploadDropZone
			onDrop={(files) => void handleDrop(files)}
			style={{ display: "inline-flex", flexWrap: "wrap", gap: 12, padding: 12 }}
		>
			{uploads.length === 0 && "Drop files here!"}
			{uploads.map((upload) => (
				<UploadPreview key={upload.id} {...upload} />
			))}
		</FileUploadDropZone>
	)
}

================================================================================
File: components\ui\demos\FormDemo.tsx
Lines: 64
--------------------------------------------------------------------------------
import React, { useState } from "react"

import { ComboBox } from "../ComboBox"
import { Input } from "../Input"

const colors = [
	"Red",
	"Orange",
	"Yellow",
	"Green",
	"Blue",
	"Indigo",
	"Violet",
];

// TODO: this is very much a work in progress!
export function FormDemo() {
	const [name, setName] = useState("")
	const [email, setEmail] = useState("")
	const [color, setColor] = useState<string>()

	return (
		<div>
			<div style={{ marginBottom: 8 }}>
				<label>
					Name:
					<Input
						value={name}
						onChange={(e: React.ChangeEvent<HTMLInputElement>) => setName(e.target.value)}
						placeholder="Enter your name"
					/>
				</label>
			</div>
			<div style={{ marginBottom: 8 }}>
				<label>
					Email:
					<Input
						type="email"
						value={email}
						onChange={(e: React.ChangeEvent<HTMLInputElement>) => setEmail(e.target.value)}
						placeholder="Enter your email"
					/>
				</label>
			</div>
			<div style={{ marginBottom: 8 }}>
				<label>
					Favorite Color:
					<ComboBox
						items={colors}
						renderItem={(item) => item}
						onSelect={setColor}
						value={color}
						placeholder="Select a color..."
					/>
				</label>
			</div>
			<div>
				<div>Name: {name || "Not set"}</div>
				<div>Email: {email || "Not set"}</div>
				<div>Favorite Color: {color || "Not set"}</div>
			</div>
		</div>
	)
}

================================================================================
File: components\ui\demos\FuzzyStringDemo.tsx
Lines: 39
--------------------------------------------------------------------------------
import React, { useState } from "react"

import { fuzzyMatch } from "../../../../shared/fuzzyMatch"
import { FuzzyString } from "../FuzzyString"
import { Input } from "../Input"

const sampleTexts = [
	"hello world",
	"The quick brown fox jumps over the lazy dog",
	"Lorem ipsum dolor sit amet",
	"React is awesome",
	"TypeScript makes JavaScript better",
]

export function FuzzyStringDemo() {
	const [value, setValue] = useState("")

	return (
		<div>
			<div style={{ marginBottom: 8 }}>
				<Input
					value={value}
					onChange={(e: React.ChangeEvent<HTMLInputElement>) => setValue(e.target.value)}
					placeholder="Type to search..."
				/>
			</div>
			<div style={{ display: 'flex', flexDirection: 'column', gap: '0.5rem' }}>
				{sampleTexts.map((text, i) => {
					const match = fuzzyMatch(value, text);
					return (
						<div key={i}>
							<FuzzyString match={match || undefined} text={text} />
						</div>
					);
				})}
			</div>
		</div>
	)
}

================================================================================
File: components\ui\demos\ListBoxDemo.tsx
Lines: 35
--------------------------------------------------------------------------------
import { useState } from "react"

import { ListBox, ListItem } from "../ListBox"

const items = [
	"Item 1",
	"Item 2",
	"Item 3",
	"Item 4",
	"Item 5",
];

export function ListBoxDemo() {
	const [selectedIndex, setSelectedIndex] = useState(0)

	return (
		<div>
			<ListBox
				items={items}
				selectedIndex={selectedIndex}
				onSelectIndex={setSelectedIndex}
				autoFocus
			>
				{(item, props) => (
					<ListItem {...props}>
						{item}
					</ListItem>
				)}
			</ListBox>
			<div style={{ marginTop: 8 }}>
				Selected: {items[selectedIndex]}
			</div>
		</div>
	)
}

================================================================================
File: components\ui\demos\PopupDemo.tsx
Lines: 22
--------------------------------------------------------------------------------
import React, { useState } from "react"

import { Button } from "../Button"
import { Popup } from "../Popup"

export function PopupDemo() {
	const [open, setOpen] = useState(false)
	const buttonRef = React.useRef<HTMLButtonElement>(null)

	return (
		<div>
			<Button ref={buttonRef} onClick={() => setOpen(true)}>
				Open Popup
			</Button>
			<Popup open={open} anchor={buttonRef.current} onDismiss={() => setOpen(false)}>
				<div style={{ padding: '1rem', backgroundColor: 'white', borderRadius: '0.25rem', boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)' }}>
					This is a popup!
				</div>
			</Popup>
		</div>
	)
}

================================================================================
File: components\ui\demos\SpinnerDemo.tsx
Lines: 10
--------------------------------------------------------------------------------
import { Spinner } from "../Spinner"

// TODO: Throttle component
export function SpinnerDemo() {
	return (
		<div style={{ display: "flex", gap: 4, padding: 12 }}>
			<Spinner />
		</div>
	)
}

================================================================================
File: components\ui\demos\TokenInputDemo.tsx
Lines: 54
--------------------------------------------------------------------------------
export function TokenInputDemo() {
	return <div>Work in progress</div>
}

// function TokenInput<T, V>(props: {
// 	tokens: T[]
// 	children: [
// 		(token: T, props: { selected: boolean }) => void,
// 		(value: V, props: { selected: boolean }) => void
// 	]

// 	text: string
// 	setText: (text: string) => void

// 	result:
// 		| { loading: true }
// 		| { loading: false; error: string }
// 		| { loading: false; error?: undefined; result: V[] }
// }) {
// 	return (
// 		<div>
// 			<ListBox items={[...props.tokens, "INPUT"]} selectedIndex={props.tokens.length} ></ListBox>

// 			{props.tokens.map((token) => props.children[0](token))}
// 			<span>
// 				<Input
// 					ref={inputRef}
// 					type="text"
// 					value={text}
// 					onChange={(e) => setText(e.target.value)}
// 					onFocus={() => setFocused(true)}
// 					onBlur={() => setFocused(false)}
// 				/>
// 				<Popup open={focused && text.length > 0} anchor={inputRef.current}>
// 					{error ? (
// 						<span style={{ color: "var(--red)" }}>{error}</span>
// 					) : !userIds ? (
// 						<Spinner />
// 					) : userIds.length === 0 ? (
// 						"No results..."
// 					) : (
// 						<ListBox items={userIds}>
// 							{(userId, { focused, selected }) => (
// 								<ListItem focused={focused} selected={selected}>
// 									<Username userId={userId} key={userId} />
// 								</ListItem>
// 							)}
// 						</ListBox>
// 					)}
// 				</Popup>
// 			</span>
// 		</div>
// 	)
// }

================================================================================
File: config\environment.ts
Lines: 44
--------------------------------------------------------------------------------
// src/client/config/environment.ts
// Client-side environment configuration

interface ImportMetaEnv {
  [key: string]: string | undefined;
}

declare global {
  interface ImportMeta {
    env: ImportMetaEnv;
  }
}

// Type definitions for client environment variables
export interface ClientEnv {
    NODE_ENV: 'development' | 'production';
    API_URL: string;
    WS_URL: string;
    APP_TITLE: string;
  }
  
  // Helper function to access environment variables safely
  function getEnvVariable(key: string, defaultValue?: string): string {
    // Access Vite's import.meta.env at build time
    const envVar = (import.meta.env as ImportMetaEnv)[`VITE_${key}`];
    if (envVar === undefined && defaultValue === undefined) {
      console.warn(`Environment variable VITE_${key} is not defined`);
      return '';
    }
    return envVar || defaultValue || '';
  }
  
  // Client environment configuration
  export const clientEnv: ClientEnv = {
    NODE_ENV: getEnvVariable('NODE_ENV', 'development') as 'development' | 'production',
    API_URL: getEnvVariable('API_URL', '/api'),
    WS_URL: getEnvVariable('WS_URL', (location.protocol === 'https:' ? 'wss:' : 'ws:') + '//' + location.host + '/ws'),
    APP_TITLE: getEnvVariable('APP_TITLE', 'ABE Stack Application'),
  };
  
  // Freeze the config object to prevent modifications
  Object.freeze(clientEnv);
  
  export default clientEnv;
================================================================================
File: contexts\SocialContext.tsx
Lines: 214
--------------------------------------------------------------------------------
import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';

import { socialService } from '../services/social';

export interface User {
  id: string;
  username: string;
  displayName: string;
  avatar: string;
  bio: string;
  followersCount: number;
  followingCount: number;
  postsCount: number;
  isFollowing: boolean;
}

interface Post {
  id: string;
  userId: string;
  username: string;
  userAvatar: string;
  content: string;
  media?: {
    type: 'image' | 'video' | 'audio';
    url: string;
    thumbnail?: string;
  };
  likesCount: number;
  commentsCount: number;
  sharesCount: number;
  isLiked: boolean;
  createdAt: string;
}

interface SocialContextType {
  currentUser: User | null;
  feed: Post[];
  isLoading: boolean;
  error: string | null;
  followUser: (userId: string) => Promise<void>;
  unfollowUser: (userId: string) => Promise<void>;
  likePost: (postId: string) => Promise<void>;
  unlikePost: (postId: string) => Promise<void>;
  sharePost: (postId: string) => Promise<void>;
  createPost: (content: string, media?: File) => Promise<void>;
  refreshFeed: () => Promise<void>;
}

const SocialContext = createContext<SocialContextType | null>(null);

export const useSocial = () => {
  const context = useContext(SocialContext);
  if (!context) {
    throw new Error('useSocial must be used within a SocialProvider');
  }
  return context;
};

interface SocialProviderProps {
  children: React.ReactNode;
}

export const SocialProvider: React.FC<SocialProviderProps> = ({ children }) => {
  const [currentUser, setCurrentUser] = useState<User | null>(null);
  const [feed, setFeed] = useState<Post[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const refreshFeed = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);
      const response = await socialService.getFeed('home');
      setFeed(response.posts);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to refresh feed');
    } finally {
      setIsLoading(false);
    }
  }, []);
  
  const initializeSocial = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);
      const user = await socialService.getUserProfile('current');
      setCurrentUser(user);
      await refreshFeed();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to initialize social');
    } finally {
      setIsLoading(false);
    }
  }, [refreshFeed]);
  
  useEffect(() => {
    void initializeSocial();
  }, [initializeSocial]);


  const followUser = async (userId: string) => {
    try {
      setError(null);
      await socialService.followUser(userId);
      if (currentUser) {
        setCurrentUser({
          ...currentUser,
          followingCount: currentUser.followingCount + 1,
        });
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to follow user');
      throw err;
    }
  };

  const unfollowUser = async (userId: string) => {
    try {
      setError(null);
      await socialService.unfollowUser(userId);
      if (currentUser) {
        setCurrentUser({
          ...currentUser,
          followingCount: currentUser.followingCount - 1,
        });
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to unfollow user');
      throw err;
    }
  };

  const likePost = async (postId: string) => {
    try {
      setError(null);
      await socialService.likePost(postId);
      setFeed(prev => prev.map(post =>
        post.id === postId
          ? { ...post, isLiked: true, likesCount: post.likesCount + 1 }
          : post
      ));
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to like post');
      throw err;
    }
  };

  const unlikePost = async (postId: string) => {
    try {
      setError(null);
      await socialService.unlikePost(postId);
      setFeed(prev => prev.map(post =>
        post.id === postId
          ? { ...post, isLiked: false, likesCount: post.likesCount - 1 }
          : post
      ));
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to unlike post');
      throw err;
    }
  };

  const sharePost = async (postId: string) => {
    try {
      setError(null);
      await socialService.sharePost(postId);
      setFeed(prev => prev.map(post =>
        post.id === postId
          ? { ...post, sharesCount: post.sharesCount + 1 }
          : post
      ));
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to share post');
      throw err;
    }
  };

  const createPost = async (content: string, media?: File) => {
    try {
      setError(null);
      const newPost = await socialService.createPost(content, media);
      setFeed(prev => [newPost, ...prev]);
      if (currentUser) {
        setCurrentUser({
          ...currentUser,
          postsCount: currentUser.postsCount + 1,
        });
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to create post');
      throw err;
    }
  };

  const value = {
    currentUser,
    feed,
    isLoading,
    error,
    followUser,
    unfollowUser,
    likePost,
    unlikePost,
    sharePost,
    createPost,
    refreshFeed,
  };

  return (
    <SocialContext.Provider value={value}>
      {children}
    </SocialContext.Provider>
  );
}; 
================================================================================
File: helpers\cookieHelpers.ts
Lines: 24
--------------------------------------------------------------------------------
import { groupBy, mapValues } from "lodash"

export function parseCookies(cookie: string) {
	const entries = cookie.split(";").map((line) => line.split("=").map((p) => p.trim()))
	const grouped = groupBy(entries, (entry) => entry[0])
	const cookies = mapValues(grouped, (entries) => entries.map((entry) => entry[1]))
	return cookies
}

export function deleteCookie(cookieName: string): void {
	const domain: string = window.location.hostname
	const path: string = "/"
	document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 GMT; domain=${domain}; path=${path}`
}

export function getCurrentUserId() {
	const cookies = parseCookies(document.cookie)
	const userId = cookies.userId?.[0]
	return userId
}

export function deleteLoginCookie() {
	deleteCookie("userId")
}

================================================================================
File: helpers\focusHelpers.ts
Lines: 130
--------------------------------------------------------------------------------
function nextElement(element: Element): Element | undefined {
	// Start by looking for the first child.
	if (element.firstElementChild) {
		return element.firstElementChild
	}

	return nextNonChildElement(element)
}

function nextNonChildElement(element: Element): Element | undefined {
	// If no children, look for next sibling.
	let currentElement: Element | undefined = element
	while (currentElement) {
		if (currentElement.nextElementSibling) {
			return currentElement.nextElementSibling
		}

		// If no next sibling, move up to the parent and look for its next sibling.
		currentElement = currentElement.parentElement || undefined
	}
}

/** Does not yield container or start elements. */
export function* iterateNextElement(args: { container: Element; start: Element; wrap: boolean }) {
	const { container, start, wrap } = args

	let cursor: Element | undefined = start
	while ((cursor = nextElement(cursor))) {
		// Break if we escape the container.
		if (cursor === container || !container.contains(cursor)) break
		yield cursor
	}

	if (wrap) {
		// Start over from the beginning
		if (start === container) return
		cursor = container
		while ((cursor = nextElement(cursor))) {
			if (cursor === start) break
			yield cursor
		}
	}
}

function prevElement(element: Element): Element | undefined {
	// If element has a previous sibling, find its last descendant.
	const prevSibling = element.previousElementSibling
	if (prevSibling) {
		return lastChildElement(prevSibling) || prevSibling
	}

	// If no previous sibling, return the parent.
	return element.parentElement || undefined
}

function lastChildElement(element: Element): Element | undefined {
	let lastChild = element.lastElementChild || undefined
	if (!lastChild) return
	while (lastChild.lastElementChild) {
		lastChild = lastChild.lastElementChild || undefined
	}
	return lastChild
}

/** Does not yield container or start elements. */
export function* iteratePrevElement(args: { container: Element; start: Element; wrap: boolean }) {
	const { container, start, wrap } = args

	let cursor: Element | undefined = start
	while ((cursor = prevElement(cursor))) {
		// Break if we escape the container.
		if (cursor === container || !container.contains(cursor)) break
		yield cursor
	}

	if (wrap || start === container) {
		// Start over from the end

		const last = lastChildElement(container)
		if (!last) return
		if (last === start) return
		yield last

		cursor = last
		while ((cursor = prevElement(cursor))) {
			if (cursor === start) break
			yield cursor
		}
	}
}

function getContainerFocus(container: Element) {
	if (!document.activeElement) return container
	if (container.contains(document.activeElement)) return document.activeElement
	return container
}

export function nextFocusable(container: Element) {
	const start = getContainerFocus(container)
	for (const element of iterateNextElement({ container, start, wrap: false })) {
		if (isFocusable(element)) return element as HTMLElement
	}
}

export function prevFocusable(container: Element) {
	const start = getContainerFocus(container)
	for (const element of iteratePrevElement({ container, start, wrap: false })) {
		if (isFocusable(element)) return element as HTMLElement
	}
}

export function isFocusable(element: Element) {
	if (element.hasAttribute("tabindex")) return true
	const tagName = element.tagName.toLowerCase()
	if (tagName === "input") return true
	if (tagName === "button") return true
}

/*


How to properly manage browser focus and keyboard events.

- set tabindex=0 if you want something to be focusable AND tabbable.
- set tabindex=-1 if you want something to be focusable and NOT tabbable, e.g. arrowing around a list box.
- element.focus() is slow and triggers a reflow!
	- hover and focus must be different, otherwise you'll kill your performance.
- listen to keyboard events on the element. leverage browser focus for events to bubble up so you don't have conflicting shortcuts.

*/

================================================================================
File: helpers\formatters.ts
Lines: 77
--------------------------------------------------------------------------------
/**
 * Format duration in seconds to MM:SS format
 */
export function formatDuration(seconds: number): string {
  if (isNaN(seconds) || !isFinite(seconds)) {
    return '00:00';
  }
  
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  
  return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}

/**
 * Format file size to human-readable format
 */
export function formatFileSize(bytes: number): string {
  if (bytes === 0) return '0 Bytes';
  
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

/**
 * Format a date to a human-readable format
 */
export function formatDate(date: Date | string): string {
  const d = new Date(date);
  return d.toLocaleDateString(undefined, {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  });
}

/**
 * Format a relative time (e.g., "2 days ago")
 */
export function formatRelativeTime(date: Date | string): string {
  const now = new Date();
  const then = new Date(date);
  const diffMs = now.getTime() - then.getTime();
  const diffSecs = Math.floor(diffMs / 1000);
  const diffMins = Math.floor(diffSecs / 60);
  const diffHours = Math.floor(diffMins / 60);
  const diffDays = Math.floor(diffHours / 24);
  const diffWeeks = Math.floor(diffDays / 7);
  const diffMonths = Math.floor(diffDays / 30);
  const diffYears = Math.floor(diffDays / 365);
  
  if (diffSecs < 60) {
    return 'just now';
  } else if (diffMins < 60) {
    return `${diffMins} minute${diffMins === 1 ? '' : 's'} ago`;
  } else if (diffHours < 24) {
    return `${diffHours} hour${diffHours === 1 ? '' : 's'} ago`;
  } else if (diffDays < 7) {
    return `${diffDays} day${diffDays === 1 ? '' : 's'} ago`;
  } else if (diffWeeks < 4) {
    return `${diffWeeks} week${diffWeeks === 1 ? '' : 's'} ago`;
  } else if (diffMonths < 12) {
    return `${diffMonths} month${diffMonths === 1 ? '' : 's'} ago`;
  } else {
    return `${diffYears} year${diffYears === 1 ? '' : 's'} ago`;
  }
}

/**
 * Format a number with commas (e.g., 1,234,567)
 */
export function formatNumber(num: number): string {
  return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
} 
================================================================================
File: helpers\mergeEvents.ts
Lines: 9
--------------------------------------------------------------------------------
export function mergeEvents<T extends Event | React.UIEvent>(
	...args: ((event: T) => boolean | undefined | void)[]
) {
	return (event: T) => {
		for (const fn of args) {
			if (fn(event) === false) break
		}
	}
}

================================================================================
File: helpers\passthroughRef.tsx
Lines: 11
--------------------------------------------------------------------------------
import { forwardRef, ComponentType, PropsWithoutRef } from 'react';

export function passthroughRef<P extends object, T = unknown>(
	Component: ComponentType<P>
) {
	const ForwardedComponent = forwardRef<T, PropsWithoutRef<P>>((props, ref) => {
		return <Component {...props as P} ref={ref} />;
	});
	ForwardedComponent.displayName = `ForwardedRef(${Component.displayName || Component.name || 'Component'})`;
	return ForwardedComponent;
}

================================================================================
File: hooks\useAsync.ts
Lines: 28
--------------------------------------------------------------------------------
import { isEqual } from "lodash"
import { useEffect, useRef, useState } from "react"

import { useRefCurrent } from "./useRefCurrent"
import { useRefPrevious } from "./useRefPrevious"

export function useAsync<T, Args extends unknown[]>(fn: (...args: Args) => Promise<T>, args: Args) {
	const [state, setState] = useState<T | undefined>(undefined)

	const currentFn = useRefCurrent(fn)

	const changeCount = useRef(0)
	const prevArgs = useRefPrevious(args)
	const same = isEqual(prevArgs.current, args)
	if (!same) changeCount.current += 1

	useEffect(() => {
		const currentCount = changeCount.current
		void currentFn.current(...args).then((result) => {
			if (changeCount.current === currentCount) {
				setState(result)
			}
		})
		return
	}, [args, currentFn])

	return state
}

================================================================================
File: hooks\useCounter.ts
Lines: 8
--------------------------------------------------------------------------------
import { useState } from "react"

// This is useful for forcing a re-render.
export function useCounter() {
	const [count, setCount] = useState(0)
	const inc = () => setCount((s) => s + 1)
	return [count, inc] as const
}

================================================================================
File: hooks\useOnline.ts
Lines: 19
--------------------------------------------------------------------------------
import { useEffect, useState } from "react"

// TODO: an improved online/offline detector would ping the server to see if its online.
// When the browser is online, but the server is down, this still says online.
// You can also monitor api requests or the websocket connection as well.
export function useOnline() {
	const [state, setState] = useState(navigator.onLine)
	useEffect(() => {
		const setOnline = () => setState(true)
		const setOffline = () => setState(false)
		window.addEventListener("online", setOnline)
		window.addEventListener("offline", setOffline)
		return () => {
			window.removeEventListener("online", setOnline)
			window.removeEventListener("offline", setOffline)
		}
	}, [])
	return state
}

================================================================================
File: hooks\usePopper.ts
Lines: 114
--------------------------------------------------------------------------------
import { useEffect, useRef } from 'react';

// Define types similar to what popper.js provides
export type Placement = 'top' | 'bottom' | 'right' | 'left' | 
  'top-start' | 'top-end' | 'bottom-start' | 'bottom-end' | 
  'right-start' | 'right-end' | 'left-start' | 'left-end';

export interface Options {
  placement?: Placement;
  modifiers?: Array<{ name: string; options?: Record<string, unknown> }>;
  strategy?: 'absolute' | 'fixed';
}

export interface Instance {
  destroy: () => void;
  update: () => Promise<{ placement: Placement }>;
  state: { placement: Placement };
}

// Simple positioning function to replace popper.js
function createSimplePopper(
  referenceElement: HTMLElement, 
  popperElement: HTMLElement, 
  options: Options = {}
): Instance {
  const placement = options.placement || 'bottom';
  const strategy = options.strategy || 'absolute';
  
  function update() {
    if (!referenceElement || !popperElement) {
      return Promise.resolve({ placement });
    }
    
    const refRect = referenceElement.getBoundingClientRect();
    
    popperElement.style.position = strategy;
    
    // Basic positioning based on placement
    switch (placement) {
      case 'top':
        popperElement.style.bottom = `${window.innerHeight - refRect.top}px`;
        popperElement.style.left = `${refRect.left + refRect.width / 2 - popperElement.offsetWidth / 2}px`;
        break;
      case 'bottom':
        popperElement.style.top = `${refRect.bottom}px`;
        popperElement.style.left = `${refRect.left + refRect.width / 2 - popperElement.offsetWidth / 2}px`;
        break;
      case 'left':
        popperElement.style.right = `${window.innerWidth - refRect.left}px`;
        popperElement.style.top = `${refRect.top + refRect.height / 2 - popperElement.offsetHeight / 2}px`;
        break;
      case 'right':
        popperElement.style.left = `${refRect.right}px`;
        popperElement.style.top = `${refRect.top + refRect.height / 2 - popperElement.offsetHeight / 2}px`;
        break;
      case 'bottom-start':
        popperElement.style.top = `${refRect.bottom}px`;
        popperElement.style.left = `${refRect.left}px`;
        break;
      case 'bottom-end':
        popperElement.style.top = `${refRect.bottom}px`;
        popperElement.style.left = `${refRect.right - popperElement.offsetWidth}px`;
        break;
      // Add other placements as needed
      default:
        popperElement.style.top = `${refRect.bottom}px`;
        popperElement.style.left = `${refRect.left}px`;
    }
    
    return Promise.resolve({ placement });
  }
  
  // Initial positioning
  void update();
  
  // Return an instance similar to popper.js
  return {
    destroy: () => {},
    update,
    state: { placement }
  };
}

export function usePopper(
  referenceElement: HTMLElement | null,
  popperElement: HTMLElement | null,
  options: Options = {}
) {
  const popperInstanceRef = useRef<Instance | null>(null);
  
  useEffect(() => {
    if (referenceElement && popperElement) {
      // Create new popper instance
      popperInstanceRef.current = createSimplePopper(
        referenceElement,
        popperElement,
        options
      );
      
      // Clean up on unmount
      return () => {
        if (popperInstanceRef.current) {
          popperInstanceRef.current.destroy();
          popperInstanceRef.current = null;
        }
      };
    }
    return undefined;
  }, [referenceElement, popperElement, options]);
  
  return { update: () => popperInstanceRef.current?.update() };
}

export { createSimplePopper as createPopper }; 
================================================================================
File: hooks\useRefCurrent.ts
Lines: 7
--------------------------------------------------------------------------------
import { useRef } from "react"

export function useRefCurrent<T>(value: T) {
	const ref = useRef<T>(value)
	ref.current = value
	return ref
}

================================================================================
File: hooks\useRefPrevious.ts
Lines: 9
--------------------------------------------------------------------------------
import { useEffect, useRef } from "react"

export function useRefPrevious<T>(value: T) {
	const ref = useRef<T>(value)
	useEffect(() => {
		ref.current = value
	})
	return ref
}

================================================================================
File: hooks\useShortcut.ts
Lines: 254
--------------------------------------------------------------------------------
// Adapted from https://github.com/marijnh/w3c-keyname
// The shift keycode map was removed so we can use Shift as a modifier.
// For example: "Shift-]" instead of "}

import { capitalize } from "lodash"
import { useEffect } from "react"

import { useRefCurrent } from "./useRefCurrent"

const base: { [key: number]: string } = {
	8: "Backspace",
	9: "Tab",
	10: "Enter",
	12: "NumLock",
	13: "Enter",
	16: "Shift",
	17: "Control",
	18: "Alt",
	20: "CapsLock",
	27: "Escape",
	32: " ",
	33: "PageUp",
	34: "PageDown",
	35: "End",
	36: "Home",
	37: "ArrowLeft",
	38: "ArrowUp",
	39: "ArrowRight",
	40: "ArrowDown",
	44: "PrintScreen",
	45: "Insert",
	46: "Delete",
	59: ";",
	61: "=",
	91: "Meta",
	92: "Meta",
	106: "*",
	107: "+",
	108: ",",
	109: "-",
	110: ".",
	111: "/",
	144: "NumLock",
	145: "ScrollLock",
	160: "Shift",
	161: "Shift",
	162: "Control",
	163: "Control",
	164: "Alt",
	165: "Alt",
	173: "-",
	186: ";",
	187: "=",
	188: ",",
	189: "-",
	190: ".",
	191: "/",
	192: "`",
	219: "[",
	220: "\\",
	221: "]",
	222: "'",
}

const chrome = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent)
const safari = typeof navigator != "undefined" && /Apple Computer/.test(navigator.vendor)
const gecko = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent)
const mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform)
const ie =
	typeof navigator != "undefined" &&
	/MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent)
const brokenModifierNames = (chrome && (mac || +chrome[1] < 57)) || (gecko && mac)

// Fill in the digit keys
for (let i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i)

// The function keys
for (let i = 1; i <= 24; i++) base[i + 111] = "F" + i

// And the alphabetic keys
for (let i = 65; i <= 90; i++) {
	base[i] = String.fromCharCode(i + 32)
}

function keyName(event: KeyboardEvent) {
	const ignoreKey =
		(brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey)) ||
		((safari || ie) && event.shiftKey && event.key && event.key.length == 1)
	let name = (!ignoreKey && event.key) || base[event.keyCode] || event.key || "Unidentified"
	// Edge sometimes produces wrong names (Issue #3)
	if (name == "Esc") name = "Escape"
	if (name == "Del") name = "Delete"
	// https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/
	if (name == "Left") name = "ArrowLeft"
	if (name == "Up") name = "ArrowUp"
	if (name == "Right") name = "ArrowRight"
	if (name == "Down") name = "ArrowDown"
	return name
}

// Aliases for various keyboard events, allowing shortcuts to be defined
// using some more colloquial terms.
const keyboardAliases: Record<string, string | undefined> = {
	ctrl: "control",
	mod: "meta",
	cmd: "meta",
	" ": "space",
	left: "arrowleft",
	right: "arrowright",
	down: "arrowdown",
	up: "arrowup",
	option: "alt",
	opt: "alt",
	delete: "backspace",
}

// Used for view test keyboard event mocking
export function shortcutToEvent(shortcut: string) {
	const keys = shortcut
		.split(/-(?!$)/)
		.map((str) => str.toLowerCase())
		.map((char) => keyboardAliases[char] || char)

	const parsed: ParsedShortcut = {}
	for (const key of keys) {
		if (key === "meta") parsed.metaKey = true
		else if (key === "control") parsed.ctrlKey = true
		else if (key === "alt") parsed.altKey = true
		else if (key === "shift") parsed.shiftKey = true
		// Used to emulate the behavior that all non-alphabetic keys in keyboard events
		// are capitalized:
		// https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_key_values
		else parsed.key = key.length === 1 ? key : key[0].toUpperCase() + key.slice(1)
	}

	return new KeyboardEvent("keydown", parsed)
}

interface ParsedShortcut {
	shiftKey?: boolean
	altKey?: boolean
	ctrlKey?: boolean
	metaKey?: boolean
	key?: string
}

function parseShortcut(shortcut: string) {
	const keys = shortcut
		.split(/-(?!$)/)
		.map((str) => str.toLowerCase())
		.map((char) => keyboardAliases[char] || char)

	const parsed: ParsedShortcut = {}
	for (const key of keys) {
		if (key === "meta") parsed.metaKey = true
		else if (key === "control") parsed.ctrlKey = true
		else if (key === "alt") parsed.altKey = true
		else if (key === "shift") parsed.shiftKey = true
		else parsed.key = key.toLowerCase()
	}
	return parsed
}

function formatShortcutKeys(parsed: ParsedShortcut) {
	const keys: Array<string> = []
	if (parsed.shiftKey) keys.push("shift")
	if (parsed.altKey) keys.push("alt")
	if (parsed.ctrlKey) keys.push("control")
	if (parsed.metaKey) keys.push("meta")
	if (parsed.key) keys.push(parsed.key)
	return keys
}

function formatShortcut(parsed: ParsedShortcut) {
	return formatShortcutKeys(parsed).join("-")
}

function normalizeShortcut(shortcut: string) {
	return formatShortcut(parseShortcut(shortcut))
}

const modifierCodes = new Set([
	"ControlLeft",
	"ControlRight",
	"ShiftLeft",
	"ShiftRight",
	"AltLeft",
	"AltRight",
	"MetaLeft",
	"MetaRight",
])

function parseKeyboardEvent(event: KeyboardEvent) {
	const parsed: ParsedShortcut = {}
	if (event.shiftKey) parsed.shiftKey = true
	if (event.altKey) parsed.altKey = true
	if (event.ctrlKey) parsed.ctrlKey = true
	if (event.metaKey) parsed.metaKey = true
	if (!modifierCodes.has(event.code)) parsed.key = keyName(event).toLowerCase()
	return parsed
}

function normalizeKeyboardShortcut(event: KeyboardEvent) {
	return formatShortcut(parseKeyboardEvent(event))
}

export function isShortcut(shortcut: string, event: KeyboardEvent) {
	return normalizeShortcut(shortcut) === normalizeKeyboardShortcut(event)
}

const isMac = true as boolean // process.platform === "darwin"

const shortKeys: Record<string, string> = {
	meta: isMac ? "⌘" : "^",
	control: "^",
	alt: "⌥",
	shift: "⇧",
	enter: "↵",
	tab: "⇥",
	arrowleft: "←",
	arrowright: "→",
	arrowup: "↑",
	arrowdown: "↓",
}

export function displayShortcut(shortcut: string) {
	const parsed = parseShortcut(shortcut)
	const keys = formatShortcutKeys(parsed)
	return keys
		.map((char) => shortKeys[char] || char)
		.map((char) => capitalize(char))
		.join("")
}

type KeyboardEventHandler = (event: KeyboardEvent) => void

/** Use with care. Prefer to put listeners on DOM elements to work better with focus. */
export function useShortcut(shortcut: string, fn: () => void) {
	const fnRef = useRefCurrent(fn)
	const shortcutRef = useRefCurrent(shortcut)

	useEffect(() => {
		const onKeydown: KeyboardEventHandler = (event) => {
			if (isShortcut(shortcutRef.current, event)) {
				event.preventDefault()
				fnRef.current()
			}
		}
		window.addEventListener("keydown", onKeydown)
		return () => {
			window.removeEventListener("keydown", onKeydown)
		}
	}, [fnRef, shortcutRef])
}

================================================================================
File: hooks\useSocialInteractions.ts
Lines: 163
--------------------------------------------------------------------------------
import { useState, useCallback } from 'react';

import { useSocial, type User } from '../contexts/SocialContext';
import { socialService } from '../services/social';

interface UseSocialInteractionsProps {
  onError?: (error: Error) => void;
}

export type { User };
export const useSocialInteractions = ({ onError }: UseSocialInteractionsProps = {}) => {
  const { currentUser, refreshFeed } = useSocial();
  const [isLoading, setIsLoading] = useState(false);

  const handleError = useCallback((error: Error) => {
    onError?.(error);
  }, [onError]);

  const followUser = useCallback(async (userId: string) => {
    try {
      setIsLoading(true);
      await socialService.followUser(userId);
      await refreshFeed();
    } catch (error) {
      handleError(error instanceof Error ? error : new Error('Failed to follow user'));
      throw error;
    } finally {
      setIsLoading(false);
    }
  }, [refreshFeed, handleError]);

  const unfollowUser = useCallback(async (userId: string) => {
    try {
      setIsLoading(true);
      await socialService.unfollowUser(userId);
      await refreshFeed();
    } catch (error) {
      handleError(error instanceof Error ? error : new Error('Failed to unfollow user'));
      throw error;
    } finally {
      setIsLoading(false);
    }
  }, [refreshFeed, handleError]);

  const likePost = useCallback(async (postId: string) => {
    try {
      setIsLoading(true);
      await socialService.likePost(postId);
      await refreshFeed();
    } catch (error) {
      handleError(error instanceof Error ? error : new Error('Failed to like post'));
      throw error;
    } finally {
      setIsLoading(false);
    }
  }, [refreshFeed, handleError]);

  const unlikePost = useCallback(async (postId: string) => {
    try {
      setIsLoading(true);
      await socialService.unlikePost(postId);
      await refreshFeed();
    } catch (error) {
      handleError(error instanceof Error ? error : new Error('Failed to unlike post'));
      throw error;
    } finally {
      setIsLoading(false);
    }
  }, [refreshFeed, handleError]);

  const sharePost = useCallback(async (postId: string) => {
    try {
      setIsLoading(true);
      await socialService.sharePost(postId);
      await refreshFeed();
    } catch (error) {
      handleError(error instanceof Error ? error : new Error('Failed to share post'));
      throw error;
    } finally {
      setIsLoading(false);
    }
  }, [refreshFeed, handleError]);

  const createPost = useCallback(async (content: string, media?: File) => {
    try {
      setIsLoading(true);
      await socialService.createPost(content, media);
      await refreshFeed();
    } catch (error) {
      handleError(error instanceof Error ? error : new Error('Failed to create post'));
      throw error;
    } finally {
      setIsLoading(false);
    }
  }, [refreshFeed, handleError]);

  const createComment = useCallback(async (postId: string, content: string) => {
    try {
      setIsLoading(true);
      await socialService.createComment(postId, content);
      await refreshFeed();
    } catch (error) {
      handleError(error instanceof Error ? error : new Error('Failed to create comment'));
      throw error;
    } finally {
      setIsLoading(false);
    }
  }, [refreshFeed, handleError]);

  const likeComment = useCallback(async (commentId: string) => {
    try {
      setIsLoading(true);
      await socialService.likeComment(commentId);
      await refreshFeed();
    } catch (error) {
      handleError(error instanceof Error ? error : new Error('Failed to like comment'));
      throw error;
    } finally {
      setIsLoading(false);
    }
  }, [refreshFeed, handleError]);

  const unlikeComment = useCallback(async (commentId: string) => {
    try {
      setIsLoading(true);
      await socialService.unlikeComment(commentId);
      await refreshFeed();
    } catch (error) {
      handleError(error instanceof Error ? error : new Error('Failed to unlike comment'));
      throw error;
    } finally {
      setIsLoading(false);
    }
  }, [refreshFeed, handleError]);

  const replyToComment = useCallback(async (commentId: string, content: string) => {
    try {
      setIsLoading(true);
      await socialService.replyToComment(commentId, content);
      await refreshFeed();
    } catch (error) {
      handleError(error instanceof Error ? error : new Error('Failed to reply to comment'));
      throw error;
    } finally {
      setIsLoading(false);
    }
  }, [refreshFeed, handleError]);

  return {
    currentUser,
    isLoading,
    followUser,
    unfollowUser,
    likePost,
    unlikePost,
    sharePost,
    createPost,
    createComment,
    likeComment,
    unlikeComment,
    replyToComment,
  };
}; 
================================================================================
File: public\manifest.json
Lines: 25
--------------------------------------------------------------------------------
{
  "short_name": "ABE Stack",
  "name": "ABE Stack - Media & Social Platform",
  "icons": [
    {
      "src": "/icons/favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "/icons/logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "/icons/logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
} 
================================================================================
File: public\service-worker.js
Lines: 217
--------------------------------------------------------------------------------
const CACHE_VERSION = "v1";
const ASSETS_CACHE = `app-assets-${CACHE_VERSION}`;
const IMAGES_CACHE = `images-${CACHE_VERSION}`;
const FONTS_CACHE = `fonts-${CACHE_VERSION}`;
const API_CACHE = `api-${CACHE_VERSION}`;

const cacheWhitelist = [ASSETS_CACHE, IMAGES_CACHE, FONTS_CACHE, API_CACHE];

// Check if we're in development mode
const isDevelopment = self.location.hostname === 'localhost' || 
                     self.location.hostname === '127.0.0.1' ||
                     self.location.hostname.includes('localhost') ||
                     self.location.port === '3000';

// If in development, immediately unregister
if (isDevelopment) {
	console.log('[ServiceWorker] Development mode detected, unregistering');
	self.registration?.unregister();
	return;
}

// Skip caching for development-related paths
const DEV_PATHS = [
	'/@vite/client',
	'/@react-refresh',
	'/index.tsx',
	'/index.css',
	'/vite',
	'/@fs',
	'/@vite',
	'/@fs/',
	'/@vite/',
	'/@react-refresh/',
	'/@vite/client/'
];

// Assets to cache on install
const PRE_CACHED_ASSETS = [
	'/',
	'/index.html',
	'/manifest.json'
];

// Perform install steps
self.addEventListener("install", function (event) {
	console.log('[ServiceWorker] Install');
	
	// Skip waiting forces the waiting service worker to become the active service worker
	self.skipWaiting();
	
	// Skip caching in development
	if (isDevelopment) {
		console.log('[ServiceWorker] Development mode detected, skipping cache');
		return;
	}
	
	event.waitUntil(
		caches.open(ASSETS_CACHE)
			.then(function(cache) {
				console.log('[ServiceWorker] Caching app shell');
				return cache.addAll(PRE_CACHED_ASSETS).catch(error => {
					console.error('[ServiceWorker] Pre-cache error:', error);
					return Promise.resolve();
				});
			})
	);
});

// Delete any old caches
self.addEventListener("activate", function (event) {
	console.log('[ServiceWorker] Activate');
	
	// Claim control of all clients
	event.waitUntil(self.clients.claim());
	
	// Skip cache cleanup in development
	if (isDevelopment) {
		console.log('[ServiceWorker] Development mode detected, skipping cache cleanup');
		return;
	}
	
	event.waitUntil(
		caches.keys().then(function (cacheNames) {
			return Promise.all(
				cacheNames.map(function (cacheName) {
					if (cacheWhitelist.indexOf(cacheName) === -1) {
						console.log('[ServiceWorker] Deleting old cache:', cacheName);
						return caches.delete(cacheName);
					}
				})
			);
		})
	);
});

// Helper function to determine cache based on request URL and type
function getCacheForRequest(request) {
	const url = new URL(request.url);
	
	// Skip caching for development-related paths
	if (DEV_PATHS.some(path => url.pathname.includes(path))) {
		return null;
	}
	
	// Cache images
	if (request.destination === 'image' || url.pathname.match(/\.(jpe?g|png|gif|svg|webp)$/i)) {
		return IMAGES_CACHE;
	}
	
	// Cache fonts
	if (request.destination === 'font' || url.pathname.match(/\.(woff2?|ttf|otf|eot)$/i)) {
		return FONTS_CACHE;
	}
	
	// Cache API responses (with caution)
	if (url.pathname.startsWith('/api/')) {
		return API_CACHE;
	}
	
	// Default to assets cache
	return ASSETS_CACHE;
}

// Fetch handler with improved caching strategy
self.addEventListener("fetch", function (event) {
	// Skip all caching in development
	if (isDevelopment) {
		console.log('[ServiceWorker] Development mode detected, skipping fetch handling');
		return;
	}
	
	// Skip cross-origin requests
	if (!event.request.url.startsWith(self.location.origin)) {
		return;
	}
	
	// Skip non-GET requests
	if (event.request.method !== 'GET') {
		return;
	}

	// Skip caching for development-related paths
	const url = new URL(event.request.url);
	if (DEV_PATHS.some(path => url.pathname.includes(path))) {
		return;
	}
	
	// Network-first strategy with fallback to cache
	event.respondWith(
		fetch(event.request)
			.then(response => {
				// Don't cache bad responses
				if (!response || response.status !== 200 || response.type !== 'basic') {
					return response;
				}
				
				// Clone the response
				const responseToCache = response.clone();
				
				// Store in the appropriate cache
				const cacheName = getCacheForRequest(event.request);
				if (cacheName) {
					caches.open(cacheName).then(cache => {
						cache.put(event.request, responseToCache);
					}).catch(error => {
						console.error('[ServiceWorker] Cache error:', error);
					});
				}
				
				return response;
			})
			.catch(() => {
				// Return from cache if network fails
				return caches.match(event.request)
					.then(cachedResponse => {
						if (cachedResponse) {
							return cachedResponse;
						}
						
						// Check if request is for an HTML document (or navigation request)
						// Return index.html for SPA routes
						const acceptHeader = event.request.headers.get('accept');
						if (
							event.request.mode === 'navigate' ||
							(acceptHeader && acceptHeader.includes('text/html'))
						) {
							return caches.match('/');
						}
						
						// If we get here, we couldn't serve the request from cache either
						console.log('[ServiceWorker] Could not fetch:', event.request.url);
						
						// Create a minimal offline response for common asset types
						if (url.pathname.match(/\.(jpe?g|png|gif|svg)$/i)) {
							return new Response(
								'<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200" viewBox="0 0 200 200"><rect width="100%" height="100%" fill="#f0f0f0"/><text x="50%" y="50%" font-family="sans-serif" font-size="16" text-anchor="middle" dominant-baseline="middle" fill="#999">Image unavailable</text></svg>',
								{ headers: { 'Content-Type': 'image/svg+xml' } }
							);
						}
						
						// For missing JavaScript or CSS, return empty response
						if (url.pathname.match(/\.(js|css)$/i)) {
							const contentType = url.pathname.endsWith('.js') ? 'application/javascript' : 'text/css';
							return new Response('/* Offline: resource unavailable */', { 
								headers: { 'Content-Type': contentType } 
							});
						}
						
						// Default response for other types
						return new Response('Resource unavailable offline', { 
							status: 503,
							headers: { 'Content-Type': 'text/plain' } 
						});
					});
			})
	);
}); 
================================================================================
File: services\api.ts
Lines: 194
--------------------------------------------------------------------------------
import type * as apis from "../../server/apis/autoindex"
import type { ServerEnvironment } from "../../server/services/ServerEnvironment"
import { sleep } from "../../shared/sleep"

// Update InputOutput to match the actual handler signature
type InputOutput<T extends (env: ServerEnvironment, args: unknown) => unknown> = {
	input: Parameters<T>[1]
	output: ReturnType<T>
}

type Apis = typeof apis
type ApiSchema = { [K in keyof Apis]: InputOutput<Apis[K]["handler"]> }

// https://github.com/microsoft/TypeScript/issues/55095
type StatusCode = 0 | 200 | 400 | 409 | 424 | 403 | 500
type ErrorStatusCode = Exclude<StatusCode, 200>
type ErrorResponse = { status: ErrorStatusCode; body?: unknown }

type ApiResponse<T> = {
	success: boolean;
	data?: T;
	error?: string;
};

const debug = (...args: unknown[]) => console.log("api:", ...args)

export async function apiRequest<T extends keyof ApiSchema>(
	name: T,
	args: ApiSchema[T]["input"]
): Promise<ApiResponse<Awaited<ApiSchema[T]["output"]>>> {
	debug(name, JSON.stringify(args))

	const result = await httpRequest("/api/" + name, args)

	// Control how much loading spinners we see during development.
	await sleep(400)

	// Convert HttpResponse to ApiResponse
	if (result.status === 200) {
		return { 
			success: true, 
			data: result.body as Awaited<ApiSchema[T]["output"]> 
		};
	} else {
		return {
			success: false,
			error: formatResponseError(result as ErrorResponse)
		};
	}
}

export type ClientApi = {
	get: <T>(path: string) => Promise<ApiResponse<T>>;
	post: <T>(path: string, data?: Record<string, unknown>) => Promise<ApiResponse<T>>;
	put: <T>(path: string, data?: Record<string, unknown>) => Promise<ApiResponse<T>>;
	delete: <T>(path: string) => Promise<ApiResponse<T>>;
	upload: (path: string, file: File) => Promise<ApiResponse<string>>;
};

export function createApi(): ClientApi {
	const baseUrl = '/api';

	async function fetchApi<T>(
		method: string,
		path: string,
		data?: Record<string, unknown>
	): Promise<ApiResponse<T>> {
		const url = `${baseUrl}${path}`;
		const headers: HeadersInit = {
			'Content-Type': 'application/json',
		};

		try {
			const response = await fetch(url, {
				method,
				headers,
				body: data ? JSON.stringify(data) : undefined,
			});

			if (!response.ok) {
				const errorData = await response.json() as { message?: string };
				return {
					success: false,
					error: errorData.message || `HTTP error ${response.status}`,
				};
			}

			const responseData = await response.json() as T;
			return {
				success: true,
				data: responseData,
			};
		} catch (error) {
			return {
				success: false,
				error: error instanceof Error ? error.message : 'Unknown error',
			};
		}
	}

	async function uploadFile(
		path: string,
		file: File
	): Promise<ApiResponse<string>> {
		const url = `${baseUrl}${path}`;
		const formData = new FormData();
		formData.append('file', file);

		try {
			const response = await fetch(url, {
				method: 'POST',
				body: formData,
			});

			if (!response.ok) {
				const errorData = await response.json() as { message?: string };
				return {
					success: false,
					error: errorData.message || `HTTP error ${response.status}`,
				};
			}

			const responseData = await response.json() as { url: string };
			return {
				success: true,
				data: responseData.url,
			};
		} catch (error) {
			return {
				success: false,
				error: error instanceof Error ? error.message : 'Unknown error',
			};
		}
	}

	return {
		get: <T>(path: string) => fetchApi<T>('GET', path),
		post: <T>(path: string, data?: Record<string, unknown>) => fetchApi<T>('POST', path, data),
		put: <T>(path: string, data?: Record<string, unknown>) => fetchApi<T>('PUT', path, data),
		delete: <T>(path: string) => fetchApi<T>('DELETE', path),
		upload: (path: string, file: File) => uploadFile(path, file),
	};
}

export function formatResponseError(response: ErrorResponse) {
	const { status, body } = response
	if (body === null) return `${status}: Unkown error.`
	if (body === undefined) return `${status}: Unkown error.`
	if (typeof body === "string") return body
	if (typeof body === "object") {
		if ("message" in body) {
			if (typeof body.message === "string") {
				return body.message
			}
		}
	}
	return `${status}: ${JSON.stringify(body)}`
}

export type HttpResponse<Body = unknown> = { status: 200; body: Body } | { status: number; body?: unknown }

// Only POST requests for now because this is only used for the API.
export async function httpRequest(url: string, args: unknown): Promise<HttpResponse> {
	let response: Response
	try {
		response = await fetch(url, {
			method: "post",
			credentials: "same-origin",
			headers: { "Content-Type": "application/json" },
			body: JSON.stringify(args),
		})
	} catch (error) {
		// Offline
		return { status: 0 }
	}

	if (response.status === 200) {
		try {
			const body = await response.json() as unknown;
			return { status: 200, body }
		} catch (error) {
			return { status: 200, body: {} }
		}
	}

	let body: unknown;
	try {
		body = await response.json();
	} catch (error) {
		console.warn("Could not parse body of error response.")
	}

	return { status: response.status, body }
}

================================================================================
File: services\AuthClient.ts
Lines: 287
--------------------------------------------------------------------------------
import { useState, useEffect, useCallback, useMemo } from 'react';

// Remove unused import
// import { useClientEnvironment } from './ClientEnvironment';

// User types
export interface User {
  id: string;
  username: string;
  email: string;
  displayName: string;
  bio: string | null;
  profileImage: string | null;
  emailConfirmed: boolean;
  createdAt: string;
  updatedAt: string;
}

// API response types
interface ApiResponse<T> {
  status: 'success' | 'error';
  message?: string;
  data?: T;
  requireEmailConfirmation?: boolean;
}

interface UserResponse {
  user: User;
  token?: string;
  requireTwoFactor?: boolean;
  userId?: string;
}

export class AuthClient {
  // Get the server port
  private getServerPort(): number {
    // In production, use the same port as the client
    if (process.env.NODE_ENV === 'production') {
      return window.location.port ? parseInt(window.location.port) : 80;
    }
    
    // In development, try to find the server port
    // First, check if we can read the port from localStorage (set by previous successful connections)
    const savedPort = localStorage.getItem('server_port');
    if (savedPort) {
      return parseInt(savedPort);
    }
    
    // Default to 8080 for the server in development
    return 8080;
  }

  // Get the base API URL
  private getApiUrl() {
    // In development, use a direct URL to the server
    if (process.env.NODE_ENV === 'development') {
      return `http://localhost:${this.getServerPort()}/api`;
    }
    
    // In production, use the current window location
    return `${window.location.protocol}//${window.location.host}/api`;
  }

  // Store token in localStorage
  setToken(token: string) {
    localStorage.setItem('auth_token', token);
  }

  getToken(): string | null {
    return localStorage.getItem('auth_token');
  }

  removeToken() {
    localStorage.removeItem('auth_token');
  }

  isAuthenticated(): boolean {
    return !!this.getToken();
  }

  getAuthHeaders() {
    const token = this.getToken();
    return token ? { Authorization: `Bearer ${token}` } : {};
  }

  // Email verification methods
  async confirmEmail(token: string): Promise<{ success: boolean }> {
    try {
      const response = await fetch(`${this.getApiUrl()}/auth/confirm-email?token=${token}`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json'
        }
      });
      
      return await response.json() as Promise<{ success: boolean }>;
    } catch (error) {
      console.error('Error confirming email:', error);
      throw error;
    }
  }

  async resendConfirmationEmail(email: string) {
    try {
      const response = await fetch(`${this.getApiUrl()}/auth/resend-confirmation`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ email })
      });
      
      return await response.json() as Promise<{ success: boolean }>;
    } catch (error) {
      console.error('Error resending confirmation email:', error);
      throw error;
    }
  }
}

// Static instance for non-hook usage
export const authClientInstance = new AuthClient();

// React hook for authentication
export function useAuth() {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  // Memoize the authClient instance
  const authClient = useMemo(() => new AuthClient(), []);

  const loadUser = useCallback(async () => {
    if (!authClient.isAuthenticated()) {
      setUser(null);
      setLoading(false);
      return;
    }

    try {
      setLoading(true);
      // Use fetch directly to avoid API structure issues
      const token = authClient.getToken();
      const response = await fetch('/api/auth/me', {
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        }
      });
      
      const data = await response.json() as ApiResponse<UserResponse>;
      
      if (data.status === 'success' && data.data?.user) {
        setUser(data.data.user);
      } else {
        // If we get a response but no user, token might be invalid
        authClient.removeToken();
        setUser(null);
      }
    } catch (err) {
      console.error('Failed to load user:', err);
      // Clear token on auth error
      authClient.removeToken();
      setUser(null);
      setError('Failed to authenticate');
    } finally {
      setLoading(false);
    }
  }, [authClient]);

  const login = async (email: string, password: string) => {
    try {
      setLoading(true);
      setError(null);
      
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ email, password })
      });
      
      const data = await response.json() as ApiResponse<UserResponse>;
      
      if (data.status === 'success') {
        if (data.data?.requireTwoFactor) {
          // Return the 2FA requirement
          return { requireTwoFactor: true, userId: data.data.userId };
        }
        
        if (data.data?.token) {
          authClient.setToken(data.data.token);
        }
        if (data.data?.user) {
          setUser(data.data.user);
        }
        return { success: true };
      } else if (data.requireEmailConfirmation) {
        // Email not confirmed
        return { 
          success: false, 
          requireEmailConfirmation: true, 
          email, 
          error: data.message || 'Email confirmation required'
        };
      } else {
        throw new Error(data.message || 'Login failed');
      }
    } catch (err: unknown) {
      const errorMessage = err instanceof Error ? err.message : 'Login failed';
      setError(errorMessage);
      return { success: false, error: errorMessage };
    } finally {
      setLoading(false);
    }
  };

  const register = async (userData: { 
    username: string; 
    email: string; 
    password: string; 
    displayName?: string;
    firstName: string;
    lastName: string;
  }) => {
    try {
      setLoading(true);
      setError(null);
      
      const response = await fetch('/api/auth/register', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(userData)
      });
      
      const data = await response.json() as ApiResponse<UserResponse>;
      
      if (data.status === 'success' && data.data) {
        if (data.data.token) {
          authClient.setToken(data.data.token);
        }
        if (data.data.user) {
          setUser(data.data.user);
        }
        return { 
          success: true,
          requireEmailConfirmation: !data.data.user.emailConfirmed,
          message: data.message || 'Registration successful'
        };
      } else {
        throw new Error(data.message || 'Registration failed');
      }
    } catch (err: unknown) {
      const errorMessage = err instanceof Error ? err.message : 'Registration failed';
      setError(errorMessage);
      return { success: false, error: errorMessage };
    } finally {
      setLoading(false);
    }
  };

  const logout = () => {
    authClient.removeToken();
    setUser(null);
  };

  // Load user on mount and when token changes
  useEffect(() => {
    void loadUser();
  }, [loadUser]);

  return {
    user,
    loading,
    error,
    login,
    register,
    logout,
    isAuthenticated: !!user,
    refreshUser: loadUser,
    confirmEmail: authClient.confirmEmail.bind(authClient),
    resendConfirmationEmail: authClient.resendConfirmationEmail.bind(authClient)
  };
} 
================================================================================
File: services\ClientConfig.ts
Lines: 26
--------------------------------------------------------------------------------
// src/client/services/ClientConfig.ts
// Remove unused import
// import { clientEnv } from '../config/environment';

export type ClientConfig = {
  production: boolean;
  host: string;
};

// Add interface for window with config
interface WindowWithConfig extends Window {
  __config: ClientConfig;
}

// Safely access environment variables
const isProd = process.env.NODE_ENV === 'production';
const apiHost = process.env.VITE_API_HOST || window.location.host;

// For Vite, we'll use environment variables instead of import.meta.env
export const clientConfig: ClientConfig = {
  production: isProd,
  host: apiHost
};

// Use double assertion for window
(window as unknown as WindowWithConfig).__config = clientConfig;
================================================================================
File: services\ClientEnvironment.tsx
Lines: 37
--------------------------------------------------------------------------------
import React, { createContext, useContext } from 'react';

import type { ClientApi } from './api';
import type { Router } from './Router';
import type { WebsocketPubsubClient } from './WebsocketPubsubClient';

export type ClientConfig = {
	apiUrl: string;
	wsUrl: string;
	production: boolean;
};

export type ClientEnvironment = {
	config: ClientConfig;
	router: Router;
	api: ClientApi;
	pubsub: WebsocketPubsubClient;
};

const ClientEnvironmentContext = createContext<ClientEnvironment | undefined>(undefined);

export function ClientEnvironmentProvider(props: {
	value: ClientEnvironment;
	children: React.ReactNode;
}) {
	return (
		<ClientEnvironmentContext.Provider value={props.value}>
			{props.children}
		</ClientEnvironmentContext.Provider>
	);
}

export function useClientEnvironment(): ClientEnvironment {
	const clientEnvironment = useContext(ClientEnvironmentContext);
	if (!clientEnvironment) throw new Error('Missing ClientEnvironment');
	return clientEnvironment;
}

================================================================================
File: services\Router.ts
Lines: 155
--------------------------------------------------------------------------------
import { useEffect, useState } from "react"

export type Route = 
	| { type: 'root'; url: string }
	| { type: 'home'; url: string }
	| { type: 'media'; url: string }
	| { type: 'social'; url: string }
	| { type: 'settings'; url: string }
	| { type: 'dashboard'; url: string }
	| { type: 'profile'; url: string }
	| { type: 'upload'; url: string }
	| { type: 'explore'; url: string }
	| { type: 'notifications'; url: string }
	| { type: 'design'; url: string; page: string }
	| { type: 'auth'; url: string; action: string; token?: string }
	| { type: 'unknown'; url: string };

// Define interface for window with router
interface WindowWithRouter extends Window {
	router?: Router;
}

export class Router {
	private listeners: Set<() => void> = new Set()
	private currentRoute: Route

	constructor() {
		this.currentRoute = this.parseUrl(window.location.pathname + window.location.search)

		// Listen for popstate events (back/forward buttons)
		window.addEventListener('popstate', () => {
			this.currentRoute = this.parseUrl(window.location.pathname + window.location.search)
			this.notifyListeners()
		})
	}

	private parseUrl(url: string): Route {
		// Extract path and search params
		const [path, search] = url.split('?');
		const searchParams = new URLSearchParams(search ? `?${search}` : '');
		
		if (path === '/' || path === '') {
			return { type: 'root', url: path }
		}
		
		if (path === '/home') {
			return { type: 'home', url: path }
		}
		
		if (path === '/media') {
			return { type: 'media', url: path }
		}
		
		if (path === '/social') {
			return { type: 'social', url: path }
		}
		
		if (path === '/settings') {
			return { type: 'settings', url: path }
		}
		
		if (path === '/dashboard') {
			return { type: 'dashboard', url: path }
		}
		
		if (path === '/profile') {
			return { type: 'profile', url: path }
		}
		
		if (path === '/upload') {
			return { type: 'upload', url: path }
		}
		
		if (path === '/explore') {
			return { type: 'explore', url: path }
		}
		
		if (path === '/notifications') {
			return { type: 'notifications', url: path }
		}
		
		if (path.startsWith('/design/')) {
			const page = path.slice('/design/'.length)
			return { type: 'design', url: path, page }
		}
		
		// Auth routes
		if (path.startsWith('/auth/')) {
			const action = path.slice('/auth/'.length);
			const token = searchParams.get('token') || undefined;
			return { type: 'auth', url: path, action, token };
		}
		
		return { type: 'unknown', url: path }
	}

	private notifyListeners() {
		this.listeners.forEach(listener => listener())
	}

	public getCurrentRoute(): Route {
		return this.currentRoute
	}

	public navigate(url: string) {
		window.history.pushState(null, '', url)
		this.currentRoute = this.parseUrl(url)
		this.notifyListeners()
	}

	public subscribe(listener: () => void): () => void {
		this.listeners.add(listener)
		return () => {
			this.listeners.delete(listener)
		}
	}
}

export function useRouter(): { route: Route; navigate: (url: string) => void } {
	const [route, setRoute] = useState<Route>(() => {
		// Access the router from the window object during development
		const router = (window as WindowWithRouter).router
		return router ? router.getCurrentRoute() : { type: 'unknown', url: window.location.pathname }
	})

	useEffect(() => {
		const router = (window as WindowWithRouter).router
		if (!router) {
			console.error('Router not found on window object')
			return
		}

		const unsubscribe = router.subscribe(() => {
			setRoute(router.getCurrentRoute())
		})

		return unsubscribe
	}, [])

	const navigate = (url: string) => {
		const router = (window as WindowWithRouter).router
		if (!router) {
			console.error('Router not found on window object')
			return
		}
		router.navigate(url)
	}

	return { route, navigate }
}

export function useRoute(): Route {
	const { route } = useRouter()
	return route
}

================================================================================
File: services\social.ts
Lines: 218
--------------------------------------------------------------------------------
interface User {
  id: string;
  username: string;
  displayName: string;
  avatar: string;
  bio: string;
  followersCount: number;
  followingCount: number;
  postsCount: number;
  isFollowing: boolean;
}

interface Post {
  id: string;
  userId: string;
  username: string;
  userAvatar: string;
  content: string;
  media?: {
    type: 'image' | 'video' | 'audio';
    url: string;
    thumbnail?: string;
  };
  likesCount: number;
  commentsCount: number;
  sharesCount: number;
  isLiked: boolean;
  createdAt: string;
}

interface Comment {
  id: string;
  userId: string;
  username: string;
  userAvatar: string;
  content: string;
  likesCount: number;
  isLiked: boolean;
  createdAt: string;
  replies?: Comment[];
}

interface FeedResponse {
  posts: Post[];
  hasMore: boolean;
}

interface CommentsResponse {
  comments: Comment[];
  hasMore: boolean;
}

class SocialService {
  private static instance: SocialService;
  private baseUrl: string;

  private constructor() {
    this.baseUrl = '/api';
  }

  public static getInstance(): SocialService {
    if (!SocialService.instance) {
      SocialService.instance = new SocialService();
    }
    return SocialService.instance;
  }

  // User-related methods
  async getUserProfile(userId: string): Promise<User> {
    const response = await fetch(`${this.baseUrl}/users/${userId}`);
    if (!response.ok) {
      throw new Error('Failed to fetch user profile');
    }
    return response.json() as Promise<User>;
  }

  async followUser(userId: string): Promise<void> {
    const response = await fetch(`${this.baseUrl}/users/${userId}/follow`, {
      method: 'POST',
    });
    if (!response.ok) {
      throw new Error('Failed to follow user');
    }
  }

  async unfollowUser(userId: string): Promise<void> {
    const response = await fetch(`${this.baseUrl}/users/${userId}/unfollow`, {
      method: 'POST',
    });
    if (!response.ok) {
      throw new Error('Failed to unfollow user');
    }
  }

  // Post-related methods
  async getFeed(type: 'home' | 'profile' | 'explore', userId?: string, offset: number = 0): Promise<FeedResponse> {
    const url = new URL(`${this.baseUrl}/feed`);
    url.searchParams.append('type', type);
    if (userId) {
      url.searchParams.append('userId', userId);
    }
    if (offset > 0) {
      url.searchParams.append('offset', offset.toString());
    }

    const response = await fetch(url.toString());
    if (!response.ok) {
      throw new Error('Failed to fetch feed');
    }
    return response.json() as Promise<FeedResponse>;
  }

  async createPost(content: string, media?: File): Promise<Post> {
    const formData = new FormData();
    formData.append('content', content);
    if (media) {
      formData.append('media', media);
    }

    const response = await fetch(`${this.baseUrl}/posts`, {
      method: 'POST',
      body: formData,
    });
    if (!response.ok) {
      throw new Error('Failed to create post');
    }
    return response.json() as Promise<Post>;
  }

  async likePost(postId: string): Promise<void> {
    const response = await fetch(`${this.baseUrl}/posts/${postId}/like`, {
      method: 'POST',
    });
    if (!response.ok) {
      throw new Error('Failed to like post');
    }
  }

  async unlikePost(postId: string): Promise<void> {
    const response = await fetch(`${this.baseUrl}/posts/${postId}/unlike`, {
      method: 'POST',
    });
    if (!response.ok) {
      throw new Error('Failed to unlike post');
    }
  }

  async sharePost(postId: string): Promise<void> {
    const response = await fetch(`${this.baseUrl}/posts/${postId}/share`, {
      method: 'POST',
    });
    if (!response.ok) {
      throw new Error('Failed to share post');
    }
  }

  // Comment-related methods
  async getComments(postId: string, offset: number = 0): Promise<CommentsResponse> {
    const url = new URL(`${this.baseUrl}/posts/${postId}/comments`);
    if (offset > 0) {
      url.searchParams.append('offset', offset.toString());
    }

    const response = await fetch(url.toString());
    if (!response.ok) {
      throw new Error('Failed to fetch comments');
    }
    return response.json() as Promise<CommentsResponse>;
  }

  async createComment(postId: string, content: string): Promise<Comment> {
    const response = await fetch(`${this.baseUrl}/posts/${postId}/comments`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ content }),
    });
    if (!response.ok) {
      throw new Error('Failed to create comment');
    }
    return response.json() as Promise<Comment>;
  }

  async likeComment(commentId: string): Promise<void> {
    const response = await fetch(`${this.baseUrl}/comments/${commentId}/like`, {
      method: 'POST',
    });
    if (!response.ok) {
      throw new Error('Failed to like comment');
    }
  }

  async unlikeComment(commentId: string): Promise<void> {
    const response = await fetch(`${this.baseUrl}/comments/${commentId}/unlike`, {
      method: 'POST',
    });
    if (!response.ok) {
      throw new Error('Failed to unlike comment');
    }
  }

  async replyToComment(commentId: string, content: string): Promise<Comment> {
    const response = await fetch(`${this.baseUrl}/comments/${commentId}/replies`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ content }),
    });
    if (!response.ok) {
      throw new Error('Failed to create reply');
    }
    return response.json() as Promise<Comment>;
  }
}

export const socialService = SocialService.getInstance(); 
================================================================================
File: services\types.ts
Lines: 5
--------------------------------------------------------------------------------
export type ClientConfig = {
  apiUrl: string;
  wsUrl: string;
  production: boolean;
}; 
================================================================================
File: services\WebsocketPubsubClient.ts
Lines: 125
--------------------------------------------------------------------------------
import { SecondMs } from "../../shared/dateHelpers"
import { ClientPubsubMessage, ServerPubsubMessage } from "../../shared/PubSubTypes"
import { sleep } from "../../shared/sleep"

import { ClientConfig } from "./ClientConfig"

// Define a type for pubsub values
type PubSubValue = unknown;

const debug = (...args: unknown[]) => console.log("pubsub:", ...args)

export class WebsocketPubsubClient {
	private ws!: WebSocket
	private reconnectAttempt = 1
	private subscriptions: Map<string, Set<(value: PubSubValue) => void>> = new Map()

	constructor(
		private args: {
			config: ClientConfig
			onChange: (key: string, value: PubSubValue) => void
			onStart: () => void
		}
	) {
		this.connect()

		window.addEventListener("online", () => {
			this.reconnectAttempt = 1
			this.connect()
		})
	}

	private connect() {
		debug("connecting...")
		this.ws = new WebSocket(`ws://${this.args.config.host}`)

		this.ws.onopen = () => {
			debug("connected!")
			this.reconnectAttempt = 1
			this.args.onStart()
			
			// Resubscribe to all previous subscriptions
			for (const key of this.subscriptions.keys()) {
				this.send({ type: "subscribe", key })
			}
		}

		this.ws.onmessage = (event) => {
			const message = JSON.parse(event.data as string) as ServerPubsubMessage
			debug("<", message.type, message.key, message.value)
			
			// Call the global onChange handler
			this.args.onChange(message.key, message.value)
			
			// Call individual subscription callbacks
			const callbacks = this.subscriptions.get(message.key)
			if (callbacks) {
				for (const callback of callbacks) {
					callback(message.value)
				}
			}
		}

		this.ws.onerror = (error) => {
			debug("error", error)
		}
		
		this.ws.onclose = () => {
			debug("closed")
			void this.attemptReconnect()
		}
	}

	private async attemptReconnect() {
		if (!navigator.onLine) return

		await sleep(2 ** this.reconnectAttempt * SecondMs)
		this.reconnectAttempt += 1
		this.connect()
	}

	private send(message: ClientPubsubMessage) {
		if (this.ws.readyState === WebSocket.OPEN) {
			debug(">", message.type, message.key)
			this.ws.send(JSON.stringify(message))
		}
	}

	subscribe(key: string, callback?: (value: PubSubValue) => void) {
		// Add to subscriptions map
		if (callback) {
			if (!this.subscriptions.has(key)) {
				this.subscriptions.set(key, new Set())
			}
			this.subscriptions.get(key)?.add(callback)
		}
		
		// Send subscribe message
		this.send({ type: "subscribe", key })
		
		// Return unsubscribe function
		return () => this.unsubscribe(key, callback)
	}

	unsubscribe(key: string, callback?: (value: PubSubValue) => void) {
		// Remove from subscriptions map
		if (callback && this.subscriptions.has(key)) {
			this.subscriptions.get(key)?.delete(callback)
			if ((this.subscriptions.get(key)?.size ?? 0) === 0) {
				this.subscriptions.delete(key)
				// Only send unsubscribe if no more callbacks for this key
				this.send({ type: "unsubscribe", key })
			}
		} else if (!callback) {
			// If no callback provided, remove all subscriptions for this key
			this.subscriptions.delete(key)
			this.send({ type: "unsubscribe", key })
		}
	}
	
	close() {
		if (this.ws) {
			this.ws.close()
		}
	}
}

================================================================================
File: test\base.e2e.ts
Lines: 27
--------------------------------------------------------------------------------
import { Page, test } from "@playwright/test"

async function waitFor(page: Page, selector: string) {
	const element = await page.waitForSelector(selector)
	if (!element) throw new Error("Element not found: " + selector)
	return element
}

export async function write(page: Page, selector: string, value: string) {
	const input = await waitFor(page, selector)
	await input.fill(value)
	await input.focus()
	return input
}

export async function click(page: Page, selector: string) {
	const button = await waitFor(page, selector)
	await button.click()
	return button
}

test("Smoke Test", async ({ browser }) => {
	const context = await browser.newContext()
	const page = await context.newPage()
	await page.goto("/")
	await waitFor(page, "body")
})

================================================================================
File: test\base.test.ts
Lines: 10
--------------------------------------------------------------------------------
import { strict as assert } from "assert"
import { describe, it, expect } from "jest"

describe("Unit Testing", () => {
	it("works", () => {
		assert.ok(true)
		assert.equal(1 + 1, 2)
		assert.deepEqual({}, {})
	})
})

================================================================================
File: utils\styleUtils.ts
Lines: 112
--------------------------------------------------------------------------------
/**
 * Merges multiple style objects together
 * @param styles Array of style objects to merge
 * @returns Merged style object
 */
export const mergeStyles = (...styles: (React.CSSProperties | undefined)[]): React.CSSProperties => {
  return Object.assign({}, ...styles.filter(Boolean)) as React.CSSProperties;
};

/**
 * Creates a conditional style object
 * @param condition Boolean condition
 * @param trueStyles Styles to apply if condition is true
 * @param falseStyles Optional styles to apply if condition is false
 * @returns Style object based on condition
 */
export const conditionalStyle = (
  condition: boolean,
  trueStyles: React.CSSProperties,
  falseStyles?: React.CSSProperties
): React.CSSProperties => {
  return condition ? trueStyles : (falseStyles || {});
};

/**
 * Applies styles based on hover state
 * @param isHovered Boolean indicating hover state
 * @param baseStyles Base styles
 * @param hoverStyles Styles to apply when hovered
 * @returns Combined style object
 */
export const applyHoverStyles = (
  isHovered: boolean,
  baseStyles: React.CSSProperties,
  hoverStyles: React.CSSProperties
): React.CSSProperties => {
  return mergeStyles(baseStyles, conditionalStyle(isHovered, hoverStyles));
};

/**
 * Creates a CSS variable string from a variables object
 * @param variables Object containing CSS variable definitions
 * @returns CSS variables as a string
 */
export const createCSSVariables = (variables: Record<string, string>): string => {
  return Object.entries(variables)
    .map(([key, value]) => `--${key}: ${value};`)
    .join(' ');
};

/**
 * Injects global CSS variables into the document
 * @param lightVariables Light theme variables
 * @param darkVariables Dark theme variables
 */
export const injectGlobalCSSVariables = (
  lightVariables: Record<string, string>,
  darkVariables: Record<string, string>
): void => {
  // Create style element
  const styleElement = document.createElement('style');
  
  // Create CSS content
  const cssContent = `
    :root {
      ${createCSSVariables(lightVariables)}
    }
    
    @media (prefers-color-scheme: dark) {
      :root {
        color-scheme: dark;
        ${createCSSVariables(darkVariables)}
      }
    }
    
    @keyframes rotation {
      from {
        transform: rotate(0deg);
      }
      to {
        transform: rotate(360deg);
      }
    }
  `;
  
  // Set style content
  styleElement.textContent = cssContent;
  
  // Append to head
  document.head.appendChild(styleElement);
};

/**
 * Creates a className string from conditional classes
 * @param baseClass Base class name
 * @param conditionalClasses Object with class names as keys and conditions as values
 * @returns Combined class name string
 */
export const classNames = (
  baseClass: string,
  conditionalClasses: Record<string, boolean> = {}
): string => {
  const classes = [baseClass];
  
  Object.entries(conditionalClasses).forEach(([className, condition]) => {
    if (condition) {
      classes.push(className);
    }
  });
  
  return classes.join(' ');
}; 