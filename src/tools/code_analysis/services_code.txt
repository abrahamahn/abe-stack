===========================================================
DATABASE LAYER CODE EXTRACTION
===========================================================

Total Files: 59
Total Lines: 11641

File Listing:
1. app\core\auth\AuthService.ts (588 lines)
2. app\core\auth\EmailVerificationService.ts (387 lines)
3. app\core\auth\MFAService.ts (36 lines)
4. app\core\auth\PasswordService.ts (332 lines)
5. app\core\auth\TokenService.ts (300 lines)
6. app\core\auth\index.ts (8 lines)
7. app\core\auth\types.ts (91 lines)
8. app\core\index.ts (5 lines)
9. app\core\permission\PermissionService.ts (550 lines)
10. app\core\permission\RoleService.ts (491 lines)
11. app\core\permission\index.ts (4 lines)
12. app\core\user\UserPreferencesService.ts (627 lines)
13. app\core\user\UserProfileService.ts (551 lines)
14. app\core\user\UserService.ts (451 lines)
15. app\core\user\index.ts (5 lines)
16. app\email\EmailService.ts (21 lines)
17. app\email\index.ts (3 lines)
18. app\index.ts (5 lines)
19. app\media\MediaService.ts (345 lines)
20. app\media\collection\MediaCollectionService.ts (460 lines)
21. app\media\processor\MediaProcessorService.ts (619 lines)
22. app\social\feed\FeedService.ts (971 lines)
23. app\social\hashtag\HashtagService.ts (477 lines)
24. app\social\hashtag\index.ts (3 lines)
25. app\social\index.ts (7 lines)
26. app\social\interaction\BookmarkService.ts (189 lines)
27. app\social\interaction\CommentService.ts (376 lines)
28. app\social\interaction\FollowService.ts (463 lines)
29. app\social\interaction\LikeService.ts (311 lines)
30. app\social\interaction\index.ts (6 lines)
31. app\social\monitoring\MetricsService.ts (117 lines)
32. app\social\monitoring\index.ts (3 lines)
33. app\social\notification\NotificationService.ts (628 lines)
34. app\social\notification\index.ts (3 lines)
35. app\social\post\PostService.ts (843 lines)
36. app\social\post\index.ts (3 lines)
37. dev\index.ts (4 lines)
38. dev\logger\LoggerService.ts (207 lines)
39. dev\logger\index.ts (2 lines)
40. dev\tests\index.ts (5 lines)
41. index.ts (7 lines)
42. shared\base\BaseService.ts (89 lines)
43. shared\cache\CacheManager.ts (40 lines)
44. shared\cache\PostCacheManager.ts (108 lines)
45. shared\communication\EventEmitter.ts (46 lines)
46. shared\communication\TemplateEngine.ts (17 lines)
47. shared\errors\PostErrors.ts (48 lines)
48. shared\errors\ServiceError.ts (72 lines)
49. shared\errors\ValidationError.ts (15 lines)
50. shared\index.ts (47 lines)
51. shared\security\PostRateLimiter.ts (117 lines)
52. shared\security\ProfanityFilter.ts (25 lines)
53. shared\security\RateLimiter.ts (55 lines)
54. shared\session\SessionManager.ts (63 lines)
55. shared\types\validation.ts (61 lines)
56. shared\validation\ContentValidator.ts (181 lines)
57. shared\validation\UrlValidator.ts (23 lines)
58. shared\validation\ValidationRule.ts (13 lines)
59. shared\validation\commonValidators.ts (117 lines)


===========================================================
FILE 1: app\core\auth\AuthService.ts
===========================================================

import NodeCache from "node-cache";

import { User } from "@models/auth";
import { UserRepository } from "@repositories/auth";
import {
  EmailVerificationService,
  MFAService,
  PasswordService,
  TokenService,
} from "@services/app/core/auth";
import {
  BaseService,
  ValidationRule,
  commonValidators,
  DuplicateResourceError,
  UnauthorizedError,
  TooManyRequestsError,
  RateLimiter,
  SessionManager,
} from "@services/shared";

import {
  RegisterDTO,
  LoginDTO,
  AuthResult,
  PasswordResetRequestDTO,
  PasswordResetConfirmDTO,
  EmailVerificationDTO,
  MFASetupDTO,
  LoginAttempt,
  DeviceInfo,
  SessionInfo,
} from "./types";

/**
 * Service for handling authentication operations with enhanced security
 */
export class AuthService extends BaseService {
  private readonly loginRateLimiter: RateLimiter;
  private readonly resetRateLimiter: RateLimiter;
  private readonly verifyRateLimiter: RateLimiter;
  private readonly sessionManager: SessionManager;
  private readonly loginAttemptsCache: NodeCache;
  private readonly MAX_LOGIN_ATTEMPTS = 5;
  private readonly LOGIN_LOCKOUT_TIME = 15 * 60; // 15 minutes

  constructor(
    private readonly userRepository: UserRepository,
    private readonly tokenService: TokenService,
    private readonly passwordService: PasswordService,
    private readonly emailVerificationService: EmailVerificationService,
    private readonly mfaService: MFAService,
  ) {
    super("AuthService");
    this.loginRateLimiter = new RateLimiter("login", 5, 60); // 5 attempts per minute
    this.resetRateLimiter = new RateLimiter("reset", 3, 60); // 3 attempts per minute
    this.verifyRateLimiter = new RateLimiter("verify", 3, 60); // 3 attempts per minute
    this.sessionManager = new SessionManager();
    this.loginAttemptsCache = new NodeCache({
      stdTTL: this.LOGIN_LOCKOUT_TIME,
    });
  }

  /**
   * Register a new user with enhanced security
   */
  public async register(
    data: RegisterDTO,
    deviceInfo: DeviceInfo,
  ): Promise<AuthResult> {
    try {
      // Validate registration data
      this.validateRegistration(data);

      // Check if email already exists
      const existingUser = await this.userRepository.findByEmail(data.email);
      if (existingUser) {
        throw new DuplicateResourceError("User", "email", data.email);
      }

      // Create user with hashed password and additional security fields
      const hashedPassword = await this.passwordService.hashPassword(
        data.password,
      );
      const user = await this.userRepository.createWithHashedPassword({
        ...data,
        password: hashedPassword,
        role: "user",
        isVerified: false,
        emailConfirmed: false,
        mfaEnabled: false,
        mfaSecret: null,
        lastPasswordChange: new Date(),
        passwordHistory: [],
        securityQuestions: [],
      });

      // Generate verification token and send email
      const verificationToken =
        await this.emailVerificationService.generateVerificationToken(user);
      await this.emailVerificationService.sendVerificationEmail(
        user,
        verificationToken,
      );

      // Create session and generate tokens
      const session = await this.sessionManager.createSession(
        user.id,
        deviceInfo,
      );
      const tokens = this.generateAuthTokens(user, session.id);

      return {
        user,
        ...tokens,
        requiresMFA: false,
        sessionId: session.id,
      };
    } catch (error) {
      this.logger.error("Error in register:", error);
      throw error;
    }
  }

  /**
   * Login user with MFA and session support
   */
  public async login(
    data: LoginDTO,
    deviceInfo: DeviceInfo,
  ): Promise<AuthResult> {
    try {
      // Check rate limiting
      await this.checkLoginRateLimit(data.email);

      // Validate login data
      this.validateLogin(data);

      // Find user by email
      const user = await this.userRepository.findByEmail(data.email);
      if (!user) {
        await this.recordFailedLoginAttempt(data.email);
        throw new UnauthorizedError("Invalid email or password");
      }

      // Check account lockout
      if (await this.isAccountLocked(data.email)) {
        throw new TooManyRequestsError(
          "Account temporarily locked due to too many failed attempts",
        );
      }

      // Verify password
      const isPasswordValid = await this.passwordService.comparePassword(
        data.password,
        user.password,
      );
      if (!isPasswordValid) {
        await this.recordFailedLoginAttempt(data.email);
        throw new UnauthorizedError("Invalid email or password");
      }

      // Reset failed login attempts on successful password verification
      await this.resetLoginAttempts(data.email);

      // Check if MFA is required
      if (user.mfaEnabled && !data.mfaToken) {
        return {
          user,
          token: "",
          refreshToken: "",
          requiresMFA: true,
          tempToken: this.tokenService.generateTempToken(user.id),
        };
      }

      // Verify MFA if enabled
      if (user.mfaEnabled) {
        const isMFAValid = await this.mfaService.verifyToken(
          user.id,
          data.mfaToken!,
        );
        if (!isMFAValid) {
          throw new UnauthorizedError("Invalid MFA token");
        }
      }

      // Create new session
      const session = await this.sessionManager.createSession(
        user.id,
        deviceInfo,
      );
      const tokens = this.generateAuthTokens(user, session.id);

      // Update last login information
      await this.userRepository.update(user.id, {
        lastLoginAt: new Date(),
        lastLoginIp: deviceInfo.ip,
        lastLoginUserAgent: deviceInfo.userAgent,
      });

      return {
        user,
        ...tokens,
        requiresMFA: false,
        sessionId: session.id,
      };
    } catch (error) {
      this.logger.error("Error in login:", error);
      throw error;
    }
  }

  /**
   * Setup MFA for user
   */
  public async setupMFA(userId: string): Promise<MFASetupDTO> {
    try {
      const user = await this.userRepository.findById(userId);
      if (!user) {
        throw new UnauthorizedError("User not found");
      }

      const { secret, qrCode } = await this.mfaService.generateSecret(
        user.email,
      );

      // Store secret temporarily until verification
      await this.mfaService.storeTemporarySecret(userId, secret);

      return {
        secret,
        qrCode,
      };
    } catch (error) {
      this.logger.error("Error in setupMFA:", error);
      throw error;
    }
  }

  /**
   * Verify and enable MFA
   */
  public async verifyAndEnableMFA(
    userId: string,
    token: string,
  ): Promise<boolean> {
    try {
      const user = await this.userRepository.findById(userId);
      if (!user) {
        throw new UnauthorizedError("User not found");
      }

      const tempSecret = await this.mfaService.getTemporarySecret(userId);
      if (!tempSecret) {
        throw new UnauthorizedError("MFA setup expired");
      }

      const isValid = await this.mfaService.verifyToken(
        userId,
        token,
        tempSecret,
      );
      if (!isValid) {
        throw new UnauthorizedError("Invalid MFA token");
      }

      // Enable MFA and store secret permanently
      await this.userRepository.update(userId, {
        mfaEnabled: true,
        mfaSecret: tempSecret,
      });

      await this.mfaService.clearTemporarySecret(userId);
      return true;
    } catch (error) {
      this.logger.error("Error in verifyAndEnableMFA:", error);
      throw error;
    }
  }

  /**
   * Disable MFA
   */
  public async disableMFA(userId: string, token: string): Promise<boolean> {
    try {
      const user = await this.userRepository.findById(userId);
      if (!user) {
        throw new UnauthorizedError("User not found");
      }

      if (!user.mfaEnabled) {
        throw new UnauthorizedError("MFA is not enabled");
      }

      const isValid = await this.mfaService.verifyToken(userId, token);
      if (!isValid) {
        throw new UnauthorizedError("Invalid MFA token");
      }

      await this.userRepository.update(userId, {
        mfaEnabled: false,
        mfaSecret: null,
      });

      return true;
    } catch (error) {
      this.logger.error("Error in disableMFA:", error);
      throw error;
    }
  }

  /**
   * Get all active sessions for a user
   */
  public async getUserSessions(userId: string): Promise<SessionInfo[]> {
    try {
      return await this.sessionManager.getUserSessions(userId);
    } catch (error) {
      this.logger.error("Error in getUserSessions:", error);
      throw error;
    }
  }

  /**
   * Terminate a specific session
   */
  public async terminateSession(
    userId: string,
    sessionId: string,
  ): Promise<boolean> {
    try {
      return await this.sessionManager.terminateSession(userId, sessionId);
    } catch (error) {
      this.logger.error("Error in terminateSession:", error);
      throw error;
    }
  }

  /**
   * Terminate all sessions except current
   */
  public async terminateOtherSessions(
    userId: string,
    currentSessionId: string,
  ): Promise<boolean> {
    try {
      return await this.sessionManager.terminateOtherSessions(
        userId,
        currentSessionId,
      );
    } catch (error) {
      this.logger.error("Error in terminateOtherSessions:", error);
      throw error;
    }
  }

  /**
   * Request password reset with rate limiting
   */
  public async requestPasswordReset(
    data: PasswordResetRequestDTO,
  ): Promise<void> {
    try {
      await this.resetRateLimiter.checkLimit(data.email);

      const user = await this.userRepository.findByEmail(data.email);
      if (!user) {
        // Don't reveal that email doesn't exist
        return;
      }

      const resetToken = await this.passwordService.generateResetToken();
      const resetTokenExpiration =
        this.passwordService.getResetTokenExpiration();

      await this.userRepository.update(user.id, {
        emailToken: resetToken,
        emailTokenExpire: resetTokenExpiration,
      });

      await this.emailVerificationService.sendPasswordResetEmail(
        user,
        resetToken,
      );
    } catch (error) {
      this.logger.error("Error in requestPasswordReset:", error);
      throw error;
    }
  }

  /**
   * Reset password with token
   */
  public async resetPassword(data: PasswordResetConfirmDTO): Promise<void> {
    try {
      const user = await this.userRepository.findByEmailToken(data.token);
      if (
        !user ||
        !user.emailTokenExpire ||
        user.emailTokenExpire < new Date()
      ) {
        throw new UnauthorizedError("Invalid or expired reset token");
      }

      // Validate new password
      if (!this.passwordService.validatePassword(data.newPassword)) {
        throw new UnauthorizedError("Password does not meet requirements");
      }

      // Update password
      const hashedPassword = await this.passwordService.hashPassword(
        data.newPassword,
      );
      const updatedUser = await this.userRepository.update(user.id, {
        password: hashedPassword,
        emailToken: null,
        emailTokenExpire: null,
      });

      if (!updatedUser) {
        throw new UnauthorizedError("Failed to update password");
      }
    } catch (error) {
      this.logger.error("Error in resetPassword:", error);
      throw error;
    }
  }

  /**
   * Verify email
   */
  public async verifyEmail(data: EmailVerificationDTO): Promise<User> {
    try {
      await this.verifyRateLimiter.checkLimit(data.token);
      return await this.emailVerificationService.verifyEmail(data.token);
    } catch (error) {
      this.logger.error("Error in verifyEmail:", error);
      throw error;
    }
  }

  /**
   * Refresh access token
   */
  public async refreshToken(refreshToken: string): Promise<{ token: string }> {
    try {
      const payload = await this.tokenService.verifyRefreshToken(refreshToken);
      const user = await this.userRepository.findById(payload.userId);

      if (!user) {
        throw new UnauthorizedError("User not found");
      }

      const token = this.tokenService.generateToken({
        userId: user.id,
        email: user.email,
        role: user.role,
        sessionId: payload.sessionId,
      });

      return { token };
    } catch (error) {
      this.logger.error("Error in refreshToken:", error);
      throw error;
    }
  }

  /**
   * Check login rate limit
   */
  private async checkLoginRateLimit(identifier: string): Promise<void> {
    await this.loginRateLimiter.checkLimit(identifier);
  }

  /**
   * Record failed login attempt
   */
  private async recordFailedLoginAttempt(identifier: string): Promise<void> {
    const attempts: LoginAttempt[] =
      this.loginAttemptsCache.get(identifier) || [];
    attempts.push({
      timestamp: new Date(),
      successful: false,
    });
    this.loginAttemptsCache.set(identifier, attempts);
  }

  /**
   * Reset login attempts
   */
  private async resetLoginAttempts(identifier: string): Promise<void> {
    this.loginAttemptsCache.del(identifier);
  }

  /**
   * Check if account is locked
   */
  private async isAccountLocked(identifier: string): Promise<boolean> {
    const attempts: LoginAttempt[] =
      this.loginAttemptsCache.get(identifier) || [];
    const recentAttempts = attempts.filter(
      (attempt) =>
        !attempt.successful &&
        attempt.timestamp >
          new Date(Date.now() - this.LOGIN_LOCKOUT_TIME * 1000),
    );
    return recentAttempts.length >= this.MAX_LOGIN_ATTEMPTS;
  }

  /**
   * Generate authentication tokens with session ID
   */
  private generateAuthTokens(
    user: User,
    sessionId: string,
  ): { token: string; refreshToken: string } {
    const payload = {
      userId: user.id,
      email: user.email,
      role: user.role,
      sessionId,
    };

    return {
      token: this.tokenService.generateToken(payload),
      refreshToken: this.tokenService.generateRefreshToken(payload),
    };
  }

  /**
   * Validate registration data
   */
  private validateRegistration(data: RegisterDTO): void {
    const rules: ValidationRule[] = [
      {
        field: "email",
        rules: [
          commonValidators.required("Email"),
          commonValidators.email("Email"),
        ],
      },
      {
        field: "password",
        rules: [
          commonValidators.required("Password"),
          commonValidators.minLength("Password", 8),
          (value) =>
            !this.passwordService.validatePassword(value as string)
              ? "Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character"
              : null,
        ],
      },
      {
        field: "username",
        rules: [
          commonValidators.required("Username"),
          commonValidators.minLength("Username", 3),
          commonValidators.maxLength("Username", 30),
        ],
      },
    ];

    this.validateAndThrow(data, rules);
  }

  /**
   * Validate login data
   */
  private validateLogin(data: LoginDTO): void {
    const rules: ValidationRule[] = [
      {
        field: "email",
        rules: [
          commonValidators.required("Email"),
          commonValidators.email("Email"),
        ],
      },
      {
        field: "password",
        rules: [commonValidators.required("Password")],
      },
    ];

    this.validateAndThrow(data, rules);
  }
}



===========================================================
FILE 2: app\core\auth\EmailVerificationService.ts
===========================================================

import crypto from "crypto";
import path from "path";

import NodeCache from "node-cache";

import { User } from "@models/auth";
import { UserRepository } from "@repositories/auth";
import { EmailService } from "@services/app/email";
import { BaseService, RateLimiter } from "@services/shared";
import { TemplateEngine } from "@services/shared/communication/TemplateEngine";
import {
  ExternalServiceError,
  TooManyRequestsError,
  ValidationError,
} from "@services/shared/errors/ServiceError";

interface EmailTemplate {
  subject: string;
  text: string;
  html: string;
}

interface VerificationAttempt {
  timestamp: Date;
  success: boolean;
  ip?: string;
}

interface EmailVerificationConfig {
  tokenExpiry: number; // hours
  maxAttempts: number; // per time window
  timeWindow: number; // minutes
  resendCooldown: number; // minutes
  templatePath: string;
}

/**
 * Service for handling email verification
 */
export class EmailVerificationService extends BaseService {
  private readonly config: EmailVerificationConfig;
  private readonly rateLimiter: RateLimiter;
  private readonly templateCache: NodeCache;
  private readonly verificationAttempts: NodeCache;
  private readonly userRepository: UserRepository;

  constructor(
    private readonly emailService: EmailService,
    private readonly templateEngine: TemplateEngine,
    userRepository: UserRepository,
  ) {
    super("EmailVerificationService");
    this.userRepository = userRepository;

    this.config = {
      tokenExpiry: parseInt(process.env.EMAIL_VERIFICATION_EXPIRY || "24", 10),
      maxAttempts: parseInt(
        process.env.EMAIL_VERIFICATION_MAX_ATTEMPTS || "5",
        10,
      ),
      timeWindow: parseInt(
        process.env.EMAIL_VERIFICATION_TIME_WINDOW || "60",
        10,
      ),
      resendCooldown: parseInt(
        process.env.EMAIL_VERIFICATION_RESEND_COOLDOWN || "5",
        10,
      ),
      templatePath:
        process.env.EMAIL_TEMPLATE_PATH ||
        path.join(__dirname, "../../../templates/email"),
    };

    this.rateLimiter = new RateLimiter(
      "email_verification",
      this.config.maxAttempts,
      this.config.timeWindow,
    );
    this.templateCache = new NodeCache({ stdTTL: 3600 }); // 1 hour cache for templates
    this.verificationAttempts = new NodeCache({
      stdTTL: this.config.timeWindow * 60,
    }); // Cache for tracking attempts
  }

  /**
   * Generate a verification token for a user
   */
  public async generateVerificationToken(user: User): Promise<string> {
    try {
      const token = await this.generateSecureToken();
      const expiration = this.getTokenExpiration();

      await this.updateUserVerificationToken(user.id, token, expiration);

      return token;
    } catch (error) {
      this.logger.error("Error generating verification token:", error);
      throw new ExternalServiceError(
        "EmailVerification",
        "Failed to generate verification token",
      );
    }
  }

  /**
   * Verify a user's email with a token
   */
  public async verifyEmail(token: string, ip?: string): Promise<User> {
    try {
      // Check verification attempt rate limiting
      await this.checkVerificationRateLimit(ip || "unknown");

      const user = await this.findUserByVerificationToken(token);
      if (!user) {
        await this.recordVerificationAttempt(ip || "unknown", false);
        throw new ValidationError("Invalid verification token");
      }

      if (!user.emailTokenExpire || user.emailTokenExpire < new Date()) {
        await this.recordVerificationAttempt(ip || "unknown", false);
        throw new ValidationError("Verification token has expired");
      }

      // Update user verification status
      await this.updateUserVerificationStatus(user.id);
      await this.recordVerificationAttempt(ip || "unknown", true);

      return user;
    } catch (error) {
      this.logger.error("Error verifying email:", error);
      if (error instanceof ExternalServiceError) {
        throw error;
      }
      throw new ExternalServiceError(
        "EmailVerification",
        "Failed to verify email",
      );
    }
  }

  /**
   * Send verification email
   * Note: This is a placeholder. You'll need to implement actual email sending logic
   */
  public async sendVerificationEmail(user: User, token: string): Promise<void> {
    try {
      // Check rate limiting for email sending
      await this.checkResendRateLimit(user.email);

      const template = await this.getEmailTemplate("verification");
      const verificationUrl = this.generateVerificationUrl(token);

      const emailData = {
        to: user.email,
        subject: template.subject,
        text: this.templateEngine.render(template.text, {
          username: user.username,
          verificationUrl,
          expiryHours: this.config.tokenExpiry,
        }),
        html: this.templateEngine.render(template.html, {
          username: user.username,
          verificationUrl,
          expiryHours: this.config.tokenExpiry,
        }),
      };

      await this.emailService.sendEmail(emailData);
      this.recordEmailSent(user.email);
    } catch (error) {
      this.logger.error("Error sending verification email:", error);
      throw new ExternalServiceError(
        "EmailVerification",
        "Failed to send verification email",
      );
    }
  }

  /**
   * Resend verification email
   */
  public async resendVerificationEmail(userId: string): Promise<void> {
    try {
      const user = await this.userRepository.findById(userId);

      if (!user) {
        throw new ExternalServiceError("EmailVerification", "User not found");
      }

      if (user.emailConfirmed) {
        throw new ExternalServiceError(
          "EmailVerification",
          "Email already verified",
        );
      }

      const token = await this.generateVerificationToken(user);
      await this.sendVerificationEmail(user, token);
    } catch (error) {
      this.logger.error("Error resending verification email:", error);
      if (error instanceof ExternalServiceError) {
        throw error;
      }
      throw new ExternalServiceError(
        "EmailVerification",
        "Failed to resend verification email",
      );
    }
  }

  /**
   * Get email template
   */
  private async getEmailTemplate(templateName: string): Promise<EmailTemplate> {
    const cacheKey = `template:${templateName}`;
    const cachedTemplate = this.templateCache.get<EmailTemplate>(cacheKey);

    if (cachedTemplate) {
      return cachedTemplate;
    }

    try {
      const template = await this.loadEmailTemplate(templateName);
      this.templateCache.set(cacheKey, template);
      return template;
    } catch (error) {
      this.logger.error("Error loading email template:", error);
      throw new Error("Failed to load email template");
    }
  }

  /**
   * Load email template from file system
   */
  private async loadEmailTemplate(
    _templateName: string,
  ): Promise<EmailTemplate> {
    // Implementation would load and parse template files
    // This is a placeholder that would be replaced with actual template loading logic
    return {
      subject: "Verify your email",
      text: "Please verify your email by clicking: {verificationUrl}",
      html: '<p>Please verify your email by clicking: <a href="{verificationUrl}">here</a></p>',
    };
  }

  /**
   * Generate a secure random token
   */
  private async generateSecureToken(): Promise<string> {
    const buffer = await crypto.randomBytes(32);
    return buffer.toString("base64url");
  }

  /**
   * Get token expiration date
   */
  private getTokenExpiration(): Date {
    const expiration = new Date();
    expiration.setHours(expiration.getHours() + this.config.tokenExpiry);
    return expiration;
  }

  /**
   * Generate verification URL
   */
  private generateVerificationUrl(token: string): string {
    const baseUrl = process.env.APP_URL || "http://localhost:3000";
    return `${baseUrl}/verify-email?token=${token}`;
  }

  /**
   * Check verification rate limit
   */
  private async checkVerificationRateLimit(identifier: string): Promise<void> {
    await this.rateLimiter.checkLimit(identifier);
  }

  /**
   * Check resend rate limit
   */
  private async checkResendRateLimit(email: string): Promise<void> {
    const lastSent = this.verificationAttempts.get<Date>(`resend:${email}`);
    if (lastSent) {
      const timeSinceLastSend = Math.floor(
        (Date.now() - lastSent.getTime()) / (1000 * 60),
      );
      if (timeSinceLastSend < this.config.resendCooldown) {
        throw new TooManyRequestsError(
          `Please wait ${this.config.resendCooldown - timeSinceLastSend} minutes before requesting another email`,
        );
      }
    }
  }

  /**
   * Record verification attempt
   */
  private async recordVerificationAttempt(
    identifier: string,
    success: boolean,
  ): Promise<void> {
    const attempts =
      this.verificationAttempts.get<VerificationAttempt[]>(identifier) || [];
    attempts.push({
      timestamp: new Date(),
      success,
      ip: identifier,
    });
    this.verificationAttempts.set(identifier, attempts);
  }

  /**
   * Record email sent
   */
  private recordEmailSent(email: string): void {
    this.verificationAttempts.set(`resend:${email}`, new Date());
  }

  /**
   * Update user verification token
   */
  private async updateUserVerificationToken(
    _userId: string,
    _token: string,
    _expiration: Date,
  ): Promise<void> {
    // Implementation would update user in database
    // This is a placeholder that would be replaced with actual database update
  }

  /**
   * Update user verification status
   */
  private async updateUserVerificationStatus(_userId: string): Promise<void> {
    // Implementation would update user in database
    // This is a placeholder that would be replaced with actual database update
  }

  /**
   * Find user by verification token
   */
  private async findUserByVerificationToken(
    _token: string,
  ): Promise<User | null> {
    // Implementation would query database
    // This is a placeholder that would be replaced with actual database query
    return null;
  }

  /**
   * Send password reset email
   */
  public async sendPasswordResetEmail(
    user: User,
    token: string,
  ): Promise<void> {
    try {
      const template = await this.getEmailTemplate("password-reset");
      const resetUrl = `${process.env.APP_URL || "http://localhost:3000"}/reset-password?token=${token}`;

      const emailData = {
        to: user.email,
        subject: "Reset Your Password",
        text: this.templateEngine.render(template.text, {
          username: user.username,
          resetUrl,
          expiryHours: this.config.tokenExpiry,
        }),
        html: this.templateEngine.render(template.html, {
          username: user.username,
          resetUrl,
          expiryHours: this.config.tokenExpiry,
        }),
      };

      await this.emailService.sendEmail(emailData);
    } catch (error) {
      this.logger.error("Error sending password reset email:", error);
      throw new ExternalServiceError(
        "EmailVerification",
        "Failed to send password reset email",
      );
    }
  }
}



===========================================================
FILE 3: app\core\auth\MFAService.ts
===========================================================

import { authenticator } from "otplib";

export class MFAService {
  private tempSecrets = new Map<string, string>();

  async generateSecret(
    email: string,
  ): Promise<{ secret: string; qrCode: string }> {
    const secret = authenticator.generateSecret();
    const otpauth = authenticator.keyuri(email, "YourApp", secret);
    return { secret, qrCode: otpauth };
  }

  async verifyToken(
    userId: string,
    token: string,
    secret?: string,
  ): Promise<boolean> {
    const mfaSecret = secret || this.tempSecrets.get(userId);
    if (!mfaSecret) return false;
    return authenticator.verify({ token, secret: mfaSecret });
  }

  async storeTemporarySecret(userId: string, secret: string): Promise<void> {
    this.tempSecrets.set(userId, secret);
  }

  async getTemporarySecret(userId: string): Promise<string | undefined> {
    return this.tempSecrets.get(userId);
  }

  async clearTemporarySecret(userId: string): Promise<void> {
    this.tempSecrets.delete(userId);
  }
}



===========================================================
FILE 4: app\core\auth\PasswordService.ts
===========================================================

import crypto from "crypto";

import bcrypt from "bcrypt";
import NodeCache from "node-cache";
import zxcvbn from "zxcvbn";

import { BaseService } from "@services/shared";
import { ValidationError } from "@services/shared/errors/ServiceError";

interface PasswordPolicy {
  minLength: number;
  maxLength: number;
  requireUppercase: boolean;
  requireLowercase: boolean;
  requireNumbers: boolean;
  requireSpecialChars: boolean;
  preventCommonWords: boolean;
  preventPersonalInfo: boolean;
  preventReuse: number; // Number of previous passwords to check
  minAge: number; // Minimum days before password can be changed
  maxAge: number; // Maximum days before password must be changed
  preventPwnedPasswords: boolean;
}

interface PasswordStrengthResult {
  score: number; // 0-4
  feedback: {
    warning?: string;
    suggestions: string[];
  };
  isStrong: boolean;
}

interface PasswordHistoryEntry {
  hash: string;
  timestamp: Date;
}

/**
 * Service for handling password operations with enhanced security
 */
export class PasswordService extends BaseService {
  private readonly saltRounds: number;
  private readonly resetTokenExpiration: number; // in hours
  private readonly policy: PasswordPolicy;
  private readonly breachCache: NodeCache;
  private readonly BREACH_CACHE_TTL = 7 * 24 * 60 * 60; // 7 days

  constructor() {
    super("PasswordService");
    this.saltRounds = parseInt(process.env.SALT_ROUNDS || "10", 10);
    this.resetTokenExpiration = parseInt(
      process.env.RESET_TOKEN_EXPIRATION || "24",
      10,
    );
    this.breachCache = new NodeCache({ stdTTL: this.BREACH_CACHE_TTL });

    // Initialize password policy from environment or use secure defaults
    this.policy = {
      minLength: parseInt(process.env.PASSWORD_MIN_LENGTH || "12", 10),
      maxLength: parseInt(process.env.PASSWORD_MAX_LENGTH || "128", 10),
      requireUppercase: process.env.PASSWORD_REQUIRE_UPPERCASE !== "false",
      requireLowercase: process.env.PASSWORD_REQUIRE_LOWERCASE !== "false",
      requireNumbers: process.env.PASSWORD_REQUIRE_NUMBERS !== "false",
      requireSpecialChars: process.env.PASSWORD_REQUIRE_SPECIAL !== "false",
      preventCommonWords: process.env.PASSWORD_PREVENT_COMMON !== "false",
      preventPersonalInfo: process.env.PASSWORD_PREVENT_PERSONAL !== "false",
      preventReuse: parseInt(process.env.PASSWORD_PREVENT_REUSE || "5", 10),
      minAge: parseInt(process.env.PASSWORD_MIN_AGE || "1", 10),
      maxAge: parseInt(process.env.PASSWORD_MAX_AGE || "90", 10),
      preventPwnedPasswords: process.env.PASSWORD_PREVENT_PWNED !== "false",
    };
  }

  /**
   * Hash a password with additional security measures
   */
  public async hashPassword(password: string): Promise<string> {
    try {
      // Add pepper to password before hashing if configured
      const pepperedPassword = this.addPepper(password);
      return await bcrypt.hash(pepperedPassword, this.saltRounds);
    } catch (error) {
      this.logger.error("Error hashing password:", error);
      throw new Error("Failed to hash password");
    }
  }

  /**
   * Compare a password with a hash
   */
  public async comparePassword(
    password: string,
    hash: string,
  ): Promise<boolean> {
    try {
      const pepperedPassword = this.addPepper(password);
      return await bcrypt.compare(pepperedPassword, hash);
    } catch (error) {
      this.logger.error("Error comparing password:", error);
      throw new Error("Failed to compare password");
    }
  }

  /**
   * Validate password against all security policies
   */
  public async validatePassword(
    password: string,
    personalInfo?: { email?: string; username?: string; name?: string },
    passwordHistory?: PasswordHistoryEntry[],
    lastChanged?: Date,
  ): Promise<PasswordStrengthResult> {
    try {
      const errors: string[] = [];

      // Check basic requirements
      if (password.length < this.policy.minLength) {
        errors.push(
          `Password must be at least ${this.policy.minLength} characters long`,
        );
      }
      if (password.length > this.policy.maxLength) {
        errors.push(
          `Password must be less than ${this.policy.maxLength} characters long`,
        );
      }
      if (this.policy.requireUppercase && !/[A-Z]/.test(password)) {
        errors.push("Password must contain at least one uppercase letter");
      }
      if (this.policy.requireLowercase && !/[a-z]/.test(password)) {
        errors.push("Password must contain at least one lowercase letter");
      }
      if (this.policy.requireNumbers && !/\d/.test(password)) {
        errors.push("Password must contain at least one number");
      }
      if (this.policy.requireSpecialChars && !/[^A-Za-z0-9]/.test(password)) {
        errors.push("Password must contain at least one special character");
      }

      // Check password age if lastChanged is provided
      if (lastChanged) {
        const daysSinceChange = Math.floor(
          (Date.now() - lastChanged.getTime()) / (1000 * 60 * 60 * 24),
        );
        if (daysSinceChange < this.policy.minAge) {
          errors.push(
            `Password cannot be changed within ${this.policy.minAge} days of last change`,
          );
        }
      }

      // Check password history
      if (passwordHistory && passwordHistory.length > 0) {
        const isReused = await this.checkPasswordHistory(
          password,
          passwordHistory,
        );
        if (isReused) {
          errors.push(
            `Password cannot be reused from last ${this.policy.preventReuse} passwords`,
          );
        }
      }

      // Check for common passwords and patterns using zxcvbn
      const strengthAnalysis = zxcvbn(
        password,
        personalInfo
          ? ([
              personalInfo.email,
              personalInfo.username,
              personalInfo.name,
            ].filter(Boolean) as string[])
          : undefined,
      );

      if (this.policy.preventCommonWords && strengthAnalysis.score < 3) {
        errors.push("Password is too common or easily guessable");
      }

      // Check if password has been exposed in data breaches
      if (this.policy.preventPwnedPasswords) {
        const isExposed = await this.checkPwnedPassword(password);
        if (isExposed) {
          errors.push("This password has been exposed in data breaches");
        }
      }

      return {
        score: strengthAnalysis.score,
        feedback: {
          warning: strengthAnalysis.feedback.warning,
          suggestions: [...errors, ...strengthAnalysis.feedback.suggestions],
        },
        isStrong: errors.length === 0 && strengthAnalysis.score >= 3,
      };
    } catch (error) {
      this.logger.error("Error validating password:", error);
      throw new ValidationError("Failed to validate password");
    }
  }

  /**
   * Generate a cryptographically secure reset token
   */
  public async generateResetToken(): Promise<string> {
    try {
      const buffer = await crypto.randomBytes(32);
      return buffer.toString("base64url");
    } catch (error) {
      this.logger.error("Error generating reset token:", error);
      throw new Error("Failed to generate reset token");
    }
  }

  /**
   * Get token expiration date
   */
  public getResetTokenExpiration(): Date {
    const expiration = new Date();
    expiration.setHours(expiration.getHours() + this.resetTokenExpiration);
    return expiration;
  }

  /**
   * Generate a strong temporary password
   */
  public generateTemporaryPassword(): string {
    const length = this.policy.minLength;
    const uppercase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    const lowercase = "abcdefghijklmnopqrstuvwxyz";
    const numbers = "0123456789";
    const special = "@$!%*?&#";

    let password = "";

    // Ensure at least one character from each required set
    password += uppercase[crypto.randomInt(0, uppercase.length)];
    password += lowercase[crypto.randomInt(0, lowercase.length)];
    password += numbers[crypto.randomInt(0, numbers.length)];
    password += special[crypto.randomInt(0, special.length)];

    // Fill the rest with random characters from all sets
    const allChars = uppercase + lowercase + numbers + special;
    for (let i = password.length; i < length; i++) {
      password += allChars[crypto.randomInt(0, allChars.length)];
    }

    // Shuffle the password
    return password
      .split("")
      .sort(() => Math.random() - 0.5)
      .join("");
  }

  /**
   * Get current password policy
   */
  public getPasswordPolicy(): PasswordPolicy {
    return { ...this.policy };
  }

  /**
   * Check if a password exists in password history
   */
  private async checkPasswordHistory(
    password: string,
    history: PasswordHistoryEntry[],
  ): Promise<boolean> {
    const recentHistory = history.slice(-this.policy.preventReuse);

    for (const entry of recentHistory) {
      if (await this.comparePassword(password, entry.hash)) {
        return true;
      }
    }

    return false;
  }

  /**
   * Check if a password has been exposed in known data breaches
   */
  private async checkPwnedPassword(password: string): Promise<boolean> {
    try {
      const hash = crypto
        .createHash("sha1")
        .update(password)
        .digest("hex")
        .toUpperCase();
      const prefix = hash.slice(0, 5);
      const suffix = hash.slice(5);

      // Check cache first
      const cacheKey = `pwned:${prefix}`;
      const cachedResult = this.breachCache.get<string[]>(cacheKey);

      if (cachedResult) {
        return cachedResult.includes(suffix);
      }

      // Make API request to haveibeenpwned.com
      const response = await fetch(
        `https://api.pwnedpasswords.com/range/${prefix}`,
      );
      if (!response.ok) {
        throw new Error("Failed to check password breach status");
      }

      const text = await response.text();
      const hashes = text.split("\n").map((line) => line.split(":")[0]);

      // Cache the results
      this.breachCache.set(cacheKey, hashes);

      return hashes.includes(suffix);
    } catch (error) {
      this.logger.error("Error checking pwned password:", error);
      return false; // Fail open if the service is unavailable
    }
  }

  /**
   * Add pepper to password if configured
   */
  private addPepper(password: string): string {
    const pepper = process.env.PASSWORD_PEPPER;
    return pepper ? `${password}${pepper}` : password;
  }
}



===========================================================
FILE 5: app\core\auth\TokenService.ts
===========================================================

import crypto from "crypto";

import jwt from "jsonwebtoken";
import NodeCache from "node-cache";

import { TokenRepository } from "@repositories/auth";
import { BaseService, UnauthorizedError } from "@services/shared";

interface TokenPayload {
  userId: string;
  email: string;
  role: string;
  sessionId: string;
  tokenId?: string;
  deviceInfo?: {
    ip: string;
    userAgent: string;
  };
}

interface TokenMetadata {
  issuedAt: number;
  expiresAt: number;
  deviceInfo?: {
    ip: string;
    userAgent: string;
  };
}

/**
 * Service for handling JWT token operations with enhanced security
 */
export class TokenService extends BaseService {
  private readonly tokenBlacklist: NodeCache;
  private readonly TOKEN_SECRET: string;
  private readonly REFRESH_TOKEN_SECRET: string;
  private readonly ACCESS_TOKEN_EXPIRY = "15m";
  private readonly REFRESH_TOKEN_EXPIRY = "7d";
  private readonly TEMP_TOKEN_EXPIRY = "5m";
  private readonly ROTATION_WINDOW = 60 * 5; // 5 minutes in seconds

  constructor(
    private readonly tokenRepository: TokenRepository,
    tokenSecret?: string,
    refreshTokenSecret?: string,
  ) {
    super("TokenService");
    this.TOKEN_SECRET =
      tokenSecret || process.env.JWT_SECRET || this.generateSecret();
    this.REFRESH_TOKEN_SECRET =
      refreshTokenSecret ||
      process.env.JWT_REFRESH_SECRET ||
      this.generateSecret();
    this.tokenBlacklist = new NodeCache({ stdTTL: 24 * 60 * 60 }); // 24 hours TTL
  }

  /**
   * Generate a new access token
   */
  public generateToken(payload: Omit<TokenPayload, "tokenId">): string {
    const tokenId = crypto.randomUUID();
    const token = jwt.sign({ ...payload, tokenId }, this.TOKEN_SECRET, {
      expiresIn: this.ACCESS_TOKEN_EXPIRY,
      algorithm: "HS512",
      audience: process.env.JWT_AUDIENCE,
      issuer: process.env.JWT_ISSUER,
      jwtid: tokenId,
    });

    // Store token metadata
    this.storeTokenMetadata(tokenId, {
      issuedAt: Date.now(),
      expiresAt: Date.now() + this.parseExpiry(this.ACCESS_TOKEN_EXPIRY),
      deviceInfo: payload.deviceInfo,
    });

    return token;
  }

  /**
   * Generate a new refresh token
   */
  public generateRefreshToken(payload: Omit<TokenPayload, "tokenId">): string {
    const tokenId = crypto.randomUUID();
    const token = jwt.sign({ ...payload, tokenId }, this.REFRESH_TOKEN_SECRET, {
      expiresIn: this.REFRESH_TOKEN_EXPIRY,
      algorithm: "HS512",
      audience: process.env.JWT_AUDIENCE,
      issuer: process.env.JWT_ISSUER,
      jwtid: tokenId,
    });

    // Store refresh token in database
    this.tokenRepository.create({
      id: tokenId,
      userId: payload.userId,
      type: "refresh",
      expiresAt: new Date(
        Date.now() + this.parseExpiry(this.REFRESH_TOKEN_EXPIRY),
      ),
      sessionId: payload.sessionId,
    });

    return token;
  }

  /**
   * Generate a temporary token for MFA verification
   */
  public generateTempToken(userId: string): string {
    const tokenId = crypto.randomUUID();
    return jwt.sign({ userId, tokenId, type: "temp" }, this.TOKEN_SECRET, {
      expiresIn: this.TEMP_TOKEN_EXPIRY,
      algorithm: "HS512",
      audience: process.env.JWT_AUDIENCE,
      issuer: process.env.JWT_ISSUER,
      jwtid: tokenId,
    });
  }

  /**
   * Verify and decode an access token
   */
  public verifyToken(token: string): TokenPayload {
    try {
      const decoded = jwt.verify(token, this.TOKEN_SECRET, {
        algorithms: ["HS512"],
        audience: process.env.JWT_AUDIENCE,
        issuer: process.env.JWT_ISSUER,
      }) as TokenPayload;

      // Check if token is blacklisted
      if (this.isTokenBlacklisted(decoded.tokenId!)) {
        throw new UnauthorizedError("Token has been revoked");
      }

      return decoded;
    } catch (error) {
      if (error instanceof jwt.TokenExpiredError) {
        throw new UnauthorizedError("Token has expired");
      }
      throw new UnauthorizedError("Invalid token");
    }
  }

  /**
   * Verify and decode a refresh token
   */
  public async verifyRefreshToken(token: string): Promise<TokenPayload> {
    try {
      const decoded = jwt.verify(token, this.REFRESH_TOKEN_SECRET, {
        algorithms: ["HS512"],
        audience: process.env.JWT_AUDIENCE,
        issuer: process.env.JWT_ISSUER,
      }) as TokenPayload;

      // Check if refresh token exists and is valid
      const storedToken = await this.tokenRepository.findById(decoded.tokenId!);
      if (
        !storedToken ||
        storedToken.isRevoked() ||
        storedToken.expiresAt < new Date()
      ) {
        throw new UnauthorizedError("Invalid refresh token");
      }

      return decoded;
    } catch (error) {
      if (error instanceof jwt.TokenExpiredError) {
        throw new UnauthorizedError("Refresh token has expired");
      }
      throw new UnauthorizedError("Invalid refresh token");
    }
  }

  /**
   * Verify a temporary token
   */
  public verifyTempToken(token: string): { userId: string } {
    try {
      const decoded = jwt.verify(token, this.TOKEN_SECRET, {
        algorithms: ["HS512"],
        audience: process.env.JWT_AUDIENCE,
        issuer: process.env.JWT_ISSUER,
      }) as { userId: string; type: string };

      if (decoded.type !== "temp") {
        throw new UnauthorizedError("Invalid token type");
      }

      return { userId: decoded.userId };
    } catch (error) {
      if (error instanceof jwt.TokenExpiredError) {
        throw new UnauthorizedError("Temporary token has expired");
      }
      throw new UnauthorizedError("Invalid temporary token");
    }
  }

  /**
   * Rotate refresh token
   */
  public async rotateRefreshToken(
    oldToken: string,
  ): Promise<{ token: string; refreshToken: string }> {
    const decoded = await this.verifyRefreshToken(oldToken);

    // Check if token is within rotation window
    const storedToken = await this.tokenRepository.findById(decoded.tokenId!);
    const now = Date.now();
    const tokenAge = now - storedToken!.createdAt.getTime();

    if (tokenAge < this.ROTATION_WINDOW * 1000) {
      throw new UnauthorizedError("Token rotation not allowed yet");
    }

    // Revoke old refresh token
    await this.revokeRefreshToken(decoded.tokenId!);

    // Generate new tokens
    const newToken = this.generateToken(decoded);
    const newRefreshToken = this.generateRefreshToken(decoded);

    return {
      token: newToken,
      refreshToken: newRefreshToken,
    };
  }

  /**
   * Revoke a refresh token
   */
  public async revokeRefreshToken(tokenId: string): Promise<boolean> {
    const token = await this.tokenRepository.findById(tokenId);
    if (!token) {
      return false;
    }

    await this.tokenRepository.update(tokenId, { isRevoked: true });
    return true;
  }

  /**
   * Revoke all refresh tokens for a user
   */
  public async revokeAllUserTokens(userId: string): Promise<boolean> {
    await this.tokenRepository.revokeAllUserTokens(userId);
    return true;
  }

  /**
   * Blacklist an access token
   */
  public blacklistToken(tokenId: string): void {
    this.tokenBlacklist.set(tokenId, true);
  }

  /**
   * Check if a token is blacklisted
   */
  private isTokenBlacklisted(tokenId: string): boolean {
    return this.tokenBlacklist.has(tokenId);
  }

  /**
   * Store token metadata
   */
  private storeTokenMetadata(tokenId: string, metadata: TokenMetadata): void {
    this.tokenBlacklist.set(`metadata:${tokenId}`, metadata);
  }

  /**
   * Parse expiry string to milliseconds
   */
  private parseExpiry(expiry: string): number {
    const unit = expiry.slice(-1);
    const value = parseInt(expiry.slice(0, -1));

    switch (unit) {
      case "s":
        return value * 1000;
      case "m":
        return value * 60 * 1000;
      case "h":
        return value * 60 * 60 * 1000;
      case "d":
        return value * 24 * 60 * 60 * 1000;
      default:
        return value;
    }
  }

  /**
   * Generate a secure random secret
   */
  private generateSecret(): string {
    return crypto.randomBytes(64).toString("hex");
  }
}



===========================================================
FILE 6: app\core\auth\index.ts
===========================================================

// Export auth services
export * from "./AuthService";
export * from "./EmailVerificationService";
export * from "./MFAService";
export * from "./PasswordService";
export * from "./TokenService";
export * from "./types";



===========================================================
FILE 7: app\core\auth\types.ts
===========================================================

import { User } from "@models/auth";

/**
 * Registration request data
 */
export interface RegisterDTO {
  username: string;
  email: string;
  password: string;
  firstName?: string;
  lastName?: string;
}

/**
 * Login request data
 */
export interface LoginDTO {
  email: string;
  password: string;
  mfaToken?: string;
}

/**
 * Password reset request data
 */
export interface PasswordResetRequestDTO {
  email: string;
}

/**
 * Password reset confirmation data
 */
export interface PasswordResetConfirmDTO {
  token: string;
  newPassword: string;
}

/**
 * Email verification data
 */
export interface EmailVerificationDTO {
  token: string;
}

/**
 * Authentication result containing user and token
 */
export interface AuthResult {
  user: User;
  token: string;
  refreshToken: string;
  requiresMFA?: boolean;
  sessionId?: string;
  tempToken?: string;
}

/**
 * Token payload structure
 */
export interface TokenPayload {
  userId: string;
  email: string;
  role: string;
  iat?: number;
  exp?: number;
}

export interface MFASetupDTO {
  secret: string;
  qrCode: string;
}

export interface LoginAttempt {
  timestamp: Date;
  successful: boolean;
}

export interface DeviceInfo {
  ip: string;
  userAgent: string;
  deviceId?: string;
}

export interface SessionInfo {
  id: string;
  userId: string;
  deviceInfo: DeviceInfo;
  createdAt: Date;
  lastActiveAt: Date;
}



===========================================================
FILE 8: app\core\index.ts
===========================================================

// Export core service modules
export * from "./user";
export * from "./permission";
export * from "./auth";



===========================================================
FILE 9: app\core\permission\PermissionService.ts
===========================================================

import NodeCache from "node-cache";

import { Permission, PermissionAttributes } from "@models/auth";
import {
  PermissionRepository,
  RolePermissionRepository,
} from "@repositories/auth";
import { Logger } from "@services/dev/logger";

import { RoleService } from "./RoleService";

/**
 * Interface for permission pattern
 */
interface PermissionPattern {
  resource: string;
  action: string;
  scope?: string;
  isWildcard: boolean;
}

/**
 * Interface for permission validation rules
 */
interface PermissionValidationRules {
  allowedResources: string[];
  allowedActions: Record<string, string[]>;
  allowedScopes: string[];
}

/**
 * Interface for permission analytics
 */
interface PermissionAnalytics {
  totalPermissions: number;
  permissionsByResource: Record<string, number>;
  permissionsByAction: Record<string, number>;
  mostUsedPermissions: Array<{ permission: string; count: number }>;
  unusedPermissions: string[];
  permissionDensity: number;
  averagePermissionsPerRole: number;
  wildcardUsage: {
    total: number;
    byResource: Record<string, number>;
  };
}

/**
 * Interface for permission context
 */
interface PermissionContext {
  userId?: string;
  targetId?: string;
  [key: string]: unknown;
}

/**
 * Default permission validation rules
 */
const DEFAULT_VALIDATION_RULES: PermissionValidationRules = {
  allowedResources: [
    "user",
    "role",
    "permission",
    "content",
    "comment",
    "profile",
    "system",
  ],
  allowedActions: {
    user: ["create", "read", "update", "delete", "list", "search"],
    role: ["create", "read", "update", "delete", "list", "assign", "remove"],
    permission: [
      "create",
      "read",
      "update",
      "delete",
      "list",
      "assign",
      "remove",
    ],
    content: [
      "create",
      "read",
      "update",
      "delete",
      "list",
      "publish",
      "unpublish",
    ],
    comment: ["create", "read", "update", "delete", "list", "moderate"],
    profile: ["read", "update", "delete"],
    system: ["configure", "monitor", "backup", "restore"],
  },
  allowedScopes: ["self", "team", "organization", "all"],
};

/**
 * Service responsible for permission management operations.
 * This service handles:
 * 1. Permission CRUD operations
 * 2. Permission assignment to roles
 * 3. Permission checking and validation
 * 4. Permission pattern matching
 * 5. Permission inheritance
 * 6. Permission analytics
 */
export class PermissionService {
  private logger: Logger;
  private cache: NodeCache;
  private validationRules: PermissionValidationRules;

  constructor(
    private readonly permissionRepository: PermissionRepository,
    private readonly rolePermissionRepository: RolePermissionRepository,
    private readonly roleService: RoleService,
  ) {
    this.logger = new Logger("PermissionService");
    this.cache = new NodeCache({ stdTTL: 300 }); // 5 minutes cache
    this.validationRules = DEFAULT_VALIDATION_RULES;
  }

  /**
   * Create a new permission
   * @param data The permission data
   * @returns The created permission
   */
  async createPermission(
    data: Partial<PermissionAttributes>,
  ): Promise<Permission> {
    this.logger.debug("Creating new permission", { data });

    // Parse and validate permission pattern
    const pattern = this.parsePermissionPattern(data.name!);
    this.validatePermissionPattern(pattern);

    // Check if permission already exists
    const existingPermission = await this.getPermissionByName(data.name!);
    if (existingPermission) {
      throw new Error(`Permission '${data.name}' already exists`);
    }

    const permission = await this.permissionRepository.create(data);
    this.invalidatePermissionCache(permission);

    return permission;
  }

  /**
   * Get a permission by ID with caching
   * @param id The permission ID
   * @returns The permission or null if not found
   */
  async getPermissionById(id: string): Promise<Permission | null> {
    this.logger.debug("Getting permission by ID", { id });

    const cacheKey = `permission:${id}`;
    const cachedPermission = this.cache.get<Permission>(cacheKey);
    if (cachedPermission) {
      return cachedPermission;
    }

    const permission = await this.permissionRepository.findByPk(id);
    if (permission) {
      this.cache.set(cacheKey, permission);
    }

    return permission;
  }

  /**
   * Get a permission by name with caching
   * @param name The permission name
   * @returns The permission or null if not found
   */
  async getPermissionByName(name: string): Promise<Permission | null> {
    this.logger.debug("Getting permission by name", { name });

    const cacheKey = `permission:name:${name}`;
    const cachedPermission = this.cache.get<Permission>(cacheKey);
    if (cachedPermission) {
      return cachedPermission;
    }

    const pattern = this.parsePermissionPattern(name);
    const permission = await this.permissionRepository.findByResourceAndAction(
      pattern.resource,
      pattern.action,
    );

    if (permission) {
      this.cache.set(cacheKey, permission);
      this.cache.set(`permission:${permission.id}`, permission);
    }

    return permission;
  }

  /**
   * Update a permission
   * @param id The permission ID
   * @param data The permission data to update
   * @returns The updated permission or null if not found
   */
  async updatePermission(
    id: string,
    data: Partial<PermissionAttributes>,
  ): Promise<Permission | null> {
    this.logger.debug("Updating permission", { id, data });

    const permission = await this.getPermissionById(id);
    if (!permission) {
      return null;
    }

    // Validate new permission name if provided
    if (data.name) {
      const pattern = this.parsePermissionPattern(data.name);
      this.validatePermissionPattern(pattern);

      // Check if new name conflicts with existing permission
      const existingPermission = await this.getPermissionByName(data.name);
      if (existingPermission && existingPermission.id !== id) {
        throw new Error(`Permission '${data.name}' already exists`);
      }
    }

    const updatedPermission = await this.permissionRepository.update(id, data);
    if (updatedPermission) {
      this.invalidatePermissionCache(updatedPermission);
    }

    return updatedPermission;
  }

  /**
   * Delete a permission
   * @param id The permission ID
   * @returns True if permission was deleted
   */
  async deletePermission(id: string): Promise<boolean> {
    this.logger.debug("Deleting permission", { id });

    const permission = await this.getPermissionById(id);
    if (!permission) {
      return false;
    }

    const deleted = await this.permissionRepository.delete(id);
    if (deleted) {
      this.invalidatePermissionCache(permission);
    }

    return deleted;
  }

  /**
   * Assign a permission to a role
   * @param roleId The role ID
   * @param permissionId The permission ID
   * @returns True if permission was assigned
   */
  async assignPermissionToRole(
    roleId: string,
    permissionId: string,
  ): Promise<boolean> {
    this.logger.debug("Assigning permission to role", { roleId, permissionId });

    const [role, permission] = await Promise.all([
      this.roleService.getRoleById(roleId),
      this.getPermissionById(permissionId),
    ]);

    if (!role) {
      throw new Error("Role not found");
    }

    if (!permission) {
      throw new Error("Permission not found");
    }

    return this.rolePermissionRepository.assignPermission(roleId, permissionId);
  }

  /**
   * Remove a permission from a role
   * @param roleId The role ID
   * @param permissionId The permission ID
   * @returns True if permission was removed
   */
  async removePermissionFromRole(
    roleId: string,
    permissionId: string,
  ): Promise<boolean> {
    this.logger.debug("Removing permission from role", {
      roleId,
      permissionId,
    });

    const [role, permission] = await Promise.all([
      this.roleService.getRoleById(roleId),
      this.getPermissionById(permissionId),
    ]);

    if (!role) {
      throw new Error("Role not found");
    }

    if (!permission) {
      throw new Error("Permission not found");
    }

    return this.rolePermissionRepository.removePermission(roleId, permissionId);
  }

  /**
   * Check if a user has a specific permission
   * @param userId The user ID
   * @param permissionName The permission name to check
   * @param context Additional context for permission check
   * @returns True if user has the permission
   */
  async checkUserPermission(
    userId: string,
    permissionName: string,
    context: PermissionContext = {},
  ): Promise<boolean> {
    this.logger.debug("Checking user permission", {
      userId,
      permissionName,
      context,
    });

    const roles = await this.roleService.getUserInheritedRoles(userId);
    const targetPattern = this.parsePermissionPattern(permissionName);

    for (const role of roles) {
      const permissions = await this.getRolePermissions(role.id);

      for (const permission of permissions) {
        const permPattern = this.parsePermissionPattern(permission.name);

        if (this.matchPermissionPattern(permPattern, targetPattern, context)) {
          return true;
        }
      }
    }

    return false;
  }

  /**
   * Get all permissions assigned to a role
   * @param roleId The role ID
   * @returns Array of permissions
   */
  async getRolePermissions(roleId: string): Promise<Permission[]> {
    this.logger.debug("Getting role permissions", { roleId });

    const cacheKey = `role:${roleId}:permissions`;
    const cachedPermissions = this.cache.get<Permission[]>(cacheKey);
    if (cachedPermissions) {
      return cachedPermissions;
    }

    const permissions =
      await this.rolePermissionRepository.findPermissionsForRole(roleId);
    this.cache.set(cacheKey, permissions);

    return permissions;
  }

  /**
   * Get permission analytics
   * @returns Permission analytics data
   */
  async getPermissionAnalytics(): Promise<PermissionAnalytics> {
    this.logger.debug("Getting permission analytics");

    const permissions = await this.permissionRepository.findAll();
    const rolePermissions = await this.rolePermissionRepository.findAll();
    const roles = await this.roleService.getRoleAnalytics();

    const permissionsByResource: Record<string, number> = {};
    const permissionsByAction: Record<string, number> = {};
    const wildcardsByResource: Record<string, number> = {};
    let totalWildcards = 0;

    permissions.forEach((permission) => {
      const pattern = this.parsePermissionPattern(permission.name);

      // Count by resource
      permissionsByResource[pattern.resource] =
        (permissionsByResource[pattern.resource] || 0) + 1;

      // Count by action
      permissionsByAction[pattern.action] =
        (permissionsByAction[pattern.action] || 0) + 1;

      // Count wildcards
      if (pattern.isWildcard) {
        totalWildcards++;
        wildcardsByResource[pattern.resource] =
          (wildcardsByResource[pattern.resource] || 0) + 1;
      }
    });

    // Calculate permission usage
    const permissionUsage = new Map<string, number>();
    rolePermissions.forEach((rp) => {
      const count = permissionUsage.get(rp.permissionId) || 0;
      permissionUsage.set(rp.permissionId, count + 1);
    });

    const sortedUsage = Array.from(permissionUsage.entries())
      .map(([permissionId, count]) => {
        const permission = permissions.find((p) => p.id === permissionId);
        return { permission: permission?.name || permissionId, count };
      })
      .sort((a, b) => b.count - a.count);

    const unusedPermissions = permissions
      .filter((p) => !permissionUsage.has(p.id))
      .map((p) => p.name);

    return {
      totalPermissions: permissions.length,
      permissionsByResource,
      permissionsByAction,
      mostUsedPermissions: sortedUsage.slice(0, 5),
      unusedPermissions,
      permissionDensity:
        rolePermissions.length / (permissions.length * roles.totalRoles),
      averagePermissionsPerRole: rolePermissions.length / roles.totalRoles,
      wildcardUsage: {
        total: totalWildcards,
        byResource: wildcardsByResource,
      },
    };
  }

  /**
   * Parse a permission pattern from a permission name
   * @param name The permission name
   * @returns The parsed permission pattern
   */
  private parsePermissionPattern(name: string): PermissionPattern {
    const parts = name.split(".");
    const isWildcard = parts.some((p) => p === "*");

    if (parts.length < 2) {
      throw new Error(
        "Invalid permission format. Expected: resource.action[.scope]",
      );
    }

    return {
      resource: parts[0],
      action: parts[1],
      scope: parts[2],
      isWildcard,
    };
  }

  /**
   * Validate a permission pattern
   * @param pattern The permission pattern to validate
   * @throws Error if pattern is invalid
   */
  private validatePermissionPattern(pattern: PermissionPattern): void {
    if (pattern.isWildcard) {
      return; // Skip validation for wildcard permissions
    }

    if (!this.validationRules.allowedResources.includes(pattern.resource)) {
      throw new Error(
        `Invalid resource '${pattern.resource}'. Allowed: ${this.validationRules.allowedResources.join(", ")}`,
      );
    }

    const allowedActions =
      this.validationRules.allowedActions[pattern.resource];
    if (!allowedActions?.includes(pattern.action)) {
      throw new Error(
        `Invalid action '${pattern.action}' for resource '${pattern.resource}'. Allowed: ${allowedActions?.join(", ")}`,
      );
    }

    if (
      pattern.scope &&
      !this.validationRules.allowedScopes.includes(pattern.scope)
    ) {
      throw new Error(
        `Invalid scope '${pattern.scope}'. Allowed: ${this.validationRules.allowedScopes.join(", ")}`,
      );
    }
  }

  /**
   * Match a permission pattern against a target pattern
   * @param pattern The permission pattern to check
   * @param target The target pattern to match against
   * @param context Additional context for matching
   * @returns True if patterns match
   */
  private matchPermissionPattern(
    pattern: PermissionPattern,
    target: PermissionPattern,
    context: PermissionContext,
  ): boolean {
    // Check resource match
    if (pattern.resource !== "*" && pattern.resource !== target.resource) {
      return false;
    }

    // Check action match
    if (pattern.action !== "*" && pattern.action !== target.action) {
      return false;
    }

    // Check scope match if present
    if (pattern.scope && target.scope && pattern.scope !== "*") {
      if (pattern.scope === "self" && context.userId !== context.targetId) {
        return false;
      }
      if (pattern.scope !== target.scope) {
        return false;
      }
    }

    return true;
  }

  /**
   * Invalidate permission cache
   * @param permission Permission to invalidate cache for
   */
  private invalidatePermissionCache(permission: Permission): void {
    this.cache.del(`permission:${permission.id}`);
    this.cache.del(`permission:name:${permission.name}`);

    // Invalidate role permissions cache for all roles
    this.cache.keys().forEach((key) => {
      if (key.startsWith("role:") && key.endsWith(":permissions")) {
        this.cache.del(key);
      }
    });
  }
}



===========================================================
FILE 10: app\core\permission\RoleService.ts
===========================================================

import NodeCache from "node-cache";

import { Role, RoleAttributes } from "@models/auth";
import { RoleRepository, UserRoleRepository } from "@repositories/auth";
import { Logger } from "@services/dev/logger";

/**
 * Interface for role hierarchy
 */
interface RoleHierarchy {
  parentRole: string;
  childRoles: string[];
  level: number;
}

/**
 * Interface for role analytics
 */
interface RoleAnalytics {
  totalRoles: number;
  totalUsers: number;
  rolesDistribution: Record<string, number>;
  averageRolesPerUser: number;
  hierarchyDepth: number;
  mostUsedRoles: Array<{ role: string; count: number }>;
  leastUsedRoles: Array<{ role: string; count: number }>;
  roleHierarchy: Record<string, RoleHierarchy>;
}

/**
 * Interface for role template
 */
interface RoleTemplate {
  name: string;
  description: string;
  permissions: string[];
  inheritsFrom?: string;
  isSystem?: boolean;
}

/**
 * Default system roles
 */
const SYSTEM_ROLES: RoleTemplate[] = [
  {
    name: "admin",
    description: "System administrator with full access",
    permissions: ["*"],
    isSystem: true,
  },
  {
    name: "moderator",
    description: "Content moderator with elevated access",
    permissions: [
      "user.read",
      "user.update",
      "content.read",
      "content.update",
      "content.delete",
      "comment.read",
      "comment.update",
      "comment.delete",
    ],
    inheritsFrom: "user",
    isSystem: true,
  },
  {
    name: "user",
    description: "Standard user with basic access",
    permissions: [
      "user.read.self",
      "user.update.self",
      "content.read",
      "content.create",
      "content.update.self",
      "content.delete.self",
      "comment.create",
      "comment.read",
      "comment.update.self",
      "comment.delete.self",
    ],
    isSystem: true,
  },
  {
    name: "guest",
    description: "Guest user with limited access",
    permissions: ["content.read", "comment.read"],
    isSystem: true,
  },
];

/**
 * Service responsible for role management operations.
 * This service handles:
 * 1. Role CRUD operations
 * 2. Role assignment and removal
 * 3. Role hierarchy management
 * 4. Role inheritance
 * 5. Role analytics
 * 6. System role management
 */
export class RoleService {
  private logger: Logger;
  private cache: NodeCache;
  private roleHierarchy: Map<string, RoleHierarchy>;

  constructor(
    private readonly roleRepository: RoleRepository,
    private readonly userRoleRepository: UserRoleRepository,
  ) {
    this.logger = new Logger("RoleService");
    this.cache = new NodeCache({ stdTTL: 300 }); // 5 minutes cache
    this.roleHierarchy = new Map();
  }

  /**
   * Initialize the role hierarchy
   */
  private async initializeRoleHierarchy(): Promise<void> {
    this.logger.debug("Initializing role hierarchy");

    const roles = await this.roleRepository.findAll();
    this.roleHierarchy.clear();

    // First pass: Create hierarchy entries
    roles.forEach((role) => {
      this.roleHierarchy.set(role.id, {
        parentRole: "",
        childRoles: [],
        level: 0,
      });
    });

    // Second pass: Build relationships and calculate levels
    roles.forEach((role) => {
      if (role.inheritsFrom) {
        const hierarchy = this.roleHierarchy.get(role.id);
        const parentHierarchy = this.roleHierarchy.get(role.inheritsFrom);

        if (hierarchy && parentHierarchy) {
          hierarchy.parentRole = role.inheritsFrom;
          hierarchy.level = parentHierarchy.level + 1;
          parentHierarchy.childRoles.push(role.id);
        }
      }
    });
  }

  /**
   * Get a role by ID with caching
   * @param id The role ID
   * @returns The role or null if not found
   */
  async getRoleById(id: string): Promise<Role | null> {
    this.logger.debug("Getting role by ID", { id });

    const cacheKey = `role:${id}`;
    const cachedRole = this.cache.get<Role>(cacheKey);
    if (cachedRole) {
      return cachedRole;
    }

    const role = await this.roleRepository.findByPk(id);
    if (role) {
      this.cache.set(cacheKey, role);
    }

    return role;
  }

  /**
   * Get a role by name with caching
   * @param name The role name
   * @returns The role or null if not found
   */
  async getRoleByName(name: string): Promise<Role | null> {
    this.logger.debug("Getting role by name", { name });

    const cacheKey = `role:name:${name}`;
    const cachedRole = this.cache.get<Role>(cacheKey);
    if (cachedRole) {
      return cachedRole;
    }

    const role = await this.roleRepository.findByName(name);
    if (role) {
      this.cache.set(cacheKey, role);
      this.cache.set(`role:${role.id}`, role);
    }

    return role;
  }

  /**
   * Create a new role with inheritance
   * @param data The role data
   * @returns The created role
   */
  async createRole(data: Partial<RoleAttributes>): Promise<Role> {
    this.logger.debug("Creating new role", { data });

    // Validate role name uniqueness
    const existingRole = await this.getRoleByName(data.name!);
    if (existingRole) {
      throw new Error(`Role with name '${data.name}' already exists`);
    }

    // Validate parent role if specified
    if (data.inheritsFrom) {
      const parentRole = await this.getRoleById(data.inheritsFrom);
      if (!parentRole) {
        throw new Error("Parent role not found");
      }
    }

    const role = await this.roleRepository.create(data);
    await this.initializeRoleHierarchy();
    this.invalidateRoleCache(role);

    return role;
  }

  /**
   * Update a role
   * @param id The role ID
   * @param data The role data to update
   * @returns The updated role or null if not found
   */
  async updateRole(
    id: string,
    data: Partial<RoleAttributes>,
  ): Promise<Role | null> {
    this.logger.debug("Updating role", { id, data });

    const role = await this.getRoleById(id);
    if (!role) {
      return null;
    }

    // Prevent modification of system roles
    if (role.isSystem) {
      throw new Error("System roles cannot be modified");
    }

    // Validate name uniqueness if changing name
    if (data.name && data.name !== role.name) {
      const existingRole = await this.getRoleByName(data.name);
      if (existingRole) {
        throw new Error(`Role with name '${data.name}' already exists`);
      }
    }

    // Validate parent role if changing inheritance
    if (data.inheritsFrom && data.inheritsFrom !== role.inheritsFrom) {
      const parentRole = await this.getRoleById(data.inheritsFrom);
      if (!parentRole) {
        throw new Error("Parent role not found");
      }
      // Prevent circular inheritance
      if (await this.isCircularInheritance(id, data.inheritsFrom)) {
        throw new Error("Circular role inheritance detected");
      }
    }

    const updatedRole = await this.roleRepository.update(id, data);
    if (updatedRole) {
      await this.initializeRoleHierarchy();
      this.invalidateRoleCache(updatedRole);
    }

    return updatedRole;
  }

  /**
   * Delete a role
   * @param id The role ID
   * @returns True if role was deleted
   */
  async deleteRole(id: string): Promise<boolean> {
    this.logger.debug("Deleting role", { id });

    const role = await this.getRoleById(id);
    if (!role) {
      return false;
    }

    // Prevent deletion of system roles
    if (role.isSystem) {
      throw new Error("System roles cannot be deleted");
    }

    // Check if role has child roles
    const hierarchy = this.roleHierarchy.get(id);
    if (hierarchy && hierarchy.childRoles.length > 0) {
      throw new Error("Cannot delete role with child roles");
    }

    const deleted = await this.roleRepository.delete(id);
    if (deleted) {
      await this.initializeRoleHierarchy();
      this.invalidateRoleCache(role);
    }

    return deleted;
  }

  /**
   * Assign a role to a user
   * @param userId The user ID
   * @param roleId The role ID
   * @returns True if role was assigned
   */
  async assignRoleToUser(userId: string, roleId: string): Promise<boolean> {
    this.logger.debug("Assigning role to user", { userId, roleId });

    const role = await this.getRoleById(roleId);
    if (!role) {
      throw new Error("Role not found");
    }

    const result = await this.userRoleRepository.assignRole(userId, roleId);
    return !!result;
  }

  /**
   * Remove a role from a user
   * @param userId The user ID
   * @param roleId The role ID
   * @returns True if role was removed
   */
  async removeRoleFromUser(userId: string, roleId: string): Promise<boolean> {
    this.logger.debug("Removing role from user", { userId, roleId });

    const role = await this.getRoleById(roleId);
    if (!role) {
      throw new Error("Role not found");
    }

    // Prevent removal of last role
    const userRoles = await this.userRoleRepository.findRolesForUser(userId);
    if (userRoles.length === 1 && userRoles[0].id === roleId) {
      throw new Error("Cannot remove the last role from a user");
    }

    return this.userRoleRepository.removeRole(userId, roleId);
  }

  /**
   * Get all roles assigned to a user
   * @param userId The user ID
   * @returns Array of roles
   */
  async getUserRoles(userId: string): Promise<Role[]> {
    this.logger.debug("Getting user roles", { userId });
    return this.userRoleRepository.findRolesForUser(userId);
  }

  /**
   * Get all inherited roles for a user
   * @param userId The user ID
   * @returns Array of roles including inherited roles
   */
  async getUserInheritedRoles(userId: string): Promise<Role[]> {
    this.logger.debug("Getting user inherited roles", { userId });

    const directRoles = await this.getUserRoles(userId);
    const inheritedRoles = new Set<Role>();

    for (const role of directRoles) {
      inheritedRoles.add(role);
      await this.addInheritedRoles(role, inheritedRoles);
    }

    return Array.from(inheritedRoles);
  }

  /**
   * Initialize system roles
   */
  async initializeSystemRoles(): Promise<void> {
    this.logger.debug("Initializing system roles");

    for (const template of SYSTEM_ROLES) {
      const existingRole = await this.getRoleByName(template.name);
      if (!existingRole) {
        const roleData: Partial<RoleAttributes> = {
          name: template.name,
          description: template.description,
          isSystem: template.isSystem,
          inheritsFrom: template.inheritsFrom,
        };
        await this.createRole(roleData);
      }
    }

    await this.initializeRoleHierarchy();
  }

  /**
   * Get role analytics
   * @returns Role analytics data
   */
  async getRoleAnalytics(): Promise<RoleAnalytics> {
    this.logger.debug("Getting role analytics");

    const roles = await this.roleRepository.findAll();
    const userRoles = await this.userRoleRepository.findAll();
    const totalUsers = new Set(userRoles.map((ur) => ur.userId)).size;

    const rolesDistribution: Record<string, number> = {};
    roles.forEach((role) => {
      rolesDistribution[role.name] = userRoles.filter(
        (ur) => ur.roleId === role.id,
      ).length;
    });

    const sortedRoles = Object.entries(rolesDistribution)
      .map(([role, count]) => ({ role, count }))
      .sort((a, b) => b.count - a.count);

    return {
      totalRoles: roles.length,
      totalUsers,
      rolesDistribution,
      averageRolesPerUser: userRoles.length / totalUsers,
      hierarchyDepth: Math.max(
        ...Array.from(this.roleHierarchy.values()).map((h) => h.level),
      ),
      mostUsedRoles: sortedRoles.slice(0, 5),
      leastUsedRoles: sortedRoles.slice(-5).reverse(),
      roleHierarchy: Object.fromEntries(this.roleHierarchy),
    };
  }

  /**
   * Check for circular inheritance
   * @param roleId The role ID
   * @param parentId The parent role ID
   * @returns True if circular inheritance is detected
   */
  private async isCircularInheritance(
    roleId: string,
    parentId: string,
  ): Promise<boolean> {
    const visited = new Set<string>();
    let currentId = parentId;

    while (currentId) {
      if (currentId === roleId) {
        return true;
      }
      if (visited.has(currentId)) {
        return false;
      }
      visited.add(currentId);

      const role = await this.getRoleById(currentId);
      currentId = role?.inheritsFrom || "";
    }

    return false;
  }

  /**
   * Add inherited roles recursively
   * @param role The role to process
   * @param inheritedRoles Set of inherited roles
   */
  private async addInheritedRoles(
    role: Role,
    inheritedRoles: Set<Role>,
  ): Promise<void> {
    if (role.inheritsFrom) {
      const parentRole = await this.getRoleById(role.inheritsFrom);
      if (parentRole && !inheritedRoles.has(parentRole)) {
        inheritedRoles.add(parentRole);
        await this.addInheritedRoles(parentRole, inheritedRoles);
      }
    }
  }

  /**
   * Invalidate role cache
   * @param role Role to invalidate cache for
   */
  private invalidateRoleCache(role: Role): void {
    this.cache.del(`role:${role.id}`);
    this.cache.del(`role:name:${role.name}`);
  }
}



===========================================================
FILE 11: app\core\permission\index.ts
===========================================================

// Export permission services
export * from "./PermissionService";
export * from "./RoleService";



===========================================================
FILE 12: app\core\user\UserPreferencesService.ts
===========================================================

import NodeCache from "node-cache";

import { UserPreferences, UserPreferencesAttributes } from "@models/auth";
import { UserPreferencesRepository } from "@repositories/auth";
import { Logger } from "@services/dev/logger";

import { UserService } from "./UserService";

/**
 * Interface for user notification preferences
 */
interface NotificationPreferences {
  emailNotifications: boolean;
  pushNotifications: boolean;
  mentionNotifications: boolean;
  commentNotifications: boolean;
  followNotifications: boolean;
  messageNotifications: boolean;
  emailDigestFrequency: "never" | "daily" | "weekly" | "monthly";
  notificationSound: boolean;
  desktopNotifications: boolean;
}

/**
 * Interface for user privacy preferences
 */
interface PrivacyPreferences {
  profileVisibility: "public" | "private" | "friends";
  showOnlineStatus: boolean;
  allowMessagesFrom: "everyone" | "friends" | "none";
  showActivityStatus: boolean;
  showLastSeen: boolean;
  allowTagging: boolean;
  allowFriendRequests: boolean;
}

/**
 * Interface for user theme preferences
 */
interface ThemePreferences {
  theme: "light" | "dark" | "system";
  fontSize: "small" | "medium" | "large";
  reducedMotion: boolean;
  highContrast: boolean;
  customColors?: {
    primary: string;
    secondary: string;
    background: string;
  };
}

/**
 * Interface for user accessibility preferences
 */
interface AccessibilityPreferences {
  screenReader: boolean;
  keyboardNavigation: boolean;
  colorBlindMode: "none" | "protanopia" | "deuteranopia" | "tritanopia";
  textToSpeech: boolean;
  captionsEnabled: boolean;
}

/**
 * Interface for all user preferences
 */
interface IUserPreferences {
  userId: string;
  notifications: NotificationPreferences;
  privacy: PrivacyPreferences;
  theme: ThemePreferences;
  accessibility: AccessibilityPreferences;
  language: string;
  timezone: string;
  updatedAt: Date;
}

/**
 * Interface for preference validation rules
 */
interface PreferenceValidationRules<T = unknown> {
  allowedValues?: T[];
  minValue?: number;
  maxValue?: number;
  pattern?: RegExp;
  customValidator?: (value: T) => boolean;
}

/**
 * Interface for preference analytics
 */
interface PreferenceAnalytics {
  totalUsers: number;
  themeDistribution: Record<string, number>;
  notificationStats: {
    emailEnabled: number;
    pushEnabled: number;
    averageEnabledTypes: number;
  };
  privacyStats: {
    privateProfiles: number;
    publicProfiles: number;
    averagePrivacyLevel: number;
  };
  accessibilityUsage: {
    screenReaderEnabled: number;
    colorBlindModeEnabled: number;
    keyboardNavigationEnabled: number;
  };
  languageDistribution: Record<string, number>;
  timezoneDistribution: Record<string, number>;
}

/**
 * Default preferences for new users
 */
const DEFAULT_PREFERENCES: Omit<IUserPreferences, "userId" | "updatedAt"> = {
  notifications: {
    emailNotifications: true,
    pushNotifications: true,
    mentionNotifications: true,
    commentNotifications: true,
    followNotifications: true,
    messageNotifications: true,
    emailDigestFrequency: "weekly",
    notificationSound: true,
    desktopNotifications: false,
  },
  privacy: {
    profileVisibility: "public",
    showOnlineStatus: true,
    allowMessagesFrom: "everyone",
    showActivityStatus: true,
    showLastSeen: true,
    allowTagging: true,
    allowFriendRequests: true,
  },
  theme: {
    theme: "system",
    fontSize: "medium",
    reducedMotion: false,
    highContrast: false,
  },
  accessibility: {
    screenReader: false,
    keyboardNavigation: false,
    colorBlindMode: "none",
    textToSpeech: false,
    captionsEnabled: false,
  },
  language: "en",
  timezone: "UTC",
};

/**
 * Service responsible for managing user preferences.
 * This service handles:
 * 1. Notification preferences
 * 2. Privacy settings
 * 3. Theme preferences
 * 4. Accessibility settings
 * 5. Language and timezone settings
 * 6. Preference inheritance and defaults
 * 7. Preference analytics
 */
export class UserPreferencesService {
  private logger: Logger;
  private cache: NodeCache;
  private readonly validationRules: Record<string, PreferenceValidationRules> =
    {
      language: {
        pattern: /^[a-z]{2}(-[A-Z]{2})?$/,
        allowedValues: [
          "en",
          "es",
          "fr",
          "de",
          "it",
          "pt",
          "ru",
          "zh",
          "ja",
          "ko",
        ],
      },
      timezone: {
        customValidator: (value: unknown) => {
          if (typeof value !== "string") return false;
          try {
            Intl.DateTimeFormat(undefined, { timeZone: value });
            return true;
          } catch {
            return false;
          }
        },
      },
      "theme.fontSize": {
        allowedValues: ["small", "medium", "large"],
      },
      "theme.theme": {
        allowedValues: ["light", "dark", "system"],
      },
      "notifications.emailDigestFrequency": {
        allowedValues: ["never", "daily", "weekly", "monthly"],
      },
      "privacy.profileVisibility": {
        allowedValues: ["public", "private", "friends"],
      },
      "privacy.allowMessagesFrom": {
        allowedValues: ["everyone", "friends", "none"],
      },
      "accessibility.colorBlindMode": {
        allowedValues: ["none", "protanopia", "deuteranopia", "tritanopia"],
      },
    };

  constructor(
    private readonly userService: UserService,
    private readonly preferencesRepository: UserPreferencesRepository,
  ) {
    this.logger = new Logger("UserPreferencesService");
    this.cache = new NodeCache({ stdTTL: 300 }); // 5 minutes cache
  }

  /**
   * Get user preferences with caching
   * @param userId The user ID
   * @returns The user's preferences
   */
  async getPreferences(userId: string): Promise<IUserPreferences> {
    this.logger.debug("Getting user preferences", { userId });

    const cacheKey = `preferences:${userId}`;
    const cachedPrefs = this.cache.get<IUserPreferences>(cacheKey);
    if (cachedPrefs) {
      return cachedPrefs;
    }

    // Check if user exists
    const user = await this.userService.getUserById(userId);
    if (!user) {
      this.logger.warn("User not found for preferences retrieval", { userId });
      throw new Error("User not found");
    }

    // Get preferences from storage or create default
    let preferences = await this.preferencesRepository.findByUserId(userId);
    if (!preferences) {
      preferences = new UserPreferences({
        userId,
        ...DEFAULT_PREFERENCES,
        updatedAt: new Date(),
      });
      await this.preferencesRepository.create(preferences);
    }

    this.cache.set(cacheKey, preferences);
    return preferences;
  }

  /**
   * Update notification preferences with validation
   * @param userId The user ID
   * @param preferences The notification preferences to update
   * @returns The updated preferences
   */
  async updateNotificationPreferences(
    userId: string,
    preferences: Partial<NotificationPreferences>,
  ): Promise<IUserPreferences> {
    this.logger.debug("Updating notification preferences", {
      userId,
      preferences,
    });

    const userPrefs = await this.getPreferences(userId);
    const updatedPrefs = {
      ...userPrefs,
      notifications: {
        ...userPrefs.notifications,
        ...preferences,
      },
      updatedAt: new Date(),
    };

    // Validate notification preferences
    this.validatePreferences("notifications", updatedPrefs.notifications);

    await this.preferencesRepository.update(userId, updatedPrefs);
    this.cache.del(`preferences:${userId}`);

    return updatedPrefs;
  }

  /**
   * Update privacy preferences with validation
   * @param userId The user ID
   * @param preferences The privacy preferences to update
   * @returns The updated preferences
   */
  async updatePrivacyPreferences(
    userId: string,
    preferences: Partial<PrivacyPreferences>,
  ): Promise<IUserPreferences> {
    this.logger.debug("Updating privacy preferences", { userId, preferences });

    const userPrefs = await this.getPreferences(userId);
    const updatedPrefs = {
      ...userPrefs,
      privacy: {
        ...userPrefs.privacy,
        ...preferences,
      },
      updatedAt: new Date(),
    };

    // Validate privacy preferences
    this.validatePreferences("privacy", updatedPrefs.privacy);

    await this.preferencesRepository.update(userId, updatedPrefs);
    this.cache.del(`preferences:${userId}`);

    return updatedPrefs;
  }

  /**
   * Update theme preferences with validation
   * @param userId The user ID
   * @param preferences The theme preferences to update
   * @returns The updated preferences
   */
  async updateThemePreferences(
    userId: string,
    preferences: Partial<ThemePreferences>,
  ): Promise<IUserPreferences> {
    this.logger.debug("Updating theme preferences", { userId, preferences });

    const userPrefs = await this.getPreferences(userId);
    const updatedPrefs = {
      ...userPrefs,
      theme: {
        ...userPrefs.theme,
        ...preferences,
      },
      updatedAt: new Date(),
    };

    // Validate theme preferences
    this.validatePreferences("theme", updatedPrefs.theme);

    await this.preferencesRepository.update(userId, updatedPrefs);
    this.cache.del(`preferences:${userId}`);

    return updatedPrefs;
  }

  /**
   * Update accessibility preferences with validation
   * @param userId The user ID
   * @param preferences The accessibility preferences to update
   * @returns The updated preferences
   */
  async updateAccessibilityPreferences(
    userId: string,
    preferences: Partial<AccessibilityPreferences>,
  ): Promise<IUserPreferences> {
    this.logger.debug("Updating accessibility preferences", {
      userId,
      preferences,
    });

    const userPrefs = await this.getPreferences(userId);
    const updatedPrefs = {
      ...userPrefs,
      accessibility: {
        ...userPrefs.accessibility,
        ...preferences,
      },
      updatedAt: new Date(),
    };

    // Validate accessibility preferences
    this.validatePreferences("accessibility", updatedPrefs.accessibility);

    await this.preferencesRepository.update(userId, updatedPrefs);
    this.cache.del(`preferences:${userId}`);

    return updatedPrefs;
  }

  /**
   * Update language preference with validation
   * @param userId The user ID
   * @param language The language code
   * @returns The updated preferences
   */
  async updateLanguage(
    userId: string,
    language: string,
  ): Promise<IUserPreferences> {
    this.logger.debug("Updating language preference", { userId, language });

    // Validate language code
    this.validateField("language", language);

    const userPrefs = await this.getPreferences(userId);
    const updatedPrefs = {
      ...userPrefs,
      language,
      updatedAt: new Date(),
    };

    await this.preferencesRepository.update(userId, updatedPrefs);
    this.cache.del(`preferences:${userId}`);

    return updatedPrefs;
  }

  /**
   * Update timezone preference with validation
   * @param userId The user ID
   * @param timezone The timezone
   * @returns The updated preferences
   */
  async updateTimezone(
    userId: string,
    timezone: string,
  ): Promise<IUserPreferences> {
    this.logger.debug("Updating timezone preference", { userId, timezone });

    // Validate timezone
    this.validateField("timezone", timezone);

    const userPrefs = await this.getPreferences(userId);
    const updatedPrefs = {
      ...userPrefs,
      timezone,
      updatedAt: new Date(),
    };

    await this.preferencesRepository.update(userId, updatedPrefs);
    this.cache.del(`preferences:${userId}`);

    return updatedPrefs;
  }

  /**
   * Reset preferences to default values
   * @param userId The user ID
   * @returns The reset preferences
   */
  async resetPreferences(userId: string): Promise<IUserPreferences> {
    this.logger.debug("Resetting user preferences", { userId });

    // Check if user exists
    const user = await this.userService.getUserById(userId);
    if (!user) {
      this.logger.warn("User not found for preferences reset", { userId });
      throw new Error("User not found");
    }

    const preferences = new UserPreferences({
      userId,
      ...DEFAULT_PREFERENCES,
      updatedAt: new Date(),
    });

    await this.preferencesRepository.update(userId, preferences);
    this.cache.del(`preferences:${userId}`);

    return preferences;
  }

  /**
   * Delete user preferences
   * @param userId The user ID
   * @returns True if preferences were deleted
   */
  async deletePreferences(userId: string): Promise<boolean> {
    this.logger.debug("Deleting user preferences", { userId });

    const deleted = await this.preferencesRepository.delete(userId);
    if (deleted) {
      this.cache.del(`preferences:${userId}`);
    }

    return deleted;
  }

  /**
   * Get preference analytics
   * @returns Preference analytics data
   */
  async getPreferenceAnalytics(): Promise<PreferenceAnalytics> {
    this.logger.debug("Getting preference analytics");

    const allPreferences = await this.preferencesRepository.findAll();
    const totalUsers = allPreferences.length;

    const themeDistribution: Record<string, number> = {};
    const languageDistribution: Record<string, number> = {};
    const timezoneDistribution: Record<string, number> = {};
    let emailEnabled = 0;
    let pushEnabled = 0;
    let totalNotificationTypes = 0;
    let privateProfiles = 0;
    let publicProfiles = 0;
    let totalPrivacyLevel = 0;
    let screenReaderEnabled = 0;
    let colorBlindModeEnabled = 0;
    let keyboardNavigationEnabled = 0;

    allPreferences.forEach((prefs) => {
      // Theme stats
      themeDistribution[prefs.theme.theme] =
        (themeDistribution[prefs.theme.theme] || 0) + 1;

      // Language stats
      languageDistribution[prefs.language] =
        (languageDistribution[prefs.language] || 0) + 1;

      // Timezone stats
      timezoneDistribution[prefs.timezone] =
        (timezoneDistribution[prefs.timezone] || 0) + 1;

      // Notification stats
      if (prefs.notifications.emailNotifications) emailEnabled++;
      if (prefs.notifications.pushNotifications) pushEnabled++;
      totalNotificationTypes += Object.values(prefs.notifications).filter(
        (v) => v === true,
      ).length;

      // Privacy stats
      if (prefs.privacy.profileVisibility === "private") privateProfiles++;
      if (prefs.privacy.profileVisibility === "public") publicProfiles++;
      totalPrivacyLevel += Object.values(prefs.privacy).filter(
        (v) => v === false,
      ).length;

      // Accessibility stats
      if (prefs.accessibility.screenReader) screenReaderEnabled++;
      if (prefs.accessibility.colorBlindMode !== "none")
        colorBlindModeEnabled++;
      if (prefs.accessibility.keyboardNavigation) keyboardNavigationEnabled++;
    });

    return {
      totalUsers,
      themeDistribution,
      notificationStats: {
        emailEnabled,
        pushEnabled,
        averageEnabledTypes: totalNotificationTypes / totalUsers,
      },
      privacyStats: {
        privateProfiles,
        publicProfiles,
        averagePrivacyLevel: totalPrivacyLevel / totalUsers,
      },
      accessibilityUsage: {
        screenReaderEnabled,
        colorBlindModeEnabled,
        keyboardNavigationEnabled,
      },
      languageDistribution,
      timezoneDistribution,
    };
  }

  /**
   * Validate preferences for a specific section
   * @param section The preference section
   * @param preferences The preferences to validate
   * @throws Error if validation fails
   */
  private validatePreferences<T extends keyof UserPreferencesAttributes>(
    section: T,
    preferences: UserPreferencesAttributes[T],
  ): void {
    Object.entries(preferences as Record<string, unknown>).forEach(
      ([key, value]) => {
        const fieldPath = `${section}.${key}`;
        if (this.validationRules[fieldPath]) {
          this.validateField(fieldPath, value);
        }
      },
    );
  }

  /**
   * Validate a preference field
   * @param field The field to validate
   * @param value The value to validate
   * @throws Error if validation fails
   */
  private validateField<T>(field: string, value: T): void {
    const rules = this.validationRules[field];
    if (!rules) return;

    if (rules.allowedValues && !rules.allowedValues.includes(value)) {
      throw new Error(
        `Invalid value for ${field}. Allowed values: ${rules.allowedValues.join(", ")}`,
      );
    }

    if (
      rules.pattern &&
      typeof value === "string" &&
      !rules.pattern.test(value)
    ) {
      throw new Error(`Invalid format for ${field}`);
    }

    if (rules.customValidator && !rules.customValidator(value)) {
      throw new Error(`Invalid value for ${field}`);
    }

    if (typeof value === "number") {
      if (rules.minValue !== undefined && value < rules.minValue) {
        throw new Error(`${field} must be at least ${rules.minValue}`);
      }
      if (rules.maxValue !== undefined && value > rules.maxValue) {
        throw new Error(`${field} must be at most ${rules.maxValue}`);
      }
    }
  }
}



===========================================================
FILE 13: app\core\user\UserProfileService.ts
===========================================================

import NodeCache from "node-cache";
import sanitizeHtml from "sanitize-html";

import { User, UserAttributes } from "@models/auth";
import { UserRepository } from "@repositories/auth";
import { Logger } from "@services/dev/logger/LoggerService";

import { UserService } from "./UserService";

/**
 * Interface for profile validation rules
 */
interface ProfileValidationRules {
  minLength: number;
  maxLength: number;
  allowedTags?: string[];
  allowedAttributes?: { [key: string]: string[] };
}

/**
 * Interface for profile analytics
 */
interface ProfileAnalytics {
  totalProfiles: number;
  averageCompletionRate: number;
  completionByField: Record<string, number>;
  profileUpdatesLastWeek: number;
  mostCommonFields: Array<{ field: string; count: number }>;
  missingFieldsDistribution: Record<string, number>;
}

/**
 * Service responsible for user profile operations.
 * This service handles:
 * 1. Profile data management (display name, bio, etc.)
 * 2. Profile image management
 * 3. Profile visibility and privacy
 * 4. Profile completion status
 * 5. Profile validation and sanitization
 * 6. Profile analytics
 */
export class ProfileService {
  private logger: Logger;
  private cache: NodeCache;
  private readonly validationRules: Record<
    keyof UserAttributes,
    ProfileValidationRules
  > = {
    displayName: { minLength: 2, maxLength: 50 },
    firstName: { minLength: 2, maxLength: 50 },
    lastName: { minLength: 2, maxLength: 50 },
    bio: {
      minLength: 0,
      maxLength: 500,
      allowedTags: ["b", "i", "em", "strong", "a"],
      allowedAttributes: {
        a: ["href", "title"],
      },
    },
    profileImage: { minLength: 0, maxLength: 255 },
    bannerImage: { minLength: 0, maxLength: 255 },
  };

  constructor(
    private readonly userService: UserService,
    private readonly userRepository: UserRepository,
  ) {
    this.logger = new Logger("ProfileService");
    this.cache = new NodeCache({ stdTTL: 300 }); // 5 minutes cache
  }

  /**
   * Get a user's public profile with caching
   * @param userId The user ID
   * @returns The user's public profile or null if not found
   */
  async getProfile(userId: string): Promise<Partial<User> | null> {
    this.logger.debug("Getting user profile", { userId });

    const cacheKey = `profile:${userId}`;
    const cachedProfile = this.cache.get<Partial<User>>(cacheKey);
    if (cachedProfile) {
      return cachedProfile;
    }

    const user = await this.userService.getUserById(userId);
    if (!user) {
      this.logger.warn("User not found for profile retrieval", { userId });
      return null;
    }

    // Return only public profile fields
    const profile = {
      id: user.id,
      username: user.username,
      displayName: user.displayName,
      firstName: user.firstName,
      lastName: user.lastName,
      bio: user.bio,
      profileImage: user.profileImage,
      bannerImage: user.bannerImage,
      createdAt: user.createdAt,
      updatedAt: user.updatedAt,
    };

    this.cache.set(cacheKey, profile);
    return profile;
  }

  /**
   * Update profile information with validation and sanitization
   * @param userId The user ID
   * @param profileData The profile data to update
   * @returns The updated profile or null if not found
   * @throws Error if validation fails
   */
  async updateProfile(
    userId: string,
    profileData: Partial<UserAttributes>,
  ): Promise<User | null> {
    this.logger.debug("Updating user profile", { userId, profileData });

    // Only allow updating profile-specific fields
    const allowedFields: (keyof UserAttributes)[] = [
      "displayName",
      "firstName",
      "lastName",
      "bio",
      "profileImage",
      "bannerImage",
    ];

    // Validate and sanitize each field
    const sanitizedData = Object.keys(profileData).reduce((acc, key) => {
      if (allowedFields.includes(key as keyof UserAttributes)) {
        const value = profileData[key as keyof UserAttributes];
        if (value !== undefined) {
          // Validate field
          this.validateField(key as keyof UserAttributes, value);
          // Sanitize field
          acc[key] = this.sanitizeField(key as keyof UserAttributes, value);
        }
      }
      return acc;
    }, {} as Partial<UserAttributes>);

    const updatedUser = await this.userService.updateProfile(
      userId,
      sanitizedData,
    );
    if (updatedUser) {
      this.cache.del(`profile:${userId}`);
    }

    return updatedUser;
  }

  /**
   * Update profile image
   * @param userId The user ID
   * @param imageUrl The new profile image URL
   * @returns The updated profile or null if not found
   */
  async updateProfileImage(
    userId: string,
    imageUrl: string,
  ): Promise<User | null> {
    this.logger.debug("Updating profile image", { userId, imageUrl });
    return this.updateProfile(userId, { profileImage: imageUrl });
  }

  /**
   * Update banner image
   * @param userId The user ID
   * @param imageUrl The new banner image URL
   * @returns The updated profile or null if not found
   */
  async updateBannerImage(
    userId: string,
    imageUrl: string,
  ): Promise<User | null> {
    this.logger.debug("Updating banner image", { userId, imageUrl });
    return this.updateProfile(userId, { bannerImage: imageUrl });
  }

  /**
   * Check profile completion status with detailed feedback
   * @param userId The user ID
   * @returns Object containing completion status and missing fields
   */
  async getProfileCompletionStatus(userId: string): Promise<{
    isComplete: boolean;
    missingFields: string[];
    completionPercentage: number;
    recommendations: string[];
    fieldStatus: Record<string, { complete: boolean; recommendation?: string }>;
  }> {
    this.logger.debug("Checking profile completion status", { userId });

    const user = await this.userService.getUserById(userId);
    if (!user) {
      this.logger.warn("User not found for completion status check", {
        userId,
      });
      throw new Error("User not found");
    }

    const requiredFields: (keyof UserAttributes)[] = [
      "displayName",
      "firstName",
      "lastName",
      "bio",
      "profileImage",
    ];

    const fieldStatus: Record<
      string,
      { complete: boolean; recommendation?: string }
    > = {};
    const recommendations: string[] = [];

    requiredFields.forEach((field) => {
      const value = user[field];
      const isComplete = !!value;
      fieldStatus[field] = { complete: isComplete };

      if (!isComplete) {
        const recommendation = this.getFieldRecommendation(field);
        fieldStatus[field].recommendation = recommendation;
        recommendations.push(recommendation);
      }
    });

    const missingFields = requiredFields.filter((field) => !user[field]);
    const completedFields = requiredFields.length - missingFields.length;
    const completionPercentage =
      (completedFields / requiredFields.length) * 100;

    return {
      isComplete: missingFields.length === 0,
      missingFields: missingFields.map((field) => field.toString()),
      completionPercentage,
      recommendations,
      fieldStatus,
    };
  }

  /**
   * Get multiple user profiles with caching
   * @param userIds Array of user IDs
   * @returns Array of public profiles
   */
  async getProfiles(userIds: string[]): Promise<Partial<User>[]> {
    this.logger.debug("Getting multiple user profiles", { userIds });

    const profiles = await Promise.all(
      userIds.map(async (id) => {
        try {
          return await this.getProfile(id);
        } catch (error) {
          this.logger.error("Error getting profile", { id, error });
          return null;
        }
      }),
    );

    return profiles.filter(
      (profile): profile is Partial<User> => profile !== null,
    );
  }

  /**
   * Search profiles by name or username with improved matching
   * @param query The search query
   * @param options Search options
   * @returns Array of matching profiles
   */
  async searchProfiles(
    query: string,
    options: {
      limit?: number;
      offset?: number;
      sortBy?: "relevance" | "name" | "recent";
      includeInactive?: boolean;
    } = {},
  ): Promise<{
    profiles: Partial<User>[];
    total: number;
    hasMore: boolean;
  }> {
    this.logger.debug("Searching profiles", { query, options });

    const {
      limit = 10,
      offset = 0,
      sortBy = "relevance",
      includeInactive = false,
    } = options;

    // Normalize query
    const normalizedQuery = query.toLowerCase().trim();
    const queryWords = normalizedQuery.split(/\s+/);

    // Get all users
    const users = await this.userRepository.findAll();

    // Filter and score users based on search criteria
    const scoredUsers = users
      .filter((user) => includeInactive || user.isActive)
      .map((user) => {
        const searchableFields = {
          username: user.username.toLowerCase(),
          displayName: (user.displayName || "").toLowerCase(),
          firstName: (user.firstName || "").toLowerCase(),
          lastName: (user.lastName || "").toLowerCase(),
        };

        // Calculate match score
        let score = 0;
        queryWords.forEach((word) => {
          if (searchableFields.username.includes(word)) score += 3;
          if (searchableFields.displayName.includes(word)) score += 2;
          if (searchableFields.firstName.includes(word)) score += 1;
          if (searchableFields.lastName.includes(word)) score += 1;
          if (searchableFields.username === word) score += 5;
          if (searchableFields.displayName === word) score += 4;
        });

        return { user, score };
      })
      .filter(({ score }) => score > 0);

    // Sort results
    switch (sortBy) {
      case "name":
        scoredUsers.sort(
          (a, b) =>
            a.user.displayName?.localeCompare(b.user.displayName || "") || 0,
        );
        break;
      case "recent":
        scoredUsers.sort(
          (a, b) =>
            (b.user.updatedAt?.getTime() || 0) -
            (a.user.updatedAt?.getTime() || 0),
        );
        break;
      case "relevance":
      default:
        scoredUsers.sort((a, b) => b.score - a.score);
    }

    // Apply pagination
    const total = scoredUsers.length;
    const paginatedUsers = scoredUsers.slice(offset, offset + limit);

    // Convert to public profiles
    const profiles = paginatedUsers.map(({ user }) => ({
      id: user.id,
      username: user.username,
      displayName: user.displayName,
      firstName: user.firstName,
      lastName: user.lastName,
      bio: user.bio,
      profileImage: user.profileImage,
      bannerImage: user.bannerImage,
    }));

    return {
      profiles,
      total,
      hasMore: offset + limit < total,
    };
  }

  /**
   * Get profile analytics
   * @returns Profile analytics data
   */
  async getProfileAnalytics(): Promise<ProfileAnalytics> {
    this.logger.debug("Getting profile analytics");

    const users = await this.userRepository.findAll();
    const profileFields = [
      "displayName",
      "firstName",
      "lastName",
      "bio",
      "profileImage",
    ];
    const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);

    let totalCompletionRate = 0;
    const completionByField: Record<string, number> = {};
    const missingFieldsDistribution: Record<string, number> = {};
    const fieldCounts: Record<string, number> = {};

    users.forEach((user) => {
      let userCompletionCount = 0;

      profileFields.forEach((field) => {
        if (user[field]) {
          userCompletionCount++;
          fieldCounts[field] = (fieldCounts[field] || 0) + 1;
        } else {
          missingFieldsDistribution[field] =
            (missingFieldsDistribution[field] || 0) + 1;
        }
      });

      const userCompletionRate =
        (userCompletionCount / profileFields.length) * 100;
      totalCompletionRate += userCompletionRate;
    });

    profileFields.forEach((field) => {
      completionByField[field] =
        ((fieldCounts[field] || 0) / users.length) * 100;
    });

    const mostCommonFields = Object.entries(fieldCounts)
      .map(([field, count]) => ({ field, count }))
      .sort((a, b) => b.count - a.count);

    return {
      totalProfiles: users.length,
      averageCompletionRate: totalCompletionRate / users.length,
      completionByField,
      profileUpdatesLastWeek: users.filter(
        (user) => user.updatedAt && user.updatedAt > weekAgo,
      ).length,
      mostCommonFields,
      missingFieldsDistribution,
    };
  }

  /**
   * Export user profile data
   * @param userId The user ID
   * @returns Exported profile data
   */
  async exportProfile(userId: string): Promise<object> {
    this.logger.debug("Exporting user profile", { userId });

    const profile = await this.getProfile(userId);
    if (!profile) {
      throw new Error("Profile not found");
    }

    return {
      profile,
      exportedAt: new Date(),
      version: "1.0",
    };
  }

  /**
   * Import user profile data
   * @param userId The user ID
   * @param data The profile data to import
   * @returns Updated profile
   */
  async importProfile(
    userId: string,
    data: { profile: Partial<UserAttributes>; version?: string },
  ): Promise<User | null> {
    this.logger.debug("Importing user profile", { userId });

    if (!data.profile) {
      throw new Error("Invalid profile data format");
    }

    return this.updateProfile(userId, data.profile);
  }

  /**
   * Validate a profile field
   * @param field The field to validate
   * @param value The value to validate
   * @throws Error if validation fails
   */
  private validateField(
    field: keyof UserAttributes,
    value: UserAttributes[keyof UserAttributes],
  ): void {
    const rules = this.validationRules[field];
    if (!rules) return;

    if (typeof value === "string") {
      if (value.length < rules.minLength) {
        throw new Error(
          `${field} must be at least ${rules.minLength} characters long`,
        );
      }
      if (value.length > rules.maxLength) {
        throw new Error(
          `${field} must be at most ${rules.maxLength} characters long`,
        );
      }
    }
  }

  /**
   * Sanitize a profile field
   * @param field The field to sanitize
   * @param value The value to sanitize
   * @returns Sanitized value
   */
  private sanitizeField(
    field: keyof UserAttributes,
    value: UserAttributes[keyof UserAttributes],
  ): UserAttributes[keyof UserAttributes] {
    if (typeof value !== "string") return value;

    const rules = this.validationRules[field];
    if (!rules) return value;

    if (rules.allowedTags) {
      return sanitizeHtml(value, {
        allowedTags: rules.allowedTags,
        allowedAttributes: rules.allowedAttributes || {},
      });
    }

    // For non-HTML fields, remove all HTML tags
    return value.replace(/<[^>]*>/g, "");
  }

  /**
   * Get recommendation for a profile field
   * @param field The field to get recommendation for
   * @returns Recommendation message
   */
  private getFieldRecommendation(field: keyof UserAttributes): string {
    switch (field) {
      case "displayName":
        return "Add a display name to make your profile more personalized";
      case "firstName":
        return "Add your first name to help others identify you";
      case "lastName":
        return "Add your last name to complete your identity";
      case "bio":
        return "Write a short bio to tell others about yourself";
      case "profileImage":
        return "Upload a profile picture to make your profile more engaging";
      default:
        return `Complete your ${field} to improve your profile`;
    }
  }
}



===========================================================
FILE 14: app\core\user\UserService.ts
===========================================================

import NodeCache from "node-cache";

import { User, UserAttributes } from "@models/auth";
import { UserRepository } from "@repositories/auth";
import { Logger } from "@services/dev/logger";

/**
 * Interface for user search options
 */
interface UserSearchOptions {
  query?: string;
  role?: string;
  status?: "active" | "inactive" | "all";
  sortBy?: "username" | "createdAt" | "lastLogin";
  sortOrder?: "asc" | "desc";
}

/**
 * Interface for pagination options
 */
interface PaginationOptions {
  page: number;
  limit: number;
}

/**
 * Interface for paginated response
 */
interface PaginatedResponse<T> {
  items: T[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

/**
 * Interface for user statistics
 */
interface UserStatistics {
  totalUsers: number;
  activeUsers: number;
  newUsersToday: number;
  newUsersThisWeek: number;
  newUsersThisMonth: number;
  usersByRole: Record<string, number>;
  averageProfileCompletion: number;
}

/**
 * Service responsible for user management operations.
 * This service handles:
 * 1. User CRUD operations
 * 2. User profile management
 * 3. User search and filtering
 * 4. User role management
 * 5. User statistics and analytics
 * 6. Batch operations
 */
export class UserService {
  private logger: Logger;
  private cache: NodeCache;

  constructor(private readonly userRepository: UserRepository) {
    this.logger = new Logger("UserService");
    this.cache = new NodeCache({ stdTTL: 300 }); // 5 minutes cache
  }

  /**
   * Get a user by their ID with caching
   * @param id The user ID
   * @returns The user or null if not found
   */
  async getUserById(id: string): Promise<User | null> {
    this.logger.debug("Getting user by ID", { id });

    // Check cache first
    const cachedUser = this.cache.get<User>(this.getCacheKey("user", id));
    if (cachedUser) {
      this.logger.debug("User found in cache", { id });
      return cachedUser;
    }

    const user = await this.userRepository.findByPk(id);
    if (user) {
      this.cache.set(this.getCacheKey("user", id), user);
    }

    return user;
  }

  /**
   * Get a user by their email with caching
   * @param email The user's email
   * @returns The user or null if not found
   */
  async getUserByEmail(email: string): Promise<User | null> {
    this.logger.debug("Getting user by email", { email });

    const cachedUser = this.cache.get<User>(this.getCacheKey("email", email));
    if (cachedUser) {
      return cachedUser;
    }

    const user = await this.userRepository.findByEmail(email);
    if (user) {
      this.cache.set(this.getCacheKey("email", email), user);
      this.cache.set(this.getCacheKey("user", user.id), user);
    }

    return user;
  }

  /**
   * Get a user by their username with caching
   * @param username The username
   * @returns The user or null if not found
   */
  async getUserByUsername(username: string): Promise<User | null> {
    this.logger.debug("Getting user by username", { username });

    const cachedUser = this.cache.get<User>(
      this.getCacheKey("username", username),
    );
    if (cachedUser) {
      return cachedUser;
    }

    const user = await this.userRepository.findByUsername(username);
    if (user) {
      this.cache.set(this.getCacheKey("username", username), user);
      this.cache.set(this.getCacheKey("user", user.id), user);
    }

    return user;
  }

  /**
   * Get users with pagination and search options
   * @param options Search options
   * @param pagination Pagination options
   * @returns Paginated response of users
   */
  async getUsers(
    options: UserSearchOptions = {},
    pagination: PaginationOptions = { page: 1, limit: 10 },
  ): Promise<PaginatedResponse<User>> {
    this.logger.debug("Getting users with options", { options, pagination });

    const { query, role, status, sortBy, sortOrder } = options;
    const { page, limit } = pagination;

    // Get all users (in a real app, this would be a database query with proper filtering)
    let users = await this.userRepository.findAll();

    // Apply filters
    if (query) {
      const normalizedQuery = query.toLowerCase();
      users = users.filter((user) => {
        return (
          user.username.toLowerCase().includes(normalizedQuery) ||
          user.email.toLowerCase().includes(normalizedQuery) ||
          user.displayName?.toLowerCase().includes(normalizedQuery)
        );
      });
    }

    if (role) {
      users = users.filter((user) => user.role === role);
    }

    if (status && status !== "all") {
      users = users.filter((user) => {
        const isActive =
          user.lastLogin &&
          new Date(user.lastLogin as string) >
            new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
        return status === "active" ? isActive : !isActive;
      });
    }

    // Apply sorting
    if (sortBy) {
      users.sort((a, b) => {
        const aValue = a[sortBy] as string | number;
        const bValue = b[sortBy] as string | number;
        const order = sortOrder === "desc" ? -1 : 1;
        return aValue < bValue ? -1 * order : aValue > bValue ? 1 * order : 0;
      });
    }

    // Apply pagination
    const total = users.length;
    const totalPages = Math.ceil(total / limit);
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + limit;
    const paginatedUsers = users.slice(startIndex, endIndex);

    return {
      items: paginatedUsers,
      total,
      page,
      limit,
      totalPages,
    };
  }

  /**
   * Update a user's profile with cache invalidation
   * @param id The user ID
   * @param data The profile data to update
   * @returns The updated user or null if not found
   */
  async updateProfile(
    id: string,
    data: Partial<UserAttributes>,
  ): Promise<User | null> {
    this.logger.debug("Updating user profile", { id, data });

    // Remove sensitive fields that shouldn't be updated directly
    const {
      password: _password,
      emailToken: _emailToken,
      emailTokenExpire: _emailTokenExpire,
      role: _role,
      ...updateData
    } = data;

    const user = await this.userRepository.findByPk(id);
    if (!user) {
      this.logger.warn("User not found for profile update", { id });
      return null;
    }

    const updatedUser = await this.userRepository.update(id, updateData);
    if (updatedUser) {
      this.invalidateUserCache(updatedUser);
    }

    return updatedUser;
  }

  /**
   * Update a user's password with cache invalidation
   * @param id The user ID
   * @param currentPassword The current password
   * @param newPassword The new password
   * @returns True if password was updated successfully
   * @throws Error if current password is invalid
   */
  async updatePassword(
    id: string,
    currentPassword: string,
    newPassword: string,
  ): Promise<boolean> {
    this.logger.debug("Updating user password", { id });

    const user = await this.userRepository.findByPk(id);
    if (!user) {
      this.logger.warn("User not found for password update", { id });
      throw new Error("User not found");
    }

    // Verify current password
    const isValid = await user.comparePassword(currentPassword);
    if (!isValid) {
      this.logger.warn("Invalid current password provided", { id });
      throw new Error("Invalid current password");
    }

    // Update password
    await user.updatePassword(newPassword);
    const updated = await this.userRepository.update(id, {
      password: user.password,
    });

    if (updated) {
      this.invalidateUserCache(user);
    }

    return !!updated;
  }

  /**
   * Delete a user account with cache invalidation
   * @param id The user ID
   * @returns True if user was deleted successfully
   */
  async deleteUser(id: string): Promise<boolean> {
    this.logger.debug("Deleting user", { id });

    const user = await this.userRepository.findByPk(id);
    if (!user) {
      this.logger.warn("User not found for deletion", { id });
      return false;
    }

    const deleted = await this.userRepository.delete(id);
    if (deleted) {
      this.invalidateUserCache(user);
    }

    return deleted;
  }

  /**
   * Update a user's role with cache invalidation
   * @param id The user ID
   * @param newRole The new role to assign
   * @returns The updated user or null if not found
   */
  async updateRole(id: string, newRole: string): Promise<User | null> {
    this.logger.debug("Updating user role", { id, newRole });

    const user = await this.userRepository.findByPk(id);
    if (!user) {
      this.logger.warn("User not found for role update", { id });
      return null;
    }

    const updatedUser = await this.userRepository.update(id, { role: newRole });
    if (updatedUser) {
      this.invalidateUserCache(updatedUser);
    }

    return updatedUser;
  }

  /**
   * Batch update users
   * @param updates Array of user updates
   * @returns Array of updated users
   */
  async batchUpdateUsers(
    updates: Array<{ id: string; data: Partial<UserAttributes> }>,
  ): Promise<Array<User | null>> {
    this.logger.debug("Batch updating users", { count: updates.length });

    const results = await Promise.all(
      updates.map(async ({ id, data }) => {
        try {
          return await this.updateProfile(id, data);
        } catch (error) {
          this.logger.error("Error updating user", { id, error });
          return null;
        }
      }),
    );

    return results;
  }

  /**
   * Batch delete users
   * @param ids Array of user IDs to delete
   * @returns Array of deletion results
   */
  async batchDeleteUsers(ids: string[]): Promise<Array<boolean>> {
    this.logger.debug("Batch deleting users", { count: ids.length });

    const results = await Promise.all(
      ids.map(async (id) => {
        try {
          return await this.deleteUser(id);
        } catch (error) {
          this.logger.error("Error deleting user", { id, error });
          return false;
        }
      }),
    );

    return results;
  }

  /**
   * Get user statistics
   * @returns User statistics
   */
  async getUserStatistics(): Promise<UserStatistics> {
    this.logger.debug("Getting user statistics");

    const users = await this.userRepository.findAll();
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const weekAgo = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000);
    const monthAgo = new Date(
      today.getFullYear(),
      today.getMonth() - 1,
      today.getDate(),
    );

    const usersByRole: Record<string, number> = {};
    let totalProfileFields = 0;
    let completedProfileFields = 0;

    users.forEach((user) => {
      // Count users by role
      usersByRole[user.role] = (usersByRole[user.role] || 0) + 1;

      // Calculate profile completion
      const profileFields = [
        "displayName",
        "firstName",
        "lastName",
        "bio",
        "profileImage",
      ];
      totalProfileFields += profileFields.length;
      completedProfileFields += profileFields.filter(
        (field) => user[field],
      ).length;
    });

    return {
      totalUsers: users.length,
      activeUsers: users.filter(
        (user) =>
          user.lastLogin && new Date(user.lastLogin as string) > monthAgo,
      ).length,
      newUsersToday: users.filter((user) => user.createdAt >= today).length,
      newUsersThisWeek: users.filter((user) => user.createdAt >= weekAgo)
        .length,
      newUsersThisMonth: users.filter((user) => user.createdAt >= monthAgo)
        .length,
      usersByRole,
      averageProfileCompletion:
        (completedProfileFields / totalProfileFields) * 100,
    };
  }

  /**
   * Generate cache key
   * @param type Cache key type
   * @param value Cache key value
   * @returns Cache key
   */
  private getCacheKey(type: string, value: string): string {
    return `user:${type}:${value}`;
  }

  /**
   * Invalidate user cache
   * @param user User to invalidate cache for
   */
  private invalidateUserCache(user: User): void {
    this.cache.del(this.getCacheKey("user", user.id));
    this.cache.del(this.getCacheKey("email", user.email));
    this.cache.del(this.getCacheKey("username", user.username));
  }
}



===========================================================
FILE 15: app\core\user\index.ts
===========================================================

// Export user services
export * from "./UserService";
export * from "./UserPreferencesService";
export * from "./UserProfileService";



===========================================================
FILE 16: app\email\EmailService.ts
===========================================================

import { BaseService } from "@services/shared";

interface EmailData {
  to: string;
  subject: string;
  text: string;
  html: string;
}

export class EmailService extends BaseService {
  constructor() {
    super("EmailService");
  }

  async sendEmail(data: EmailData): Promise<void> {
    // Implementation would integrate with an email service provider
    // This is a placeholder that would be replaced with actual email sending logic
    this.logger.info("Sending email to:", data.to);
  }
}



===========================================================
FILE 17: app\email\index.ts
===========================================================

// Export email services
export * from "./EmailService";



===========================================================
FILE 18: app\index.ts
===========================================================

// Export all application services
export * from "./core";
export * from "./email";
export * from "./social";



===========================================================
FILE 19: app\media\MediaService.ts
===========================================================

import { Media, MediaType, MediaPrivacy, MediaAttributes } from "@database/models/media/Media";
import { MediaRepository, UserRepository } from "@database/repositories";
import { MetricsService } from "@services/app/social/monitoring";
import { BaseService, CacheManager } from "@services/shared";
import {
  ResourceNotFoundError,
  ValidationError,
} from "@services/shared/errors/ServiceError";
import { PaginatedResult, PaginationOptions } from "@shared/types";


// Constants for caching and file handling
const MEDIA_CACHE_TTL = 3600; // 1 hour
const CACHE_KEY_PREFIX = "media:";
const MAX_FILE_SIZE = 100 * 1024 * 1024; // 100MB
const ALLOWED_MIME_TYPES = [
  'image/jpeg',
  'image/png',
  'image/gif',
  'video/mp4',
  'video/quicktime',
  'audio/mpeg',
  'audio/wav'
];

export interface FileUpload {
  buffer: Buffer;
  originalname: string;
  mimetype: string;
  size: number;
}

export interface MediaMetadata {
  title?: string;
  description?: string;
  type: MediaType;
  visibility: MediaPrivacy;
  tags?: string[];
  location?: {
    latitude: number;
    longitude: number;
  };
}

export interface MediaUpdateDTO extends Partial<MediaAttributes> {
  title?: string;
  description?: string;
  visibility?: MediaPrivacy;
  tags?: string[];
  location?: {
    latitude: number;
    longitude: number;
  };
}

export interface MediaQueryOptions extends PaginationOptions {
  type?: MediaType;
  visibility?: MediaPrivacy;
  startDate?: Date;
  endDate?: Date;
  tags?: string[];
}

/**
 * Service responsible for managing media uploads and retrieval.
 * Features:
 * 1. Media upload handling and validation
 * 2. Secure storage management
 * 3. Media metadata extraction and storage
 * 4. Access control and privacy
 * 5. Media relation to other entities
 * 6. Caching for frequently accessed media
 * 7. Performance metrics tracking
 */
export class MediaService extends BaseService {
  constructor(
    private mediaRepository: MediaRepository,
    private userRepository: UserRepository,
    private metricsService: MetricsService,
    private cacheManager: CacheManager,
  ) {
    super("MediaService");
  }

  /**
   * Upload a new media file
   * 
   * @param userId - ID of the user uploading the media
   * @param file - File upload data
   * @param metadata - Media metadata
   * @returns Newly created media object
   * @throws ValidationError if file or metadata is invalid
   * @throws ResourceNotFoundError if user doesn't exist
   */
  async uploadMedia(
    userId: string,
    file: FileUpload,
    metadata: MediaMetadata
  ): Promise<Media> {
    const startTime = Date.now();
    try {
      // Validate user exists
      const user = await this.userRepository.findById(userId);
      if (!user) {
        throw new ResourceNotFoundError(`User with ID ${userId} not found`);
      }

      // Validate file
      this.validateFileUpload(file);

      // Process and store the file
      const mediaData = {
        userId,
        filename: this.generateUniqueFilename(file.originalname),
        originalFilename: file.originalname,
        mimeType: file.mimetype,
        size: file.size,
        ...metadata,
      };

      // Create media record
      const media = await this.mediaRepository.create(mediaData);

      // Track metrics
      this.metricsService.recordOperationDuration("media_upload", 1);
      this.metricsService.recordOperationDuration("media_upload_time", Date.now() - startTime);

      return media;
    } catch (error) {
      this.logger.error("Error uploading media", {
        userId,
        filename: file.originalname,
        error: error instanceof Error ? error.message : String(error)
      });

      this.metricsService.recordOperationDuration("media_upload_error", 1);

      throw error;
    }
  }

  /**
   * Get media by ID
   * 
   * @param mediaId - ID of the media to retrieve
   * @returns Media object if found, null otherwise
   */
  async getMedia(mediaId: string): Promise<Media | null> {
    try {
      // Try to get from cache
      const cacheKey = `${CACHE_KEY_PREFIX}${mediaId}`;
      const cachedMedia = await this.cacheManager.get<Media>(cacheKey);
      if (cachedMedia) {
        this.metricsService.recordOperationDuration("media_cache_hit", 1);
        return cachedMedia;
      }

      // Get from repository
      const media = await this.mediaRepository.findById(mediaId);
      if (!media) {
        return null;
      }

      // Cache the result
      await this.cacheManager.set(cacheKey, media, MEDIA_CACHE_TTL);

      return media;
    } catch (error) {
      this.logger.error("Error getting media", {
        mediaId,
        error: error instanceof Error ? error.message : String(error)
      });

      throw error;
    }
  }

  /**
   * Update media metadata
   * 
   * @param userId - ID of the user updating the media
   * @param mediaId - ID of the media to update
   * @param updates - Update data
   * @returns Updated media object
   * @throws ResourceNotFoundError if media not found
   * @throws ValidationError if updates are invalid
   */
  async updateMedia(
    userId: string,
    mediaId: string,
    updates: MediaUpdateDTO
  ): Promise<Media> {
    try {
      // Get existing media
      const media = await this.mediaRepository.findById(mediaId);
      if (!media) {
        throw new ResourceNotFoundError(`Media with ID ${mediaId} not found`);
      }

      // Verify ownership
      if (media.userId !== userId) {
        throw new ValidationError("You don't have permission to update this media");
      }

      // Update media
      const updatedMedia = await this.mediaRepository.update(mediaId, updates);
      if (!updatedMedia) {
        throw new ResourceNotFoundError(`Failed to update media with ID ${mediaId}`);
      }

      // Invalidate cache
      const cacheKey = `${CACHE_KEY_PREFIX}${mediaId}`;
      await this.cacheManager.delete(cacheKey);

      return updatedMedia;
    } catch (error) {
      this.logger.error("Error updating media", {
        userId,
        mediaId,
        error: error instanceof Error ? error.message : String(error)
      });

      throw error;
    }
  }

  /**
   * Delete media
   * 
   * @param userId - ID of the user deleting the media
   * @param mediaId - ID of the media to delete
   * @returns true if deleted, false otherwise
   */
  async deleteMedia(userId: string, mediaId: string): Promise<boolean> {
    try {
      // Get existing media
      const media = await this.mediaRepository.findById(mediaId);
      if (!media) {
        return false;
      }

      // Verify ownership
      if (media.userId !== userId) {
        throw new ValidationError("You don't have permission to delete this media");
      }

      // Delete media
      await this.mediaRepository.delete(mediaId);

      // Invalidate cache
      const cacheKey = `${CACHE_KEY_PREFIX}${mediaId}`;
      await this.cacheManager.delete(cacheKey);

      // Track metrics
      this.metricsService.recordOperationDuration("media_deletion", 1);

      return true;
    } catch (error) {
      this.logger.error("Error deleting media", {
        userId,
        mediaId,
        error: error instanceof Error ? error.message : String(error)
      });

      throw error;
    }
  }

  /**
   * Get media items by user
   * 
   * @param userId - ID of the user whose media to retrieve
   * @param options - Query options for filtering and pagination
   * @returns Paginated media results
   */
  async getMediaByUser(
    userId: string,
    options: MediaQueryOptions
  ): Promise<PaginatedResult<Media>> {
    try {
      // Get media items
      const media = await this.mediaRepository.findByUserId(
        userId,
        options.type,
        options.limit,
        options.page ? (options.page - 1) * (options.limit || 20) : 0
      );

      // Track metrics
      this.metricsService.recordOperationDuration("media_retrieval", 1);

      // Format as paginated result
      return {
        items: media,
        total: media.length,
        page: options.page || 1,
        limit: options.limit || 20,
        totalPages: Math.ceil(media.length / (options.limit || 20))
      };
    } catch (error) {
      this.logger.error("Error getting user media", {
        userId,
        error: error instanceof Error ? error.message : String(error)
      });

      throw error;
    }
  }

  /**
   * Validate file upload
   * 
   * @param file - File upload data to validate
   * @throws ValidationError if file is invalid
   */
  private validateFileUpload(file: FileUpload): void {
    // Check file size
    if (file.size > MAX_FILE_SIZE) {
      throw new ValidationError(`File size exceeds maximum allowed size of ${MAX_FILE_SIZE / 1024 / 1024}MB`);
    }

    // Check mime type
    if (!ALLOWED_MIME_TYPES.includes(file.mimetype)) {
      throw new ValidationError(`File type ${file.mimetype} is not allowed`);
    }

    // Check if file buffer exists and is not empty
    if (!file.buffer || file.buffer.length === 0) {
      throw new ValidationError("File content is empty");
    }
  }

  /**
   * Generate a unique filename for storage
   * 
   * @param originalFilename - Original filename
   * @returns Unique filename
   */
  private generateUniqueFilename(originalFilename: string): string {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(2, 15);
    const extension = originalFilename.split('.').pop();
    return `${timestamp}-${random}.${extension}`;
  }
} 


===========================================================
FILE 20: app\media\collection\MediaCollectionService.ts
===========================================================

import { Media } from "@database/models/media/Media";
import { MediaRepository, CollectionRepository, UserRepository } from "@database/repositories";
import { MetricsService } from "@services/app/social/monitoring";
import { BaseService, CacheManager } from "@services/shared";
import {
  ResourceNotFoundError,
  ValidationError,
} from "@services/shared/errors/ServiceError";
import { PaginatedResult, PaginationOptions } from "@shared/types";

// Constants
const COLLECTION_CACHE_TTL = 3600; // 1 hour
const CACHE_KEY_PREFIX = "collection:";

export enum CollectionPrivacy {
  PRIVATE = 'PRIVATE',
  PUBLIC = 'PUBLIC',
  SHARED = 'SHARED'
}

export interface CollectionCreateDTO {
  name: string;
  description?: string;
  privacy: CollectionPrivacy;
  coverMediaId?: string;
  tags?: string[];
}

export interface CollectionUpdateDTO {
  name?: string;
  description?: string;
  privacy?: CollectionPrivacy;
  coverMediaId?: string;
  tags?: string[];
}

export interface CollectionQueryOptions extends PaginationOptions {
  privacy?: CollectionPrivacy;
  tags?: string[];
  includeShared?: boolean;
}

/**
 * Service responsible for managing media collections.
 * Features:
 * 1. Collection CRUD operations
 * 2. Collection sharing and permissions
 * 3. Media organization within collections
 * 4. Collection recommendations
 * 5. Caching for frequently accessed collections
 */
export class MediaCollectionService extends BaseService {
  constructor(
    private collectionRepository: CollectionRepository,
    private mediaRepository: MediaRepository,
    private userRepository: UserRepository,
    private metricsService: MetricsService,
    private cacheManager: CacheManager,
  ) {
    super("MediaCollectionService");
  }

  /**
   * Create a new collection
   * 
   * @param userId - ID of the user creating the collection
   * @param data - Collection creation data
   * @returns Newly created collection
   */
  async createCollection(userId: string, data: CollectionCreateDTO): Promise<Collection> {
    try {
      // Validate user exists
      const user = await this.userRepository.findById(userId);
      if (!user) {
        throw new ResourceNotFoundError(`User with ID ${userId} not found`);
      }

      // Validate cover media if provided
      if (data.coverMediaId) {
        const coverMedia = await this.mediaRepository.findById(data.coverMediaId);
        if (!coverMedia) {
          throw new ValidationError(`Cover media with ID ${data.coverMediaId} not found`);
        }
        if (coverMedia.userId !== userId) {
          throw new ValidationError("You don't have permission to use this media as cover");
        }
      }

      // Create collection
      const collection = await this.collectionRepository.create({
        ...data,
        userId,
        mediaCount: 0,
        createdAt: new Date(),
        updatedAt: new Date()
      });

      // Track metrics
      this.metricsService.recordOperationDuration("collection_creation", 1);

      return collection;
    } catch (error) {
      this.logger.error("Error creating collection", {
        userId,
        error: error instanceof Error ? error.message : String(error)
      });
      throw error;
    }
  }

  /**
   * Get collection by ID
   * 
   * @param collectionId - ID of the collection to retrieve
   * @param userId - ID of the user requesting the collection
   * @returns Collection if found and accessible, null otherwise
   */
  async getCollection(collectionId: string, userId: string): Promise<Collection | null> {
    try {
      // Try to get from cache
      const cacheKey = `${CACHE_KEY_PREFIX}${collectionId}`;
      const cachedCollection = await this.cacheManager.get<Collection>(cacheKey);
      if (cachedCollection) {
        // Verify access
        if (this.canAccessCollection(cachedCollection, userId)) {
          this.metricsService.recordOperationDuration("collection_cache_hit", 1);
          return cachedCollection;
        }
        return null;
      }

      // Get from repository
      const collection = await this.collectionRepository.findById(collectionId);
      if (!collection || !this.canAccessCollection(collection, userId)) {
        return null;
      }

      // Cache the result
      await this.cacheManager.set(cacheKey, collection, COLLECTION_CACHE_TTL);

      return collection;
    } catch (error) {
      this.logger.error("Error getting collection", {
        collectionId,
        userId,
        error: error instanceof Error ? error.message : String(error)
      });
      throw error;
    }
  }

  /**
   * Update collection
   * 
   * @param userId - ID of the user updating the collection
   * @param collectionId - ID of the collection to update
   * @param updates - Update data
   * @returns Updated collection
   */
  async updateCollection(
    userId: string,
    collectionId: string,
    updates: CollectionUpdateDTO
  ): Promise<Collection> {
    try {
      // Get existing collection
      const collection = await this.collectionRepository.findById(collectionId);
      if (!collection) {
        throw new ResourceNotFoundError(`Collection with ID ${collectionId} not found`);
      }

      // Verify ownership
      if (collection.userId !== userId) {
        throw new ValidationError("You don't have permission to update this collection");
      }

      // Validate cover media if being updated
      if (updates.coverMediaId) {
        const coverMedia = await this.mediaRepository.findById(updates.coverMediaId);
        if (!coverMedia) {
          throw new ValidationError(`Cover media with ID ${updates.coverMediaId} not found`);
        }
        if (coverMedia.userId !== userId) {
          throw new ValidationError("You don't have permission to use this media as cover");
        }
      }

      // Update collection
      const updatedCollection = await this.collectionRepository.update(collectionId, {
        ...updates,
        updatedAt: new Date()
      });

      if (!updatedCollection) {
        throw new ResourceNotFoundError(`Failed to update collection with ID ${collectionId}`);
      }

      // Invalidate cache
      const cacheKey = `${CACHE_KEY_PREFIX}${collectionId}`;
      await this.cacheManager.delete(cacheKey);

      return updatedCollection;
    } catch (error) {
      this.logger.error("Error updating collection", {
        userId,
        collectionId,
        error: error instanceof Error ? error.message : String(error)
      });
      throw error;
    }
  }

  /**
   * Delete collection
   * 
   * @param userId - ID of the user deleting the collection
   * @param collectionId - ID of the collection to delete
   * @returns true if deleted, false otherwise
   */
  async deleteCollection(userId: string, collectionId: string): Promise<boolean> {
    try {
      // Get existing collection
      const collection = await this.collectionRepository.findById(collectionId);
      if (!collection) {
        return false;
      }

      // Verify ownership
      if (collection.userId !== userId) {
        throw new ValidationError("You don't have permission to delete this collection");
      }

      // Delete collection
      await this.collectionRepository.delete(collectionId);

      // Invalidate cache
      const cacheKey = `${CACHE_KEY_PREFIX}${collectionId}`;
      await this.cacheManager.delete(cacheKey);

      // Track metrics
      this.metricsService.recordOperationDuration("collection_deletion", 1);

      return true;
    } catch (error) {
      this.logger.error("Error deleting collection", {
        userId,
        collectionId,
        error: error instanceof Error ? error.message : String(error)
      });
      throw error;
    }
  }

  /**
   * Add media to collection
   * 
   * @param userId - ID of the user adding media
   * @param collectionId - ID of the collection
   * @param mediaId - ID of the media to add
   */
  async addMediaToCollection(
    userId: string,
    collectionId: string,
    mediaId: string
  ): Promise<void> {
    try {
      // Get collection and media
      const [collection, media] = await Promise.all([
        this.collectionRepository.findById(collectionId),
        this.mediaRepository.findById(mediaId)
      ]);

      if (!collection) {
        throw new ResourceNotFoundError(`Collection with ID ${collectionId} not found`);
      }
      if (!media) {
        throw new ResourceNotFoundError(`Media with ID ${mediaId} not found`);
      }

      // Verify permissions
      if (collection.userId !== userId) {
        throw new ValidationError("You don't have permission to modify this collection");
      }

      // Add media to collection
      await this.collectionRepository.addMedia(collectionId, mediaId);

      // Invalidate cache
      const cacheKey = `${CACHE_KEY_PREFIX}${collectionId}`;
      await this.cacheManager.delete(cacheKey);

      // Track metrics
      this.metricsService.recordOperationDuration("collection_media_addition", 1);
    } catch (error) {
      this.logger.error("Error adding media to collection", {
        userId,
        collectionId,
        mediaId,
        error: error instanceof Error ? error.message : String(error)
      });
      throw error;
    }
  }

  /**
   * Remove media from collection
   * 
   * @param userId - ID of the user removing media
   * @param collectionId - ID of the collection
   * @param mediaId - ID of the media to remove
   */
  async removeMediaFromCollection(
    userId: string,
    collectionId: string,
    mediaId: string
  ): Promise<void> {
    try {
      // Get collection
      const collection = await this.collectionRepository.findById(collectionId);
      if (!collection) {
        throw new ResourceNotFoundError(`Collection with ID ${collectionId} not found`);
      }

      // Verify permissions
      if (collection.userId !== userId) {
        throw new ValidationError("You don't have permission to modify this collection");
      }

      // Remove media from collection
      await this.collectionRepository.removeMedia(collectionId, mediaId);

      // Invalidate cache
      const cacheKey = `${CACHE_KEY_PREFIX}${collectionId}`;
      await this.cacheManager.delete(cacheKey);

      // Track metrics
      this.metricsService.recordOperationDuration("collection_media_removal", 1);
    } catch (error) {
      this.logger.error("Error removing media from collection", {
        userId,
        collectionId,
        mediaId,
        error: error instanceof Error ? error.message : String(error)
      });
      throw error;
    }
  }

  /**
   * Get user's collections
   * 
   * @param userId - ID of the user
   * @param options - Query options
   * @returns Paginated collection results
   */
  async getUserCollections(
    userId: string,
    options: CollectionQueryOptions
  ): Promise<PaginatedResult<Collection>> {
    try {
      const collections = await this.collectionRepository.findByUserId(
        userId,
        options.privacy,
        options.includeShared,
        options.limit,
        options.page ? (options.page - 1) * (options.limit || 20) : 0
      );

      // Track metrics
      this.metricsService.recordOperationDuration("collection_retrieval", 1);

      return {
        items: collections,
        total: collections.length,
        page: options.page || 1,
        limit: options.limit || 20,
        totalPages: Math.ceil(collections.length / (options.limit || 20))
      };
    } catch (error) {
      this.logger.error("Error getting user collections", {
        userId,
        error: error instanceof Error ? error.message : String(error)
      });
      throw error;
    }
  }

  /**
   * Share collection with users
   * 
   * @param userId - ID of the collection owner
   * @param collectionId - ID of the collection to share
   * @param targetUserIds - IDs of users to share with
   */
  async shareCollection(
    userId: string,
    collectionId: string,
    targetUserIds: string[]
  ): Promise<void> {
    try {
      // Get collection
      const collection = await this.collectionRepository.findById(collectionId);
      if (!collection) {
        throw new ResourceNotFoundError(`Collection with ID ${collectionId} not found`);
      }

      // Verify ownership
      if (collection.userId !== userId) {
        throw new ValidationError("You don't have permission to share this collection");
      }

      // Verify target users exist
      const users = await this.userRepository.findByIds(targetUserIds);
      if (users.length !== targetUserIds.length) {
        throw new ValidationError("One or more target users not found");
      }

      // Share collection
      await this.collectionRepository.shareWithUsers(collectionId, targetUserIds);

      // Update collection privacy if needed
      if (collection.privacy === CollectionPrivacy.PRIVATE) {
        await this.collectionRepository.update(collectionId, {
          privacy: CollectionPrivacy.SHARED
        });
      }

      // Invalidate cache
      const cacheKey = `${CACHE_KEY_PREFIX}${collectionId}`;
      await this.cacheManager.delete(cacheKey);

      // Track metrics
      this.metricsService.recordOperationDuration("collection_share", 1);
    } catch (error) {
      this.logger.error("Error sharing collection", {
        userId,
        collectionId,
        targetUserIds,
        error: error instanceof Error ? error.message : String(error)
      });
      throw error;
    }
  }

  /**
   * Check if a user can access a collection
   * 
   * @param collection - Collection to check
   * @param userId - ID of the user
   * @returns Whether the user can access the collection
   */
  private canAccessCollection(collection: Collection, userId: string): boolean {
    return (
      collection.privacy === CollectionPrivacy.PUBLIC ||
      collection.userId === userId ||
      (collection.privacy === CollectionPrivacy.SHARED &&
        collection.sharedWith?.includes(userId))
    );
  }
} 


===========================================================
FILE 21: app\media\processor\MediaProcessorService.ts
===========================================================

import { promises as fs } from 'fs';

import ffmpeg from "fluent-ffmpeg";
import sharp from "sharp";

import { Media } from "@database/models/media";
import { MediaRepository } from "@database/repositories";
import { MetricsService } from "@services/app/social/monitoring";
import { BaseService } from "@services/shared";
import { ValidationError } from "@services/shared/errors/ServiceError";

// Constants for processing
const THUMBNAIL_SIZE = {
  width: 300,
  height: 300
};

const VIDEO_FORMATS = {
  HLS: 'hls',
  DASH: 'dash',
  MP4: 'mp4',
  WEBM: 'webm'
} as const;

const AUDIO_FORMATS = {
  MP3: 'mp3',
  WAV: 'wav',
  AAC: 'aac',
  OGG: 'ogg'
} as const;

const IMAGE_FORMATS = {
  JPEG: 'jpeg',
  WEBP: 'webp',
  AVIF: 'avif',
  PNG: 'png'
} as const;

// Quality constraints
const QUALITY_CONSTRAINTS = {
  MIN_IMAGE_QUALITY: 20,
  MAX_IMAGE_QUALITY: 100,
  MIN_VIDEO_BITRATE: '500k',
  MAX_VIDEO_BITRATE: '8000k',
  MIN_AUDIO_BITRATE: '64k',
  MAX_AUDIO_BITRATE: '320k',
  MAX_IMAGE_DIMENSION: 4096,
  MIN_IMAGE_DIMENSION: 16
} as const;

type VideoFormat = keyof typeof VIDEO_FORMATS;
type AudioFormat = keyof typeof AUDIO_FORMATS;
type ImageFormat = keyof typeof IMAGE_FORMATS;

interface ProcessingOptions {
  generateThumbnail?: boolean;
  optimizeForWeb?: boolean;
  convertToFormat?: string;
  quality?: number;
  resize?: {
    width?: number;
    height?: number;
    fit?: 'cover' | 'contain' | 'fill';
  };
}

interface VideoProcessingOptions extends ProcessingOptions {
  generateStreamingFormats?: boolean;
  videoBitrate?: string;
  audioBitrate?: string;
  keyframeInterval?: number;
  extractAudio?: boolean;
}

interface AudioProcessingOptions extends ProcessingOptions {
  normalize?: boolean;
  trim?: {
    start?: number;
    end?: number;
  };
  fadeIn?: number;
  fadeOut?: number;
  bitrate?: string;
  sampleRate?: number;
  channels?: number;
}

interface VideoMetadata {
  format: {
    duration: number;
    size: number;
    bit_rate: number;
  };
  streams: Array<{
    codec_type: string;
    codec_name: string;
    width?: number;
    height?: number;
    bit_rate?: string;
    sample_rate?: number;
    channels?: number;
  }>;
}

interface AudioMetadata {
  format: {
    duration: number;
    size: number;
    bit_rate: number;
  };
  streams: Array<{
    codec_type: string;
    codec_name: string;
    sample_rate: number;
    channels: number;
    bit_rate?: string;
  }>;
}

interface MetricsData {
  mediaId: string;
  duration?: number;
  originalSize?: number;
  processedSize?: number;
  [key: string]: unknown;
}

/**
 * Service responsible for processing media files.
 * Features:
 * 1. Image resizing and optimization
 * 2. Video transcoding and format conversion
 * 3. Audio processing and enhancement
 * 4. Thumbnail generation
 * 5. Streaming optimization
 * 6. Performance metrics tracking
 */
export class MediaProcessorService extends BaseService {
  constructor(
    private mediaRepository: MediaRepository,
    private metricsService: MetricsService
  ) {
    super("MediaProcessorService");
  }

  /**
   * Process an image with specified options
   * 
   * @param media - Media object to process
   * @param buffer - Original image buffer
   * @param options - Processing options
   * @returns Processed image buffer and metadata
   */
  async processImage(
    media: Media,
    buffer: Buffer,
    options: ProcessingOptions = {}
  ): Promise<{ buffer: Buffer; metadata: sharp.Metadata }> {
    try {
      // Validate input
      if (!buffer || buffer.length === 0) {
        throw new ValidationError("Empty image buffer provided");
      }

      // Validate quality
      if (options.quality) {
        if (options.quality < QUALITY_CONSTRAINTS.MIN_IMAGE_QUALITY || 
            options.quality > QUALITY_CONSTRAINTS.MAX_IMAGE_QUALITY) {
          throw new ValidationError(`Image quality must be between ${QUALITY_CONSTRAINTS.MIN_IMAGE_QUALITY} and ${QUALITY_CONSTRAINTS.MAX_IMAGE_QUALITY}`);
        }
      }

      // Validate dimensions
      if (options.resize) {
        if (options.resize.width) {
          if (options.resize.width < QUALITY_CONSTRAINTS.MIN_IMAGE_DIMENSION || 
              options.resize.width > QUALITY_CONSTRAINTS.MAX_IMAGE_DIMENSION) {
            throw new ValidationError(`Image width must be between ${QUALITY_CONSTRAINTS.MIN_IMAGE_DIMENSION} and ${QUALITY_CONSTRAINTS.MAX_IMAGE_DIMENSION}`);
          }
        }
        if (options.resize.height) {
          if (options.resize.height < QUALITY_CONSTRAINTS.MIN_IMAGE_DIMENSION || 
              options.resize.height > QUALITY_CONSTRAINTS.MAX_IMAGE_DIMENSION) {
            throw new ValidationError(`Image height must be between ${QUALITY_CONSTRAINTS.MIN_IMAGE_DIMENSION} and ${QUALITY_CONSTRAINTS.MAX_IMAGE_DIMENSION}`);
          }
        }
      }

      let processor = sharp(buffer);
      const metadata = await processor.metadata();

      // Resize if specified
      if (options.resize) {
        processor = processor.resize(
          options.resize.width,
          options.resize.height,
          {
            fit: options.resize.fit || 'cover',
            withoutEnlargement: true
          }
        );
      }

      // Optimize for web if requested
      if (options.optimizeForWeb) {
        processor = processor.jpeg({ quality: options.quality || 80 });
      }

      // Convert format if specified
      if (options.convertToFormat) {
        const format = options.convertToFormat.toUpperCase() as ImageFormat;
        if (format in IMAGE_FORMATS) {
          processor = processor[IMAGE_FORMATS[format]]({
            quality: options.quality || 80
          });
        } else {
          throw new ValidationError(`Unsupported image format: ${options.convertToFormat}`);
        }
      }

      // Generate thumbnail if requested
      if (options.generateThumbnail) {
        const thumbnail = await this.generateThumbnail(buffer);
        await fs.mkdir('thumbnails', { recursive: true });
        await fs.writeFile(`thumbnails/${media.id}.jpg`, thumbnail);
        await this.mediaRepository.update(media.id, { thumbnailUrl: `thumbnails/${media.id}.jpg` });
      }

      const processedBuffer = await processor.toBuffer();

      // Track metrics
      await this.recordMetrics("image_processing", {
        mediaId: media.id,
        originalSize: buffer.length,
        processedSize: processedBuffer.length,
        format: metadata.format,
        width: metadata.width,
        height: metadata.height
      });

      return {
        buffer: processedBuffer,
        metadata
      };
    } catch (error) {
      this.logger.error("Error processing image", {
        mediaId: media.id,
        error: error instanceof Error ? error.message : String(error)
      });

      throw error;
    }
  }

  /**
   * Process a video with specified options
   * 
   * @param media - Media object to process
   * @param inputPath - Path to input video file
   * @param options - Video processing options
   * @returns Processed video path and metadata
   */
  async processVideo(
    media: Media,
    inputPath: string,
    options: VideoProcessingOptions = {}
  ): Promise<{ outputPath: string; metadata: VideoMetadata }> {
    try {
      // Validate input
      if (!await this.fileExists(inputPath)) {
        throw new ValidationError("Input video file does not exist");
      }

      // Validate bitrates
      if (options.videoBitrate && !this.isValidBitrate(options.videoBitrate, QUALITY_CONSTRAINTS.MIN_VIDEO_BITRATE, QUALITY_CONSTRAINTS.MAX_VIDEO_BITRATE)) {
        throw new ValidationError(`Video bitrate must be between ${QUALITY_CONSTRAINTS.MIN_VIDEO_BITRATE} and ${QUALITY_CONSTRAINTS.MAX_VIDEO_BITRATE}`);
      }
      if (options.audioBitrate && !this.isValidBitrate(options.audioBitrate, QUALITY_CONSTRAINTS.MIN_AUDIO_BITRATE, QUALITY_CONSTRAINTS.MAX_AUDIO_BITRATE)) {
        throw new ValidationError(`Audio bitrate must be between ${QUALITY_CONSTRAINTS.MIN_AUDIO_BITRATE} and ${QUALITY_CONSTRAINTS.MAX_AUDIO_BITRATE}`);
      }

      const outputPath = `processed/${media.id}/video`;
      await fs.mkdir(outputPath, { recursive: true });
      
      // Get video metadata
      const metadata = await this.getVideoMetadata(inputPath);

      // Generate thumbnail if requested
      if (options.generateThumbnail) {
        await this.generateVideoThumbnail(inputPath, media.id);
      }

      // Process video based on options
      if (options.generateStreamingFormats) {
        await this.generateStreamingFormats(inputPath, outputPath, options);
      } else {
        await this.transcodeVideo(inputPath, outputPath, options);
      }

      // Track metrics
      await this.recordMetrics("video_processing", {
        mediaId: media.id,
        duration: metadata.format.duration,
        originalSize: metadata.format.size,
        bitrate: metadata.format.bit_rate,
        hasAudio: metadata.streams.some(s => s.codec_type === 'audio'),
        hasVideo: metadata.streams.some(s => s.codec_type === 'video')
      });

      return {
        outputPath,
        metadata
      };
    } catch (error) {
      this.logger.error("Error processing video", {
        mediaId: media.id,
        error: error instanceof Error ? error.message : String(error)
      });

      throw error;
    }
  }

  /**
   * Process an audio file with specified options
   * 
   * @param media - Media object to process
   * @param inputPath - Path to input audio file
   * @param options - Audio processing options
   * @returns Processed audio path and metadata
   */
  async processAudio(
    media: Media,
    inputPath: string,
    options: AudioProcessingOptions = {}
  ): Promise<{ outputPath: string; metadata: AudioMetadata }> {
    try {
      // Validate input
      if (!await this.fileExists(inputPath)) {
        throw new ValidationError("Input audio file does not exist");
      }

      // Validate bitrate
      if (options.bitrate && !this.isValidBitrate(options.bitrate, QUALITY_CONSTRAINTS.MIN_AUDIO_BITRATE, QUALITY_CONSTRAINTS.MAX_AUDIO_BITRATE)) {
        throw new ValidationError(`Audio bitrate must be between ${QUALITY_CONSTRAINTS.MIN_AUDIO_BITRATE} and ${QUALITY_CONSTRAINTS.MAX_AUDIO_BITRATE}`);
      }

      const outputPath = `processed/${media.id}/audio`;
      await fs.mkdir(outputPath, { recursive: true });
      
      const metadata = await this.getAudioMetadata(inputPath);

      let command = ffmpeg(inputPath);

      // Apply audio processing options
      if (options.normalize) {
        command = command.audioFilters('loudnorm');
      }

      if (options.trim) {
        if (options.trim.start) {
          command = command.setStartTime(options.trim.start);
        }
        if (options.trim.end) {
          command = command.setDuration(options.trim.end - (options.trim.start || 0));
        }
      }

      if (options.fadeIn) {
        command = command.audioFilters(`afade=t=in:st=0:d=${options.fadeIn}`);
      }

      if (options.fadeOut) {
        const duration = metadata.format.duration;
        command = command.audioFilters(`afade=t=out:st=${duration - options.fadeOut}:d=${options.fadeOut}`);
      }

      if (options.bitrate) {
        command = command.audioBitrate(options.bitrate);
      }

      if (options.sampleRate) {
        command = command.audioFrequency(options.sampleRate);
      }

      if (options.channels) {
        command = command.audioChannels(options.channels);
      }

      // Process audio
      await new Promise<void>((resolve, reject) => {
        command
          .output(`${outputPath}/output.${options.convertToFormat ? AUDIO_FORMATS[options.convertToFormat.toUpperCase() as AudioFormat] || 'mp3' : AUDIO_FORMATS.MP3}`)
          .on('end', () => resolve())
          .on('error', (err) => reject(err))
          .run();
      });

      // Track metrics
      await this.recordMetrics("audio_processing", {
        mediaId: media.id,
        duration: metadata.format.duration,
        originalSize: metadata.format.size,
        bitrate: metadata.format.bit_rate,
        sampleRate: metadata.streams[0]?.sample_rate,
        channels: metadata.streams[0]?.channels
      });

      return {
        outputPath,
        metadata
      };
    } catch (error) {
      this.logger.error("Error processing audio", {
        mediaId: media.id,
        error: error instanceof Error ? error.message : String(error)
      });
      throw error;
    }
  }

  /**
   * Generate a thumbnail for an image
   * 
   * @param buffer - Original image buffer
   * @returns Thumbnail buffer
   */
  private async generateThumbnail(buffer: Buffer): Promise<Buffer> {
    return sharp(buffer)
      .resize(THUMBNAIL_SIZE.width, THUMBNAIL_SIZE.height, {
        fit: 'cover',
        position: 'centre'
      })
      .jpeg({ quality: 80 })
      .toBuffer();
  }

  /**
   * Generate a thumbnail from a video
   * 
   * @param inputPath - Path to input video
   * @param mediaId - ID of the media
   * @returns Path to generated thumbnail
   */
  private async generateVideoThumbnail(inputPath: string, mediaId: string): Promise<string> {
    const thumbnailPath = `thumbnails/${mediaId}.jpg`;
    await fs.mkdir('thumbnails', { recursive: true });
    
    return new Promise((resolve, reject) => {
      ffmpeg(inputPath)
        .screenshots({
          timestamps: ['10%'],
          filename: thumbnailPath,
          size: `${THUMBNAIL_SIZE.width}x${THUMBNAIL_SIZE.height}`
        })
        .on('end', () => resolve(thumbnailPath))
        .on('error', (err) => reject(err));
    });
  }

  /**
   * Generate streaming formats (HLS/DASH) for a video
   * 
   * @param inputPath - Path to input video
   * @param outputPath - Base path for output files
   * @param options - Processing options
   */
  private async generateStreamingFormats(
    inputPath: string,
    outputPath: string,
    _options: VideoProcessingOptions
  ): Promise<void> {
    const hlsPath = `${outputPath}/${VIDEO_FORMATS.HLS}`;
    const dashPath = `${outputPath}/${VIDEO_FORMATS.DASH}`;

    await Promise.all([
      fs.mkdir(hlsPath, { recursive: true }),
      fs.mkdir(dashPath, { recursive: true })
    ]);

    await Promise.all([
      // Generate HLS
      new Promise<void>((resolve, reject) => {
        ffmpeg(inputPath)
          .outputOptions([
            '-hls_time 10',
            '-hls_list_size 0',
            '-hls_segment_filename', `${hlsPath}/%03d.ts`
          ])
          .output(`${hlsPath}/playlist.m3u8`)
          .on('end', () => resolve())
          .on('error', (err) => reject(err))
          .run();
      }),

      // Generate DASH
      new Promise<void>((resolve, reject) => {
        ffmpeg(inputPath)
          .outputOptions([
            `-f ${VIDEO_FORMATS.DASH}`,
            '-seg_duration 10',
            '-use_template 1',
            '-use_timeline 1'
          ])
          .output(`${dashPath}/manifest.mpd`)
          .on('end', () => resolve())
          .on('error', (err) => reject(err))
          .run();
      })
    ]);
  }

  /**
   * Transcode a video to different format/quality
   * 
   * @param inputPath - Path to input video
   * @param outputPath - Path for output video
   * @param options - Processing options
   */
  private async transcodeVideo(
    inputPath: string,
    outputPath: string,
    options: VideoProcessingOptions
  ): Promise<void> {
    return new Promise<void>((resolve, reject) => {
      let command = ffmpeg(inputPath);

      if (options.videoBitrate) {
        command = command.videoBitrate(options.videoBitrate);
      }

      if (options.audioBitrate) {
        command = command.audioBitrate(options.audioBitrate);
      }

      if (options.keyframeInterval) {
        command = command.outputOptions([
          `-g ${options.keyframeInterval}`
        ]);
      }

      command
        .output(`${outputPath}/output.${options.convertToFormat ? VIDEO_FORMATS[options.convertToFormat.toUpperCase() as VideoFormat] || VIDEO_FORMATS.MP4 : VIDEO_FORMATS.MP4}`)
        .on('end', () => resolve())
        .on('error', (err) => reject(err))
        .run();
    });
  }

  /**
   * Get video metadata
   * 
   * @param inputPath - Path to video file
   * @returns Video metadata
   */
  private async getVideoMetadata(inputPath: string): Promise<VideoMetadata> {
    return new Promise((resolve, reject) => {
      ffmpeg.ffprobe(inputPath, (err, metadata) => {
        if (err) reject(err);
        else resolve(metadata as VideoMetadata);
      });
    });
  }

  /**
   * Get audio metadata
   * 
   * @param inputPath - Path to audio file
   * @returns Audio metadata
   */
  private async getAudioMetadata(inputPath: string): Promise<AudioMetadata> {
    return new Promise((resolve, reject) => {
      ffmpeg.ffprobe(inputPath, (err, metadata) => {
        if (err) reject(err);
        else resolve(metadata as AudioMetadata);
      });
    });
  }

  /**
   * Record metrics for media processing
   * 
   * @param operation - Name of the operation
   * @param data - Metrics data
   */
  private async recordMetrics(operation: string, _data: MetricsData): Promise<void> {
    this.metricsService.recordOperationDuration(`${operation}_time`, Date.now());
  }

  /**
   * Check if a file exists
   * 
   * @param path - Path to file
   * @returns Whether file exists
   */
  private async fileExists(path: string): Promise<boolean> {
    try {
      await fs.access(path);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Validate bitrate string
   * 
   * @param bitrate - Bitrate string to validate
   * @param min - Minimum allowed bitrate
   * @param max - Maximum allowed bitrate
   * @returns Whether bitrate is valid
   */
  private isValidBitrate(bitrate: string, min: string, max: string): boolean {
    const value = parseInt(bitrate);
    const minValue = parseInt(min);
    const maxValue = parseInt(max);
    return value >= minValue && value <= maxValue;
  }
} 


===========================================================
FILE 22: app\social\feed\FeedService.ts
===========================================================

import { Post, PostVisibility } from "@database/models/social/Post";
import { UserRepository, FollowRepository, HashtagRepository, PostRepository } from "@database/repositories";
import { HashtagService, MetricsService } from "@services/app/social";
import {
  BaseService,
  CacheManager,
  PaginationOptions,
} from "@services/shared";
import {
  ResourceNotFoundError,
  ValidationError,
} from "@services/shared/errors/ServiceError";

// Constants for performance and caching
const HOME_FEED_CACHE_TTL = 300; // 5 minutes
const EXPLORE_FEED_CACHE_TTL = 900; // 15 minutes
const DEFAULT_FEED_LIMIT = 20;
const MAX_FEED_LIMIT = 100;
const CACHE_KEY_PREFIX = "feed:";

// Interfaces for repository methods
interface PostRepositoryMethods {
  findPostsByUsers(userIds: string[], limit: number, offset: number, options: PostQueryOptions): Promise<Post[]>;
  findPostsByUser(userId: string, limit: number, offset: number, options: PostQueryOptions): Promise<Post[]>;
  findPostsByHashtag(tag: string, limit: number, offset: number, options: PostQueryOptions): Promise<Post[]>;
  findPostsByHashtags(tags: string[], limit: number, offset: number, options: PostQueryOptions): Promise<Post[]>;
  findTrendingPosts(limit: number, offset: number, options: PostQueryOptions): Promise<Post[]>;
  findBookmarkedPosts(userId: string, limit: number, offset: number, options: PostQueryOptions): Promise<Post[]>;
}

interface FollowRepositoryMethods {
  getFollowing(userId: string): Promise<Array<{ followingId: string }>>;
  isFollowing(followerId: string, followingId: string): Promise<boolean>;
}

interface HashtagRepositoryMethods {
  findHashtagsByUserLikes(userId: string, limit: number): Promise<string[]>;
  findHashtagsFollowedByUser(userId: string): Promise<string[]>;
}

interface MetricsServiceMethods {
  recordMetric(name: string, value: number, tags?: Record<string, string>): void;
}

interface CacheManagerMethods {
  get<T>(key: string): Promise<T | null>;
  set<T>(key: string, value: T, ttl: number): Promise<void>;
  deletePattern(pattern: string): Promise<void>;
}

interface PostQueryOptions {
  startDate?: Date;
  endDate?: Date;
  visibility?: PostVisibility;
  excludedPostIds?: string[];
  minEngagementScore?: number;
}

/**
 * Interface for feed filtering and pagination
 */
export interface FeedOptions extends PaginationOptions {
  limit?: number;
  offset?: number;
  startDate?: Date;
  endDate?: Date;
  contentTypes?: string[];
  excludedUserIds?: string[];
  excludedPostIds?: string[];
  minEngagementScore?: number;
}

/**
 * Interface for normalized feed options with all fields required
 */
interface NormalizedFeedOptions extends Omit<Required<FeedOptions>, 'startDate' | 'endDate'> {
  startDate?: Date;
  endDate?: Date;
}

/**
 * Interface for feed response with posts and pagination info
 */
export interface FeedResponse {
  posts: Post[];
  hasMore: boolean;
  nextOffset?: number;
  totalEstimate?: number;
}

/**
 * Types of feed that can be requested
 */
export enum FeedType {
  HOME = "home",         // Personalized feed for user's home page
  PROFILE = "profile",   // Posts from a specific user profile
  EXPLORE = "explore",   // Discovery feed with trending/recommended content
  HASHTAG = "hashtag",   // Posts with a specific hashtag
  SAVED = "saved",       // User's saved/bookmarked posts
  FOLLOWING = "following" // Posts only from users being followed
}

/**
 * Interface for user's feed preferences
 */
export interface FeedPreferences {
  showReposts: boolean;
  preferredContentTypes: string[];
  preferredTopics: string[];
  hideContentFrom: string[]; // User IDs to hide
  sortOrder: "recent" | "popular";
  allowAiRecommendations: boolean;
  contentFilters: {
    sensitiveContent: boolean;
    controversialTopics: boolean;
    explicitLanguage: boolean;
  };
}

/**
 * Service responsible for generating personalized feeds and content discovery.
 * 
 * The FeedService orchestrates various data sources to create different types
 * of feeds, applying personalization, filtering, and ranking algorithms.
 */
export class FeedService extends BaseService {
  constructor(
    private postRepository: PostRepository & PostRepositoryMethods,
    private userRepository: UserRepository,
    private followRepository: FollowRepository & FollowRepositoryMethods,
    private hashtagRepository: HashtagRepository & HashtagRepositoryMethods,
    private hashtagService: HashtagService,
    private metricsService: MetricsService & MetricsServiceMethods,
    private cacheManager: CacheManager & CacheManagerMethods
  ) {
    super("FeedService");
  }

  /**
   * Get a user's personalized home feed
   * 
   * @param userId The ID of the user requesting the feed
   * @param options Options for filtering and pagination
   * @returns Feed response with posts and pagination info
   */
  async getHomeFeed(
    userId: string,
    options: FeedOptions = { limit: DEFAULT_FEED_LIMIT, offset: 0 }
  ): Promise<FeedResponse> {
    const startTime = Date.now();
    try {
      // Validate user exists
      const user = await this.userRepository.findById(userId);
      if (!user) {
        throw new ResourceNotFoundError(`User with ID ${userId} not found`);
      }

      // Validate and normalize options
      const normalizedOptions = this.normalizeOptions(options);
      
      // Try to get cached feed if no custom filters are applied
      const isCacheable = this.isFeedCacheable(normalizedOptions);
      const cacheKey = `${CACHE_KEY_PREFIX}home:${userId}:${normalizedOptions.offset}:${normalizedOptions.limit}`;
      
      if (isCacheable) {
        const cachedFeed = await this.cacheManager.get<FeedResponse>(cacheKey);
        if (cachedFeed) {
          this.logger.debug("Returned cached home feed", { userId });
          this.metricsService.recordMetric("feed_cache_hit", 1, { type: "home" });
          return cachedFeed;
        }
      }

      // Get IDs of users the current user follows
      const following = await this.followRepository.getFollowing(userId);
      const followingIds = following.map(follow => follow.followingId);
      
      // If user isn't following anyone yet, mix in some recommended posts
      let posts: Post[] = [];
      
      if (followingIds.length === 0) {
        this.logger.debug("User follows no one, getting recommended posts", { userId });
        posts = await this.getRecommendedPosts(userId, normalizedOptions);
      } else {
        // Get posts from followed users and include user's own posts
        const relevantUserIds = [...followingIds, userId];
        
        posts = await this.postRepository.findPostsByUsers(
          relevantUserIds,
          normalizedOptions.limit,
          normalizedOptions.offset,
          {
            startDate: normalizedOptions.startDate,
            endDate: normalizedOptions.endDate,
            visibility: PostVisibility.PUBLIC, // Only show public posts
            excludedPostIds: normalizedOptions.excludedPostIds
          }
        );
        
        // If we don't have enough posts, add some recommended ones
        if (posts.length < normalizedOptions.limit) {
          const recommendedPosts = await this.getRecommendedPosts(
            userId,
            {
              ...normalizedOptions,
              limit: normalizedOptions.limit - posts.length,
              excludedPostIds: [...(normalizedOptions.excludedPostIds || []), ...posts.map(p => p.id)]
            }
          );
          
          posts = [...posts, ...recommendedPosts];
        }
      }
      
      // Apply any additional filters
      posts = this.applyContentFilters(posts, normalizedOptions);
      
      // Create the feed response
      const feedResponse: FeedResponse = {
        posts,
        hasMore: posts.length >= normalizedOptions.limit,
        nextOffset: normalizedOptions.offset + posts.length,
        totalEstimate: followingIds.length * 5 // Rough estimate of total available posts
      };
      
      // Cache the results if cacheable
      if (isCacheable) {
        await this.cacheManager.set(cacheKey, feedResponse, HOME_FEED_CACHE_TTL);
      }
      
      // Record metrics
      this.metricsService.recordMetric("feed_generation_time", Date.now() - startTime, {
        type: "home",
        userId
      });
      this.metricsService.recordMetric("feed_post_count", posts.length, {
        type: "home",
        userId
      });
      
      return feedResponse;
    } catch (error) {
      this.logger.error("Error getting home feed", {
        userId,
        error: error instanceof Error ? error.message : String(error)
      });
      
      this.metricsService.recordMetric("feed_error", 1, {
        type: "home",
        userId,
        error: error instanceof Error ? error.name : "Unknown"
      });
      
      throw error;
    }
  }

  /**
   * Get posts for a user profile feed
   * 
   * @param profileUserId The ID of the user whose profile is being viewed
   * @param viewerId Optional ID of the user viewing the profile
   * @param options Options for filtering and pagination
   * @returns Feed response with posts and pagination info
   */
  async getProfileFeed(
    profileUserId: string,
    viewerId?: string,
    options: FeedOptions = { limit: DEFAULT_FEED_LIMIT, offset: 0 }
  ): Promise<FeedResponse> {
    const startTime = Date.now();
    try {
      // Validate profile user exists
      const profileUser = await this.userRepository.findById(profileUserId);
      if (!profileUser) {
        throw new ResourceNotFoundError(`User with ID ${profileUserId} not found`);
      }

      // Normalize options
      const normalizedOptions = this.normalizeOptions(options);
      
      // Determine visibility level based on relationship between viewer and profile
      let visibilityLevel: PostVisibility = PostVisibility.PUBLIC;
      
      if (viewerId) {
        // If viewing own profile, show everything
        if (viewerId === profileUserId) {
          visibilityLevel = PostVisibility.PRIVATE;
        } else {
          // Check if viewer follows profile user
          const isFollowing = await this.followRepository.isFollowing(viewerId, profileUserId);
          if (isFollowing) {
            visibilityLevel = PostVisibility.FOLLOWERS;
          }
        }
      }
      
      // Get posts for profile
      const posts = await this.postRepository.findPostsByUser(
        profileUserId,
        normalizedOptions.limit,
        normalizedOptions.offset,
        {
          startDate: normalizedOptions.startDate,
          endDate: normalizedOptions.endDate,
          visibility: visibilityLevel,
          excludedPostIds: normalizedOptions.excludedPostIds
        }
      );
      
      // Create feed response
      const feedResponse: FeedResponse = {
        posts,
        hasMore: posts.length >= normalizedOptions.limit,
        nextOffset: normalizedOptions.offset + posts.length
      };
      
      // Record metrics
      this.metricsService.recordMetric("feed_generation_time", Date.now() - startTime, {
        type: "profile",
        profileUserId,
        viewerId: viewerId || "anonymous"
      });
      
      return feedResponse;
    } catch (error) {
      this.logger.error("Error getting profile feed", {
        profileUserId,
        viewerId,
        error: error instanceof Error ? error.message : String(error)
      });
      
      this.metricsService.recordMetric("feed_error", 1, {
        type: "profile",
        profileUserId,
        viewerId: viewerId || "anonymous",
        error: error instanceof Error ? error.name : "Unknown"
      });
      
      throw error;
    }
  }

  /**
   * Get the explore feed for content discovery
   * 
   * @param userId Optional ID of the user viewing the explore feed
   * @param options Options for filtering and pagination
   * @returns Feed response with posts and pagination info
   */
  async getExploreFeed(
    userId?: string,
    options: FeedOptions = { limit: DEFAULT_FEED_LIMIT, offset: 0 }
  ): Promise<FeedResponse> {
    const startTime = Date.now();
    try {
      // Normalize options
      const normalizedOptions = this.normalizeOptions(options);
      
      // Try to get cached feed for anonymous users or basic requests
      const isCacheable = !userId && this.isFeedCacheable(normalizedOptions);
      const cacheKey = `${CACHE_KEY_PREFIX}explore:${normalizedOptions.offset}:${normalizedOptions.limit}`;
      
      if (isCacheable) {
        const cachedFeed = await this.cacheManager.get<FeedResponse>(cacheKey);
        if (cachedFeed) {
          this.logger.debug("Returned cached explore feed");
          this.metricsService.recordMetric("feed_cache_hit", 1, { type: "explore" });
          return cachedFeed;
        }
      }
      
      // Get trending posts
      const trendingPosts = await this.postRepository.findTrendingPosts(
        normalizedOptions.limit,
        normalizedOptions.offset,
        {
          startDate: normalizedOptions.startDate || new Date(Date.now() - 7 * 24 * 60 * 60 * 1000), // Last 7 days by default
          endDate: normalizedOptions.endDate,
          excludedPostIds: normalizedOptions.excludedPostIds
        }
      );
      
      // If we have a user ID, get user interests from their followed hashtags, liked posts, etc.
      let userInterests: string[] = [];
      if (userId) {
        userInterests = await this.getUserInterests(userId);
      }
      
      // Mix in some posts based on user interests if available
      let posts = trendingPosts;
      if (userId && userInterests.length > 0) {
        const interestPosts = await this.postRepository.findPostsByHashtags(
          userInterests,
          Math.floor(normalizedOptions.limit / 2),
          0,
          {
            excludedPostIds: [...(normalizedOptions.excludedPostIds || []), ...trendingPosts.map(p => p.id)]
          }
        );
        
        // Intersperse interest-based posts with trending posts
        posts = this.interspersePosts(trendingPosts, interestPosts);
        
        // Ensure we don't exceed the limit
        if (posts.length > normalizedOptions.limit) {
          posts = posts.slice(0, normalizedOptions.limit);
        }
      }
      
      // Create feed response
      const feedResponse: FeedResponse = {
        posts,
        hasMore: posts.length >= normalizedOptions.limit,
        nextOffset: normalizedOptions.offset + posts.length
      };
      
      // Cache the results if cacheable
      if (isCacheable) {
        await this.cacheManager.set(cacheKey, feedResponse, EXPLORE_FEED_CACHE_TTL);
      }
      
      // Record metrics
      this.metricsService.recordMetric("feed_generation_time", Date.now() - startTime, {
        type: "explore",
        userId: userId || "anonymous"
      });
      
      return feedResponse;
    } catch (error) {
      this.logger.error("Error getting explore feed", {
        userId,
        error: error instanceof Error ? error.message : String(error)
      });
      
      this.metricsService.recordMetric("feed_error", 1, {
        type: "explore",
        userId: userId || "anonymous",
        error: error instanceof Error ? error.name : "Unknown"
      });
      
      throw error;
    }
  }

  /**
   * Get posts for a specific hashtag
   * 
   * @param tag The hashtag to get posts for (without the # symbol)
   * @param userId Optional ID of the user viewing the hashtag feed
   * @param options Options for filtering and pagination
   * @returns Feed response with posts and pagination info
   */
  async getHashtagFeed(
    tag: string,
    userId?: string,
    options: FeedOptions = { limit: DEFAULT_FEED_LIMIT, offset: 0 }
  ): Promise<FeedResponse> {
    const startTime = Date.now();
    try {
      // Normalize the tag
      const normalizedTag = tag.toLowerCase().trim();
      if (!normalizedTag) {
        throw new ValidationError("Hashtag cannot be empty");
      }
      
      // Normalize options
      const normalizedOptions = this.normalizeOptions(options);
      
      // Get posts with the hashtag
      const posts = await this.postRepository.findPostsByHashtag(
        normalizedTag,
        normalizedOptions.limit,
        normalizedOptions.offset,
        {
          startDate: normalizedOptions.startDate,
          endDate: normalizedOptions.endDate,
          excludedPostIds: normalizedOptions.excludedPostIds
        }
      );
      
      // Create feed response
      const feedResponse: FeedResponse = {
        posts,
        hasMore: posts.length >= normalizedOptions.limit,
        nextOffset: normalizedOptions.offset + posts.length
      };
      
      // If the user is logged in, update hashtag stats to improve future recommendations
      if (userId) {
        this.hashtagService.createOrUpdateHashtag(normalizedTag)
          .catch(err => this.logger.error("Error updating hashtag", { tag: normalizedTag, error: err }));
      }
      
      // Record metrics
      this.metricsService.recordMetric("feed_generation_time", Date.now() - startTime, {
        type: "hashtag",
        tag: normalizedTag,
        userId: userId || "anonymous"
      });
      
      return feedResponse;
    } catch (error) {
      this.logger.error("Error getting hashtag feed", {
        tag,
        userId,
        error: error instanceof Error ? error.message : String(error)
      });
      
      this.metricsService.recordMetric("feed_error", 1, {
        type: "hashtag",
        tag,
        userId: userId || "anonymous",
        error: error instanceof Error ? error.name : "Unknown"
      });
      
      throw error;
    }
  }

  /**
   * Get a feed of bookmarked posts for a user
   * 
   * @param userId The ID of the user whose bookmarks to retrieve
   * @param options Options for filtering and pagination
   * @returns Feed response with posts and pagination info
   */
  async getSavedFeed(
    userId: string,
    options: FeedOptions = { limit: DEFAULT_FEED_LIMIT, offset: 0 }
  ): Promise<FeedResponse> {
    const startTime = Date.now();
    try {
      // Validate user exists
      const user = await this.userRepository.findById(userId);
      if (!user) {
        throw new ResourceNotFoundError(`User with ID ${userId} not found`);
      }

      // Normalize options
      const normalizedOptions = this.normalizeOptions(options);
      
      // Get user's bookmarked posts
      const posts = await this.postRepository.findBookmarkedPosts(
        userId,
        normalizedOptions.limit,
        normalizedOptions.offset,
        {
          startDate: normalizedOptions.startDate,
          endDate: normalizedOptions.endDate,
          excludedPostIds: normalizedOptions.excludedPostIds
        }
      );
      
      // Create feed response
      const feedResponse: FeedResponse = {
        posts,
        hasMore: posts.length >= normalizedOptions.limit,
        nextOffset: normalizedOptions.offset + posts.length
      };
      
      // Record metrics
      this.metricsService.recordMetric("feed_generation_time", Date.now() - startTime, {
        type: "saved",
        userId
      });
      
      return feedResponse;
    } catch (error) {
      this.logger.error("Error getting saved feed", {
        userId,
        error: error instanceof Error ? error.message : String(error)
      });
      
      this.metricsService.recordMetric("feed_error", 1, {
        type: "saved",
        userId,
        error: error instanceof Error ? error.name : "Unknown"
      });
      
      throw error;
    }
  }

  /**
   * Get feed based on feed type and parameters
   * 
   * @param type The type of feed to retrieve
   * @param userId Optional ID of the user requesting the feed
   * @param targetId Optional target ID (e.g., profile user ID or hashtag)
   * @param options Options for filtering and pagination
   * @returns Feed response with posts and pagination info
   */
  async getFeed(
    type: FeedType,
    userId?: string,
    targetId?: string,
    options: FeedOptions = { limit: DEFAULT_FEED_LIMIT, offset: 0 }
  ): Promise<FeedResponse> {
    switch (type) {
      case FeedType.HOME:
        if (!userId) {
          throw new ValidationError("User ID is required for home feed");
        }
        return this.getHomeFeed(userId, options);
        
      case FeedType.PROFILE:
        if (!targetId) {
          throw new ValidationError("Target user ID is required for profile feed");
        }
        return this.getProfileFeed(targetId, userId, options);
        
      case FeedType.EXPLORE:
        return this.getExploreFeed(userId, options);
        
      case FeedType.HASHTAG:
        if (!targetId) {
          throw new ValidationError("Hashtag is required for hashtag feed");
        }
        return this.getHashtagFeed(targetId, userId, options);
        
      case FeedType.SAVED:
        if (!userId) {
          throw new ValidationError("User ID is required for saved feed");
        }
        return this.getSavedFeed(userId, options);
        
      case FeedType.FOLLOWING:
        if (!userId) {
          throw new ValidationError("User ID is required for following feed");
        }
        // Use the home feed but with a filter to only show posts from followed users
        return this.getHomeFeed(userId, {
          ...options,
          excludedUserIds: [] // No excluded users for this feed type
        });
        
      default:
        throw new ValidationError(`Invalid feed type: ${type}`);
    }
  }

  /**
   * Get recommended posts for a user
   * 
   * @param userId The ID of the user to get recommendations for
   * @param options Options for filtering and pagination
   * @returns Array of recommended posts
   */
  private async getRecommendedPosts(
    userId: string,
    options: FeedOptions
  ): Promise<Post[]> {
    // Get user interests (from likes, follows, etc.)
    const userInterests = await this.getUserInterests(userId);
    
    // If we have user interests, get some posts based on those
    if (userInterests.length > 0) {
      const interestPosts = await this.postRepository.findPostsByHashtags(
        userInterests,
        options.limit || DEFAULT_FEED_LIMIT / 2,
        0,
        {
          excludedPostIds: options.excludedPostIds,
          minEngagementScore: options.minEngagementScore || 0.5
        }
      );
      
      // Also get some trending posts for variety
      const trendingPosts = await this.postRepository.findTrendingPosts(
        options.limit || DEFAULT_FEED_LIMIT / 2,
        0,
        {
          excludedPostIds: [...(options.excludedPostIds || []), ...interestPosts.map(p => p.id)]
        }
      );
      
      // Combine and shuffle the posts
      return this.interspersePosts(interestPosts, trendingPosts);
    }
    
    // If no user interests, just return trending posts
    return this.postRepository.findTrendingPosts(
      options.limit || DEFAULT_FEED_LIMIT,
      options.offset || 0,
      {
        excludedPostIds: options.excludedPostIds
      }
    );
  }

  /**
   * Get user interests based on their activity
   * 
   * @param userId The ID of the user to get interests for
   * @returns Array of interests (usually hashtags)
   */
  private async getUserInterests(userId: string): Promise<string[]> {
    // This could involve multiple repositories and complex logic
    // For now, we'll implement a simplified version
    
    try {
      const [
        likedPostHashtags,
        followedHashtags
      ] = await Promise.all([
        // Get hashtags from posts the user has liked
        this.hashtagRepository.findHashtagsByUserLikes(userId, 10),
        
        // Get hashtags the user explicitly follows
        this.hashtagRepository.findHashtagsFollowedByUser(userId)
      ]);
      
      // Combine and deduplicate hashtags
      const allTags = [...likedPostHashtags, ...followedHashtags];
      const uniqueTags = [...new Set(allTags.map(tag => tag.toLowerCase()))];
      
      return uniqueTags;
    } catch (error) {
      this.logger.error("Error getting user interests", {
        userId,
        error: error instanceof Error ? error.message : String(error)
      });
      
      // Return empty array on error
      return [];
    }
  }

  /**
   * Normalize feed options with defaults and validation
   * 
   * @param options Raw feed options
   * @returns Normalized feed options
   */
  private normalizeOptions(options: FeedOptions): NormalizedFeedOptions {
    // Set defaults for pagination
    const limit = options.limit || DEFAULT_FEED_LIMIT;
    const offset = options.offset || 0;
    
    // Validate limit
    if (limit > MAX_FEED_LIMIT) {
      throw new ValidationError(`Feed limit cannot exceed ${MAX_FEED_LIMIT}`);
    }
    
    // Return normalized options
    return {
      limit,
      offset,
      page: options.page || 1,
      sortBy: options.sortBy || 'createdAt',
      sortOrder: options.sortOrder || 'desc',
      startDate: options.startDate,
      endDate: options.endDate,
      contentTypes: options.contentTypes || [],
      excludedUserIds: options.excludedUserIds || [],
      excludedPostIds: options.excludedPostIds || [],
      minEngagementScore: options.minEngagementScore || 0.5
    };
  }

  /**
   * Check if feed can be cached based on options
   * 
   * @param options Feed options
   * @returns Whether the feed can be cached
   */
  private isFeedCacheable(options: FeedOptions): boolean {
    // Cache if using default options without custom filters
    return (
      options.limit === DEFAULT_FEED_LIMIT &&
      !options.startDate &&
      !options.endDate &&
      !options.contentTypes &&
      !options.excludedUserIds &&
      !options.excludedPostIds &&
      !options.minEngagementScore
    );
  }

  /**
   * Apply content filters to posts
   * 
   * @param posts Posts to filter
   * @param options Feed options with filters
   * @returns Filtered posts
   */
  private applyContentFilters(posts: Post[], options: FeedOptions): Post[] {
    // If no filters, return all posts
    if (
      !options.contentTypes &&
      !options.excludedUserIds &&
      !options.minEngagementScore
    ) {
      return posts;
    }
    
    return posts.filter(post => {
      // Filter by content type if specified
      if (
        options.contentTypes &&
        options.contentTypes.length > 0 &&
        !options.contentTypes.includes(post.type)
      ) {
        return false;
      }
      
      // Filter out excluded users
      if (
        options.excludedUserIds &&
        options.excludedUserIds.includes(post.userId)
      ) {
        return false;
      }
      
      // Filter by engagement score if specified
      if (
        options.minEngagementScore &&
        this.calculateEngagementScore(post) < options.minEngagementScore
      ) {
        return false;
      }
      
      return true;
    });
  }

  /**
   * Calculate engagement score for a post
   * 
   * @param post Post to calculate score for
   * @returns Engagement score between 0 and 1
   */
  private calculateEngagementScore(post: Post): number {
    const likes = post.likeCount || 0;
    const comments = post.commentCount || 0;
    const shares = post.shareCount || 0;
    const views = post.viewCount || 0;
    
    // Simple engagement formula
    if (views === 0) return 0;
    
    // Score based on like/view ratio, comment/view ratio, and share/view ratio
    const likeRatio = likes / views;
    const commentRatio = comments / views;
    const shareRatio = shares / views;
    
    // Weighted average (shares are worth more than comments, which are worth more than likes)
    const score = (likeRatio * 0.3) + (commentRatio * 0.4) + (shareRatio * 0.7);
    
    // Normalize to 0-1 range (most posts will be under 0.2)
    return Math.min(score * 5, 1);
  }

  /**
   * Intersperse two arrays of posts for a mixed feed
   * 
   * @param array1 First array of posts
   * @param array2 Second array of posts
   * @returns Combined and interspersed posts
   */
  private interspersePosts(array1: Post[], array2: Post[]): Post[] {
    const result: Post[] = [];
    const maxLength = Math.max(array1.length, array2.length);
    
    for (let i = 0; i < maxLength; i++) {
      if (i < array1.length) {
        result.push(array1[i]);
      }
      
      if (i < array2.length) {
        result.push(array2[i]);
      }
    }
    
    return result;
  }

  /**
   * Invalidate feed cache for a user
   * 
   * @param userId The ID of the user whose feed cache to invalidate
   */
  async invalidateFeedCache(userId: string): Promise<void> {
    try {
      const cachePattern = `${CACHE_KEY_PREFIX}home:${userId}:*`;
      await this.cacheManager.deletePattern(cachePattern);
      this.logger.debug("Invalidated feed cache", { userId });
    } catch (error) {
      this.logger.error("Error invalidating feed cache", {
        userId,
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }

  /**
   * Get feed preferences for a user
   * 
   * @param userId The ID of the user to get preferences for
   * @returns User's feed preferences
   */
  async getFeedPreferences(userId: string): Promise<FeedPreferences> {
    try {
      // In a real implementation, this would get preferences from a database
      // For now, return default preferences
      
      return {
        showReposts: true,
        preferredContentTypes: [],
        preferredTopics: [],
        hideContentFrom: [],
        sortOrder: "recent",
        allowAiRecommendations: true,
        contentFilters: {
          sensitiveContent: false,
          controversialTopics: false,
          explicitLanguage: false
        }
      };
    } catch (error) {
      this.logger.error("Error getting feed preferences", {
        userId,
        error: error instanceof Error ? error.message : String(error)
      });
      
      // Return default preferences on error
      return {
        showReposts: true,
        preferredContentTypes: [],
        preferredTopics: [],
        hideContentFrom: [],
        sortOrder: "recent",
        allowAiRecommendations: true,
        contentFilters: {
          sensitiveContent: false,
          controversialTopics: false,
          explicitLanguage: false
        }
      };
    }
  }

  /**
   * Update feed preferences for a user
   * 
   * @param userId The ID of the user to update preferences for
   * @param preferences The new preferences
   */
  async updateFeedPreferences(
    userId: string,
    preferences: Partial<FeedPreferences>
  ): Promise<void> {
    try {
      // In a real implementation, this would update preferences in a database
      // For now, log the update
      this.logger.info("Updated feed preferences", { userId, preferences });
      
      // Invalidate any cached feeds for this user
      await this.invalidateFeedCache(userId);
    } catch (error) {
      this.logger.error("Error updating feed preferences", {
        userId,
        preferences,
        error: error instanceof Error ? error.message : String(error)
      });
      
      throw error;
    }
  }
} 


===========================================================
FILE 23: app\social\hashtag\HashtagService.ts
===========================================================

import { Hashtag, HashtagCategory } from "@models/social/Hashtag";
import { HashtagRepository } from "@repositories/social/HashtagRepository";
import { PostRepository } from "@repositories/social/PostRepository";
import { MetricsService } from "@services/app/social/monitoring/MetricsService";
import { BaseService, CacheManager } from "@services/shared";
import {
  ResourceNotFoundError,
  ValidationError,
} from "@services/shared/errors/ServiceError";

const CACHE_TTL = 3600; // 1 hour
const TRENDING_CACHE_TTL = 300; // 5 minutes
const ANALYTICS_CACHE_TTL = 86400; // 24 hours
const BATCH_SIZE = 100;
const MAX_HASHTAGS_PER_POST = 30;
const MIN_TAG_LENGTH = 2;
const MAX_TAG_LENGTH = 50;

export interface HashtagStats {
  usageCount: number;
  postsCount: number;
  uniqueUsers: number;
  category: HashtagCategory;
  avgEngagement: number;
  lastUsedAt: Date;
}

export interface TrendingHashtag extends HashtagStats {
  tag: string;
  momentum: number;
  normalizedScore: number;
  velocityScore: number;
  peakUsageTime: string;
}

export interface HashtagAnalytics {
  hourlyUsage: Map<number, number>;
  dailyUsage: Map<string, number>;
  topUsers: Array<{ userId: string; count: number }>;
  relatedTags: Array<{ tag: string; correlation: number }>;
  engagementRate: number;
}

/**
 * Service responsible for managing hashtags and trends.
 * Features:
 * 1. Hashtag creation and management
 * 2. Trending hashtag calculation
 * 3. Hashtag search and suggestions
 * 4. Usage statistics and analytics
 * 5. Batch operations
 * 6. Caching with different TTLs
 * 7. Performance metrics tracking
 */
export class HashtagService extends BaseService {
  constructor(
    private hashtagRepository: HashtagRepository,
    private postRepository: PostRepository,
    private metricsService: MetricsService,
    private cacheManager: CacheManager,
  ) {
    super("HashtagService");
  }

  /**
   * Create or update a hashtag
   * @param tag - The hashtag text (without #)
   * @param category - Optional category for the hashtag
   */
  async createOrUpdateHashtag(
    tag: string,
    category?: HashtagCategory,
  ): Promise<Hashtag> {
    const startTime = Date.now();
    try {
      // Validate tag
      if (!this.isValidTag(tag)) {
        throw new ValidationError("Invalid hashtag format");
      }

      const normalizedTag = this.normalizeTag(tag);
      let hashtag = await this.hashtagRepository.findByTag(normalizedTag);

      if (hashtag && category && category !== hashtag.category) {
        hashtag = await this.withTransaction(async () => {
          const updated = await this.hashtagRepository.update(hashtag!.id, {
            category,
            lastUsedAt: new Date(),
          });
          await this.invalidateHashtagCache(normalizedTag);
          return updated;
        });
      }

      if (hashtag) {
        return hashtag;
      }

      const result = await this.hashtagRepository.create(
        new Hashtag({
          tag,
          normalizedTag,
          category: category || HashtagCategory.GENERAL,
          usageCount: 0,
        }),
      );

      this.metricsService.recordOperationDuration(
        "create_hashtag",
        Date.now() - startTime,
      );
      return result;
    } catch (error) {
      this.metricsService.recordOperationError(
        "create_hashtag",
        (error as Error).name,
      );
      throw error;
    }
  }

  /**
   * Extract and process hashtags from text
   * @param text - Text containing hashtags
   */
  async processHashtags(
    text: string,
    _postId: string,
    _userId: string,
  ): Promise<Hashtag[]> {
    const startTime = Date.now();
    try {
      const tags = this.extractHashtags(text);
      if (tags.length === 0) {
        return [];
      }

      if (tags.length > MAX_HASHTAGS_PER_POST) {
        throw new ValidationError(
          `Maximum ${MAX_HASHTAGS_PER_POST} hashtags allowed per post`,
        );
      }

      const hashtags = await this.withTransaction(async () => {
        const created = await Promise.all(
          tags.map((tag) => this.createOrUpdateHashtag(tag)),
        );

        await Promise.all(
          created.map((h) => this.hashtagRepository.incrementUsage(h.id)),
        );

        await this.updateTrendingScores(created.map((h) => h.normalizedTag));
        return created;
      });

      this.metricsService.recordLatency(
        "process_hashtags",
        Date.now() - startTime,
      );
      return hashtags;
    } catch (error) {
      this.metricsService.incrementCounter("hashtag_processing_error");
      throw error;
    }
  }

  /**
   * Get trending hashtags
   * @param timeframe - Timeframe in hours to consider for trending calculation
   * @param limit - Number of trending hashtags to return
   */
  async getTrendingHashtags(
    timeframe: number = 24,
    limit: number = 10,
  ): Promise<TrendingHashtag[]> {
    const cacheKey = `trending_hashtags:${timeframe}:${limit}`;
    return this.withCache(
      cacheKey,
      async () => {
        const trending = await this.hashtagRepository.findTrending(
          timeframe,
          limit,
        );

        // Enrich trending data with analytics
        const enrichedTrending = await Promise.all(
          trending.map(async (tag) => {
            const analytics = await this.getHashtagAnalytics(tag.tag);
            const stats = await this.getHashtagStats(tag.tag);
            return {
              ...tag,
              ...stats,
              peakUsageTime: this.findPeakUsageTime(analytics.hourlyUsage),
              velocityScore: this.calculateVelocityScore(analytics),
              momentum: 0,
              normalizedScore: 0,
            };
          }),
        );

        return this.normalizeTrendingScores(enrichedTrending);
      },
      TRENDING_CACHE_TTL,
    );
  }

  /**
   * Search hashtags by prefix
   * @param prefix - Hashtag prefix to search for
   * @param limit - Maximum number of results
   */
  async searchHashtags(prefix: string, limit: number = 10): Promise<Hashtag[]> {
    const cacheKey = `hashtag_search:${prefix}:${limit}`;
    return this.withCache(
      cacheKey,
      async () => {
        return this.hashtagRepository.searchByText(prefix, limit);
      },
      CACHE_TTL,
    );
  }

  /**
   * Get hashtag statistics
   * @param tag - The hashtag to get statistics for
   */
  async getHashtagStats(tag: string): Promise<HashtagStats> {
    const cacheKey = `hashtag_stats:${tag}`;
    return this.withCache(
      cacheKey,
      async () => {
        const hashtag = await this.hashtagRepository.findByTag(tag);
        if (!hashtag) {
          throw new ResourceNotFoundError("Hashtag not found");
        }

        const [postsCount, uniqueUsers] = await Promise.all([
          this.postRepository.countByHashtag(hashtag.id),
          this.postRepository.countUniqueUsersByHashtag(hashtag.id),
        ]);

        return {
          usageCount: hashtag.usageCount,
          postsCount,
          uniqueUsers,
          category: hashtag.category,
          avgEngagement: 0, // Placeholder for avgEngagement
          lastUsedAt: hashtag.lastUsedAt as Date,
        };
      },
      CACHE_TTL,
    );
  }

  /**
   * Get related hashtags
   * @param tag - The hashtag to find related tags for
   * @param limit - Maximum number of related tags to return
   */
  async getRelatedHashtags(
    tag: string,
    limit: number = 10,
  ): Promise<Hashtag[]> {
    const cacheKey = `related_hashtags:${tag}:${limit}`;
    return this.withCache(
      cacheKey,
      async () => {
        const hashtag = await this.hashtagRepository.findByTag(tag);
        if (!hashtag) {
          throw new ResourceNotFoundError("Hashtag not found");
        }

        return this.hashtagRepository.findRelated(hashtag.id, limit);
      },
      CACHE_TTL,
    );
  }

  /**
   * Batch get hashtag statistics
   * @param tags - Array of hashtags to get statistics for
   */
  async batchGetHashtagStats(
    tags: string[],
  ): Promise<Map<string, HashtagStats>> {
    const result = new Map<string, HashtagStats>();

    for (let i = 0; i < tags.length; i += BATCH_SIZE) {
      const batch = tags.slice(i, i + BATCH_SIZE);
      const stats = await this.hashtagRepository.getBatchStats(batch);

      stats.forEach((stat, tag) => {
        result.set(tag, stat);
      });
    }

    return result;
  }

  async getHashtagAnalytics(tag: string): Promise<HashtagAnalytics> {
    const cacheKey = `hashtag_analytics:${tag}`;
    return this.withCache(
      cacheKey,
      async () => {
        const hashtag = await this.hashtagRepository.findByTag(tag);
        if (!hashtag) {
          throw new ResourceNotFoundError("Hashtag not found");
        }

        const [hourlyUsage, dailyUsage, topUsers, relatedTags, engagementRate] =
          await Promise.all([
            this.hashtagRepository.getHourlyUsage(hashtag.id),
            this.hashtagRepository.getDailyUsage(hashtag.id),
            this.hashtagRepository.getTopUsers(hashtag.id),
            this.hashtagRepository.getRelatedTags(hashtag.id),
            this.calculateEngagementRate(hashtag.id),
          ]);

        return {
          hourlyUsage,
          dailyUsage,
          topUsers,
          relatedTags,
          engagementRate,
        };
      },
      ANALYTICS_CACHE_TTL,
    );
  }

  private normalizeTag(tag: string): string {
    // Remove # if present and convert to lowercase
    return tag.replace(/^#/, "").toLowerCase().trim();
  }

  private extractHashtags(text: string): string[] {
    const hashtagRegex = /#(\w+)/g;
    const matches = text.match(hashtagRegex);

    if (!matches) {
      return [];
    }

    return [...new Set(matches.map((tag) => this.normalizeTag(tag)))];
  }

  private isValidTag(tag: string): boolean {
    const normalizedTag = this.normalizeTag(tag);
    return (
      normalizedTag.length >= MIN_TAG_LENGTH &&
      normalizedTag.length <= MAX_TAG_LENGTH &&
      /^[a-z0-9_]+$/i.test(normalizedTag)
    );
  }

  private async calculateEngagementRate(hashtagId: string): Promise<number> {
    const [posts, interactions] = await Promise.all([
      this.postRepository.countByHashtag(hashtagId),
      this.postRepository.getHashtagInteractions(hashtagId),
    ]);
    return posts > 0 ? interactions / posts : 0;
  }

  private findPeakUsageTime(hourlyUsage: Map<number, number>): string {
    let peakHour = 0;
    let peakCount = 0;

    hourlyUsage.forEach((count, hour) => {
      if (count > peakCount) {
        peakCount = count;
        peakHour = hour;
      }
    });

    return `${peakHour}:00`;
  }

  private calculateVelocityScore(analytics: HashtagAnalytics): number {
    const recentHours = Array.from(analytics.hourlyUsage.entries()).slice(-6); // Last 6 hours

    if (recentHours.length < 2) return 0;

    const velocities = recentHours.slice(1).map((current, index) => {
      const previous = recentHours[index];
      return (current[1] - previous[1]) / 1;
    });

    return velocities.reduce((sum, v) => sum + v, 0) / velocities.length;
  }

  private async invalidateHashtagCache(tag: string): Promise<void> {
    const keys = [
      `hashtag:${tag}*`,
      `trending_hashtags:*`,
      `hashtag_analytics:${tag}`,
      `related_hashtags:${tag}*`,
    ];
    await Promise.all(keys.map((key) => this.cacheManager.delete(key)));
  }

  /**
   * Update trending scores for hashtags
   * @param tags - Array of normalized tag names
   */
  private async updateTrendingScores(tags: string[]): Promise<void> {
    try {
      const now = new Date();
      const oneHourAgo = new Date(now.getTime() - 3600000);
      const oneDayAgo = new Date(now.getTime() - 86400000);

      // Get usage counts for different time periods
      const [hourlyUsage, dailyUsage] = await Promise.all([
        this.hashtagRepository.getUsageCountsInTimeRange(tags, oneHourAgo, now),
        this.hashtagRepository.getUsageCountsInTimeRange(tags, oneDayAgo, now),
      ]);

      // Calculate momentum and update scores
      const updates = tags.map((tag) => {
        const hourlyCount = hourlyUsage.get(tag) || 0;
        const dailyCount = dailyUsage.get(tag) || 0;

        // Calculate momentum: weight recent activity more heavily
        const momentum = (hourlyCount * 24) / (dailyCount || 1);

        return this.hashtagRepository.updateTrendingScore(tag, {
          hourlyCount,
          dailyCount,
          momentum,
        });
      });

      await Promise.all(updates);
    } catch (error) {
      this.metricsService.incrementCounter("trending_score_update_error");
      console.error("Failed to update trending scores:", error);
    }
  }

  /**
   * Normalize trending scores for a list of trending hashtags
   * @param trending - Array of trending hashtags with raw scores
   */
  private normalizeTrendingScores(
    trending: TrendingHashtag[],
  ): TrendingHashtag[] {
    if (trending.length === 0) return trending;

    // Find maximum values for normalization
    const maxMomentum = Math.max(...trending.map((t) => t.momentum));
    const maxVelocity = Math.max(...trending.map((t) => t.velocityScore));
    const maxUsage = Math.max(...trending.map((t) => t.usageCount));

    // Normalize scores between 0 and 1
    return trending
      .map((tag) => {
        const normalizedMomentum =
          maxMomentum > 0 ? tag.momentum / maxMomentum : 0;
        const normalizedVelocity =
          maxVelocity > 0 ? tag.velocityScore / maxVelocity : 0;
        const normalizedUsage = maxUsage > 0 ? tag.usageCount / maxUsage : 0;

        // Calculate final trending score with weights
        const normalizedScore =
          normalizedMomentum * 0.4 + // Recent growth
          normalizedVelocity * 0.4 + // Rate of change
          normalizedUsage * 0.2; // Overall popularity

        return {
          ...tag,
          normalizedScore,
        };
      })
      .sort((a, b) => b.normalizedScore - a.normalizedScore);
  }
}



===========================================================
FILE 24: app\social\hashtag\index.ts
===========================================================

// Export hashtag services
export * from "./HashtagService";



===========================================================
FILE 25: app\social\index.ts
===========================================================

// Export social service modules
export * from "./post";
export * from "./notification";
export * from "./monitoring";
export * from "./interaction";
export * from "./hashtag";



===========================================================
FILE 26: app\social\interaction\BookmarkService.ts
===========================================================

import { Bookmark, EntityType } from "@database/models/social/Bookmark";
import { BookmarkRepository, PostRepository } from "@repositories/social";
import { MetricsService } from "@services/app/social/monitoring/MetricsService";
import { BaseService, CacheManager, PaginationOptions } from "@services/shared";
import { ResourceNotFoundError } from "@services/shared/errors/ServiceError";
const CACHE_TTL = 3600; // 1 hour
const BATCH_SIZE = 100;

export class BookmarkService extends BaseService {
  constructor(
    private bookmarkRepository: BookmarkRepository,
    private postRepository: PostRepository,
    private metricsService: MetricsService,
    private cacheManager: CacheManager,
  ) {
    super("BookmarkService");
  }

  async bookmarkPost(userId: string, postId: string): Promise<Bookmark> {
    const startTime = Date.now();
    try {
      const post = await this.postRepository.findById(postId);
      if (!post) {
        throw new ResourceNotFoundError("Post not found");
      }

      const existingBookmark = await this.bookmarkRepository.findByUserAndPost(
        userId,
        postId,
      );
      if (existingBookmark) {
        return existingBookmark;
      }

      const result = await this.withTransaction(async () => {
        const bookmark = await this.bookmarkRepository.create({
          userId,
          entityId: postId,
          entityType: EntityType.POST,
          collectionId: null,
          notes: null,
        });

        await this.postRepository.incrementBookmarkCount(postId);
        await this.invalidateBookmarkCache(userId, postId);

        return bookmark;
      });

      this.metricsService.recordLatency(
        "bookmark_post",
        Date.now() - startTime,
      );
      this.metricsService.incrementCounter("bookmarks_created");
      return result;
    } catch (error) {
      this.metricsService.incrementCounter("bookmark_creation_error");
      throw error;
    }
  }

  async unbookmarkPost(userId: string, postId: string): Promise<void> {
    const startTime = Date.now();
    try {
      const bookmark = await this.bookmarkRepository.findByUserAndPost(
        userId,
        postId,
      );
      if (!bookmark) {
        return;
      }

      await this.withTransaction(async () => {
        await this.bookmarkRepository.delete(bookmark.id);
        await this.postRepository.decrementBookmarkCount(postId);
        await this.invalidateBookmarkCache(userId, postId);
      });

      this.metricsService.recordLatency(
        "unbookmark_post",
        Date.now() - startTime,
      );
      this.metricsService.incrementCounter("bookmarks_deleted");
    } catch (error) {
      this.metricsService.incrementCounter("bookmark_deletion_error");
      throw error;
    }
  }

  async getUserBookmarks(
    userId: string,
    options: PaginationOptions,
  ): Promise<Bookmark[]> {
    const cacheKey = `user_bookmarks:${userId}:${JSON.stringify(options)}`;
    return this.withCache(
      cacheKey,
      async () => {
        return this.bookmarkRepository.findByUserId(userId, options);
      },
      CACHE_TTL,
    );
  }

  async isPostBookmarked(userId: string, postId: string): Promise<boolean> {
    const cacheKey = `bookmark_status:${userId}:${postId}`;
    return this.withCache(
      cacheKey,
      async () => {
        const bookmark = await this.bookmarkRepository.findByUserAndPost(
          userId,
          postId,
        );
        return !!bookmark;
      },
      CACHE_TTL,
    );
  }

  async getBookmarkCount(postId: string): Promise<number> {
    const cacheKey = `bookmark_count:${postId}`;
    return this.withCache(
      cacheKey,
      async () => {
        return this.bookmarkRepository.countByPost(postId);
      },
      CACHE_TTL,
    );
  }

  async batchGetBookmarkStatus(
    userId: string,
    postIds: string[],
  ): Promise<Map<string, boolean>> {
    const result = new Map<string, boolean>();

    // Process in batches to avoid overloading the database
    for (let i = 0; i < postIds.length; i += BATCH_SIZE) {
      const batch = postIds.slice(i, i + BATCH_SIZE);
      const bookmarks = await this.bookmarkRepository.findByUserAndPosts(
        userId,
        batch,
      );

      // Create a set of bookmarked post IDs for faster lookup
      const bookmarkedPostIds = new Set(
        bookmarks.map((bookmark) => bookmark.postId),
      );

      // Map results
      batch.forEach((postId) => {
        result.set(postId, bookmarkedPostIds.has(postId));
      });
    }

    return result;
  }

  async batchGetBookmarkCounts(
    postIds: string[],
  ): Promise<Map<string, number>> {
    const result = new Map<string, number>();

    // Process in batches
    for (let i = 0; i < postIds.length; i += BATCH_SIZE) {
      const batch = postIds.slice(i, i + BATCH_SIZE);
      const counts = await this.bookmarkRepository.countByPosts(batch);

      // Map results
      counts.forEach(({ postId, count }) => {
        result.set(postId, count);
      });
    }

    return result;
  }

  private async invalidateBookmarkCache(
    userId: string,
    postId: string,
  ): Promise<void> {
    const keys = [
      `user_bookmarks:${userId}*`,
      `bookmark_status:${userId}:${postId}`,
      `bookmark_count:${postId}`,
    ];
    await Promise.all(keys.map((key) => this.cacheManager.delete(key)));
  }
}



===========================================================
FILE 27: app\social\interaction\CommentService.ts
===========================================================

import { ContentStatus, EntityType } from "@database/models/shared/EntityTypes";
import { Comment } from "@models/social/Comment";
import { NotificationType, Notification } from "@models/social/Notification";
import {
  CommentRepository,
  NotificationRepository,
  PostRepository,
} from "@repositories/social";
import { MetricsService } from "@services/app/social/monitoring/MetricsService";
import {
  BaseService,
  ContentValidator,
  CacheManager,
  PostRateLimiter,
  PaginationOptions,
} from "@services/shared";
import {
  ResourceNotFoundError,
  UnauthorizedError,
} from "@services/shared/errors/ServiceError";

const CACHE_TTL = 3600; // 1 hour
const BATCH_SIZE = 50;

export interface CreateCommentData {
  content: string;
  parentId?: string;
}

export interface UpdateCommentData {
  content: string;
}

export interface CommentThread {
  comment: Comment;
  replies: Comment[];
  totalReplies: number;
}

export class CommentService extends BaseService {
  private cacheManager: CacheManager;

  constructor(
    private commentRepository: CommentRepository,
    private postRepository: PostRepository,
    private notificationRepository: NotificationRepository,
    private metricsService: MetricsService,
    private rateLimiter: PostRateLimiter,
    private contentValidator: ContentValidator,
  ) {
    super("CommentService");
    this.cacheManager = new CacheManager();
  }

  async createComment(
    userId: string,
    postId: string,
    data: CreateCommentData,
  ): Promise<Comment> {
    const startTime = Date.now();
    try {
      await this.rateLimiter.checkLimit(userId);
      await this.contentValidator.isValidText(data.content);

      const post = await this.postRepository.findById(postId);
      if (!post) {
        throw new ResourceNotFoundError("Post not found");
      }

      if (data.parentId) {
        const parentComment = await this.commentRepository.findById(
          data.parentId,
        );
        if (!parentComment || parentComment.postId !== postId) {
          throw new ResourceNotFoundError("Parent comment not found");
        }
      }

      const result = await this.withTransaction(async () => {
        const comment = await this.commentRepository.create({
          userId,
          postId,
          content: data.content,
          parentId: data.parentId || null,
          likesCount: 0,
          status: ContentStatus.PUBLISHED,
        });

        await this.postRepository.incrementCommentCount(postId);

        if (data.parentId) {
          await this.commentRepository.incrementReplyCount(data.parentId);
        }

        if (post.userId !== userId) {
          const notification = new Notification({
            userId: post.userId,
            type: NotificationType.COMMENT,
            actorId: userId,
            entityId: postId,
            entityType: EntityType.POST,
            content: data.content,
            metadata: { commentId: comment.id },
          });
          await this.notificationRepository.create(notification);
        }

        if (data.parentId) {
          const parentComment = await this.commentRepository.findById(
            data.parentId,
          );
          if (parentComment && parentComment.userId !== userId) {
            const notification = new Notification({
              userId: parentComment.userId,
              type: NotificationType.COMMENT,
              actorId: userId,
              entityId: data.parentId,
              entityType: EntityType.COMMENT,
              content: data.content,
              metadata: { commentId: comment.id },
            });
            await this.notificationRepository.create(notification);
          }
        }

        await this.invalidateCommentCache(postId, data.parentId);
        return comment;
      });

      this.metricsService.recordLatency(
        "create_comment",
        Date.now() - startTime,
      );
      this.metricsService.incrementCounter("comments_created");
      return result;
    } catch (error) {
      this.metricsService.incrementCounter("comment_creation_error");
      throw error;
    }
  }

  async updateComment(
    userId: string,
    commentId: string,
    data: UpdateCommentData,
  ): Promise<Comment> {
    const startTime = Date.now();
    try {
      const comment = await this.commentRepository.findById(commentId);
      if (!comment) {
        throw new ResourceNotFoundError("Comment not found");
      }

      if (comment.userId !== userId) {
        throw new UnauthorizedError("Not authorized to update this comment");
      }

      await this.contentValidator.isValidText(data.content);

      const updatedComment = await this.commentRepository.update(commentId, {
        content: data.content,
      });

      if (!updatedComment) {
        throw new ResourceNotFoundError("Failed to update comment");
      }

      await this.invalidateCommentCache(
        comment.postId,
        comment.parentId || undefined,
      );

      this.metricsService.recordLatency(
        "update_comment",
        Date.now() - startTime,
      );
      this.metricsService.incrementCounter("comments_updated");
      return updatedComment;
    } catch (error) {
      this.metricsService.incrementCounter("comment_update_error");
      throw error;
    }
  }

  async deleteComment(userId: string, commentId: string): Promise<void> {
    const startTime = Date.now();
    try {
      const comment = await this.commentRepository.findById(commentId);
      if (!comment) {
        throw new ResourceNotFoundError("Comment not found");
      }

      if (comment.userId !== userId) {
        throw new UnauthorizedError("Not authorized to delete this comment");
      }

      await this.withTransaction(async () => {
        await this.commentRepository.delete(commentId);
        await this.postRepository.decrementCommentCount(comment.postId);

        if (comment.parentId) {
          await this.commentRepository.decrementReplyCount(comment.parentId);
        }

        // Remove notifications related to this comment
        await this.notificationRepository.deleteByEntityId(
          commentId,
          EntityType.COMMENT,
        );
        await this.invalidateCommentCache(
          comment.postId,
          comment.parentId || undefined,
        );
      });

      this.metricsService.recordLatency(
        "delete_comment",
        Date.now() - startTime,
      );
      this.metricsService.incrementCounter("comments_deleted");
    } catch (error) {
      this.metricsService.incrementCounter("comment_deletion_error");
      throw error;
    }
  }

  async getPostComments(
    postId: string,
    options: PaginationOptions,
  ): Promise<Comment[]> {
    const cacheKey = `post_comments:${postId}:${JSON.stringify(options)}`;
    return this.withCache(
      cacheKey,
      async () => {
        const post = await this.postRepository.findById(postId);
        if (!post) {
          throw new ResourceNotFoundError("Post not found");
        }

        return this.commentRepository.findByPostId({
          postId,
          limit: options.limit,
          offset: options.offset || 0,
        });
      },
      CACHE_TTL,
    );
  }

  async getCommentThread(commentId: string): Promise<CommentThread> {
    const cacheKey = `comment_thread:${commentId}`;
    return this.withCache(
      cacheKey,
      async () => {
        const comment = await this.commentRepository.findById(commentId);
        if (!comment) {
          throw new ResourceNotFoundError("Comment not found");
        }

        const [replies, totalReplies] = await Promise.all([
          this.commentRepository.findByPostId({
            postId: comment.postId,
            parentId: commentId,
            limit: 5,
            offset: 0,
          }),
          this.commentRepository.countRepliesByParentId(commentId),
        ]);

        return {
          comment,
          replies,
          totalReplies,
        };
      },
      CACHE_TTL,
    );
  }

  async getCommentReplies(
    commentId: string,
    options: PaginationOptions,
  ): Promise<Comment[]> {
    const cacheKey = `comment_replies:${commentId}:${JSON.stringify(options)}`;
    return this.withCache(
      cacheKey,
      async () => {
        const comment = await this.commentRepository.findById(commentId);
        if (!comment) {
          throw new ResourceNotFoundError("Comment not found");
        }

        return this.commentRepository.findByPostId({
          postId: comment.postId,
          parentId: commentId,
          limit: options.limit,
          offset: options.offset || 0,
        });
      },
      CACHE_TTL,
    );
  }

  async getUserComments(
    userId: string,
    options: PaginationOptions,
  ): Promise<Comment[]> {
    const cacheKey = `user_comments:${userId}:${JSON.stringify(options)}`;
    return this.withCache(
      cacheKey,
      async () => {
        return this.commentRepository.findByUserId(userId, {
          limit: options.limit ?? 20,
          offset: options.offset,
        });
      },
      CACHE_TTL,
    );
  }

  async batchGetCommentThreads(
    commentIds: string[],
  ): Promise<Map<string, CommentThread>> {
    const result = new Map<string, CommentThread>();

    for (let i = 0; i < commentIds.length; i += BATCH_SIZE) {
      const batch = commentIds.slice(i, i + BATCH_SIZE);
      const comments = await Promise.all(
        batch.map((id) => this.commentRepository.findById(id)),
      );

      const validComments = comments.filter(
        (comment): comment is Comment => comment !== null,
      );

      const repliesPromises = validComments.map((comment) =>
        Promise.all([
          this.commentRepository.findByPostId({
            postId: comment.postId,
            parentId: comment.id,
            limit: 5,
            offset: 0,
          }),
          this.commentRepository.countRepliesByParentId(comment.id),
        ]),
      );

      const repliesResults = await Promise.all(repliesPromises);

      validComments.forEach((comment, index) => {
        const [replies, totalReplies] = repliesResults[index];
        result.set(comment.id, {
          comment,
          replies,
          totalReplies,
        });
      });
    }

    return result;
  }

  private async invalidateCommentCache(
    postId: string,
    parentId?: string,
  ): Promise<void> {
    const keys = [`post_comments:${postId}*`, `comment_count:${postId}`];

    if (parentId) {
      keys.push(`comment_thread:${parentId}`, `comment_replies:${parentId}*`);
    }

    await Promise.all(keys.map((key) => this.cacheManager.delete(key)));
  }
}



===========================================================
FILE 28: app\social\interaction\FollowService.ts
===========================================================

import { EntityType } from "@models/shared/EntityTypes";
import { Follow } from "@models/social/Follow";
import { NotificationType, Notification } from "@models/social/Notification";
import { UserRepository } from "@repositories/auth/UserRepository";
import { FollowRepository, NotificationRepository } from "@repositories/social";
import { MetricsService } from "@services/app/social/monitoring/MetricsService";
import { BaseService, CacheManager, PaginationOptions } from "@services/shared";
import {
  ResourceNotFoundError,
  ValidationError,
} from "@services/shared/errors/ServiceError";

const FOLLOW_RATE_LIMIT = 100; // Max follows per hour
const CACHE_TTL = 3600; // 1 hour
const BATCH_SIZE = 100;

export interface FollowStats {
  followersCount: number;
  followingCount: number;
  mutualFollowersCount: number;
  lastFollowedAt?: Date;
  lastFollowerAt?: Date;
}

export interface FollowFilters extends PaginationOptions {
  startDate?: Date;
  endDate?: Date;
  mutualOnly?: boolean;
  limit: number;
  offset: number;
}

/**
 * Service responsible for managing user follow relationships.
 * Features:
 * 1. Follow/unfollow users
 * 2. Get followers/following lists
 * 3. Check follow status
 * 4. Get follow statistics
 * 5. Batch operations for follow status
 * 6. Caching for frequently accessed data
 * 7. Performance metrics tracking
 */
export class FollowService extends BaseService {
  constructor(
    private followRepository: FollowRepository,
    private userRepository: UserRepository,
    private notificationRepository: NotificationRepository,
    private metricsService: MetricsService,
    private cacheManager: CacheManager,
  ) {
    super("FollowService");
  }

  /**
   * Follow a user
   * @param followerId - ID of the user who wants to follow
   * @param targetUserId - ID of the user to be followed
   */
  async followUser(followerId: string, targetUserId: string): Promise<Follow> {
    const startTime = Date.now();
    try {
      // Check rate limit
      const hourlyFollowCount =
        await this.followRepository.countFollowsInTimeRange(
          followerId,
          new Date(Date.now() - 3600000),
        );

      if (hourlyFollowCount >= FOLLOW_RATE_LIMIT) {
        throw new ValidationError("Follow rate limit exceeded");
      }

      // Validate users exist
      const [follower, targetUser] = await Promise.all([
        this.userRepository.findById(followerId),
        this.userRepository.findById(targetUserId),
      ]);

      if (!follower || !targetUser) {
        throw new ResourceNotFoundError("User not found");
      }

      if (followerId === targetUserId) {
        throw new ValidationError("Users cannot follow themselves");
      }

      // Check if already following with transaction
      const result = await this.withTransaction(async () => {
        const existingFollow = await this.followRepository.findByUserIds(
          followerId,
          targetUserId,
        );
        if (existingFollow) {
          return existingFollow;
        }

        const follow = await this.followRepository.create({
          followerId,
          followingId: targetUserId,
          createdAt: new Date(),
        });

        // Create notification
        const notification = new Notification({
          type: NotificationType.FOLLOW,
          userId: targetUserId,
          actorId: followerId,
          entityType: EntityType.USER,
          entityId: followerId,
          content: `${follower.username} started following you`,
          read: false,
          delivered: false,
          createdAt: new Date(),
          updatedAt: new Date(),
          metadata: {},
        });
        await this.notificationRepository.create(notification);

        await this.invalidateFollowCache(followerId, targetUserId);
        return follow;
      });

      this.metricsService.recordLatency("follow_user", Date.now() - startTime);
      this.metricsService.incrementCounter("follows_created");
      return result;
    } catch (error) {
      this.metricsService.incrementCounter("follow_creation_error");
      throw error;
    }
  }

  /**
   * Unfollow a user
   * @param followerId - ID of the user who wants to unfollow
   * @param targetUserId - ID of the user to be unfollowed
   */
  async unfollowUser(followerId: string, targetUserId: string): Promise<void> {
    const startTime = Date.now();
    try {
      const follow = await this.followRepository.findByUserIds(
        followerId,
        targetUserId,
      );
      if (!follow) {
        return;
      }

      await this.withTransaction(async () => {
        await this.followRepository.delete(follow.id);
        await this.invalidateFollowCache(followerId, targetUserId);
      });

      this.metricsService.recordLatency(
        "unfollow_user",
        Date.now() - startTime,
      );
      this.metricsService.incrementCounter("follows_deleted");
    } catch (error) {
      this.metricsService.incrementCounter("unfollow_error");
      throw error;
    }
  }

  /**
   * Get followers of a user
   * @param userId - ID of the user
   * @param filters - Pagination options and filters
   */
  async getFollowers(
    userId: string,
    filters: FollowFilters = { limit: 20, offset: 0 },
  ): Promise<Follow[]> {
    const cacheKey = `followers:${userId}:${JSON.stringify(filters)}`;
    return this.withCache(
      cacheKey,
      async () => {
        const followers = await this.followRepository.findFollowers(userId, {
          limit: filters.limit,
          offset: filters.offset,
        });

        if (filters.mutualOnly) {
          const mutualFollowers = await Promise.all(
            followers.map(async (follow: Follow) => {
              const isMutual = await this.isFollowing(
                userId,
                follow.followerId,
              );
              return isMutual ? follow : null;
            }),
          );
          return mutualFollowers.filter((f): f is Follow => f !== null);
        }

        return followers;
      },
      CACHE_TTL,
    );
  }

  /**
   * Get users that a user is following
   * @param userId - ID of the user
   * @param options - Pagination options
   */
  async getFollowing(
    userId: string,
    options: PaginationOptions,
  ): Promise<Follow[]> {
    const cacheKey = `following:${userId}:${JSON.stringify(options)}`;
    return this.withCache(
      cacheKey,
      async () => {
        return this.followRepository.findFollowing(userId, {
          limit: options.limit ?? 20,
          offset: options.offset ?? 0,
        });
      },
      CACHE_TTL,
    );
  }

  /**
   * Get follow statistics for a user
   * @param userId - ID of the user
   */
  async getFollowStats(userId: string): Promise<FollowStats> {
    const cacheKey = `follow_stats:${userId}`;
    return this.withCache(
      cacheKey,
      async () => {
        const [
          followersCount,
          followingCount,
          mutualFollowersCount,
          lastFollow,
          lastFollower,
        ] = await Promise.all([
          this.followRepository.countFollowers(userId),
          this.followRepository.countFollowing(userId),
          this.followRepository.countMutualFollowers(userId, userId),
          this.followRepository.findLastFollow(userId),
          this.followRepository.findLastFollower(userId),
        ]);

        return {
          followersCount,
          followingCount,
          mutualFollowersCount,
          lastFollowedAt: lastFollow?.createdAt,
          lastFollowerAt: lastFollower?.createdAt,
        };
      },
      CACHE_TTL,
    );
  }

  /**
   * Check if one user follows another
   * @param followerId - ID of the potential follower
   * @param targetUserId - ID of the target user
   */
  async isFollowing(
    followerId: string,
    targetUserId: string,
  ): Promise<boolean> {
    const cacheKey = `is_following:${followerId}:${targetUserId}`;
    return this.withCache(
      cacheKey,
      async () => {
        const follow = await this.followRepository.findByUserIds(
          followerId,
          targetUserId,
        );
        return !!follow;
      },
      CACHE_TTL,
    );
  }

  /**
   * Get mutual followers between two users
   * @param userId1 - First user ID
   * @param userId2 - Second user ID
   * @param options - Pagination options
   */
  async getMutualFollowers(
    userId1: string,
    userId2: string,
    options: PaginationOptions,
  ): Promise<Follow[]> {
    const cacheKey = `mutual_followers:${userId1}:${userId2}:${JSON.stringify(options)}`;
    return this.withCache(
      cacheKey,
      async () => {
        return this.followRepository.findMutualFollowers(userId1, userId2, {
          limit: options.limit ?? 20,
          offset: options.offset ?? 0,
        });
      },
      CACHE_TTL,
    );
  }

  /**
   * Batch check follow status for multiple users
   * @param followerId - ID of the potential follower
   * @param targetUserIds - IDs of users to check
   */
  async batchCheckFollowStatus(
    followerId: string,
    targetUserIds: string[],
  ): Promise<Map<string, boolean>> {
    const startTime = Date.now();
    try {
      const result = new Map<string, boolean>();
      const uniqueTargetIds = [...new Set(targetUserIds)];

      // Process in batches
      for (let i = 0; i < uniqueTargetIds.length; i += BATCH_SIZE) {
        const batch = uniqueTargetIds.slice(i, i + BATCH_SIZE);
        const follows = await this.followRepository.findFollowsByUserIds(
          followerId,
          batch,
        );

        // Create a set of followed user IDs for quick lookup
        const followedIds = new Set(follows.map((f: Follow) => f.followingId));

        // Map results for this batch
        batch.forEach((targetId) => {
          result.set(targetId, followedIds.has(targetId));
        });
      }

      this.metricsService.recordLatency(
        "batch_check_follow_status",
        Date.now() - startTime,
      );
      return result;
    } catch (error) {
      this.metricsService.incrementCounter("batch_check_follow_error");
      throw error;
    }
  }

  /**
   * Batch get follow statistics for multiple users
   * @param userIds - Array of user IDs to get stats for
   */
  async batchGetFollowStats(
    userIds: string[],
  ): Promise<Map<string, FollowStats>> {
    const startTime = Date.now();
    try {
      const result = new Map<string, FollowStats>();
      const uniqueUserIds = [...new Set(userIds)];

      // Process in batches
      for (let i = 0; i < uniqueUserIds.length; i += BATCH_SIZE) {
        const batch = uniqueUserIds.slice(i, i + BATCH_SIZE);

        // Get cached stats first
        const cachedStats = await Promise.all(
          batch.map(async (userId) => {
            const cacheKey = `follow_stats:${userId}`;
            return {
              userId,
              stats: await this.cacheManager.get<FollowStats>(cacheKey),
            };
          }),
        );

        // Filter out users that need stats calculated
        const uncachedUserIds = batch.filter(
          (userId) => !cachedStats.find((cs) => cs.userId === userId)?.stats,
        );

        if (uncachedUserIds.length > 0) {
          // Get stats for uncached users
          const [
            followerCounts,
            followingCounts,
            mutualCounts,
            lastFollows,
            lastFollowers,
          ] = await Promise.all([
            this.followRepository.batchCountFollowers(uncachedUserIds),
            this.followRepository.batchCountFollowing(uncachedUserIds),
            this.followRepository.batchCountMutualFollowers(uncachedUserIds),
            this.followRepository.batchFindLastFollows(uncachedUserIds),
            this.followRepository.batchFindLastFollowers(uncachedUserIds),
          ]);

          // Calculate and cache stats for each uncached user
          await Promise.all(
            uncachedUserIds.map(async (userId) => {
              const stats: FollowStats = {
                followersCount: followerCounts.get(userId) || 0,
                followingCount: followingCounts.get(userId) || 0,
                mutualFollowersCount: mutualCounts.get(userId) || 0,
                lastFollowedAt: lastFollows.get(userId)?.createdAt,
                lastFollowerAt: lastFollowers.get(userId)?.createdAt,
              };

              const cacheKey = `follow_stats:${userId}`;
              await this.cacheManager.set(cacheKey, stats, CACHE_TTL);
              result.set(userId, stats);
            }),
          );
        }

        // Add cached stats to result
        cachedStats.forEach(({ userId, stats }) => {
          if (stats) {
            result.set(userId, stats);
          }
        });
      }

      this.metricsService.recordLatency(
        "batch_get_follow_stats",
        Date.now() - startTime,
      );
      return result;
    } catch (error) {
      this.metricsService.incrementCounter("batch_get_follow_stats_error");
      throw error;
    }
  }

  /**
   * Invalidate follow-related cache entries
   * @param followerId - ID of the follower
   * @param targetUserId - ID of the target user
   */
  private async invalidateFollowCache(
    followerId: string,
    targetUserId: string,
  ): Promise<void> {
    const keys = [
      `followers:${targetUserId}*`,
      `following:${followerId}*`,
      `follow_stats:${followerId}`,
      `follow_stats:${targetUserId}`,
      `is_following:${followerId}:${targetUserId}`,
      `mutual_followers:${followerId}:${targetUserId}*`,
      `mutual_followers:${targetUserId}:${followerId}*`,
      `follow_suggestions:${followerId}*`,
      `follow_suggestions:${targetUserId}*`,
    ];

    try {
      await Promise.all(keys.map((key) => this.cacheManager.delete(key)));
    } catch (error) {
      this.metricsService.incrementCounter("cache_invalidation_error");
      // Log error but don't throw as cache invalidation shouldn't break the flow
      console.error("Failed to invalidate follow cache:", error);
    }
  }
}



===========================================================
FILE 29: app\social\interaction\LikeService.ts
===========================================================

import { EntityType } from "@database/models/shared/EntityTypes";
import { Like, LikeTargetType } from "@database/models/social/Like";
import {
  Notification,
  NotificationType,
} from "@database/models/social/Notification";
import {
  LikeRepository,
  CommentRepository,
  NotificationRepository,
  PostRepository,
} from "@repositories/social";
import { MetricsService } from "@services/app/social/monitoring/MetricsService";
import {
  BaseService,
  CacheManager,
  PostRateLimiter,
  PaginationOptions,
} from "@services/shared";
import { ResourceNotFoundError } from "@services/shared/errors/ServiceError";

const CACHE_TTL = 3600; // 1 hour
const BATCH_SIZE = 100;

export class LikeService extends BaseService {
  private cacheManager: CacheManager;

  constructor(
    private likeRepository: LikeRepository,
    private postRepository: PostRepository,
    private commentRepository: CommentRepository,
    private notificationRepository: NotificationRepository,
    private metricsService: MetricsService,
    private rateLimiter: PostRateLimiter,
  ) {
    super("LikeService");
    this.cacheManager = new CacheManager("likes");
  }

  async likePost(userId: string, postId: string): Promise<Like> {
    const startTime = Date.now();
    try {
      await this.rateLimiter.checkLimit(userId);

      const post = await this.postRepository.findById(postId);
      if (!post) {
        throw new ResourceNotFoundError("Post not found");
      }

      const existingLike = await this.likeRepository.findByUserAndTarget(
        userId,
        postId,
        LikeTargetType.POST,
      );
      if (existingLike) {
        return existingLike;
      }

      const result = await this.withTransaction(async () => {
        const like = await this.likeRepository.create({
          userId,
          targetId: postId,
          targetType: LikeTargetType.POST,
        });

        await this.postRepository.updateLikeCount(postId, 1);

        if (post.userId !== userId) {
          const notification = new Notification({
            userId: post.userId,
            type: NotificationType.LIKE,
            entityType: EntityType.POST,
            entityId: postId,
            actorId: userId,
            content: `liked your post`,
            metadata: {},
            read: false,
            delivered: false,
            createdAt: new Date(),
            updatedAt: new Date(),
          });
          await this.notificationRepository.create(notification);
        }

        await this.invalidatePostLikeCache(postId);
        return like;
      });

      this.metricsService.recordLatency("like_post", Date.now() - startTime);
      this.metricsService.incrementCounter("post_likes");
      return result;
    } catch (error) {
      this.metricsService.incrementCounter("post_likes_error");
      throw error;
    }
  }

  async unlikePost(userId: string, postId: string): Promise<void> {
    const startTime = Date.now();
    try {
      const like = await this.likeRepository.findByUserAndTarget(
        userId,
        postId,
        LikeTargetType.POST,
      );
      if (!like) {
        return;
      }

      const post = await this.postRepository.findById(postId);
      if (!post) {
        return;
      }

      await this.withTransaction(async () => {
        await this.likeRepository.delete(like.id);
        await this.postRepository.updateLikeCount(postId, -1);
        await this.notificationRepository.deleteMany([postId], post.userId);
        await this.invalidatePostLikeCache(postId);
      });

      this.metricsService.recordLatency("unlike_post", Date.now() - startTime);
      this.metricsService.incrementCounter("unlike_post");
    } catch (error) {
      this.metricsService.incrementCounter("unlike_post_error");
      throw error;
    }
  }

  async likeComment(userId: string, commentId: string): Promise<Like> {
    const startTime = Date.now();
    try {
      await this.rateLimiter.checkLimit(userId);

      const comment = await this.commentRepository.findById(commentId);
      if (!comment) {
        throw new ResourceNotFoundError("Comment not found");
      }

      const existingLike = await this.likeRepository.findByUserAndTarget(
        userId,
        commentId,
        LikeTargetType.COMMENT,
      );
      if (existingLike) {
        return existingLike;
      }

      const result = await this.withTransaction(async () => {
        const like = await this.likeRepository.create({
          userId,
          targetId: commentId,
          targetType: LikeTargetType.COMMENT,
        });

        await this.commentRepository.incrementLikeCount(commentId);

        if (comment.userId !== userId) {
          const notification = new Notification({
            userId: comment.userId,
            type: NotificationType.LIKE,
            entityType: EntityType.COMMENT,
            entityId: commentId,
            actorId: userId,
            content: `liked your comment`,
            metadata: {},
            read: false,
            delivered: false,
            createdAt: new Date(),
            updatedAt: new Date(),
          });
          await this.notificationRepository.create(notification);
        }

        await this.invalidatePostLikeCache(commentId);
        return like;
      });

      this.metricsService.recordLatency("like_comment", Date.now() - startTime);
      this.metricsService.incrementCounter("comment_likes");
      return result;
    } catch (error) {
      this.metricsService.incrementCounter("comment_likes_error");
      throw error;
    }
  }

  async unlikeComment(userId: string, commentId: string): Promise<void> {
    const startTime = Date.now();
    try {
      const like = await this.likeRepository.findByUserAndTarget(
        userId,
        commentId,
        LikeTargetType.COMMENT,
      );
      if (!like) {
        return;
      }

      const comment = await this.commentRepository.findById(commentId);
      if (!comment) {
        return;
      }

      await this.withTransaction(async () => {
        await this.likeRepository.delete(like.id);
        await this.commentRepository.decrementLikeCount(commentId);
        await this.notificationRepository.deleteMany(
          [commentId],
          comment.userId,
        );
        await this.invalidatePostLikeCache(commentId);
      });

      this.metricsService.recordLatency(
        "unlike_comment",
        Date.now() - startTime,
      );
      this.metricsService.incrementCounter("unlike_comment");
    } catch (error) {
      this.metricsService.incrementCounter("unlike_comment_error");
      throw error;
    }
  }

  async getUserLikes(
    userId: string,
    targetType?: LikeTargetType,
    options: PaginationOptions = { limit: 20, offset: 0 },
  ): Promise<Like[]> {
    const cacheKey = `user_likes:${userId}:${targetType || "all"}`;
    return this.withCache(
      cacheKey,
      async () => {
        return this.likeRepository.getLikesByUser(
          userId,
          targetType,
          options.limit,
          options.offset,
        );
      },
      CACHE_TTL,
    );
  }

  async getLikesByTarget(
    targetId: string,
    targetType: LikeTargetType,
    options: PaginationOptions = { limit: 20, offset: 0 },
  ): Promise<Like[]> {
    const cacheKey = `target_likes:${targetType}:${targetId}`;
    return this.withCache(
      cacheKey,
      async () => {
        return this.likeRepository.getLikesForTarget(
          targetId,
          targetType,
          options.limit,
          options.offset,
        );
      },
      CACHE_TTL,
    );
  }

  async batchGetLikeStatus(
    userId: string,
    postIds: string[],
  ): Promise<Map<string, boolean>> {
    const result = new Map<string, boolean>();

    // Process in batches to avoid overloading the database
    for (let i = 0; i < postIds.length; i += BATCH_SIZE) {
      const batch = postIds.slice(i, i + BATCH_SIZE);
      const likes = await Promise.all(
        batch.map((postId) =>
          this.likeRepository.findByUserAndTarget(
            userId,
            postId,
            LikeTargetType.POST,
          ),
        ),
      );

      // Create a set of liked post IDs for faster lookup
      const likedPostIds = new Set(
        likes
          .filter((like): like is Like => like !== null)
          .map((like) => like.targetId),
      );

      // Map results
      batch.forEach((postId) => {
        result.set(postId, likedPostIds.has(postId));
      });
    }

    return result;
  }

  private async invalidatePostLikeCache(targetId: string): Promise<void> {
    const keys = [
      `user_likes:*`,
      `target_likes:*:${targetId}`,
      `like_count:${targetId}`,
    ];

    await Promise.all(keys.map((key) => this.cacheManager.delete(key)));
  }
}



===========================================================
FILE 30: app\social\interaction\index.ts
===========================================================

// Export interaction services
export * from "./LikeService";
export * from "./CommentService";
export * from "./FollowService";
export * from "./BookmarkService";



===========================================================
FILE 31: app\social\monitoring\MetricsService.ts
===========================================================

import { Gauge, Counter, Histogram, register } from "prom-client";

export class MetricsService {
  private static instance: MetricsService;

  private readonly operationDuration: Histogram;
  private readonly operationErrors: Counter;
  private readonly activePosts: Gauge;
  private readonly postsByType: Counter;
  private readonly cacheHits: Counter;
  private readonly cacheMisses: Counter;
  private readonly rateLimit: Counter;

  private counters: Map<string, number>;
  private latencies: Map<string, number[]>;

  private constructor() {
    this.operationDuration = new Histogram({
      name: "post_operation_duration_seconds",
      help: "Duration of post operations in seconds",
      labelNames: ["operation"],
      buckets: [0.1, 0.5, 1, 2, 5],
    });

    this.operationErrors = new Counter({
      name: "post_operation_errors_total",
      help: "Total number of post operation errors",
      labelNames: ["operation", "error_type"],
    });

    this.activePosts = new Gauge({
      name: "active_posts_total",
      help: "Total number of active posts",
      labelNames: ["status"],
    });

    this.postsByType = new Counter({
      name: "posts_by_type_total",
      help: "Total number of posts by type",
      labelNames: ["type"],
    });

    this.cacheHits = new Counter({
      name: "post_cache_hits_total",
      help: "Total number of post cache hits",
      labelNames: ["operation"],
    });

    this.cacheMisses = new Counter({
      name: "post_cache_misses_total",
      help: "Total number of post cache misses",
      labelNames: ["operation"],
    });

    this.rateLimit = new Counter({
      name: "post_rate_limit_hits_total",
      help: "Total number of rate limit hits",
      labelNames: ["user_type"],
    });

    this.counters = new Map();
    this.latencies = new Map();
  }

  public static getInstance(): MetricsService {
    if (!MetricsService.instance) {
      MetricsService.instance = new MetricsService();
    }
    return MetricsService.instance;
  }

  public recordOperationDuration(operation: string, durationMs: number): void {
    this.operationDuration.labels(operation).observe(durationMs / 1000);
    this.recordLatency(operation, durationMs);
  }

  public recordOperationError(operation: string, errorType: string): void {
    this.operationErrors.labels(operation, errorType).inc();
    this.incrementCounter(`${operation}_error_${errorType}`);
  }

  public updateActivePostCount(status: string, count: number): void {
    this.activePosts.labels(status).set(count);
  }

  public incrementPostsByType(type: string): void {
    this.postsByType.labels(type).inc();
  }

  public recordCacheHit(operation: string): void {
    this.cacheHits.labels(operation).inc();
  }

  public recordCacheMiss(operation: string): void {
    this.cacheMisses.labels(operation).inc();
  }

  public recordRateLimit(userType: string): void {
    this.rateLimit.labels(userType).inc();
  }

  public async getMetrics(): Promise<string> {
    return await register.metrics();
  }

  incrementCounter(name: string, value: number = 1): void {
    const current = this.counters.get(name) || 0;
    this.counters.set(name, current + value);
  }

  recordLatency(name: string, duration: number): void {
    const latencies = this.latencies.get(name) || [];
    latencies.push(duration);
    this.latencies.set(name, latencies);
  }
}



===========================================================
FILE 32: app\social\monitoring\index.ts
===========================================================

// Export monitoring services
export * from "./MetricsService";



===========================================================
FILE 33: app\social\notification\NotificationService.ts
===========================================================

import { EntityType } from "@models/shared/EntityTypes";
import { Notification, NotificationType } from "@models/social";
import { UserRepository } from "@repositories/auth";
import { NotificationRepository } from "@repositories/social";
import { MetricsService } from "@services/app/social/monitoring/MetricsService";
import {
  BaseService,
  CacheManager,
  PaginationOptions,
  EventEmitter,
} from "@services/shared";
import { ResourceNotFoundError } from "@services/shared/errors/ServiceError";

const CACHE_TTL = 300; // 5 minutes
const BATCH_SIZE = 100;
const MAX_NOTIFICATIONS_PER_USER = 1000;
const NOTIFICATION_GROUPING_WINDOW = 300000; // 5 minutes in milliseconds

export interface NotificationPreferences {
  likes: boolean;
  comments: boolean;
  follows: boolean;
  mentions: boolean;
  messages: boolean;
  email: boolean;
  push: boolean;
  digestFrequency: "realtime" | "hourly" | "daily" | "weekly";
  quietHours: {
    enabled: boolean;
    start: string; // HH:mm format
    end: string; // HH:mm format
    timezone: string;
  };
  channels: {
    inApp: boolean;
    email: boolean;
    push: boolean;
    sms: boolean;
  };
}

export interface NotificationGroup {
  type: NotificationType;
  notifications: Notification[];
  count: number;
  latestTimestamp: Date;
  actors: string[];
  preview: string;
}

export interface NotificationDigest {
  userId: string;
  groups: NotificationGroup[];
  period: "hourly" | "daily" | "weekly";
  startDate: Date;
  endDate: Date;
}

export interface NotificationMetadata {
  entityId?: string;
  entityType?: EntityType;
  content?: string;
  [key: string]: unknown;
}

export interface NotificationCreateData {
  type: NotificationType;
  userId: string;
  actorId?: string;
  metadata?: NotificationMetadata;
}

export interface NotificationQueryOptions extends PaginationOptions {
  types?: NotificationType[];
  read?: boolean;
  delivered?: boolean;
  startDate?: Date;
  endDate?: Date;
}

/**
 * Service responsible for managing user notifications.
 * Features:
 * 1. Notification creation and delivery
 * 2. Notification preferences management
 * 3. Notification querying and filtering
 * 4. Batch operations
 * 5. Real-time delivery
 * 6. Performance metrics tracking
 * 7. Caching for frequently accessed data
 */
export class NotificationService extends BaseService {
  constructor(
    private notificationRepository: NotificationRepository,
    private userRepository: UserRepository,
    private metricsService: MetricsService,
    private cacheManager: CacheManager,
    private eventEmitter: EventEmitter,
  ) {
    super("NotificationService");
  }

  /**
   * Create a new notification
   * @param data - Notification creation data
   */
  async createNotification(
    data: NotificationCreateData,
  ): Promise<Notification> {
    const startTime = Date.now();
    try {
      const [user, preferences] = await Promise.all([
        this.userRepository.findById(data.userId),
        this.getNotificationPreferences(data.userId),
      ]);

      if (!user) {
        throw new ResourceNotFoundError("User not found");
      }

      // Check if notification type is enabled in preferences
      if (!this.isNotificationEnabled(data.type, preferences)) {
        this.metricsService.incrementCounter(
          "notifications_filtered_by_preferences",
        );
        return this.notificationRepository.create(
          new Notification({
            type: data.type,
            userId: data.userId,
            actorId: data.actorId || null,
            entityId: data.metadata?.entityId || null,
            entityType: data.metadata?.entityType || null,
            content: data.metadata?.content || null,
            metadata: data.metadata,
            read: true,
            delivered: true,
            disabled: true,
            createdAt: new Date(),
          }),
        );
      }

      // Check quiet hours
      if (this.isInQuietHours(preferences.quietHours)) {
        this.metricsService.incrementCounter(
          "notifications_filtered_by_quiet_hours",
        );
        return this.notificationRepository.create(
          new Notification({
            type: data.type,
            userId: data.userId,
            actorId: data.actorId || null,
            entityId: data.metadata?.entityId || null,
            entityType: data.metadata?.entityType || null,
            content: data.metadata?.content || null,
            metadata: data.metadata,
            read: true,
            delivered: true,
            disabled: true,
            createdAt: new Date(),
          }),
        );
      }

      // Check notification count limit
      const count = await this.notificationRepository.countByUser(data.userId);
      if (count >= MAX_NOTIFICATIONS_PER_USER) {
        await this.cleanupOldNotifications(data.userId);
      }

      // Try to group with recent similar notifications
      const similarNotification = await this.findSimilarNotification(data);
      if (similarNotification) {
        return this.updateExistingNotification(similarNotification, data);
      }

      const result = await this.withTransaction(async () => {
        const notification = await this.notificationRepository.create(
          new Notification({
            type: data.type,
            userId: data.userId,
            actorId: data.actorId || null,
            entityId: data.metadata?.entityId || null,
            entityType: data.metadata?.entityType || null,
            content: data.metadata?.content || null,
            metadata: data.metadata,
            read: false,
            delivered: false,
            createdAt: new Date(),
          }),
        );

        await this.invalidateNotificationCache(data.userId);

        // Emit real-time event if enabled
        if (preferences.digestFrequency === "realtime") {
          this.eventEmitter.emit("notification:created", {
            userId: data.userId,
            notification,
          });
        }

        return notification;
      });

      this.metricsService.recordLatency(
        "create_notification",
        Date.now() - startTime,
      );
      return result;
    } catch (error) {
      this.metricsService.incrementCounter("notification_creation_error");
      throw error;
    }
  }

  /**
   * Get user notifications with filtering and pagination
   * @param userId - ID of the user
   * @param options - Query options for filtering and pagination
   */
  async getUserNotifications(
    userId: string,
    options: NotificationQueryOptions,
  ): Promise<NotificationGroup[]> {
    const cacheKey = `user_notifications:${userId}:${JSON.stringify(options)}`;
    return this.withCache(
      cacheKey,
      async () => {
        const notifications = await this.notificationRepository.findByUserId(
          userId,
          options,
        );
        return this.groupNotifications(notifications);
      },
      CACHE_TTL,
    );
  }

  /**
   * Mark notifications as read
   * @param notificationIds - IDs of notifications to mark as read
   * @param userId - ID of the user who owns the notifications
   */
  async markAsRead(notificationIds: string[], userId: string): Promise<void> {
    const startTime = Date.now();
    try {
      await this.withTransaction(async () => {
        await this.notificationRepository.markAsRead(notificationIds, userId);
        await this.invalidateNotificationCache(userId);
      });

      this.metricsService.recordLatency(
        "mark_notifications_read",
        Date.now() - startTime,
      );
      this.metricsService.incrementCounter(
        "notifications_marked_read",
        notificationIds.length,
      );
    } catch (error) {
      this.metricsService.incrementCounter("mark_notifications_read_error");
      throw error;
    }
  }

  /**
   * Mark all notifications as read for a user
   * @param userId - ID of the user
   */
  async markAllAsRead(userId: string): Promise<void> {
    const startTime = Date.now();
    try {
      await this.withTransaction(async () => {
        await this.notificationRepository.markAllAsRead(userId);
        await this.invalidateNotificationCache(userId);
      });

      this.metricsService.recordLatency(
        "mark_all_notifications_read",
        Date.now() - startTime,
      );
      this.metricsService.incrementCounter("all_notifications_marked_read");
    } catch (error) {
      this.metricsService.incrementCounter("mark_all_notifications_read_error");
      throw error;
    }
  }

  /**
   * Mark notifications as delivered
   * @param notificationIds - IDs of notifications to mark as delivered
   */
  async markAsDelivered(notificationIds: string[]): Promise<void> {
    const startTime = Date.now();
    try {
      await this.notificationRepository.markAsDelivered(notificationIds);

      this.metricsService.recordLatency(
        "mark_notifications_delivered",
        Date.now() - startTime,
      );
      this.metricsService.incrementCounter(
        "notifications_marked_delivered",
        notificationIds.length,
      );
    } catch (error) {
      this.metricsService.incrementCounter(
        "mark_notifications_delivered_error",
      );
      throw error;
    }
  }

  /**
   * Delete notifications
   * @param notificationIds - IDs of notifications to delete
   * @param userId - ID of the user who owns the notifications
   */
  async deleteNotifications(
    notificationIds: string[],
    userId: string,
  ): Promise<void> {
    const startTime = Date.now();
    try {
      await this.withTransaction(async () => {
        await this.notificationRepository.deleteMany(notificationIds, userId);
        await this.invalidateNotificationCache(userId);
      });

      this.metricsService.recordLatency(
        "delete_notifications",
        Date.now() - startTime,
      );
      this.metricsService.incrementCounter(
        "notifications_deleted",
        notificationIds.length,
      );
    } catch (error) {
      this.metricsService.incrementCounter("delete_notifications_error");
      throw error;
    }
  }

  /**
   * Get unread notification count for a user
   * @param userId - ID of the user
   */
  async getUnreadCount(userId: string): Promise<number> {
    const cacheKey = `unread_notifications_count:${userId}`;
    return this.withCache(
      cacheKey,
      async () => {
        return this.notificationRepository.countUnread(userId);
      },
      CACHE_TTL,
    );
  }

  /**
   * Batch get unread notification counts
   * @param userIds - Array of user IDs
   */
  async batchGetUnreadCounts(userIds: string[]): Promise<Map<string, number>> {
    const result = new Map<string, number>();

    for (let i = 0; i < userIds.length; i += BATCH_SIZE) {
      const batch = userIds.slice(i, i + BATCH_SIZE);
      const counts = await this.notificationRepository.batchCountUnread(batch);

      counts.forEach((count: number, userId: string) => {
        result.set(userId, count);
      });
    }

    return result;
  }

  /**
   * Get notification preferences for a user
   * @param userId - ID of the user
   */
  async getNotificationPreferences(
    userId: string,
  ): Promise<NotificationPreferences> {
    const cacheKey = `notification_preferences:${userId}`;
    return this.withCache(
      cacheKey,
      async () => {
        return this.notificationRepository.getPreferences(userId);
      },
      CACHE_TTL,
    );
  }

  /**
   * Update notification preferences for a user
   * @param userId - ID of the user
   * @param preferences - New notification preferences
   */
  async updateNotificationPreferences(
    userId: string,
    preferences: Partial<NotificationPreferences>,
  ): Promise<void> {
    const startTime = Date.now();
    try {
      await this.withTransaction(async () => {
        await this.notificationRepository.updatePreferences(
          userId,
          preferences,
        );
        await this.invalidateNotificationCache(userId);
      });

      this.metricsService.recordLatency(
        "update_notification_preferences",
        Date.now() - startTime,
      );
      this.metricsService.incrementCounter("notification_preferences_updated");
    } catch (error) {
      this.metricsService.incrementCounter(
        "update_notification_preferences_error",
      );
      throw error;
    }
  }

  private async invalidateNotificationCache(userId: string): Promise<void> {
    const keys = [
      `user_notifications:${userId}*`,
      `unread_notifications_count:${userId}`,
      `notification_preferences:${userId}`,
    ];
    await Promise.all(keys.map((key) => this.cacheManager.delete(key)));
  }

  private isNotificationEnabled(
    type: NotificationType,
    preferences: NotificationPreferences,
  ): boolean {
    switch (type) {
      case NotificationType.LIKE:
        return preferences.likes;
      case NotificationType.COMMENT:
        return preferences.comments;
      case NotificationType.FOLLOW:
        return preferences.follows;
      case NotificationType.MENTION:
        return preferences.mentions;
      case NotificationType.MESSAGE:
        return preferences.messages;
      default:
        return true;
    }
  }

  private isInQuietHours(
    quietHours: NotificationPreferences["quietHours"],
  ): boolean {
    if (!quietHours.enabled) return false;

    const now = new Date();
    const userTime = new Date(
      now.toLocaleString("en-US", { timeZone: quietHours.timezone }),
    );
    const currentHour = userTime.getHours();
    const currentMinute = userTime.getMinutes();

    const [startHour, startMinute] = quietHours.start.split(":").map(Number);
    const [endHour, endMinute] = quietHours.end.split(":").map(Number);

    const currentMinutes = currentHour * 60 + currentMinute;
    const startMinutes = startHour * 60 + startMinute;
    const endMinutes = endHour * 60 + endMinute;

    return currentMinutes >= startMinutes && currentMinutes <= endMinutes;
  }

  private async findSimilarNotification(
    data: NotificationCreateData,
  ): Promise<Notification | null> {
    const recentNotifications = await this.notificationRepository.findRecent(
      data.userId,
      data.type,
      new Date(Date.now() - NOTIFICATION_GROUPING_WINDOW),
    );

    return (
      recentNotifications.find(
        (notification) =>
          notification.entityId === data.metadata?.entityId &&
          notification.entityType === data.metadata?.entityType,
      ) || null
    );
  }

  private async updateExistingNotification(
    existing: Notification,
    newData: NotificationCreateData,
  ): Promise<Notification> {
    const metadata = {
      ...(existing.metadata as Record<string, unknown>),
      groupedActors: [
        ...(((existing.metadata as Record<string, unknown>)
          .groupedActors as string[]) || []),
        newData.actorId,
      ],
      count:
        (((existing.metadata as Record<string, unknown>).count as number) ||
          1) + 1,
    };

    return this.notificationRepository.update(existing.id, { metadata });
  }

  private async cleanupOldNotifications(userId: string): Promise<void> {
    const oldNotifications = await this.notificationRepository.findOldestByUser(
      userId,
      Math.floor(MAX_NOTIFICATIONS_PER_USER * 0.2), // Remove oldest 20%
    );

    await this.deleteNotifications(
      oldNotifications.map((n) => n.id),
      userId,
    );
  }

  private getDigestDateRange(
    period: "hourly" | "daily" | "weekly",
  ): [Date, Date] {
    const now = new Date();
    const endDate = now;
    let startDate: Date;

    switch (period) {
      case "hourly":
        startDate = new Date(now.getTime() - 3600000);
        break;
      case "daily":
        startDate = new Date(now.getTime() - 86400000);
        break;
      case "weekly":
        startDate = new Date(now.getTime() - 604800000);
        break;
    }

    return [startDate, endDate];
  }

  private groupNotifications(
    notifications: Notification[],
  ): NotificationGroup[] {
    const groups = new Map<NotificationType, Notification[]>();

    notifications.forEach((notification) => {
      const existing = groups.get(notification.type) || [];
      groups.set(notification.type, [...existing, notification]);
    });

    return Array.from(groups.entries()).map(([type, items]) => ({
      type,
      notifications: items,
      count: items.length,
      latestTimestamp: new Date(
        Math.max(...items.map((n) => n.createdAt.getTime())),
      ),
      actors: Array.from(
        new Set(
          items.map((n) => n.actorId).filter((id): id is string => id !== null),
        ),
      ),
      preview: this.generateGroupPreview(type, items),
    }));
  }

  private generateGroupPreview(
    type: NotificationType,
    notifications: Notification[],
  ): string {
    const actorCount = new Set(notifications.map((n) => n.actorId)).size;
    const latestActor = notifications[notifications.length - 1].actorId;

    switch (type) {
      case NotificationType.LIKE:
        return `${latestActor} and ${actorCount - 1} others liked your post`;
      case NotificationType.COMMENT:
        return `${latestActor} and ${actorCount - 1} others commented on your post`;
      case NotificationType.FOLLOW:
        return `${latestActor} and ${actorCount - 1} others followed you`;
      default:
        return notifications[0].content || "New notification";
    }
  }

  async generateNotificationDigest(
    userId: string,
    period: "hourly" | "daily" | "weekly",
  ): Promise<NotificationDigest> {
    const preferences = await this.getNotificationPreferences(userId);
    if (preferences.digestFrequency !== period) {
      return {
        userId,
        groups: [],
        period,
        startDate: new Date(),
        endDate: new Date(),
      };
    }

    const [startDate, endDate] = this.getDigestDateRange(period);
    const notifications =
      await this.notificationRepository.findByUserAndDateRange(
        userId,
        startDate,
        endDate,
      );

    const groups = this.groupNotifications(notifications);
    return {
      userId,
      groups,
      period,
      startDate,
      endDate,
    };
  }
}



===========================================================
FILE 34: app\social\notification\index.ts
===========================================================

// Export notification services
export * from "./NotificationService";



===========================================================
FILE 35: app\social\post\PostService.ts
===========================================================

// Database imports
import { DatabaseConnectionManager } from "@database/config";
import { EntityType } from "@database/models/shared/EntityTypes";
import {
  NotificationType,
  Notification,
} from "@database/models/social/Notification";
import {
  Post,
  PostType,
  PostVisibility,
  PostStatus,
  PostLocation,
  PostMetadata,
} from "@database/models/social/Post";
import {
  UserRepository,
  MediaRepository,
  HashtagRepository,
  NotificationRepository,
  PostRepository,
} from "@database/repositories";
// Service imports
import { MetricsService } from "@services/app/social/monitoring/MetricsService";
import {
  BaseService,
  PostCacheManager,
  ContentValidator,
} from "@services/shared";
import {
  PostValidationError,
  PostNotFoundError,
  PostPermissionError,
} from "@services/shared/errors/PostErrors";
import { PostRateLimiter } from "@services/shared/security/PostRateLimiter";

// Define a simple Event Emitter class as a temporary placeholder
class EventEmitter {
  private listeners: Record<string, Array<(data: unknown) => void>> = {};

  on(event: string, callback: (data: unknown) => void): void {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event].push(callback);
  }

  emit(event: string, data: unknown): void {
    if (this.listeners[event]) {
      this.listeners[event].forEach((callback) => callback(data));
    }
  }
}

// Define a simple TransactionManager class as a temporary placeholder
class TransactionManager {
  async transaction<T>(callback: () => Promise<T>): Promise<T> {
    return DatabaseConnectionManager.withTransaction(callback);
  }
}

interface CreatePostDTO {
  content: string;
  type: PostType;
  visibility?: PostVisibility;
  location?: PostLocation;
  mediaIds?: string[];
  metadata?: PostMetadata;
  scheduledAt?: Date;
  parentId?: string;
}

interface UpdatePostDTO {
  content?: string;
  type?: PostType;
  visibility?: PostVisibility;
  location?: PostLocation | null;
  mediaIds?: string[];
  metadata?: PostMetadata;
  scheduledAt?: Date | null;
}

interface PostQueryOptions {
  userId?: string;
  type?: PostType;
  visibility?: PostVisibility;
  status?: PostStatus;
  beforeDate?: Date;
  afterDate?: Date;
  limit?: number;
  offset?: number;
  includeReplies?: boolean;
  includeShares?: boolean;
  cursor?: string;
}

interface PostStats {
  totalPosts: number;
  publishedPosts: number;
  draftPosts: number;
  scheduledPosts: number;
  totalViews: number;
  totalLikes: number;
  totalComments: number;
  totalShares: number;
}

/**
 * Enhanced service responsible for managing social media posts
 *
 * Features:
 * 1. Post CRUD operations with comprehensive validation
 * 2. Advanced caching with TTL management
 * 3. Tiered rate limiting by user type
 * 4. Detailed metrics and monitoring
 * 5. Content validation and moderation
 * 6. Batch operations support
 * 7. Enhanced error handling
 */
export class PostService extends BaseService {
  private readonly postCache: PostCacheManager;
  private readonly rateLimiter: PostRateLimiter;
  private readonly contentValidator: ContentValidator;
  private readonly metrics: MetricsService;

  constructor(
    private readonly postRepository: PostRepository,
    private readonly userRepository: UserRepository,
    private readonly mediaRepository: MediaRepository,
    private readonly hashtagRepository: HashtagRepository,
    private readonly notificationRepository: NotificationRepository,
    private readonly transactionManager: TransactionManager,
    private readonly eventEmitter: EventEmitter,
  ) {
    super("PostService");
    this.postCache = new PostCacheManager("posts", 3600);
    this.rateLimiter = new PostRateLimiter();
    this.contentValidator = new ContentValidator();
    this.metrics = MetricsService.getInstance();
  }

  /**
   * Create a new post with enhanced validation and monitoring
   */
  public async createPost(userId: string, data: CreatePostDTO): Promise<Post> {
    return await this.trackPerformance("create_post", async () => {
      try {
        // Get user for rate limit check
        const user = await this.userRepository.findById(userId);
        if (!user) {
          throw new PostNotFoundError("User not found");
        }

        // Check rate limiting based on user type
        await this.rateLimiter.checkLimit(userId, user.type);

        // Validate content
        await this.validatePostContent(data);

        // Validate media if provided
        if (data.mediaIds?.length) {
          await this.validateMedia(userId, data.mediaIds);
        }

        // Validate parent post if this is a reply
        if (data.parentId) {
          await this.validateParentPost(data.parentId);
        }

        // Create post within transaction
        const post = await this.transactionManager.transaction(async () => {
          const post = new Post({
            userId,
            content: data.content,
            type: data.type,
            visibility: data.visibility || PostVisibility.PUBLIC,
            location: data.location,
            mediaIds: data.mediaIds || [],
            metadata: data.metadata,
            status: data.scheduledAt
              ? PostStatus.SCHEDULED
              : PostStatus.PUBLISHED,
            parentId: data.parentId,
            scheduledAt: data.scheduledAt,
            publishedAt: data.scheduledAt ? undefined : new Date(),
          });

          // Validate post
          post.validate();

          // Save post
          const savedPost = await this.postRepository.create(post);

          // Process hashtags in batch
          if (data.metadata?.tags) {
            await this.processHashtags(savedPost.id, data.metadata.tags);
          }

          // Create notifications for mentions in batch
          if (data.metadata?.mentions) {
            await this.createMentionNotificationsBatch(
              savedPost,
              data.metadata.mentions,
            );
          }

          return savedPost;
        });

        // Cache the post
        await this.postCache.set(post.id, post);

        // Update metrics
        this.metrics.incrementPostsByType(post.type);
        // Temporary fix until countByStatus is implemented
        this.metrics.updateActivePostCount(post.status, 0);

        // Emit post created event
        this.eventEmitter.emit("post.created", { post });

        return post;
      } catch (error) {
        this.handleError("create_post", error as Error);
        throw error;
      }
    });
  }

  /**
   * Get a post by ID with enhanced caching
   */
  public async getPostById(
    postId: string,
    userId?: string,
  ): Promise<Post | null> {
    return await this.trackPerformance("get_post", async () => {
      try {
        // Generate cache key
        const cacheKey = this.postCache.generateCacheKey({ postId, userId });

        // Try cache first
        const cachedPost = await this.postCache.get(cacheKey, "get_post");
        if (cachedPost && this.checkPostVisibility(cachedPost, userId)) {
          return cachedPost;
        }

        // Get from database
        const post = await this.postRepository.findById(postId);
        if (!post || !this.checkPostVisibility(post, userId)) {
          return null;
        }

        // Cache the post
        await this.postCache.set(cacheKey, post);

        return post;
      } catch (error) {
        this.handleError("get_post", error as Error);
        throw error;
      }
    });
  }

  /**
   * Get posts with enhanced filtering and caching
   */
  public async getPosts(
    options: PostQueryOptions,
    userId?: string,
  ): Promise<Post[]> {
    return await this.trackPerformance("get_posts", async () => {
      try {
        // Generate cache key for the query
        const cacheKey = this.postCache.generateCacheKey({
          ...options,
          userId,
        });

        // Try cache first
        const cachedPosts = (await this.postCache.get(
          cacheKey,
          "get_posts",
        )) as Post[] | null;
        if (cachedPosts) {
          return cachedPosts.filter((post) =>
            this.checkPostVisibility(post, userId),
          );
        }

        // Get from database with cursor-based pagination
        const posts = await this.postRepository.findAll({
          ...options,
          limit: Math.min(options.limit || 50, 100), // Enforce reasonable limits
        });

        // Filter visible posts
        const visiblePosts = posts.filter((post) =>
          this.checkPostVisibility(post, userId),
        );

        // Cache the results - fix the typings
        await this.postCache.set(cacheKey, visiblePosts[0] || new Post({}));

        return visiblePosts;
      } catch (error) {
        this.handleError("get_posts", error as Error);
        throw error;
      }
    });
  }

  /**
   * Update a post with enhanced validation and caching
   */
  public async updatePost(
    postId: string,
    userId: string,
    data: UpdatePostDTO,
  ): Promise<Post> {
    return await this.trackPerformance("update_post", async () => {
      try {
        // Get existing post
        const post = await this.postRepository.findById(postId);
        if (!post) {
          throw new PostNotFoundError(postId);
        }

        // Check ownership
        if (post.userId !== userId) {
          throw new PostPermissionError("Not authorized to update this post");
        }

        // Validate update is allowed
        if (!this.canUpdatePost(post)) {
          throw new PostValidationError(
            "Post cannot be updated in its current state",
          );
        }

        // Validate content if provided
        if (data.content) {
          await this.validatePostContent({
            content: data.content,
            type: data.type || post.type,
          });
        }

        // Validate media if provided
        if (data.mediaIds) {
          await this.validateMedia(userId, data.mediaIds);
        }

        // Update post within transaction
        const updatedPost = await this.transactionManager.transaction(
          async () => {
            // Handle content update
            if (data.content) {
              post.updateContent(data.content);
            }

            // Handle type update
            if (data.type) {
              post.updateType(data.type);
            }

            // Handle visibility update
            if (data.visibility) {
              post.visibility = data.visibility;
            }

            // Handle location update
            if ("location" in data) {
              post.location = data.location || null;
            }

            // Handle media update
            if (data.mediaIds) {
              await this.updatePostMedia(post, data.mediaIds);
            }

            // Handle metadata update
            if (data.metadata) {
              await this.updatePostMetadata(post, data.metadata);
            }

            // Handle scheduling update
            if ("scheduledAt" in data) {
              this.updatePostScheduling(post, data.scheduledAt || null);
            }

            // Save updates
            const savedPost = await this.postRepository.update(post.id, post);

            return savedPost;
          },
        );

        // Update cache
        await this.postCache.invalidatePattern(`posts:*${postId}*`);
        await this.postCache.set(postId, updatedPost);

        // Update metrics
        if (data.type && data.type !== post.type) {
          this.metrics.incrementPostsByType(data.type);
        }

        // Emit post updated event
        this.eventEmitter.emit("post.updated", { post: updatedPost });

        return updatedPost;
      } catch (error) {
        this.handleError("update_post", error as Error);
        throw error;
      }
    });
  }

  /**
   * Delete a post with proper cleanup
   */
  public async deletePost(postId: string, userId: string): Promise<boolean> {
    return await this.trackPerformance("delete_post", async () => {
      try {
        // Get existing post
        const post = await this.postRepository.findById(postId);
        if (!post) {
          throw new PostNotFoundError(postId);
        }

        // Check ownership
        if (post.userId !== userId) {
          throw new PostPermissionError("Not authorized to delete this post");
        }

        // Delete post within transaction
        await this.transactionManager.transaction(async () => {
          // Soft delete the post
          post.status = PostStatus.DELETED;
          await this.postRepository.update(post.id, post);

          // Remove hashtag associations
          if (post.metadata?.tags) {
            await this.removeHashtags(post.id, post.metadata.tags as string[]);
          }

          // Remove notifications
          await this.notificationRepository.deleteByEntityId(
            post.id,
            EntityType.POST,
          );
        });

        // Clear cache
        await this.postCache.invalidatePattern(`posts:*${postId}*`);

        // Update metrics
        // Temporary fix until countByStatus is implemented
        this.metrics.updateActivePostCount(PostStatus.DELETED, 0);

        // Emit post deleted event
        this.eventEmitter.emit("post.deleted", { postId, userId });

        return true;
      } catch (error) {
        this.handleError("delete_post", error as Error);
        throw error;
      }
    });
  }

  /**
   * Get user's post statistics with caching
   */
  public async getUserPostStats(userId: string): Promise<PostStats> {
    return await this.trackPerformance("get_user_stats", async () => {
      try {
        const cacheKey = this.postCache.generateCacheKey({
          type: "stats",
          userId,
        });

        // Try cache first
        const cachedStats = (await this.postCache.get(
          cacheKey,
          "get_user_stats",
        )) as PostStats | null;

        if (cachedStats) {
          return cachedStats;
        }

        // For now, return dummy stats until getUserStats is implemented
        const postStats = {
          totalPosts: 0,
          publishedPosts: 0,
          draftPosts: 0,
          scheduledPosts: 0,
          totalViews: 0,
          totalLikes: 0,
          totalComments: 0,
          totalShares: 0,
        };

        // Cache with shorter TTL for stats
        await this.postCache.set(cacheKey, postStats as unknown as Post);

        return postStats;
      } catch (error) {
        this.handleError("get_user_stats", error as Error);
        throw error;
      }
    });
  }

  /**
   * Process scheduled posts
   */
  public async processScheduledPosts(): Promise<void> {
    return await this.trackPerformance("process_scheduled", async () => {
      try {
        // Temporary implementation until findScheduledPosts is available
        const scheduledPosts: Post[] = [];

        for (const post of scheduledPosts) {
          await this.transactionManager.transaction(async () => {
            post.status = PostStatus.PUBLISHED;
            post.publishedAt = new Date();
            await this.postRepository.update(post.id, post);

            // Clear relevant caches
            await this.postCache.invalidatePattern(`posts:*${post.id}*`);

            // Emit event
            this.eventEmitter.emit("post.published", { post });
          });
        }

        // Temporary fix until countByStatus is implemented
        this.metrics.updateActivePostCount(PostStatus.PUBLISHED, 0);
        this.metrics.updateActivePostCount(PostStatus.SCHEDULED, 0);
      } catch (error) {
        this.handleError("process_scheduled", error as Error);
        throw error;
      }
    });
  }

  /**
   * Check if a post is visible to a user
   */
  private checkPostVisibility(post: Post, userId?: string): boolean {
    if (post.status === PostStatus.DELETED) {
      return false;
    }

    if (post.status === PostStatus.DRAFT && post.userId !== userId) {
      return false;
    }

    switch (post.visibility) {
      case PostVisibility.PUBLIC:
        return true;
      case PostVisibility.PRIVATE:
        return post.userId === userId;
      case PostVisibility.FOLLOWERS:
        // TODO: Implement follower check
        return post.userId === userId;
      case PostVisibility.UNLISTED:
        return true;
      default:
        return false;
    }
  }

  /**
   * Validate post content
   */
  private async validatePostContent(
    data: Pick<CreatePostDTO, "content" | "type">,
  ): Promise<void> {
    // Validate content based on type
    switch (data.type) {
      case PostType.TEXT:
        if (!data.content || typeof data.content !== "string") {
          throw new PostValidationError(
            "Text content is required for text posts",
          );
        }
        if (!this.contentValidator.isValidText(data.content)) {
          throw new PostValidationError("Invalid text content");
        }
        break;

      case PostType.IMAGE:
        if (!data.content && typeof data.content !== "string") {
          throw new PostValidationError("Caption is required for image posts");
        }
        break;

      case PostType.VIDEO:
        if (!data.content && typeof data.content !== "string") {
          throw new PostValidationError("Caption is required for video posts");
        }
        break;

      case PostType.LINK:
        if (!data.content || typeof data.content !== "string") {
          throw new PostValidationError("URL is required for link posts");
        }
        if (!this.contentValidator.isValidUrl(data.content)) {
          throw new PostValidationError("Invalid URL");
        }
        break;

      case PostType.POLL:
        if (!data.content || typeof data.content !== "string") {
          throw new PostValidationError("Question is required for poll posts");
        }
        break;

      default:
        throw new PostValidationError("Invalid post type");
    }
  }

  /**
   * Validate media attachments
   */
  private async validateMedia(
    userId: string,
    mediaIds: string[],
  ): Promise<void> {
    // Check if all media exists and belongs to the user
    const media = await Promise.all(
      mediaIds.map((id) => this.mediaRepository.findById(id)),
    );
    const validMedia = media.filter((m) => m !== null);

    if (validMedia.length !== mediaIds.length) {
      throw new PostValidationError("One or more media items not found");
    }

    if (validMedia.some((m) => m!.userId !== userId)) {
      throw new PostValidationError(
        "One or more media items do not belong to the user",
      );
    }
  }

  /**
   * Validate parent post for replies
   */
  private async validateParentPost(parentId: string): Promise<void> {
    const parentPost = await this.postRepository.findById(parentId);

    if (!parentPost) {
      throw new PostValidationError("Parent post not found");
    }

    if (parentPost.status === PostStatus.DELETED) {
      throw new PostValidationError("Cannot reply to a deleted post");
    }
  }

  /**
   * Process hashtags for a post
   */
  private async processHashtags(
    _postId: string,
    tags: string[],
  ): Promise<void> {
    for (const tag of tags) {
      await this.hashtagRepository.findOrCreate(tag);
      // Since addPostHashtag doesn't exist, we'll simulate it
    }
  }

  /**
   * Remove hashtags from a post
   */
  private async removeHashtags(_postId: string, tags: string[]): Promise<void> {
    for (const _ of tags) {
      // Since removePostHashtag doesn't exist, we'll simulate it
    }
  }

  /**
   * Check if a post can be updated
   */
  private canUpdatePost(post: Post): boolean {
    return post.status !== PostStatus.DELETED;
  }

  /**
   * Track performance of operations
   */
  private async trackPerformance<T>(
    operation: string,
    fn: () => Promise<T>,
  ): Promise<T> {
    const startTime = Date.now();
    try {
      const result = await fn();
      const duration = Date.now() - startTime;
      this.metrics.recordOperationDuration(operation, duration);
      return result;
    } catch (error) {
      this.metrics.recordOperationError(operation, (error as Error).name);
      throw error;
    }
  }

  /**
   * Handle errors with proper logging and metrics
   */
  private handleError(operation: string, error: Error): void {
    this.logger.error(`Error in ${operation}:`, error);
    this.metrics.recordOperationError(operation, error.name);
  }

  /**
   * Update post media with proper cleanup
   */
  private async updatePostMedia(
    post: Post,
    newMediaIds: string[],
  ): Promise<void> {
    // Remove old media
    const oldMediaIds = post.mediaIds || [];
    const removedMediaIds = oldMediaIds.filter(
      (id) => !newMediaIds.includes(id),
    );

    // Add new media
    const addedMediaIds = newMediaIds.filter((id) => !oldMediaIds.includes(id));

    // Update post media IDs
    post.mediaIds = newMediaIds;

    // Cleanup old media references if needed - simplified version
    if (removedMediaIds.length > 0) {
      // Simplified implementation until updateMediaReferences is available
    }

    // Update new media references - simplified version
    if (addedMediaIds.length > 0) {
      // Simplified implementation until updateMediaReferences is available
    }
  }

  /**
   * Update post metadata with proper handling of tags and mentions
   */
  private async updatePostMetadata(
    post: Post,
    newMetadata: PostMetadata,
  ): Promise<void> {
    const oldMetadata = (post.metadata as Record<string, unknown>) || {};

    // Handle tags
    if (newMetadata.tags) {
      const oldTags = (oldMetadata.tags || []) as string[];
      const removedTags = oldTags.filter(
        (tag) => !newMetadata.tags!.includes(tag),
      );
      const addedTags = newMetadata.tags.filter(
        (tag) => !oldTags.includes(tag),
      );

      if (removedTags.length > 0) {
        await this.removeHashtags(post.id, removedTags);
      }

      if (addedTags.length > 0) {
        await this.processHashtags(post.id, addedTags);
      }
    }

    // Handle mentions
    if (newMetadata.mentions) {
      const oldMentions = (oldMetadata.mentions || []) as string[];
      const newMentions = newMetadata.mentions.filter(
        (mention) => !oldMentions.includes(mention),
      );

      if (newMentions.length > 0) {
        await this.createMentionNotificationsBatch(post, newMentions);
      }
    }

    // Update post metadata
    post.metadata = newMetadata;
  }

  /**
   * Create mention notifications in batch
   */
  private async createMentionNotificationsBatch(
    post: Post,
    mentions: string[],
  ): Promise<void> {
    const mentionedUsers = await Promise.all(
      mentions.map((username) => this.userRepository.findByUsername(username)),
    );
    const validUsers = mentionedUsers.filter((user) => user !== null);

    for (const user of validUsers) {
      if (user && user.id !== post.userId) {
        const notification = new Notification({
          userId: user.id,
          type: NotificationType.MENTION,
          entityType: EntityType.POST,
          entityId: post.id,
          actorId: post.userId,
          content: `mentioned you in a post`,
          metadata: {},
          read: false,
          delivered: false,
          createdAt: new Date(),
          updatedAt: new Date(),
        });
        await this.notificationRepository.create(notification);
      }
    }
  }

  /**
   * Update post scheduling
   */
  private updatePostScheduling(post: Post, scheduledAt: Date | null): void {
    if (scheduledAt) {
      if (scheduledAt <= new Date()) {
        throw new PostValidationError("Scheduled time must be in the future");
      }
      post.scheduledAt = scheduledAt;
      post.status = PostStatus.SCHEDULED;
    } else if (post.status === PostStatus.SCHEDULED) {
      post.status = PostStatus.PUBLISHED;
      post.publishedAt = new Date();
    }
  }
}



===========================================================
FILE 36: app\social\post\index.ts
===========================================================

// Export post services
export * from "./PostService";



===========================================================
FILE 37: dev\index.ts
===========================================================

// Export development service modules
export * from "./logger";
export * from "./tests";



===========================================================
FILE 38: dev\logger\LoggerService.ts
===========================================================

import path from "path";

import { Request, Response } from "express";
import winston from "winston";
// Environment variables with defaults
const { LOG_LEVEL = "info", NODE_ENV = "development" } = process.env;

/**
 * Helper function to format objects for better readability
 */
const formatObject = (obj: unknown): string => {
  if (!obj) return "";

  try {
    // For strings that look like JSON, parse and then stringify with indentation
    if (
      typeof obj === "string" &&
      (obj.startsWith("{") || obj.startsWith("["))
    ) {
      try {
        const parsed = JSON.parse(obj) as Record<string, unknown>;
        return "\n" + JSON.stringify(parsed, null, 2);
      } catch {
        // If parsing fails, treat as regular string
        return obj;
      }
    }

    // For objects, stringify with indentation
    if (typeof obj === "object") {
      return "\n" + JSON.stringify(obj, null, 2);
    }

    // For other types, convert to string
    return String(obj);
  } catch (error) {
    return `[Unformattable object: ${String(error)}]`;
  }
};

/**
 * Sanitize sensitive data from objects
 */
const sanitizeData = (
  data: Record<string, unknown>,
): Record<string, unknown> => {
  if (!data) return data;
  const sanitized = { ...data };

  // Remove sensitive fields
  if (sanitized.password) sanitized.password = "***";
  if (sanitized.passwordConfirmation) sanitized.passwordConfirmation = "***";
  if (sanitized.token) sanitized.token = "***";
  if (sanitized.refreshToken) sanitized.refreshToken = "***";

  return sanitized;
};

/**
 * Unified Logger service for consistent logging across the application
 */
export class Logger {
  private logger: winston.Logger;

  constructor(serviceName?: string) {
    // Ensure logs directory exists
    const logsDir = path.resolve(process.cwd(), "logs");

    // Create Winston logger
    this.logger = winston.createLogger({
      level: LOG_LEVEL,
      format: winston.format.combine(
        winston.format.timestamp({
          format: "YYYY-MM-DD HH:mm:ss",
        }),
        winston.format.errors({ stack: true }),
        winston.format.splat(),
        winston.format.json(),
      ),
      defaultMeta: { service: serviceName },
      transports: [
        // Write logs to console with colorization
        new winston.transports.Console({
          format: winston.format.combine(
            winston.format.colorize(),
            winston.format.printf((info) => {
              const { timestamp, level, message, service, ...meta } = info;
              const messageStr = String(message);
              // Format metadata for better readability
              let metaOutput = "";

              if (Object.keys(meta).length) {
                // Handle body property specially for HTTP requests
                if (meta.body) {
                  meta.body = sanitizeData(
                    meta.body as Record<string, unknown>,
                  );
                  metaOutput += `\nBody: ${formatObject(meta.body)}`;
                  delete meta.body;
                }

                // Format remaining metadata
                if (Object.keys(meta).length) {
                  metaOutput += `\nMeta: ${formatObject(meta)}`;
                }
              }

              // Add visual separator for debug level
              const separator = level.includes("debug")
                ? "\n----------------------------------------"
                : "";

              const servicePart = service ? `[${String(service)}]` : "";
              return `${String(timestamp)} ${String(level)} ${servicePart}: ${messageStr}${metaOutput}${String(separator)}`;
            }),
          ),
        }),
      ],
    });

    // Add file transports in production
    if (NODE_ENV === "production") {
      this.logger.add(
        new winston.transports.File({
          filename: path.join(logsDir, "error.log"),
          level: "error",
        }),
      );
      this.logger.add(
        new winston.transports.File({
          filename: path.join(logsDir, "combined.log"),
        }),
      );
    }
  }

  /**
   * Log an info message
   */
  public info(message: string, ...meta: unknown[]): void {
    this.logger.info(message, ...meta);
  }

  /**
   * Log a warning message
   */
  public warn(message: string, ...meta: unknown[]): void {
    this.logger.warn(message, ...meta);
  }

  /**
   * Log an error message
   */
  public error(message: string, ...meta: unknown[]): void {
    this.logger.error(message, ...meta);
  }

  /**
   * Log a debug message
   */
  public debug(message: string, ...meta: unknown[]): void {
    this.logger.debug(message, ...meta);
  }

  /**
   * Log HTTP request details
   */
  public logRequest(req: Request): void {
    const logData = {
      method: String(req.method),
      url: String(req.url),
      body: sanitizeData(req.body as Record<string, unknown>),
      query: sanitizeData(req.query as Record<string, unknown>),
      ip: String(req.ip ?? ""),
      userAgent: String(
        (req.get as (name: string) => string | null)("user-agent") ?? "",
      ),
    };

    if (NODE_ENV === "development") {
      this.debug("Incoming request", logData);
    }
  }

  /**
   * Log HTTP response details
   */
  public logResponse(req: Request, res: Response, duration: number): void {
    const responseData = {
      method: String(req.method),
      url: String(req.url),
      status: Number(res.statusCode),
      duration: `${duration}ms`,
      timestamp: new Date().toISOString(),
    };

    if (NODE_ENV === "production" && res.statusCode >= 400) {
      this.error("Request error", responseData);
    } else if (NODE_ENV === "development") {
      this.info("Request completed", responseData);
    }
  }
}

// Export a default logger instance
export const logger = new Logger("DefaultLogger");



===========================================================
FILE 39: dev\logger\index.ts
===========================================================

export * from "./LoggerService";



===========================================================
FILE 40: dev\tests\index.ts
===========================================================

// Test utilities will be exported from here
export const TestUtils = {
  // Placeholder for test utilities
};



===========================================================
FILE 41: index.ts
===========================================================

// Export services with namespace prefixes to avoid naming conflicts
import * as AppServices from "./app";
import * as DevServices from "./dev";
import * as SharedServices from "./shared";

export { AppServices, DevServices, SharedServices };



===========================================================
FILE 42: shared\base\BaseService.ts
===========================================================

import { DatabaseConnectionManager } from "@database/config";
import { Logger } from "@services/dev/logger/LoggerService";
import {
  ValidationFailedError,
  ValidationError,
  ValidationRule,
} from "@services/shared";

/**
 * Base service class that provides common functionality for all services
 * Services are responsible for:
 * 1. Implementing business logic
 * 2. Orchestrating operations across multiple repositories
 * 3. Handling validation and error checking
 * 4. Managing transactions when needed
 */
export abstract class BaseService {
  protected logger: Logger;

  constructor(serviceName: string) {
    this.logger = new Logger(serviceName);
  }

  /**
   * Execute operations within a transaction
   * @param operation Function containing the operations to execute in transaction
   * @returns Result of the operation
   */
  protected async withTransaction<T>(operation: () => Promise<T>): Promise<T> {
    return DatabaseConnectionManager.withTransaction(operation);
  }

  /**
   * Validate data against rules and throw if validation fails
   * @param data Data to validate
   * @param validationRules Rules to validate against
   * @throws ValidationFailedError if validation fails
   */
  protected validateAndThrow(
    data: unknown,
    validationRules: ValidationRule[],
  ): void {
    const errors = this.validate(data, validationRules);
    if (errors.length > 0) {
      throw new ValidationFailedError(errors);
    }
  }

  /**
   * Validate data against rules
   * @param data Data to validate
   * @param validationRules Rules to validate against
   * @returns Array of validation errors
   */
  protected validate(
    data: unknown,
    validationRules: ValidationRule[],
  ): ValidationError[] {
    const errors: ValidationError[] = [];

    for (const rule of validationRules) {
      for (const validator of rule.rules) {
        const error = validator(data);
        if (error) {
          errors.push({
            field: rule.field,
            message: error,
          });
        }
      }
    }

    return errors;
  }

  protected async withCache<T>(
    _key: string,
    operation: () => Promise<T>,
    _ttl: number,
  ): Promise<T> {
    try {
      return operation();
    } catch (error) {
      this.logger.error("Cache operation failed:", error);
      throw error;
    }
  }
}



===========================================================
FILE 43: shared\cache\CacheManager.ts
===========================================================

export class CacheManager<K extends string = string, V = unknown> {
  private cache = new Map<K, { value: V; expiresAt: number }>();

  constructor(
    protected namespace: string = "",
    protected ttlSeconds: number = 3600,
  ) {}

  async get<T extends V>(key: K): Promise<T | null> {
    const entry = this.cache.get(key);
    if (!entry || entry.expiresAt < Date.now()) {
      return null;
    }
    return entry.value as T;
  }

  async set(
    key: K,
    value: V,
    ttlSeconds: number = this.ttlSeconds,
  ): Promise<void> {
    this.cache.set(key, {
      value,
      expiresAt: Date.now() + ttlSeconds * 1000,
    });
  }

  async delete(key: K): Promise<void> {
    this.cache.delete(key);
  }

  async mget(keys: K[]): Promise<(V | null)[]> {
    return Promise.all(keys.map((key) => this.get(key)));
  }

  async mset(entries: { key: K; value: V }[]): Promise<void> {
    await Promise.all(entries.map((entry) => this.set(entry.key, entry.value)));
  }
}



===========================================================
FILE 44: shared\cache\PostCacheManager.ts
===========================================================

import { Post } from "@models/social/Post";
import { MetricsService } from "@services/app/social/monitoring/MetricsService";

import { CacheManager } from "./CacheManager";

export class PostCacheManager extends CacheManager<string, Post> {
  private readonly metrics: MetricsService;
  private readonly prefetchThreshold = 0.8; // Trigger prefetch when 80% of TTL has elapsed

  constructor(namespace: string = "posts", ttlSeconds: number = 3600) {
    super(namespace, ttlSeconds);
    this.metrics = MetricsService.getInstance();
  }

  public async get<T extends Post = Post>(
    key: string,
    operation: string = "default",
  ): Promise<T | null> {
    const value = await super.get<T>(key);
    if (value) {
      this.metrics.recordCacheHit(operation);
      // Check if we need to extend TTL
      await this.extendTTLIfNeeded(key, value);
    } else {
      this.metrics.recordCacheMiss(operation);
    }
    return value;
  }

  public async set(key: string, value: Post): Promise<void> {
    await super.set(key, value);
    this.metrics.incrementPostsByType(value.type);
  }

  public async mget(keys: string[]): Promise<(Post | null)[]> {
    const operation = "batch_get";
    const values = await super.mget(keys);
    const hits = values.filter((v) => v !== null).length;
    const misses = values.length - hits;

    if (hits > 0) this.metrics.recordCacheHit(operation);
    if (misses > 0) this.metrics.recordCacheMiss(operation);

    return values;
  }

  public async mset(entries: { key: string; value: Post }[]): Promise<void> {
    await super.mset(entries);
    entries.forEach((entry) => {
      this.metrics.incrementPostsByType(entry.value.type);
    });
  }

  public async invalidate(key: string): Promise<void> {
    await super.delete(key);
  }

  public async invalidatePattern(pattern: string): Promise<void> {
    const keys = await this.getKeysByPattern(pattern);
    await Promise.all(keys.map((key) => this.invalidate(key)));
  }

  private async extendTTLIfNeeded(key: string, value: Post): Promise<void> {
    const ttl = await this.getTTL(key);
    const maxTTL = this.ttlSeconds;

    if (ttl < maxTTL * this.prefetchThreshold) {
      await this.set(key, value);
    }
  }

  public generateCacheKey(params: Record<string, unknown>): string {
    const sortedParams = Object.keys(params)
      .sort()
      .reduce(
        (acc, key) => {
          acc[key] = params[key];
          return acc;
        },
        {} as Record<string, unknown>,
      );

    return `${this.namespace}:${JSON.stringify(sortedParams)}`;
  }

  public async warmUp(posts: Post[]): Promise<void> {
    const entries = posts.map((post) => ({
      key: post.id,
      value: post,
    }));
    await this.mset(entries);
  }

  private async getKeysByPattern(_pattern: string): Promise<string[]> {
    // Implementation depends on your cache backend
    // For Redis, you would use KEYS or SCAN
    // For in-memory cache, you might need to filter keys manually
    return [];
  }

  private async getTTL(_key: string): Promise<number> {
    // Implementation depends on your cache backend
    // For Redis, you would use TTL command
    // For in-memory cache, you might need to track expiration times separately
    return 0;
  }
}



===========================================================
FILE 45: shared\communication\EventEmitter.ts
===========================================================

type EventHandler = (...args: unknown[]) => void;

export class EventEmitter {
  private events: Map<string, EventHandler[]>;

  constructor() {
    this.events = new Map();
  }

  emit(event: string, ...args: unknown[]): void {
    const handlers = this.events.get(event);
    if (handlers) {
      handlers.forEach((handler) => handler(...args));
    }
  }

  on(event: string, handler: EventHandler): void {
    const handlers = this.events.get(event) || [];
    handlers.push(handler);
    this.events.set(event, handlers);
  }

  off(event: string, handler: EventHandler): void {
    const handlers = this.events.get(event);
    if (handlers) {
      const index = handlers.indexOf(handler);
      if (index > -1) {
        handlers.splice(index, 1);
        if (handlers.length === 0) {
          this.events.delete(event);
        } else {
          this.events.set(event, handlers);
        }
      }
    }
  }

  removeAllListeners(event?: string): void {
    if (event) {
      this.events.delete(event);
    } else {
      this.events.clear();
    }
  }
}



===========================================================
FILE 46: shared\communication\TemplateEngine.ts
===========================================================

/**
 * Simple template engine for rendering text with variables
 */
export class TemplateEngine {
  /**
   * Render a template by replacing placeholders with values
   * @param template The template string with {placeholders}
   * @param variables Object containing values for placeholders
   */
  render(template: string, variables: Record<string, unknown>): string {
    return template.replace(/{(\w+)}/g, (match, key) => {
      const value = variables[key];
      return value !== undefined ? String(value) : match;
    });
  }
}



===========================================================
FILE 47: shared\errors\PostErrors.ts
===========================================================

import {
  ValidationError,
  ResourceNotFoundError,
  UnauthorizedError,
} from "./ServiceError";

export class PostValidationError extends ValidationError {
  constructor(message: string) {
    super(message);
    this.name = "PostValidationError";
  }
}

export class PostNotFoundError extends ResourceNotFoundError {
  constructor(postId: string) {
    super(`Post with ID ${postId} not found`);
    this.name = "PostNotFoundError";
  }
}

export class PostPermissionError extends UnauthorizedError {
  constructor(message: string) {
    super(message);
    this.name = "PostPermissionError";
  }
}

export class PostRateLimitError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "PostRateLimitError";
  }
}

export class PostContentError extends ValidationError {
  constructor(message: string) {
    super(message);
    this.name = "PostContentError";
  }
}

export class PostSchedulingError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "PostSchedulingError";
  }
}



===========================================================
FILE 48: shared\errors\ServiceError.ts
===========================================================

/**
 * Base error class for service-level errors
 */
export class ServiceError extends Error {
  constructor(message: string) {
    super(message);
    this.name = this.constructor.name;
  }
}

/**
 * Error thrown when a resource is not found
 */
export class ResourceNotFoundError extends ServiceError {
  constructor(resource: string) {
    super(`${resource} not found`);
  }
}

/**
 * Error thrown when a duplicate resource is detected
 */
export class DuplicateResourceError extends ServiceError {
  constructor(resource: string, field: string, value: string) {
    super(`${resource} with ${field} '${value}' already exists`);
    this.name = "DuplicateResourceError";
  }
}

/**
 * Error thrown when an operation is not authorized
 */
export class UnauthorizedError extends ServiceError {
  constructor(message: string) {
    super(message);
  }
}

/**
 * Error thrown when an operation is not permitted
 */
export class ForbiddenError extends ServiceError {
  constructor(message = "Operation not permitted") {
    super(message);
    this.name = "ForbiddenError";
  }
}

/**
 * Error thrown when there's an issue with external service integration
 */
export class ExternalServiceError extends ServiceError {
  constructor(service: string, details?: string) {
    super(
      `Error in external service ${service}${details ? `: ${details}` : ""}`,
    );
    this.name = "ExternalServiceError";
  }
}

export class ValidationError extends ServiceError {
  constructor(message: string) {
    super(message);
  }
}

export class TooManyRequestsError extends ServiceError {
  constructor(message: string) {
    super(message);
  }
}



===========================================================
FILE 49: shared\errors\ValidationError.ts
===========================================================

import { ValidationError as IValidationError } from "@services/shared/types/validation";

/**
 * Error thrown when validation fails
 */
export class ValidationFailedError extends Error {
  public errors: IValidationError[];

  constructor(errors: IValidationError[]) {
    super("Validation failed");
    this.name = "ValidationFailedError";
    this.errors = errors;
  }
}



===========================================================
FILE 50: shared\index.ts
===========================================================

// Base classes
export { BaseService } from "./base/BaseService";

// Types
export {
  ValidationError,
  ServiceResponse,
  PaginatedResponse,
  PaginationOptions,
  CrudOperations,
  PaginatedOperations,
} from "./types/validation";

// Errors
export { ValidationFailedError } from "./errors/ValidationError";
export {
  ServiceError,
  ResourceNotFoundError,
  DuplicateResourceError,
  UnauthorizedError,
  ForbiddenError,
  ExternalServiceError,
  TooManyRequestsError,
} from "./errors/ServiceError";

// Validation
export { ValidationRule, Validator } from "./validation/ValidationRule";
export { commonValidators } from "./validation/commonValidators";
export { ContentValidator } from "./validation/ContentValidator";
export { urlValidator } from "./validation/UrlValidator";

// Security
export { RateLimiter } from "./security/RateLimiter";
export { PostRateLimiter } from "./security/PostRateLimiter";
export { profanityFilter } from "./security/ProfanityFilter";

// Communication
export { TemplateEngine } from "./communication/TemplateEngine";
export { EventEmitter } from "./communication/EventEmitter";

// Session
export { SessionManager } from "./session/SessionManager";

// Utilities - Caching
export { CacheManager } from "./cache/CacheManager";
export { PostCacheManager } from "./cache/PostCacheManager";



===========================================================
FILE 51: shared\security\PostRateLimiter.ts
===========================================================

import { UserType } from "@models/auth";
import { MetricsService } from "@services/app/social/monitoring/MetricsService";
import { PostRateLimitError } from "@services/shared/errors/PostErrors";

import { RateLimiter } from "./RateLimiter";

interface RateLimitConfig {
  windowSeconds: number;
  maxRequests: number;
}

export class PostRateLimiter extends RateLimiter {
  private readonly metrics: MetricsService;
  private readonly limitsByUserType: Map<UserType, RateLimitConfig>;
  protected namespace: string;

  constructor() {
    super("post_creation", 3600, 100);
    this.metrics = MetricsService.getInstance();
    this.namespace = "post_creation";

    // Configure rate limits by user type
    this.limitsByUserType = new Map([
      [UserType.PREMIUM, { windowSeconds: 3600, maxRequests: 500 }],
      [UserType.VERIFIED, { windowSeconds: 3600, maxRequests: 200 }],
      [UserType.STANDARD, { windowSeconds: 3600, maxRequests: 100 }],
      [UserType.RESTRICTED, { windowSeconds: 3600, maxRequests: 20 }],
    ]);
  }

  protected async getCurrentCount(key: string): Promise<number> {
    return super.getCurrentCount(key);
  }

  protected async increment(key: string, windowSeconds: number): Promise<void> {
    await super.increment(key, windowSeconds);
  }

  protected async reset(key: string): Promise<void> {
    await super.reset(key);
  }

  public async checkLimit(
    userId: string,
    userType: UserType = UserType.STANDARD,
  ): Promise<void> {
    const config =
      this.limitsByUserType.get(userType) ||
      this.limitsByUserType.get(UserType.STANDARD)!;

    try {
      const key = this.generateKey(userId, userType);
      const current = await this.getCurrentCount(key);

      if (current >= config.maxRequests) {
        this.metrics.recordRateLimit(userType);
        throw new PostRateLimitError(
          `Rate limit exceeded for ${userType} user. Maximum ${config.maxRequests} posts per ${config.windowSeconds / 3600} hour(s).`,
        );
      }

      await this.increment(key, config.windowSeconds);
    } catch (error) {
      if (error instanceof PostRateLimitError) {
        throw error;
      }
      throw new Error("Error checking rate limit");
    }
  }

  public async getRemainingLimit(
    userId: string,
    userType: UserType = UserType.STANDARD,
  ): Promise<number> {
    const config =
      this.limitsByUserType.get(userType) ||
      this.limitsByUserType.get(UserType.STANDARD)!;
    const key = this.generateKey(userId, userType);
    const current = await this.getCurrentCount(key);
    return Math.max(0, config.maxRequests - current);
  }

  public async resetLimit(
    userId: string,
    userType: UserType = UserType.STANDARD,
  ): Promise<void> {
    const key = this.generateKey(userId, userType);
    await this.reset(key);
  }

  private generateKey(userId: string, userType: UserType): string {
    return `${this.namespace}:${userType}:${userId}`;
  }

  public getLimitConfig(userType: UserType): RateLimitConfig {
    return (
      this.limitsByUserType.get(userType) ||
      this.limitsByUserType.get(UserType.STANDARD)!
    );
  }

  public async isWithinLimit(
    userId: string,
    userType: UserType = UserType.STANDARD,
  ): Promise<boolean> {
    try {
      await this.checkLimit(userId, userType);
      return true;
    } catch (error) {
      if (error instanceof PostRateLimitError) {
        return false;
      }
      throw error;
    }
  }
}



===========================================================
FILE 52: shared\security\ProfanityFilter.ts
===========================================================

export class ProfanityFilter {
  private static instance: ProfanityFilter;
  private readonly profanityList: Set<string> = new Set();

  private constructor() {
    // Initialize with basic profanity list
    // In production, load from a proper source
    this.profanityList = new Set(["badword1", "badword2"]);
  }

  static getInstance(): ProfanityFilter {
    if (!ProfanityFilter.instance) {
      ProfanityFilter.instance = new ProfanityFilter();
    }
    return ProfanityFilter.instance;
  }

  async check(text: string): Promise<boolean> {
    const words = text.toLowerCase().split(/\s+/);
    return words.some((word) => this.profanityList.has(word));
  }
}

export const profanityFilter = ProfanityFilter.getInstance();



===========================================================
FILE 53: shared\security\RateLimiter.ts
===========================================================

import { TooManyRequestsError } from "@services/shared/errors/ServiceError";

export class RateLimiter {
  private cache = new Map<string, { count: number; expiresAt: number }>();

  constructor(
    protected namespace: string,
    protected windowSeconds: number,
    protected maxRequests: number,
  ) {}

  protected async getCurrentCount(key: string): Promise<number> {
    const entry = this.cache.get(key);
    if (!entry || entry.expiresAt < Date.now()) {
      return 0;
    }
    return entry.count;
  }

  protected async increment(key: string, windowSeconds: number): Promise<void> {
    const entry = this.cache.get(key) || {
      count: 0,
      expiresAt: Date.now() + windowSeconds * 1000,
    };
    entry.count++;
    this.cache.set(key, entry);
  }

  protected async reset(key: string): Promise<void> {
    this.cache.delete(key);
  }

  async checkLimit(identifier: string): Promise<void> {
    const key = `${this.namespace}:${identifier}`;
    const now = Date.now();
    const attempt = this.cache.get(key);

    if (!attempt || now > attempt.expiresAt) {
      this.cache.set(key, {
        count: 1,
        expiresAt: now + this.windowSeconds * 1000,
      });
      return;
    }

    if (attempt.count >= this.maxRequests) {
      throw new TooManyRequestsError(
        "Too many attempts. Please try again later.",
      );
    }

    attempt.count++;
  }
}



===========================================================
FILE 54: shared\session\SessionManager.ts
===========================================================

export interface DeviceInfo {
  ip: string;
  userAgent: string;
  platform?: string;
  browser?: string;
}

export interface SessionInfo {
  id: string;
  userId: string;
  deviceInfo: DeviceInfo;
  createdAt: Date;
  lastActiveAt: Date;
}

export class SessionManager {
  private sessions = new Map<string, SessionInfo>();

  async createSession(
    userId: string,
    deviceInfo: DeviceInfo,
  ): Promise<SessionInfo> {
    const id = Math.random().toString(36).substring(2);
    const session: SessionInfo = {
      id,
      userId,
      deviceInfo,
      createdAt: new Date(),
      lastActiveAt: new Date(),
    };
    this.sessions.set(id, session);
    return session;
  }

  async getUserSessions(userId: string): Promise<SessionInfo[]> {
    return Array.from(this.sessions.values()).filter(
      (session) => session.userId === userId,
    );
  }

  async terminateSession(userId: string, sessionId: string): Promise<boolean> {
    const session = this.sessions.get(sessionId);
    if (session && session.userId === userId) {
      return this.sessions.delete(sessionId);
    }
    return false;
  }

  async terminateOtherSessions(
    userId: string,
    currentSessionId: string,
  ): Promise<boolean> {
    let terminated = false;
    this.sessions.forEach((session, id) => {
      if (session.userId === userId && id !== currentSessionId) {
        this.sessions.delete(id);
        terminated = true;
      }
    });
    return terminated;
  }
}



===========================================================
FILE 55: shared\types\validation.ts
===========================================================

/**
 * Represents a validation error with field and message
 */
export interface ValidationError {
  field: string;
  message: string;
}

/**
 * Generic service response type
 */
export interface ServiceResponse<T> {
  success: boolean;
  data?: T;
  error?: {
    code: string;
    message: string;
    details?: unknown;
  };
}

/**
 * Paginated response type
 */
export interface PaginatedResponse<T> extends ServiceResponse<T[]> {
  pagination: {
    page: number;
    limit: number;
    total: number;
    hasMore: boolean;
  };
}

/**
 * Pagination options for list operations
 */
export interface PaginationOptions {
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: "asc" | "desc";
  offset?: number;
}

/**
 * Base interface for CRUD operations
 */
export interface CrudOperations<T> {
  create(data: Partial<T>): Promise<T>;
  findById(id: string): Promise<T | null>;
  update(id: string, data: Partial<T>): Promise<T>;
  delete(id: string): Promise<boolean>;
}

/**
 * Interface for services that support pagination
 */
export interface PaginatedOperations<T> {
  list(options: PaginationOptions): Promise<PaginatedResponse<T>>;
}



===========================================================
FILE 56: shared\validation\ContentValidator.ts
===========================================================

import { PostContentError } from "@services/shared/errors/PostErrors";
import { profanityFilter } from "@services/shared/security/ProfanityFilter";
import { urlValidator } from "@services/shared/validation/UrlValidator";

interface ContentLimits {
  maxTextLength: number;
  maxCaptionLength: number;
  maxPollOptions: number;
  minPollOptions: number;
  maxPollOptionLength: number;
  maxHashtags: number;
  maxMentions: number;
  maxUrls: number;
}

export class ContentValidator {
  private readonly limits: ContentLimits = {
    maxTextLength: 5000,
    maxCaptionLength: 1000,
    maxPollOptions: 4,
    minPollOptions: 2,
    maxPollOptionLength: 100,
    maxHashtags: 30,
    maxMentions: 50,
    maxUrls: 5,
  };

  private readonly urlRegex =
    /^(https?:\/\/)?([\da-z.-]+)\.([a-z.]{2,6})([/\w .-]*)*\/?$/;
  private readonly hashtagRegex = /^[a-zA-Z0-9_]+$/;
  private readonly mentionRegex = /^[a-zA-Z0-9_]+$/;

  public async isValidText(text: string): Promise<boolean> {
    if (!text || typeof text !== "string") {
      throw new PostContentError("Text content must be a non-empty string");
    }

    if (text.length > this.limits.maxTextLength) {
      throw new PostContentError(
        `Text content cannot exceed ${this.limits.maxTextLength} characters`,
      );
    }

    if (await this.containsProfanity(text)) {
      throw new PostContentError("Content contains inappropriate language");
    }

    return true;
  }

  public async isValidCaption(caption: string): Promise<boolean> {
    if (!caption || typeof caption !== "string") {
      throw new PostContentError("Caption must be a non-empty string");
    }

    if (caption.length > this.limits.maxCaptionLength) {
      throw new PostContentError(
        `Caption cannot exceed ${this.limits.maxCaptionLength} characters`,
      );
    }

    if (await this.containsProfanity(caption)) {
      throw new PostContentError("Caption contains inappropriate language");
    }

    return true;
  }

  public isValidUrl(url: string): boolean {
    if (!url || typeof url !== "string") {
      throw new PostContentError("URL must be a non-empty string");
    }

    if (!this.urlRegex.test(url)) {
      throw new PostContentError("Invalid URL format");
    }

    return urlValidator.isValid(url);
  }

  public isValidPoll(question: string, options: string[]): boolean {
    if (!question || typeof question !== "string") {
      throw new PostContentError("Poll question must be a non-empty string");
    }

    if (question.length > this.limits.maxCaptionLength) {
      throw new PostContentError(
        `Poll question cannot exceed ${this.limits.maxCaptionLength} characters`,
      );
    }

    if (!Array.isArray(options)) {
      throw new PostContentError("Poll options must be an array");
    }

    if (options.length < this.limits.minPollOptions) {
      throw new PostContentError(
        `Poll must have at least ${this.limits.minPollOptions} options`,
      );
    }

    if (options.length > this.limits.maxPollOptions) {
      throw new PostContentError(
        `Poll cannot have more than ${this.limits.maxPollOptions} options`,
      );
    }

    options.forEach((option, index) => {
      if (!option || typeof option !== "string") {
        throw new PostContentError(
          `Poll option ${index + 1} must be a non-empty string`,
        );
      }

      if (option.length > this.limits.maxPollOptionLength) {
        throw new PostContentError(
          `Poll option ${index + 1} cannot exceed ${this.limits.maxPollOptionLength} characters`,
        );
      }
    });

    return true;
  }

  public isValidHashtags(hashtags: string[]): boolean {
    if (!Array.isArray(hashtags)) {
      throw new PostContentError("Hashtags must be an array");
    }

    if (hashtags.length > this.limits.maxHashtags) {
      throw new PostContentError(
        `Cannot include more than ${this.limits.maxHashtags} hashtags`,
      );
    }

    hashtags.forEach((hashtag) => {
      if (!hashtag || typeof hashtag !== "string") {
        throw new PostContentError("Each hashtag must be a non-empty string");
      }

      if (!this.hashtagRegex.test(hashtag)) {
        throw new PostContentError(`Invalid hashtag format: ${hashtag}`);
      }
    });

    return true;
  }

  public isValidMentions(mentions: string[]): boolean {
    if (!Array.isArray(mentions)) {
      throw new PostContentError("Mentions must be an array");
    }

    if (mentions.length > this.limits.maxMentions) {
      throw new PostContentError(
        `Cannot include more than ${this.limits.maxMentions} mentions`,
      );
    }

    mentions.forEach((mention) => {
      if (!mention || typeof mention !== "string") {
        throw new PostContentError("Each mention must be a non-empty string");
      }

      if (!this.mentionRegex.test(mention)) {
        throw new PostContentError(`Invalid mention format: ${mention}`);
      }
    });

    return true;
  }

  public async containsProfanity(text: string): Promise<boolean> {
    return profanityFilter.check(text);
  }

  public getLimits(): ContentLimits {
    return { ...this.limits };
  }
}



===========================================================
FILE 57: shared\validation\UrlValidator.ts
===========================================================

class UrlValidator {
  private static instance: UrlValidator;
  private readonly maxUrlLength = 2048;
  private readonly urlRegex =
    /^(https?:\/\/)?([\da-z.-]+)\.([a-z.]{2,6})([/\w .-]*)*\/?$/;

  private constructor() {}

  static getInstance(): UrlValidator {
    if (!UrlValidator.instance) {
      UrlValidator.instance = new UrlValidator();
    }
    return UrlValidator.instance;
  }

  isValid(url: string): boolean {
    if (!url || url.length > this.maxUrlLength) return false;
    return this.urlRegex.test(url);
  }
}

export const urlValidator = UrlValidator.getInstance();



===========================================================
FILE 58: shared\validation\ValidationRule.ts
===========================================================

/**
 * Type for validator functions
 */
export type Validator = (value: unknown) => string | null;

/**
 * Interface for validation rules
 */
export interface ValidationRule {
  field: string;
  rules: Validator[];
}



===========================================================
FILE 59: shared\validation\commonValidators.ts
===========================================================

import { Validator } from "@services/shared/validation/ValidationRule";

/**
 * Common validator functions that can be reused across services
 */
export const commonValidators = {
  /**
   * Validates that a value is not undefined or null
   */
  required:
    (field: string): Validator =>
    (value: unknown): string | null =>
      value === undefined || value === null ? `${field} is required` : null,

  /**
   * Validates that a string meets minimum length requirement
   */
  minLength:
    (field: string, min: number): Validator =>
    (value: unknown): string | null =>
      typeof value === "string" && value.length < min
        ? `${field} must be at least ${min} characters`
        : null,

  /**
   * Validates that a string doesn't exceed maximum length
   */
  maxLength:
    (field: string, max: number): Validator =>
    (value: unknown): string | null =>
      typeof value === "string" && value.length > max
        ? `${field} must not exceed ${max} characters`
        : null,

  /**
   * Validates that a value is a valid email address
   */
  email:
    (field: string): Validator =>
    (value: unknown): string | null =>
      typeof value === "string" && !value.match(/^[^\s@]+@[^\s@]+\.[^\s@]+$/)
        ? `${field} must be a valid email address`
        : null,

  /**
   * Validates that a value matches a regular expression pattern
   */
  pattern:
    (field: string, pattern: RegExp, message?: string): Validator =>
    (value: unknown): string | null =>
      typeof value === "string" && !pattern.test(value)
        ? message || `${field} format is invalid`
        : null,

  /**
   * Validates that a number is within a specified range
   */
  range:
    (field: string, min: number, max: number): Validator =>
    (value: unknown): string | null =>
      typeof value === "number" && (value < min || value > max)
        ? `${field} must be between ${min} and ${max}`
        : null,

  /**
   * Validates that a value is one of a set of allowed values
   */
  oneOf:
    (field: string, allowedValues: unknown[]): Validator =>
    (value: unknown): string | null =>
      !allowedValues.includes(value)
        ? `${field} must be one of: ${allowedValues.join(", ")}`
        : null,

  /**
   * Validates that a value is a valid URL
   */
  url:
    (field: string): Validator =>
    (value: unknown): string | null => {
      if (typeof value !== "string") return `${field} must be a string`;
      try {
        new URL(value);
        return null;
      } catch {
        return `${field} must be a valid URL`;
      }
    },

  /**
   * Validates that a value is a valid UUID
   */
  uuid:
    (field: string): Validator =>
    (value: unknown): string | null =>
      typeof value === "string" &&
      !/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(
        value,
      )
        ? `${field} must be a valid UUID`
        : null,

  /**
   * Validates that an array has a specific length
   */
  arrayLength:
    (field: string, min?: number, max?: number): Validator =>
    (value: unknown): string | null => {
      if (!Array.isArray(value)) return `${field} must be an array`;
      if (min !== undefined && value.length < min)
        return `${field} must contain at least ${min} items`;
      if (max !== undefined && value.length > max)
        return `${field} must not contain more than ${max} items`;
      return null;
    },
};



