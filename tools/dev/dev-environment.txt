# ABE Stack - Development Environment Snapshot

Generated: 2025-12-28T03:59:17.713Z

---

## 1. Project Structure (Tree View)

```
.
├── .claude/
│   └── settings.local.json
├── .github/
│   └── workflows/
│       ├── audit.yml
│       └── ci.yml
├── .vscode/
│   ├── extensions.json
│   ├── launch.json
│   ├── settings.json
│   └── tasks.json
├── apps/
│   ├── desktop/
│   │   ├── electron/
│   │   │   ├── main.ts
│   │   │   ├── preload.ts
│   │   │   └── tsconfig.json
│   │   ├── src/
│   │   │   ├── native/
│   │   │   │   └── README.md
│   │   │   ├── App.tsx
│   │   │   └── main.tsx
│   │   ├── .env.example
│   │   ├── README.md
│   │   ├── index.html
│   │   ├── package.json
│   │   ├── tsconfig.json
│   │   └── vite.config.ts
│   ├── mobile/
│   │   ├── src/
│   │   │   └── App.tsx
│   │   ├── .env.example
│   │   ├── README.md
│   │   ├── app.json
│   │   ├── babel.config.js
│   │   ├── index.js
│   │   ├── metro.config.js
│   │   ├── package.json
│   │   ├── tsconfig.json
│   │   └── tsconfig.tsbuildinfo
│   ├── server/
│   │   ├── src/
│   │   │   ├── fastify/
│   │   │   │   └── server.ts
│   │   │   ├── scripts/
│   │   │   │   ├── dbHealthCheck.ts
│   │   │   │   └── seed.ts
│   │   │   ├── README.md
│   │   │   ├── index.md
│   │   │   └── index.ts
│   │   ├── drizzle.config.ts
│   │   ├── package.json
│   │   ├── tsconfig.json
│   │   └── tsconfig.tsbuildinfo
│   └── web/
│       ├── __tests__/
│       │   ├── base.e2e.ts
│       │   └── base.test.ts
│       ├── public/
│       │   ├── icons/
│       │   │   ├── apple-touch-icon.png
│       │   │   ├── favicon.ico
│       │   │   ├── favicon.svg
│       │   │   ├── logo192.png
│       │   │   └── logo512.png
│       │   ├── favicon.ico
│       │   ├── manifest.json
│       │   ├── robots.txt
│       │   └── service-worker.js
│       ├── src/
│       │   ├── api/
│       │   │   ├── auth.api.ts
│       │   │   └── index.ts
│       │   ├── components/
│       │   │   ├── auth/
│       │   │   │   ├── AuthContext.tsx
│       │   │   │   ├── AuthModal.tsx
│       │   │   │   ├── ConfirmEmail.tsx
│       │   │   │   ├── LoginModal.tsx
│       │   │   │   ├── RegisterModal.tsx
│       │   │   │   ├── ResendVerification.tsx
│       │   │   │   ├── VerificationModal.tsx
│       │   │   │   └── index.tsx
│       │   │   ├── debug/
│       │   │   │   ├── DbTest.tsx
│       │   │   │   └── index.ts
│       │   │   ├── media/
│       │   │   │   ├── AudioPlayer.tsx
│       │   │   │   ├── ImageGallery.tsx
│       │   │   │   ├── MediaGallery.tsx
│       │   │   │   ├── VideoPlayer.tsx
│       │   │   │   ├── mediaPlayer.tsx
│       │   │   │   ├── mediaUpload.tsx
│       │   │   │   └── mediaView.tsx
│       │   │   ├── pages/
│       │   │   │   ├── DashboardPage.tsx
│       │   │   │   ├── DesignPage.tsx
│       │   │   │   ├── ExplorePage.tsx
│       │   │   │   ├── HomePage.tsx
│       │   │   │   ├── MediaPage.tsx
│       │   │   │   ├── NotificationsPage.tsx
│       │   │   │   ├── ProfilePage.tsx
│       │   │   │   ├── SettingsPage.tsx
│       │   │   │   ├── SocialPage.tsx
│       │   │   │   └── UploadPage.tsx
│       │   │   ├── social/
│       │   │   │   ├── CommentSection.tsx
│       │   │   │   ├── Comments.tsx
│       │   │   │   ├── CreatePost.tsx
│       │   │   │   ├── CreatePostForm.tsx
│       │   │   │   ├── Feed.tsx
│       │   │   │   ├── PostCard.tsx
│       │   │   │   ├── SocialFeed.tsx
│       │   │   │   ├── UserProfile.tsx
│       │   │   │   └── UserProfileCard.tsx
│       │   │   ├── theme/
│       │   │   │   ├── ThemeContext.tsx
│       │   │   │   └── index.ts
│       │   │   ├── ui/
│       │   │   │   ├── demos/
│       │   │   │   │   ├── BadgeDemo.tsx
│       │   │   │   │   ├── ButtonDemo.tsx
│       │   │   │   │   ├── CalendarDemo.tsx
│       │   │   │   │   ├── ComboBoxDemo.tsx
│       │   │   │   │   ├── DropdownDemo.tsx
│       │   │   │   │   ├── FileUploadDemo.tsx
│       │   │   │   │   ├── FormDemo.tsx
│       │   │   │   │   ├── FuzzyStringDemo.tsx
│       │   │   │   │   ├── ListBoxDemo.tsx
│       │   │   │   │   ├── PopupDemo.tsx
│       │   │   │   │   ├── SpinnerDemo.tsx
│       │   │   │   │   ├── TokenInputDemo.tsx
│       │   │   │   │   └── autoindex.ts
│       │   │   │   ├── Badge.tsx
│       │   │   │   ├── Button.tsx
│       │   │   │   ├── Card.tsx
│       │   │   │   ├── ComboBox.tsx
│       │   │   │   ├── DropdownMenu.tsx
│       │   │   │   ├── FileUpload.tsx
│       │   │   │   ├── FuzzyString.tsx
│       │   │   │   ├── Input.tsx
│       │   │   │   ├── Link.tsx
│       │   │   │   ├── ListBox.tsx
│       │   │   │   ├── MenuItem.tsx
│       │   │   │   ├── OfflineBadge.tsx
│       │   │   │   ├── Popup.tsx
│       │   │   │   ├── Spinner.tsx
│       │   │   │   ├── Throttle.tsx
│       │   │   │   └── button.css
│       │   │   ├── Design.tsx
│       │   │   ├── Link.tsx
│       │   │   ├── ProtectedRoute.tsx
│       │   │   └── Root.tsx
│       │   ├── config/
│       │   │   └── environment.ts
│       │   ├── contexts/
│       │   │   ├── AuthContext.tsx
│       │   │   └── SocialContext.tsx
│       │   ├── helpers/
│       │   │   ├── cookieHelpers.ts
│       │   │   ├── focusHelpers.ts
│       │   │   ├── formatters.ts
│       │   │   ├── mergeEvents.ts
│       │   │   └── passthroughRef.tsx
│       │   ├── hooks/
│       │   │   ├── useAsync.ts
│       │   │   ├── useCounter.ts
│       │   │   ├── useOnline.ts
│       │   │   ├── usePopper.ts
│       │   │   ├── useRefCurrent.ts
│       │   │   ├── useRefPrevious.ts
│       │   │   ├── useShortcut.ts
│       │   │   └── useSocialInteractions.ts
│       │   ├── layouts/
│       │   │   ├── MainLayout.tsx
│       │   │   ├── PageContent.tsx
│       │   │   ├── main-layout.css
│       │   │   └── page-content.css
│       │   ├── services/
│       │   │   ├── AuthClient.ts
│       │   │   ├── ClientConfig.ts
│       │   │   ├── ClientEnvironment.tsx
│       │   │   ├── Router.ts
│       │   │   ├── WebsocketPubsubClient.ts
│       │   │   ├── api.ts
│       │   │   ├── social.ts
│       │   │   └── types.ts
│       │   ├── utils/
│       │   │   └── styleUtils.ts
│       │   ├── web-only/
│       │   │   └── README.md
│       │   ├── App.tsx
│       │   ├── index.css
│       │   ├── index.tsx
│       │   ├── routes.tsx
│       │   ├── service-worker.js
│       │   ├── service-worker.ts
│       │   └── styles.ts
│       ├── .env.example
│       ├── index.html
│       ├── package.json
│       └── tsconfig.json
├── archive/
│   ├── database/
│   │   ├── models/
│   │   │   ├── analytics/
│   │   │   │   ├── ActivityLog.ts
│   │   │   │   └── index.ts
│   │   │   ├── community/
│   │   │   │   ├── Group.ts
│   │   │   │   ├── GroupMember.ts
│   │   │   │   └── index.ts
│   │   │   ├── discovery/
│   │   │   │   ├── SearchIndex.ts
│   │   │   │   └── index.ts
│   │   │   ├── media/
│   │   │   │   ├── Media.ts
│   │   │   │   ├── MediaCollection.ts
│   │   │   │   ├── MediaTag.ts
│   │   │   │   └── index.ts
│   │   │   ├── messaging/
│   │   │   │   ├── Conversation.ts
│   │   │   │   ├── Message.ts
│   │   │   │   └── index.ts
│   │   │   ├── moderation/
│   │   │   │   ├── ContentReport.ts
│   │   │   │   ├── ModerationAction.ts
│   │   │   │   └── index.ts
│   │   │   ├── social/
│   │   │   │   ├── Bookmark.ts
│   │   │   │   ├── Comment.ts
│   │   │   │   ├── CommentLike.ts
│   │   │   │   ├── Follow.ts
│   │   │   │   ├── Hashtag.ts
│   │   │   │   ├── Like.ts
│   │   │   │   ├── Notification.ts
│   │   │   │   ├── Post.ts
│   │   │   │   └── index.ts
│   │   │   ├── README.md
│   │   │   └── index.ts
│   │   └── repositories/
│   │       ├── analytics/
│   │       │   ├── ActivityLogRepository.ts
│   │       │   └── index.ts
│   │       ├── community/
│   │       │   ├── GroupMemberRepository.ts
│   │       │   ├── GroupRepository.ts
│   │       │   └── index.ts
│   │       ├── discovery/
│   │       │   ├── SearchIndexRepository.ts
│   │       │   └── index.ts
│   │       ├── media/
│   │       │   ├── MediaCollectionRepository.ts
│   │       │   ├── MediaRepository.ts
│   │       │   ├── MediaTagRepository.ts
│   │       │   └── index.ts
│   │       ├── messaging/
│   │       │   ├── ConversationRepository.ts
│   │       │   ├── MessageRepository.ts
│   │       │   └── index.ts
│   │       ├── moderation/
│   │       │   ├── ContentReportRepository.ts
│   │       │   ├── ModerationActionRepository.ts
│   │       │   └── index.ts
│   │       ├── social/
│   │       │   ├── BookmarkRepository.ts
│   │       │   ├── CollectionRepository.ts
│   │       │   ├── CommentLikeRepository.ts
│   │       │   ├── CommentRepository.ts
│   │       │   ├── FollowRepository.ts
│   │       │   ├── HashtagRepository.ts
│   │       │   ├── LikeRepository.ts
│   │       │   ├── MessageRepository.ts
│   │       │   ├── NotificationRepository.ts
│   │       │   ├── PostRepository.ts
│   │       │   ├── TagRepository.ts
│   │       │   ├── UserProfileRepository.ts
│   │       │   ├── UserSettingsRepository.ts
│   │       │   ├── UserStatsRepository.ts
│   │       │   └── index.ts
│   │       ├── ChatRoomRepository.ts
│   │       ├── NotificationRepository.ts
│   │       └── index.ts
│   ├── services/
│   │   ├── analytics/
│   │   │   ├── ActivityLogService.ts
│   │   │   ├── InsightsService.ts
│   │   │   └── index.ts
│   │   ├── media/
│   │   │   ├── collection/
│   │   │   │   └── MediaCollectionService.ts
│   │   │   ├── jobs/
│   │   │   │   └── MediaProcessingJobProcessor.ts
│   │   │   ├── tag/
│   │   │   │   └── MediaTagService.ts
│   │   │   ├── MediaProcessingService.ts
│   │   │   ├── MediaService.ts
│   │   │   └── index.ts
│   │   ├── messaging/
│   │   │   ├── ConversationService.ts
│   │   │   ├── IMessagingService.ts
│   │   │   ├── MessageService.ts
│   │   │   ├── MessagingService.ts
│   │   │   └── index.ts
│   │   ├── presence/
│   │   │   └── UserPresenceService.ts
│   │   ├── shared/
│   │   │   ├── communication/
│   │   │   │   ├── EventBusService.ts
│   │   │   │   ├── EventEmitter.ts
│   │   │   │   ├── RealTimeService.ts
│   │   │   │   ├── TemplateEngine.ts
│   │   │   │   └── index.ts
│   │   │   ├── monitoring/
│   │   │   │   ├── MetricsService.ts
│   │   │   │   └── index.ts
│   │   │   ├── security/
│   │   │   │   ├── PostRateLimiter.ts
│   │   │   │   ├── ProfanityFilter.ts
│   │   │   │   └── index.ts
│   │   │   ├── types/
│   │   │   │   └── index.ts
│   │   │   ├── validation/
│   │   │   │   ├── ContentValidator.ts
│   │   │   │   ├── UrlValidator.ts
│   │   │   │   ├── ValidationRule.ts
│   │   │   │   ├── commonValidators.ts
│   │   │   │   └── index.ts
│   │   │   ├── ServiceContainer.ts
│   │   │   └── index.ts
│   │   ├── social/
│   │   │   ├── community/
│   │   │   │   ├── GroupMemberService.ts
│   │   │   │   ├── GroupService.ts
│   │   │   │   └── index.ts
│   │   │   ├── discovery/
│   │   │   │   ├── FeedService.ts
│   │   │   │   ├── RecommendationService.ts
│   │   │   │   ├── SearchService.ts
│   │   │   │   └── index.ts
│   │   │   ├── hashtag/
│   │   │   │   ├── HashtagService.ts
│   │   │   │   └── index.ts
│   │   │   ├── interaction/
│   │   │   │   ├── BookmarkService.ts
│   │   │   │   ├── CommentService.ts
│   │   │   │   ├── FollowService.ts
│   │   │   │   ├── LikeService.ts
│   │   │   │   └── index.ts
│   │   │   ├── moderation/
│   │   │   │   ├── AutoModerationService.ts
│   │   │   │   ├── ContentModerationService.ts
│   │   │   │   ├── ModerationActionService.ts
│   │   │   │   ├── ReportingService.ts
│   │   │   │   └── index.ts
│   │   │   ├── notification/
│   │   │   │   ├── NotificationDeliveryService.ts
│   │   │   │   ├── NotificationService.ts
│   │   │   │   └── index.ts
│   │   │   ├── post/
│   │   │   │   ├── PostCacheManager.ts
│   │   │   │   ├── PostService.ts
│   │   │   │   └── index.ts
│   │   │   └── index.ts
│   │   ├── README.md
│   │   └── index.ts
│   └── index.ts
├── config/
│   ├── env/
│   │   ├── .env.development
│   │   ├── .env.example
│   │   └── .env.production
│   └── test/
│       ├── playwright.config.ts
│       ├── vitest.config.ts
│       └── vitest.integration.config.ts
├── docs/
│   ├── api/
│   │   ├── auth/
│   │   │   ├── DATABASE.md
│   │   │   ├── IMPLEMENTATION.md
│   │   │   └── README.md
│   │   ├── LIST.md
│   │   ├── database.yaml
│   │   ├── infrastructure.yaml
│   │   ├── overview.md
│   │   ├── services-1.yaml
│   │   └── services-2.yaml
│   ├── README.md
│   ├── architecture.md
│   ├── development.md
│   └── security.md
├── packages/
│   ├── api-client/
│   │   ├── src/
│   │   │   ├── index.ts
│   │   │   └── types.ts
│   │   ├── package.json
│   │   └── tsconfig.json
│   ├── shared/
│   │   ├── src/
│   │   │   ├── constants/
│   │   │   │   └── index.ts
│   │   │   ├── contracts/
│   │   │   │   ├── auth.ts
│   │   │   │   └── index.ts
│   │   │   ├── types/
│   │   │   │   └── index.ts
│   │   │   ├── utils/
│   │   │   │   └── index.ts
│   │   │   ├── env.ts
│   │   │   └── index.ts
│   │   ├── package.json
│   │   ├── tsconfig.json
│   │   └── tsconfig.tsbuildinfo
│   └── ui/
│       ├── src/
│       │   ├── components/
│       │   │   ├── Box/
│       │   │   │   ├── index.native.tsx
│       │   │   │   ├── index.web.tsx
│       │   │   │   └── types.ts
│       │   │   ├── demos/
│       │   │   │   ├── BadgeDemo.tsx
│       │   │   │   ├── ButtonDemo.tsx
│       │   │   │   ├── CalendarDemo.tsx
│       │   │   │   ├── ComboBoxDemo.tsx
│       │   │   │   ├── DropdownDemo.tsx
│       │   │   │   ├── FileUploadDemo.tsx
│       │   │   │   ├── FormDemo.tsx
│       │   │   │   ├── FuzzyStringDemo.tsx
│       │   │   │   ├── ListBoxDemo.tsx
│       │   │   │   ├── PopupDemo.tsx
│       │   │   │   ├── SpinnerDemo.tsx
│       │   │   │   ├── TokenInputDemo.tsx
│       │   │   │   └── autoindex.ts
│       │   │   ├── Badge.tsx
│       │   │   ├── Button.tsx
│       │   │   ├── Card.tsx
│       │   │   ├── ComboBox.tsx
│       │   │   ├── DropdownMenu.tsx
│       │   │   ├── FileUpload.tsx
│       │   │   ├── FuzzyString.tsx
│       │   │   ├── Input.tsx
│       │   │   ├── Link.tsx
│       │   │   ├── ListBox.tsx
│       │   │   ├── MenuItem.tsx
│       │   │   ├── OfflineBadge.tsx
│       │   │   ├── Popup.tsx
│       │   │   ├── Spinner.tsx
│       │   │   ├── Throttle.tsx
│       │   │   ├── button.css
│       │   │   └── index.ts
│       │   ├── contexts/
│       │   │   ├── AuthContext.tsx
│       │   │   ├── SocialContext.tsx
│       │   │   └── index.ts
│       │   ├── features/
│       │   │   ├── auth/
│       │   │   │   ├── AuthContext.tsx
│       │   │   │   ├── AuthModal.tsx
│       │   │   │   ├── ConfirmEmail.tsx
│       │   │   │   ├── LoginModal.tsx
│       │   │   │   ├── RegisterModal.tsx
│       │   │   │   ├── ResendVerification.tsx
│       │   │   │   ├── VerificationModal.tsx
│       │   │   │   └── index.tsx
│       │   │   ├── media/
│       │   │   │   ├── AudioPlayer.tsx
│       │   │   │   ├── ImageGallery.tsx
│       │   │   │   ├── MediaGallery.tsx
│       │   │   │   ├── VideoPlayer.tsx
│       │   │   │   ├── mediaPlayer.tsx
│       │   │   │   ├── mediaUpload.tsx
│       │   │   │   └── mediaView.tsx
│       │   │   ├── social/
│       │   │   │   ├── CommentSection.tsx
│       │   │   │   ├── Comments.tsx
│       │   │   │   ├── CreatePost.tsx
│       │   │   │   ├── CreatePostForm.tsx
│       │   │   │   ├── Feed.tsx
│       │   │   │   ├── PostCard.tsx
│       │   │   │   ├── SocialFeed.tsx
│       │   │   │   ├── UserProfile.tsx
│       │   │   │   └── UserProfileCard.tsx
│       │   │   ├── theme/
│       │   │   │   ├── ThemeContext.tsx
│       │   │   │   └── index.ts
│       │   │   └── index.ts
│       │   ├── hooks/
│       │   │   ├── index.ts
│       │   │   ├── useAsync.ts
│       │   │   ├── useCounter.ts
│       │   │   ├── useOnline.ts
│       │   │   ├── usePopper.ts
│       │   │   ├── useRefCurrent.ts
│       │   │   ├── useRefPrevious.ts
│       │   │   ├── useShortcut.ts
│       │   │   └── useSocialInteractions.ts
│       │   ├── layouts/
│       │   │   ├── MainLayout.tsx
│       │   │   ├── PageContent.tsx
│       │   │   ├── index.ts
│       │   │   ├── main-layout.css
│       │   │   └── page-content.css
│       │   └── index.ts
│       ├── README.md
│       ├── package.json
│       ├── tsconfig.json
│       └── tsconfig.tsbuildinfo
├── tools/
│   ├── dev/
│   │   ├── dev-environment.txt
│   │   └── export-dev-env.js
│   ├── README.md
│   ├── restart-db.ts
│   ├── setup.ts
│   ├── start-dev.ts
│   └── tsconfig.json
├── .gitignore
├── .npmrc
├── .prettierignore
├── .prettierrc
├── Dockerfile
├── README.md
├── docker-compose.yml
├── eslint.config.ts
├── package.json
├── pnpm-lock.yaml
├── pnpm-workspace.yaml
├── tsconfig.base.json
├── tsconfig.eslint.json
├── tsconfig.json
└── turbo.json
```

---

## 2. Complete File Listing (Categorized)

Total files: 426

### Root (15 files)

```
.gitignore
.npmrc
.prettierignore
.prettierrc
Dockerfile
README.md
docker-compose.yml
eslint.config.ts
package.json
pnpm-lock.yaml
pnpm-workspace.yaml
tsconfig.base.json
tsconfig.eslint.json
tsconfig.json
turbo.json
```

### Apps (157 files)

```
apps/desktop/.env.example
apps/desktop/README.md
apps/desktop/electron/main.ts
apps/desktop/electron/preload.ts
apps/desktop/electron/tsconfig.json
apps/desktop/index.html
apps/desktop/package.json
apps/desktop/src/App.tsx
apps/desktop/src/main.tsx
apps/desktop/src/native/README.md
apps/desktop/tsconfig.json
apps/desktop/vite.config.ts
apps/mobile/.env.example
apps/mobile/README.md
apps/mobile/app.json
apps/mobile/babel.config.js
apps/mobile/index.js
apps/mobile/metro.config.js
apps/mobile/package.json
apps/mobile/src/App.tsx
apps/mobile/tsconfig.json
apps/mobile/tsconfig.tsbuildinfo
apps/server/drizzle.config.ts
apps/server/package.json
apps/server/src/README.md
apps/server/src/fastify/server.ts
apps/server/src/index.md
apps/server/src/index.ts
apps/server/src/scripts/dbHealthCheck.ts
apps/server/src/scripts/seed.ts
apps/server/tsconfig.json
apps/server/tsconfig.tsbuildinfo
apps/web/.env.example
apps/web/__tests__/base.e2e.ts
apps/web/__tests__/base.test.ts
apps/web/index.html
apps/web/package.json
apps/web/public/favicon.ico
apps/web/public/icons/apple-touch-icon.png
apps/web/public/icons/favicon.ico
apps/web/public/icons/favicon.svg
apps/web/public/icons/logo192.png
apps/web/public/icons/logo512.png
apps/web/public/manifest.json
apps/web/public/robots.txt
apps/web/public/service-worker.js
apps/web/src/App.tsx
apps/web/src/api/auth.api.ts
apps/web/src/api/index.ts
apps/web/src/components/Design.tsx
apps/web/src/components/Link.tsx
apps/web/src/components/ProtectedRoute.tsx
apps/web/src/components/Root.tsx
apps/web/src/components/auth/AuthContext.tsx
apps/web/src/components/auth/AuthModal.tsx
apps/web/src/components/auth/ConfirmEmail.tsx
apps/web/src/components/auth/LoginModal.tsx
apps/web/src/components/auth/RegisterModal.tsx
apps/web/src/components/auth/ResendVerification.tsx
apps/web/src/components/auth/VerificationModal.tsx
apps/web/src/components/auth/index.tsx
apps/web/src/components/debug/DbTest.tsx
apps/web/src/components/debug/index.ts
apps/web/src/components/media/AudioPlayer.tsx
apps/web/src/components/media/ImageGallery.tsx
apps/web/src/components/media/MediaGallery.tsx
apps/web/src/components/media/VideoPlayer.tsx
apps/web/src/components/media/mediaPlayer.tsx
apps/web/src/components/media/mediaUpload.tsx
apps/web/src/components/media/mediaView.tsx
apps/web/src/components/pages/DashboardPage.tsx
apps/web/src/components/pages/DesignPage.tsx
apps/web/src/components/pages/ExplorePage.tsx
apps/web/src/components/pages/HomePage.tsx
apps/web/src/components/pages/MediaPage.tsx
apps/web/src/components/pages/NotificationsPage.tsx
apps/web/src/components/pages/ProfilePage.tsx
apps/web/src/components/pages/SettingsPage.tsx
apps/web/src/components/pages/SocialPage.tsx
apps/web/src/components/pages/UploadPage.tsx
apps/web/src/components/social/CommentSection.tsx
apps/web/src/components/social/Comments.tsx
apps/web/src/components/social/CreatePost.tsx
apps/web/src/components/social/CreatePostForm.tsx
apps/web/src/components/social/Feed.tsx
apps/web/src/components/social/PostCard.tsx
apps/web/src/components/social/SocialFeed.tsx
apps/web/src/components/social/UserProfile.tsx
apps/web/src/components/social/UserProfileCard.tsx
apps/web/src/components/theme/ThemeContext.tsx
apps/web/src/components/theme/index.ts
apps/web/src/components/ui/Badge.tsx
apps/web/src/components/ui/Button.tsx
apps/web/src/components/ui/Card.tsx
apps/web/src/components/ui/ComboBox.tsx
apps/web/src/components/ui/DropdownMenu.tsx
apps/web/src/components/ui/FileUpload.tsx
apps/web/src/components/ui/FuzzyString.tsx
apps/web/src/components/ui/Input.tsx
apps/web/src/components/ui/Link.tsx
apps/web/src/components/ui/ListBox.tsx
apps/web/src/components/ui/MenuItem.tsx
apps/web/src/components/ui/OfflineBadge.tsx
apps/web/src/components/ui/Popup.tsx
apps/web/src/components/ui/Spinner.tsx
apps/web/src/components/ui/Throttle.tsx
apps/web/src/components/ui/button.css
apps/web/src/components/ui/demos/BadgeDemo.tsx
apps/web/src/components/ui/demos/ButtonDemo.tsx
apps/web/src/components/ui/demos/CalendarDemo.tsx
apps/web/src/components/ui/demos/ComboBoxDemo.tsx
apps/web/src/components/ui/demos/DropdownDemo.tsx
apps/web/src/components/ui/demos/FileUploadDemo.tsx
apps/web/src/components/ui/demos/FormDemo.tsx
apps/web/src/components/ui/demos/FuzzyStringDemo.tsx
apps/web/src/components/ui/demos/ListBoxDemo.tsx
apps/web/src/components/ui/demos/PopupDemo.tsx
apps/web/src/components/ui/demos/SpinnerDemo.tsx
apps/web/src/components/ui/demos/TokenInputDemo.tsx
apps/web/src/components/ui/demos/autoindex.ts
apps/web/src/config/environment.ts
apps/web/src/contexts/AuthContext.tsx
apps/web/src/contexts/SocialContext.tsx
apps/web/src/helpers/cookieHelpers.ts
apps/web/src/helpers/focusHelpers.ts
apps/web/src/helpers/formatters.ts
apps/web/src/helpers/mergeEvents.ts
apps/web/src/helpers/passthroughRef.tsx
apps/web/src/hooks/useAsync.ts
apps/web/src/hooks/useCounter.ts
apps/web/src/hooks/useOnline.ts
apps/web/src/hooks/usePopper.ts
apps/web/src/hooks/useRefCurrent.ts
apps/web/src/hooks/useRefPrevious.ts
apps/web/src/hooks/useShortcut.ts
apps/web/src/hooks/useSocialInteractions.ts
apps/web/src/index.css
apps/web/src/index.tsx
apps/web/src/layouts/MainLayout.tsx
apps/web/src/layouts/PageContent.tsx
apps/web/src/layouts/main-layout.css
apps/web/src/layouts/page-content.css
apps/web/src/routes.tsx
apps/web/src/service-worker.js
apps/web/src/service-worker.ts
apps/web/src/services/AuthClient.ts
apps/web/src/services/ClientConfig.ts
apps/web/src/services/ClientEnvironment.tsx
apps/web/src/services/Router.ts
apps/web/src/services/WebsocketPubsubClient.ts
apps/web/src/services/api.ts
apps/web/src/services/social.ts
apps/web/src/services/types.ts
apps/web/src/styles.ts
apps/web/src/utils/styleUtils.ts
apps/web/src/web-only/README.md
apps/web/tsconfig.json
```

### Packages (96 files)

```
packages/api-client/package.json
packages/api-client/src/index.ts
packages/api-client/src/types.ts
packages/api-client/tsconfig.json
packages/shared/package.json
packages/shared/src/constants/index.ts
packages/shared/src/contracts/auth.ts
packages/shared/src/contracts/index.ts
packages/shared/src/env.ts
packages/shared/src/index.ts
packages/shared/src/types/index.ts
packages/shared/src/utils/index.ts
packages/shared/tsconfig.json
packages/shared/tsconfig.tsbuildinfo
packages/ui/README.md
packages/ui/package.json
packages/ui/src/components/Badge.tsx
packages/ui/src/components/Box/index.native.tsx
packages/ui/src/components/Box/index.web.tsx
packages/ui/src/components/Box/types.ts
packages/ui/src/components/Button.tsx
packages/ui/src/components/Card.tsx
packages/ui/src/components/ComboBox.tsx
packages/ui/src/components/DropdownMenu.tsx
packages/ui/src/components/FileUpload.tsx
packages/ui/src/components/FuzzyString.tsx
packages/ui/src/components/Input.tsx
packages/ui/src/components/Link.tsx
packages/ui/src/components/ListBox.tsx
packages/ui/src/components/MenuItem.tsx
packages/ui/src/components/OfflineBadge.tsx
packages/ui/src/components/Popup.tsx
packages/ui/src/components/Spinner.tsx
packages/ui/src/components/Throttle.tsx
packages/ui/src/components/button.css
packages/ui/src/components/demos/BadgeDemo.tsx
packages/ui/src/components/demos/ButtonDemo.tsx
packages/ui/src/components/demos/CalendarDemo.tsx
packages/ui/src/components/demos/ComboBoxDemo.tsx
packages/ui/src/components/demos/DropdownDemo.tsx
packages/ui/src/components/demos/FileUploadDemo.tsx
packages/ui/src/components/demos/FormDemo.tsx
packages/ui/src/components/demos/FuzzyStringDemo.tsx
packages/ui/src/components/demos/ListBoxDemo.tsx
packages/ui/src/components/demos/PopupDemo.tsx
packages/ui/src/components/demos/SpinnerDemo.tsx
packages/ui/src/components/demos/TokenInputDemo.tsx
packages/ui/src/components/demos/autoindex.ts
packages/ui/src/components/index.ts
packages/ui/src/contexts/AuthContext.tsx
packages/ui/src/contexts/SocialContext.tsx
packages/ui/src/contexts/index.ts
packages/ui/src/features/auth/AuthContext.tsx
packages/ui/src/features/auth/AuthModal.tsx
packages/ui/src/features/auth/ConfirmEmail.tsx
packages/ui/src/features/auth/LoginModal.tsx
packages/ui/src/features/auth/RegisterModal.tsx
packages/ui/src/features/auth/ResendVerification.tsx
packages/ui/src/features/auth/VerificationModal.tsx
packages/ui/src/features/auth/index.tsx
packages/ui/src/features/index.ts
packages/ui/src/features/media/AudioPlayer.tsx
packages/ui/src/features/media/ImageGallery.tsx
packages/ui/src/features/media/MediaGallery.tsx
packages/ui/src/features/media/VideoPlayer.tsx
packages/ui/src/features/media/mediaPlayer.tsx
packages/ui/src/features/media/mediaUpload.tsx
packages/ui/src/features/media/mediaView.tsx
packages/ui/src/features/social/CommentSection.tsx
packages/ui/src/features/social/Comments.tsx
packages/ui/src/features/social/CreatePost.tsx
packages/ui/src/features/social/CreatePostForm.tsx
packages/ui/src/features/social/Feed.tsx
packages/ui/src/features/social/PostCard.tsx
packages/ui/src/features/social/SocialFeed.tsx
packages/ui/src/features/social/UserProfile.tsx
packages/ui/src/features/social/UserProfileCard.tsx
packages/ui/src/features/theme/ThemeContext.tsx
packages/ui/src/features/theme/index.ts
packages/ui/src/hooks/index.ts
packages/ui/src/hooks/useAsync.ts
packages/ui/src/hooks/useCounter.ts
packages/ui/src/hooks/useOnline.ts
packages/ui/src/hooks/usePopper.ts
packages/ui/src/hooks/useRefCurrent.ts
packages/ui/src/hooks/useRefPrevious.ts
packages/ui/src/hooks/useShortcut.ts
packages/ui/src/hooks/useSocialInteractions.ts
packages/ui/src/index.ts
packages/ui/src/layouts/MainLayout.tsx
packages/ui/src/layouts/PageContent.tsx
packages/ui/src/layouts/index.ts
packages/ui/src/layouts/main-layout.css
packages/ui/src/layouts/page-content.css
packages/ui/tsconfig.json
packages/ui/tsconfig.tsbuildinfo
```

### Config (6 files)

```
config/env/.env.development
config/env/.env.example
config/env/.env.production
config/test/playwright.config.ts
config/test/vitest.config.ts
config/test/vitest.integration.config.ts
```

### Tools (7 files)

```
tools/README.md
tools/dev/dev-environment.txt
tools/dev/export-dev-env.js
tools/restart-db.ts
tools/setup.ts
tools/start-dev.ts
tools/tsconfig.json
```

### Docs (13 files)

```
docs/README.md
docs/api/LIST.md
docs/api/auth/DATABASE.md
docs/api/auth/IMPLEMENTATION.md
docs/api/auth/README.md
docs/api/database.yaml
docs/api/infrastructure.yaml
docs/api/overview.md
docs/api/services-1.yaml
docs/api/services-2.yaml
docs/architecture.md
docs/development.md
docs/security.md
```

### Other (132 files)

```
.claude/settings.local.json
.github/workflows/audit.yml
.github/workflows/ci.yml
.vscode/extensions.json
.vscode/launch.json
.vscode/settings.json
.vscode/tasks.json
archive/database/models/README.md
archive/database/models/analytics/ActivityLog.ts
archive/database/models/analytics/index.ts
archive/database/models/community/Group.ts
archive/database/models/community/GroupMember.ts
archive/database/models/community/index.ts
archive/database/models/discovery/SearchIndex.ts
archive/database/models/discovery/index.ts
archive/database/models/index.ts
archive/database/models/media/Media.ts
archive/database/models/media/MediaCollection.ts
archive/database/models/media/MediaTag.ts
archive/database/models/media/index.ts
archive/database/models/messaging/Conversation.ts
archive/database/models/messaging/Message.ts
archive/database/models/messaging/index.ts
archive/database/models/moderation/ContentReport.ts
archive/database/models/moderation/ModerationAction.ts
archive/database/models/moderation/index.ts
archive/database/models/social/Bookmark.ts
archive/database/models/social/Comment.ts
archive/database/models/social/CommentLike.ts
archive/database/models/social/Follow.ts
archive/database/models/social/Hashtag.ts
archive/database/models/social/Like.ts
archive/database/models/social/Notification.ts
archive/database/models/social/Post.ts
archive/database/models/social/index.ts
archive/database/repositories/ChatRoomRepository.ts
archive/database/repositories/NotificationRepository.ts
archive/database/repositories/analytics/ActivityLogRepository.ts
archive/database/repositories/analytics/index.ts
archive/database/repositories/community/GroupMemberRepository.ts
archive/database/repositories/community/GroupRepository.ts
archive/database/repositories/community/index.ts
archive/database/repositories/discovery/SearchIndexRepository.ts
archive/database/repositories/discovery/index.ts
archive/database/repositories/index.ts
archive/database/repositories/media/MediaCollectionRepository.ts
archive/database/repositories/media/MediaRepository.ts
archive/database/repositories/media/MediaTagRepository.ts
archive/database/repositories/media/index.ts
archive/database/repositories/messaging/ConversationRepository.ts
archive/database/repositories/messaging/MessageRepository.ts
archive/database/repositories/messaging/index.ts
archive/database/repositories/moderation/ContentReportRepository.ts
archive/database/repositories/moderation/ModerationActionRepository.ts
archive/database/repositories/moderation/index.ts
archive/database/repositories/social/BookmarkRepository.ts
archive/database/repositories/social/CollectionRepository.ts
archive/database/repositories/social/CommentLikeRepository.ts
archive/database/repositories/social/CommentRepository.ts
archive/database/repositories/social/FollowRepository.ts
archive/database/repositories/social/HashtagRepository.ts
archive/database/repositories/social/LikeRepository.ts
archive/database/repositories/social/MessageRepository.ts
archive/database/repositories/social/NotificationRepository.ts
archive/database/repositories/social/PostRepository.ts
archive/database/repositories/social/TagRepository.ts
archive/database/repositories/social/UserProfileRepository.ts
archive/database/repositories/social/UserSettingsRepository.ts
archive/database/repositories/social/UserStatsRepository.ts
archive/database/repositories/social/index.ts
archive/index.ts
archive/services/README.md
archive/services/analytics/ActivityLogService.ts
archive/services/analytics/InsightsService.ts
archive/services/analytics/index.ts
archive/services/index.ts
archive/services/media/MediaProcessingService.ts
archive/services/media/MediaService.ts
archive/services/media/collection/MediaCollectionService.ts
archive/services/media/index.ts
archive/services/media/jobs/MediaProcessingJobProcessor.ts
archive/services/media/tag/MediaTagService.ts
archive/services/messaging/ConversationService.ts
archive/services/messaging/IMessagingService.ts
archive/services/messaging/MessageService.ts
archive/services/messaging/MessagingService.ts
archive/services/messaging/index.ts
archive/services/presence/UserPresenceService.ts
archive/services/shared/ServiceContainer.ts
archive/services/shared/communication/EventBusService.ts
archive/services/shared/communication/EventEmitter.ts
archive/services/shared/communication/RealTimeService.ts
archive/services/shared/communication/TemplateEngine.ts
archive/services/shared/communication/index.ts
archive/services/shared/index.ts
archive/services/shared/monitoring/MetricsService.ts
archive/services/shared/monitoring/index.ts
archive/services/shared/security/PostRateLimiter.ts
archive/services/shared/security/ProfanityFilter.ts
archive/services/shared/security/index.ts
archive/services/shared/types/index.ts
archive/services/shared/validation/ContentValidator.ts
archive/services/shared/validation/UrlValidator.ts
archive/services/shared/validation/ValidationRule.ts
archive/services/shared/validation/commonValidators.ts
archive/services/shared/validation/index.ts
archive/services/social/community/GroupMemberService.ts
archive/services/social/community/GroupService.ts
archive/services/social/community/index.ts
archive/services/social/discovery/FeedService.ts
archive/services/social/discovery/RecommendationService.ts
archive/services/social/discovery/SearchService.ts
archive/services/social/discovery/index.ts
archive/services/social/hashtag/HashtagService.ts
archive/services/social/hashtag/index.ts
archive/services/social/index.ts
archive/services/social/interaction/BookmarkService.ts
archive/services/social/interaction/CommentService.ts
archive/services/social/interaction/FollowService.ts
archive/services/social/interaction/LikeService.ts
archive/services/social/interaction/index.ts
archive/services/social/moderation/AutoModerationService.ts
archive/services/social/moderation/ContentModerationService.ts
archive/services/social/moderation/ModerationActionService.ts
archive/services/social/moderation/ReportingService.ts
archive/services/social/moderation/index.ts
archive/services/social/notification/NotificationDeliveryService.ts
archive/services/social/notification/NotificationService.ts
archive/services/social/notification/index.ts
archive/services/social/post/PostCacheManager.ts
archive/services/social/post/PostService.ts
archive/services/social/post/index.ts
```

---

## 3. Configuration Files

Extracted 237 configuration files

---

### Root Configuration

#### .prettierignore

```txt
# dependencies and builds
node_modules
.turbo
.cache
dist
build
coverage
.next
out

# generated artifacts
*.tsbuildinfo

# lockfiles and pnpm store
pnpm-lock.yaml
.pnpm-store
```

#### .prettierrc

```txt
{
  "singleQuote": true,
  "trailingComma": "all",
  "printWidth": 100,
  "semi": true
}
```

#### eslint.config.ts

```ts
import js from "@eslint/js";
import tseslint from "typescript-eslint";
import path from "node:path";
import { fileURLToPath } from "node:url";
import type { Linter } from "eslint";
import eslintPluginImport from "eslint-plugin-import";

const tsconfigRootDir: string = path.dirname(fileURLToPath(import.meta.url));

export default [
  {
    ignores: [
      "**/node_modules/**",
      "**/.next/**",
      "**/out/**",
      "**/dist/**",
      "**/build/**",
      "**/.turbo/**",
      "**/coverage/**",
    ],
  },
  js.configs.recommended,
  ...tseslint.configs.recommended,
  // Ensure TypeScript-ESLint has an explicit root in monorepos.
  {
    files: ["**/*.{ts,tsx,cts,mts}"],
    languageOptions: {
      parserOptions: {
        tsconfigRootDir,
        project: ["./tsconfig.eslint.json"],
      },
    },
  },
  {
    files: ["apps/server/**/*.{ts,tsx,cts,mts}"],
    languageOptions: {
      parserOptions: {
        project: ["./apps/server/tsconfig.json"],
        tsconfigRootDir,
      },
    },
  },
  {
    rules: {
      // TypeScript specific rules
      "@typescript-eslint/no-unused-vars": [
        "warn",
        { argsIgnorePattern: "^_", varsIgnorePattern: "^_" },
      ],
      "@typescript-eslint/no-explicit-any": "warn",
      "@typescript-eslint/explicit-function-return-type": "off",
      "@typescript-eslint/explicit-module-boundary-types": "off",
      "@typescript-eslint/no-non-null-assertion": "warn",

      // General rules
      "no-console": ["warn", { allow: ["warn", "error"] }],
      "prefer-const": "error",
      "no-var": "error",
    },
  },
  {
    plugins: {
      import: eslintPluginImport,
    },
    rules: {
      "import/order": [
        "warn",
        {
          groups: [
            "builtin",
            "external",
            "internal",
            "parent",
            "sibling",
            "index",
            "object",
            "type",
          ],
          "newlines-between": "always",
          alphabetize: { order: "asc", caseInsensitive: true },
        },
      ],
    },
  },
  // Prevent frontend clients from importing server-side code
  {
    files: ["apps/web/**/*", "apps/desktop/**/*", "apps/mobile/**/*"],
    rules: {
      "no-restricted-imports": [
        "error",
        {
          patterns: [
            {
              group: [
                "**/apps/server/**",
                "@/server/**",
                "@abe-stack/server",
                "@server/*",
              ],
              message:
                "Frontend code must not import backend/server modules. Add an API layer or shared contract instead.",
            },
          ],
        },
      ],
    },
  },
  // Prevent UI from reaching into DB/infra directly; rely on contracts/API.
  {
    files: ["apps/web/**/*", "apps/desktop/**/*", "apps/mobile/**/*"],
    rules: {
      "no-restricted-imports": [
        "error",
        {
          patterns: [
            {
              group: [
                "**/infrastructure/**",
                "**/database/**",
                "drizzle-orm",
                "postgres",
                "pg",
                "@/server/**",
              ],
              message:
                "UI must not import database or backend internals. Use API clients or shared contracts instead.",
            },
          ],
        },
      ],
    },
  },
] satisfies Linter.Config[];
```

#### package.json

```json
{
  "name": "@abe-stack/root",
  "version": "1.0.0",
  "description": "A modern full-stack monorepo with PERN stack - Web, Desktop, Mobile, and Server",
  "private": true,
  "engines": {
    "node": ">=18.19 <25"
  },
  "scripts": {
    "_development": "=== Development Commands ===",
    "dev": "turbo run dev",
    "dev:web": "turbo run dev --filter=@abe-stack/web",
    "dev:server": "turbo run dev --filter=@abe-stack/server",
    "dev:desktop": "turbo run dev --filter=@abe-stack/desktop",
    "dev:mobile": "turbo run dev --filter=@abe-stack/mobile",
    "_build": "=== Build Commands ===",
    "build": "turbo run build",
    "build:web": "turbo run build --filter=@abe-stack/web",
    "build:server": "turbo run build --filter=@abe-stack/server",
    "build:desktop": "turbo run build --filter=@abe-stack/desktop",
    "build:shared": "turbo run build --filter=@abe-stack/shared",
    "build:ui": "turbo run build --filter=@abe-stack/ui",
    "_test": "=== Testing Commands ===",
    "test": "turbo run test",
    "test:web": "turbo run test --filter=@abe-stack/web",
    "test:server": "turbo run test --filter=@abe-stack/server",
    "test:desktop": "turbo run test --filter=@abe-stack/desktop",
    "_quality": "=== Code Quality Commands ===",
    "lint": "turbo run lint",
    "lint:fix": "turbo run lint:fix",
    "type-check": "turbo run type-check",
    "format": "prettier --write .",
    "format:check": "prettier --check .",
    "_utilities": "=== Utility Commands ===",
    "clean": "turbo run clean && rm -rf node_modules .turbo",
    "clean:build": "rm -rf apps/*/dist packages/*/dist",
    "ports:check": "node -e \"const net = require('net'); const ports = [8080, 5173, 5432]; ports.forEach(port => { const server = net.createServer(); server.listen(port, () => { console.log(`Port ${port} is free`); server.close(); }).on('error', () => console.log(`Port ${port} is in use`)); });\"",
    "dev:start": "tsx tools/start-dev.ts",
    "dev:start:quiet": "tsx tools/start-dev.ts --quiet",
    "dev:start:verbose": "tsx tools/start-dev.ts --verbose",
    "dev:start:force": "tsx tools/start-dev.ts --force",
    "dev:export-configs": "node tools/dev/export-dev-env.js",
    "db:restart": "tsx tools/restart-db.ts",
    "setup": "tsx tools/setup.ts",
    "prepare": "simple-git-hooks",
    "test:coverage": "turbo run test -- --coverage"
  },
  "devDependencies": {
    "@playwright/test": "^1.57.0",
    "@types/node": "^25.0.3",
    "cross-env": "^10.1.0",
    "eslint": "^9.39.2",
    "eslint-plugin-import": "^2.32.0",
    "prettier": "^3.7.4",
    "simple-git-hooks": "^2.11.1",
    "lint-staged": "^15.2.10",
    "tsx": "^4.21.0",
    "turbo": "^2.7.2",
    "typescript": "^5.9.3",
    "typescript-eslint": "^8.50.1"
  },
  "pnpm": {
    "overrides": {
      "esbuild": "^0.25.12",
      "metro-react-native-babel-preset": "npm:@react-native/babel-preset@^0.76.0",
      "@types/react-native": "^0.76.0"
    }
  },
  "simple-git-hooks": {
    "pre-commit": "pnpm lint-staged",
    "pre-push": "pnpm lint && pnpm type-check"
  },
  "lint-staged": {
    "*.{ts,tsx,js,jsx,json,css,scss,md}": [
      "pnpm prettier --check"
    ],
    "apps/**/{ts,tsx}": [
      "pnpm lint --filter @abe-stack/web",
      "pnpm lint --filter @abe-stack/desktop",
      "pnpm lint --filter @abe-stack/mobile"
    ],
    "apps/server/**/*.{ts,tsx}": [
      "pnpm lint --filter @abe-stack/server"
    ]
  },
  "packageManager": "pnpm@9.0.0"
}
```

#### pnpm-workspace.yaml

```yaml
packages:
  # Applications
  - 'apps/*'
  # Shared packages
  - 'packages/*'
```

#### tsconfig.base.json

```json
{
  "compilerOptions": {
    /* 1. Monorepo & Build Performance */
    "composite": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "incremental": true,

    /* 2. Language Fundamentals (Platform Agnostic) */
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,

    /* 3. Modern Strictness (The "2025 Standard") */
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitOverride": true,
    "noFallthroughCasesInSwitch": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,

    /* 4. Module Safety */
    "isolatedModules": true,
    "verbatimModuleSyntax": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true,

    /* 5. Clean Console */
    "ignoreDeprecations": "5.0"
  },
  "exclude": ["node_modules", "dist", "build", "coverage"]
}
```

#### tsconfig.eslint.json

```json
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "noEmit": true
  },
  "include": ["apps/**/*", "packages/**/*", "tools/**/*", "*.ts", "*.tsx"],
  "exclude": [
    "node_modules",
    "dist",
    "build",
    ".turbo",
    ".next",
    "coverage"
  ]
}
```

#### tsconfig.json

```json
{
  "files": [],
  "references": [
    { "path": "./apps/web" },
    { "path": "./apps/mobile" },
    { "path": "./apps/desktop" },
    { "path": "./apps/server" },
    { "path": "./packages/shared" },
    { "path": "./packages/ui" }
  ]
}
```

#### turbo.json

```json
{
  "$schema": "https://turbo.build/schema.json",
  "ui": "stream",
  "cacheDir": ".cache/turbo",
  "tasks": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["dist/**", "build/**", ".next/**"],
      "cache": true,
      "env": ["NODE_ENV", "DATABASE_URL"]
    },
    "dev": {
      "cache": false,
      "persistent": true,
      "dependsOn": ["^build"]
    },
    "lint": {
      "outputs": [],
      "cache": true
    },
    "lint:fix": {
      "cache": false
    },
    "type-check": {
      "dependsOn": ["^build"],
      "outputs": [],
      "cache": true,
      "env": ["NODE_ENV"]
    },
    "test": {
      "outputs": ["coverage/**"],
      "cache": true,
      "env": ["NODE_ENV", "DATABASE_URL"]
    },
    "test:watch": {
      "cache": false,
      "persistent": true
    },
    "clean": {
      "cache": false
    }
  },
  "globalDependencies": [
    "tsconfig.json",
    ".env",
    ".env.local"
  ]
}
```

---

### Apps Configuration

#### apps/desktop/.env.example

```example
VITE_API_URL=http://localhost:8080/api
VITE_APP_NAME=abe-stack-desktop
```

#### apps/desktop/electron/tsconfig.json

```json
{
  "extends": "../../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "../dist/electron",
    "rootDir": ".",
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "moduleResolution": "node",
    "skipLibCheck": true
  },
  "include": ["*.ts"],
  "exclude": ["node_modules"]
}
```

#### apps/desktop/package.json

```json
{
  "name": "@abe-stack/desktop",
  "version": "1.0.0",
  "description": "Electron desktop application for abe-stack",
  "main": "dist/electron/main.js",
  "scripts": {
    "dev": "concurrently \"npm run dev:renderer\" \"npm run dev:electron\"",
    "dev:renderer": "vite --config vite.config.ts",
    "dev:electron": "tsc -p electron/tsconfig.json && electron dist/electron/main.js",
    "build": "npm run build:renderer && npm run build:electron",
    "build:renderer": "vite build --config vite.config.ts",
    "build:electron": "tsc -p electron/tsconfig.json",
    "start": "electron dist/electron/main.js",
    "package": "electron-builder",
    "type-check": "tsc --noEmit"
  },
  "dependencies": {
    "@abe-stack/shared": "workspace:*",
    "@abe-stack/ui": "workspace:*",
    "@tanstack/react-query": "^5.59.9",
    "react": "^19.2.3",
    "react-dom": "^19.2.3"
  },
  "devDependencies": {
    "@types/react": "^19.2.7",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.2",
    "concurrently": "^9.2.1",
    "electron": "^39.2.7",
    "electron-builder": "^26.0.12",
    "eslint-plugin-react": "^7.37.5",
    "eslint-plugin-react-hooks": "^7.0.1",
    "typescript": "^5.9.3",
    "vite": "^7.3.0",
    "vite-plugin-electron": "^0.29.0"
  },
  "build": {
    "appId": "com.abe-stack.desktop",
    "productName": "Abe Stack",
    "directories": {
      "output": "release"
    },
    "files": [
      "dist/**/*",
      "public/**/*"
    ],
    "mac": {
      "category": "public.app-category.productivity"
    },
    "win": {
      "target": "nsis"
    },
    "linux": {
      "target": "AppImage"
    }
  }
}
```

#### apps/desktop/src/App.tsx

```tsx
import React from 'react';
// Import shared UI components from the shared package
// import { Button, Card, Spinner } from '@abe-stack/ui';

/**
 * Desktop Application Entry Point (Electron/Tauri)
 *
 * This is the desktop-specific entry that uses the SAME shared UI components
 * from @abe-stack/ui package as the web app.
 *
 * Platform-specific features (desktop-only) can be added here:
 * - File system access
 * - System notifications
 * - System tray
 * - Native menus
 * - Auto-updates
 */
function App() {
  // Example: Desktop-specific feature detection
  const isElectron = typeof window !== 'undefined' && window.electronAPI;

  return (
    <div style={{ padding: '20px' }}>
      <h1>Abe Stack Desktop App</h1>
      <p>Welcome to the desktop application!</p>

      {isElectron && (
        <div style={{ padding: '10px', background: '#e3f2fd', borderRadius: '4px', marginTop: '10px' }}>
          <strong>Running in Electron</strong>
          <p>Access to native desktop features available!</p>
        </div>
      )}

      {/* Example: Using shared components (same as web) */}
      {/* <Button>Click Me</Button> */}
      {/* <Card>Shared Card Component</Card> */}

      <div style={{ marginTop: '20px', padding: '15px', background: '#f0f0f0', borderRadius: '8px' }}>
        <h3>Architecture</h3>
        <ul>
          <li>✅ Shared UI from <code>@abe-stack/ui</code></li>
          <li>✅ Shared logic from <code>@abe-stack/shared</code></li>
          <li>✅ Desktop-specific features in <code>apps/desktop/src/native/</code></li>
          <li>✅ 80-90% code sharing with web app</li>
        </ul>
      </div>
    </div>
  );
}

export default App;
```

#### apps/desktop/src/main.tsx

```tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

#### apps/desktop/tsconfig.json

```json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "composite": true,
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"],
      "@abe-stack/shared": ["../../packages/shared/src"],
      "@abe-stack/ui": ["../../packages/ui/src"],
      "@components/*": ["./src/components/*"],
      "@hooks/*": ["./src/hooks/*"],
      "@services/*": ["./src/services/*"],
      "@config/*": ["./src/config/*"],
      "@layouts/*": ["./src/layouts/*"],
      "@routes/*": ["./src/routes/*"],
      "@utils/*": ["./src/utils/*"],
      "@api/*": ["./src/api/*"]
    },
    "tsBuildInfoFile": "./node_modules/.cache/tsconfig.desktop.tsbuildinfo"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "electron", "dist", "__tests__"],
  "references": [
    { "path": "../../packages/shared" },
    { "path": "../../packages/ui" }
  ]
}
```

#### apps/desktop/vite.config.ts

```ts
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  base: './',
  build: {
    outDir: 'dist/renderer',
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@abe-stack/shared': path.resolve(__dirname, '../../packages/shared/src'),
      '@abe-stack/ui': path.resolve(__dirname, '../../packages/ui/src'),
      '@components': path.resolve(__dirname, './src/components'),
      '@hooks': path.resolve(__dirname, './src/hooks'),
      '@services': path.resolve(__dirname, './src/services'),
      '@config': path.resolve(__dirname, './src/config'),
      '@layouts': path.resolve(__dirname, './src/layouts'),
      '@routes': path.resolve(__dirname, './src/routes'),
      '@utils': path.resolve(__dirname, './src/utils'),
      '@api': path.resolve(__dirname, './src/api'),
    },
  },
});
```

#### apps/mobile/.env.example

```example
API_URL=http://localhost:8080/api
APP_NAME=abe-stack-mobile
```

#### apps/mobile/app.json

```json
{
  "name": "AbeStackMobile",
  "displayName": "Abe Stack",
  "expo": {
    "name": "Abe Stack",
    "slug": "abe-stack-mobile",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "light",
    "splash": {
      "image": "./assets/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#ffffff"
    },
    "assetBundlePatterns": [
      "**/*"
    ],
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.abestack.mobile"
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "package": "com.abestack.mobile"
    }
  }
}
```

#### apps/mobile/babel.config.js

```js
module.exports = {
  presets: ['module:@react-native/babel-preset'],
  plugins: [
    [
      'module-resolver',
      {
        root: ['./src'],
        extensions: ['.ios.js', '.android.js', '.js', '.ts', '.tsx', '.json'],
        alias: {
          '@': './src',
          '@abe-stack/shared': '../../packages/shared/src',
        },
      },
    ],
  ],
};
```

#### apps/mobile/metro.config.js

```js
const { getDefaultConfig, mergeConfig } = require('@react-native/metro-config');
const path = require('path');

const repoRoot = path.resolve(__dirname, "..", "..");

const config = {
  watchFolders: [
    repoRoot,
    path.join(repoRoot, "packages"),
    path.join(repoRoot, "node_modules"),
  ],
  resolver: {
    nodeModulesPaths: [
      path.resolve(__dirname, "node_modules"),
      path.resolve(repoRoot, "node_modules"),
    ],
    extraNodeModules: {
      "@components": path.resolve(__dirname, "src/components"),
      "@hooks": path.resolve(__dirname, "src/hooks"),
      "@services": path.resolve(__dirname, "src/services"),
      "@config": path.resolve(__dirname, "src/config"),
      "@utils": path.resolve(__dirname, "src/utils"),
      "@api": path.resolve(__dirname, "src/api"),
      "@abe-stack/shared": path.resolve(repoRoot, "packages/shared/src"),
      "@abe-stack/ui": path.resolve(repoRoot, "packages/ui/src"),
    },
  },
};

module.exports = mergeConfig(getDefaultConfig(__dirname), config);
```

#### apps/mobile/package.json

```json
{
  "name": "@abe-stack/mobile",
  "version": "1.0.0",
  "description": "React Native mobile application for abe-stack",
  "main": "index.js",
  "scripts": {
    "android": "react-native run-android",
    "ios": "react-native run-ios",
    "start": "react-native start",
    "test": "jest",
    "lint": "eslint . --ext .js,.jsx,.ts,.tsx",
    "type-check": "tsc --noEmit"
  },
  "dependencies": {
    "@abe-stack/shared": "workspace:*",
    "@tanstack/react-query": "^5.59.9",
    "@react-navigation/native": "^7.1.26",
    "@react-navigation/stack": "^7.6.13",
    "react": "^19.2.3",
    "react-native": "^0.83.1",
    "react-native-safe-area-context": "^5.6.2",
    "react-native-screens": "^4.19.0"
  },
  "devDependencies": {
    "@babel/core": "^7.28.5",
    "@babel/preset-env": "^7.28.5",
    "@babel/runtime": "^7.28.4",
    "@react-native/babel-preset": "^0.83.1",
    "@react-native/metro-config": "^0.83.1",
    "@types/react": "^19.2.7",
    "babel-jest": "^30.2.0",
    "jest": "^30.2.0",
    "typescript": "^5.9.3"
  }
}
```

#### apps/mobile/src/App.tsx

```tsx
import React from 'react';
import {
  SafeAreaView,
  ScrollView,
  StatusBar,
  StyleSheet,
  Text,
  View,
  useColorScheme,
} from 'react-native';

function App(): React.JSX.Element {
  const isDarkMode = useColorScheme() === 'dark';

  const backgroundStyle = {
    backgroundColor: isDarkMode ? '#333' : '#fff',
    flex: 1,
  };

  return (
    <SafeAreaView style={backgroundStyle}>
      <StatusBar
        barStyle={isDarkMode ? 'light-content' : 'dark-content'}
        backgroundColor={backgroundStyle.backgroundColor}
      />
      <ScrollView
        contentInsetAdjustmentBehavior="automatic"
        style={backgroundStyle}>
        <View style={styles.container}>
          <Text style={[styles.title, { color: isDarkMode ? '#fff' : '#000' }]}>
            Abe Stack Mobile
          </Text>
          <Text style={[styles.subtitle, { color: isDarkMode ? '#ccc' : '#666' }]}>
            Welcome to the React Native mobile application!
          </Text>
          <Text style={[styles.text, { color: isDarkMode ? '#aaa' : '#444' }]}>
            This is a basic scaffold. Start building your mobile app here.
          </Text>
        </View>
      </ScrollView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    padding: 24,
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  title: {
    fontSize: 32,
    fontWeight: '700',
    marginBottom: 12,
    textAlign: 'center',
  },
  subtitle: {
    fontSize: 18,
    fontWeight: '500',
    marginBottom: 16,
    textAlign: 'center',
  },
  text: {
    fontSize: 14,
    textAlign: 'center',
  },
});

export default App;
```

#### apps/mobile/tsconfig.json

```json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "lib": ["ES2020"],
    "jsx": "react-native",
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "strict": true,
    "resolveJsonModule": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"],
      "@abe-stack/shared": ["../../packages/shared/src"],
      "@components/*": ["./src/components/*"],
      "@hooks/*": ["./src/hooks/*"],
      "@services/*": ["./src/services/*"],
      "@config/*": ["./src/config/*"],
      "@utils/*": ["./src/utils/*"],
      "@api/*": ["./src/api/*"]
    },
    "tsBuildInfoFile": "./node_modules/.cache/tsconfig.mobile.tsbuildinfo"
  },
  "include": ["src/**/*", "index.js"],
  "exclude": ["node_modules", "android", "ios", "__tests__"],
  "references": [
    { "path": "../../packages/shared" }
  ]
}
```

#### apps/server/drizzle.config.ts

```ts
import { defineConfig } from "drizzle-kit";
import * as path from "path";
import * as dotenv from "dotenv";

dotenv.config({ path: path.resolve(__dirname, ".env") });
dotenv.config({ path: path.resolve(__dirname, "../../.env") });

const connectionString =
  process.env.DATABASE_URL ||
  `postgres://${process.env.DB_USER || "postgres"}:${process.env.DB_PASSWORD || ""}@${
    process.env.DB_HOST || "localhost"
  }:${process.env.DB_PORT || "5432"}/${process.env.DB_NAME || "abe_stack"}`;

export default defineConfig({
  schema: "./src/infrastructure/database/schema.ts",
  out: "./drizzle",
  dialect: "postgresql",
  dbCredentials: {
    url: connectionString,
  },
  verbose: true,
  strict: true,
});
```

#### apps/server/package.json

```json
{
  "name": "@abe-stack/server",
  "version": "1.0.0",
  "description": "Minimal Fastify server for abe-stack",
  "main": "dist/index.js",
  "scripts": {
    "dev": "cross-env NODE_ENV=development tsx src/index.ts",
    "start": "cross-env NODE_ENV=production node dist/index.js",
    "build": "tsc",
    "type-check": "tsc --noEmit",
    "db:studio": "drizzle-kit studio"
  },
  "dependencies": {
    "@abe-stack/shared": "workspace:*",
    "@fastify/cors": "^11.2.0",
    "@fastify/helmet": "^13.0.2",
    "dotenv-flow": "^4.1.0",
    "drizzle-orm": "^0.45.1",
    "fastify": "^5.6.2",
    "fastify-type-provider-zod": "^4.0.0",
    "postgres": "^3.4.7",
    "zod": "^4.1.13"
  },
  "devDependencies": {
    "@types/node": "^25.0.3",
    "cross-env": "^10.1.0",
    "drizzle-kit": "^0.31.8",
    "tsx": "^4.21.0",
    "typescript": "^5.9.3"
  }
}
```

#### apps/server/src/fastify/server.ts

```ts
import Fastify from "fastify";
import cors from "@fastify/cors";
import helmet from "@fastify/helmet";
import {
  ZodTypeProvider,
  serializerCompiler,
  validatorCompiler,
} from "fastify-type-provider-zod";
import { z } from "zod";
import dotenvFlow from "dotenv-flow";
import postgres from "postgres";
import { drizzle } from "drizzle-orm/postgres-js";
import { sql } from "drizzle-orm";

dotenvFlow.config();

const DEFAULT_PORT = 8080;
const DEFAULT_HOST = "0.0.0.0";

function buildConnectionString(): string {
  if (process.env.DATABASE_URL) {
    return process.env.DATABASE_URL;
  }

  const user = process.env.DB_USER || "postgres";
  const password = process.env.DB_PASSWORD || "";
  const host = process.env.DB_HOST || "localhost";
  const port = Number(process.env.DB_PORT || 5432);
  const database = process.env.DB_NAME || "postgres";

  const auth = password ? `${user}:${password}` : user;
  return `postgres://${auth}@${host}:${port}/${database}`;
}

export async function createFastifyServer() {
  const app = Fastify({ logger: true }).withTypeProvider<ZodTypeProvider>();
  app.setValidatorCompiler(validatorCompiler);
  app.setSerializerCompiler(serializerCompiler);

  await app.register(cors, { origin: true, credentials: true });
  await app.register(helmet);

  const sqlClient = postgres(buildConnectionString(), {
    max: Number(process.env.DB_MAX_CONNECTIONS || 10),
    idle_timeout: Number(process.env.DB_IDLE_TIMEOUT || 30000),
    connect_timeout: Number(process.env.DB_CONNECT_TIMEOUT || 10000),
    ssl: process.env.DB_SSL === "true",
  });

  const db = drizzle(sqlClient);

  app.get(
    "/api",
    {
      schema: {
        response: {
          200: z.object({
            message: z.string(),
            timestamp: z.string(),
          }),
        },
      },
    },
    async () => ({
      message: "Fastify adapter is running",
      timestamp: new Date().toISOString(),
    })
  );

  app.get(
    "/health",
    {
      schema: {
        response: {
          200: z.object({
            status: z.enum(["ok", "degraded"]),
            database: z.boolean(),
            timestamp: z.string(),
          }),
        },
      },
    },
    async () => {
      let dbHealthy = true;
      try {
        await db.execute(sql`select 1`);
      } catch (error) {
        dbHealthy = false;
        app.log.error({ err: error }, "Database health check failed");
      }

      return {
        status: dbHealthy ? "ok" : "degraded",
        database: dbHealthy,
        timestamp: new Date().toISOString(),
      };
    }
  );

  return { app, sqlClient };
}

async function start() {
  const port = Number(process.env.PORT || DEFAULT_PORT);
  const host = process.env.HOST || DEFAULT_HOST;

  try {
    const { app, sqlClient } = await createFastifyServer();

    app.addHook("onClose", async () => {
      await sqlClient.end({ timeout: 5 });
    });

    await app.listen({ port, host });
    app.log.info(`Fastify server listening on http://${host}:${port}`);
  } catch (error) {
    console.error("Failed to start Fastify server", error);
    process.exit(1);
  }
}

start();
```

#### apps/server/src/index.ts

```ts
import Fastify from "fastify";
import cors from "@fastify/cors";
import helmet from "@fastify/helmet";
import {
  ZodTypeProvider,
  serializerCompiler,
  validatorCompiler,
} from "fastify-type-provider-zod";
import { z } from "zod";
import { drizzle } from "drizzle-orm/postgres-js";
import postgres from "postgres";
import { sql } from "drizzle-orm";
import dotenvFlow from "dotenv-flow";
import path from "path";

// Load environment variables
dotenvFlow.config({
  node_env: process.env.NODE_ENV || "development",
  path: path.resolve(__dirname, "../../../config/env"),
});

const DEFAULT_PORT = 8080;
const DEFAULT_HOST = "0.0.0.0";

/**
 * Build PostgreSQL connection string from environment variables
 */
function buildConnectionString(): string {
  if (process.env.DATABASE_URL) {
    return process.env.DATABASE_URL;
  }

  const user = process.env.POSTGRES_USER || "postgres";
  const password = process.env.POSTGRES_PASSWORD || "";
  const host = process.env.POSTGRES_HOST || "localhost";
  const port = Number(process.env.POSTGRES_PORT || 5432);
  const database = process.env.POSTGRES_DB || "abe_stack_dev";

  const auth = password ? `${user}:${password}` : user;
  return `postgres://${auth}@${host}:${port}/${database}`;
}

/**
 * Create and configure Fastify server
 */
export async function createServer() {
  const app = Fastify({
    logger: {
      level: process.env.LOG_LEVEL || "info",
    },
  }).withTypeProvider<ZodTypeProvider>();

  // Set up Zod validation
  app.setValidatorCompiler(validatorCompiler);
  app.setSerializerCompiler(serializerCompiler);

  // Register plugins
  await app.register(cors, {
    origin: process.env.CORS_ORIGIN || true,
    credentials: true,
  });

  await app.register(helmet);

  // Initialize database connection
  const sqlClient = postgres(buildConnectionString(), {
    max: Number(process.env.DB_MAX_CONNECTIONS || 10),
    idle_timeout: Number(process.env.DB_IDLE_TIMEOUT || 30000),
    connect_timeout: Number(process.env.DB_CONNECT_TIMEOUT || 10000),
  });

  const db = drizzle(sqlClient);

  // Root route
  app.get(
    "/",
    {
      schema: {
        response: {
          200: z.object({
            message: z.string(),
            timestamp: z.string(),
          }),
        },
      },
    },
    async () => ({
      message: "ABE Stack API",
      timestamp: new Date().toISOString(),
    })
  );

  // API route
  app.get(
    "/api",
    {
      schema: {
        response: {
          200: z.object({
            message: z.string(),
            version: z.string(),
            timestamp: z.string(),
          }),
        },
      },
    },
    async () => ({
      message: "ABE Stack API is running",
      version: "1.0.0",
      timestamp: new Date().toISOString(),
    })
  );

  // Health check route with database check
  app.get(
    "/health",
    {
      schema: {
        response: {
          200: z.object({
            status: z.enum(["ok", "degraded"]),
            database: z.boolean(),
            timestamp: z.string(),
          }),
        },
      },
    },
    async () => {
      let dbHealthy = true;

      try {
        await db.execute(sql`SELECT 1`);
      } catch (error) {
        dbHealthy = false;
        app.log.error({ err: error }, "Database health check failed");
      }

      return {
        status: dbHealthy ? ("ok" as const) : ("degraded" as const),
        database: dbHealthy,
        timestamp: new Date().toISOString(),
      };
    }
  );

  // Graceful shutdown
  app.addHook("onClose", async () => {
    await sqlClient.end({ timeout: 5 });
  });

  return { app, db, sqlClient };
}

/**
 * Start the server
 */
async function start() {
  const port = Number(process.env.API_PORT || DEFAULT_PORT);
  const host = process.env.HOST || DEFAULT_HOST;

  try {
    const { app } = await createServer();

    await app.listen({ port, host });
    app.log.info(`Server listening on http://${host}:${port}`);
  } catch (error) {
    console.error("Failed to start server", error);
    process.exit(1);
  }
}

// Start server if this file is run directly
if (require.main === module) {
  start();
}
```

#### apps/server/src/scripts/dbHealthCheck.ts

```ts
import dotenvFlow from "dotenv-flow";
import postgres from "postgres";

dotenvFlow.config({ path: ".env" });
dotenvFlow.config({ path: "../../.env" });

function buildConnectionString() {
  if (process.env.DATABASE_URL) return process.env.DATABASE_URL;
  const user = process.env.DB_USER || "postgres";
  const password = process.env.DB_PASSWORD || "";
  const host = process.env.DB_HOST || "localhost";
  const port = process.env.DB_PORT || "5432";
  const database = process.env.DB_NAME || "postgres";
  const auth = password ? `${user}:${password}` : user;
  return `postgres://${auth}@${host}:${port}/${database}`;
}

async function main() {
  const url = buildConnectionString();
  const sql = postgres(url, { max: 1, ssl: process.env.DB_SSL === "true" });

  try {
    await sql`select 1`;
    console.log("Database health check: OK");
    await sql.end({ timeout: 1 });
    process.exit(0);
  } catch (error) {
    console.error("Database health check failed:", error);
    await sql.end({ timeout: 1 });
    process.exit(1);
  }
}

main();
```

#### apps/server/src/scripts/seed.ts

```ts
import dotenvFlow from "dotenv-flow";
import postgres from "postgres";
import { drizzle } from "drizzle-orm/postgres-js";

dotenvFlow.config({ path: ".env" });
dotenvFlow.config({ path: "../../.env" });

function buildConnectionString() {
  if (process.env.DATABASE_URL) return process.env.DATABASE_URL;
  const user = process.env.DB_USER || "postgres";
  const password = process.env.DB_PASSWORD || "";
  const host = process.env.DB_HOST || "localhost";
  const port = process.env.DB_PORT || "5432";
  const database = process.env.DB_NAME || "postgres";
  const auth = password ? `${user}:${password}` : user;
  return `postgres://${auth}@${host}:${port}/${database}`;
}

async function main() {
  const url = buildConnectionString();
  const sql = postgres(url, {
    max: 2,
    ssl: process.env.DB_SSL === "true",
  });
  const db = drizzle(sql);

  try {
    // TODO: Add real seed data once schema is defined.
    console.log("Seed script connected. Add seed operations here.");
  } catch (error) {
    console.error("Seed script failed:", error);
    process.exitCode = 1;
  } finally {
    await sql.end({ timeout: 1 });
  }
}

main();
```

#### apps/server/tsconfig.json

```json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "composite": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "moduleResolution": "node",
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"],
      "@abe-stack/shared": ["../../packages/shared/src"],
      "@modules/*": ["./src/modules/*"],
      "@cache/*": ["./src/infrastructure/cache/*"],
      "@config/*": ["./src/infrastructure/config/*"],
      "@database/*": ["./src/infrastructure/database/*"],
      "@di/*": ["./src/infrastructure/di/*"],
      "@errors/*": ["./src/infrastructure/errors/*"],
      "@files/*": ["./src/infrastructure/files/*"],
      "@jobs/*": ["./src/infrastructure/jobs/*"],
      "@lifecycle/*": ["./src/infrastructure/lifecycle/*"],
      "@logging/*": ["./src/infrastructure/logging/*"],
      "@middleware/*": ["./src/infrastructure/middleware/*"],
      "@processor/*": ["./src/infrastructure/processor/*"],
      "@promises/*": ["./src/infrastructure/promises/*"],
      "@pubsub/*": ["./src/infrastructure/pubsub/*"],
      "@queue/*": ["./src/infrastructure/queue/*"],
      "@search/*": ["./src/infrastructure/search/*"],
      "@security/*": ["./src/infrastructure/security/*"],
      "@server/*": ["./src/infrastructure/server/*"],
      "@storage/*": ["./src/infrastructure/storage/*"],
      "@utils/*": ["./src/infrastructure/utils/*"]
    },
    "tsBuildInfoFile": "./node_modules/.cache/tsconfig.server.tsbuildinfo"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "__tests__"],
  "references": [
    { "path": "../../packages/shared" }
  ]
}
```

#### apps/web/.env.example

```example
VITE_API_URL=http://localhost:8080/api
VITE_APP_NAME=abe-stack-web
```

#### apps/web/__tests__/base.e2e.ts

```ts
import { Page, test } from "@playwright/test";

async function waitFor(page: Page, selector: string) {
  const element = await page.waitForSelector(selector);
  if (!element) throw new Error("Element not found: " + selector);
  return element;
}

export async function write(page: Page, selector: string, value: string) {
  const input = await waitFor(page, selector);
  await input.fill(value);
  await input.focus();
  return input;
}

export async function click(page: Page, selector: string) {
  const button = await waitFor(page, selector);
  await button.click();
  return button;
}

test("Smoke Test", async ({ browser }) => {
  const context = await browser.newContext();
  const page = await context.newPage();
  await page.goto("/");
  await waitFor(page, "body");
});
```

#### apps/web/__tests__/base.test.ts

```ts
import { strict as assert } from "assert";

import { describe, it } from "vitest";

describe("Unit Testing", () => {
  it("works", () => {
    assert.ok(true);
    assert.equal(1 + 1, 2);
    assert.deepEqual({}, {});
  });
});
```

#### apps/web/package.json

```json
{
  "name": "@abe-stack/web",
  "version": "1.0.0",
  "description": "React web application for abe-stack",
  "type": "module",
  "scripts": {
    "dev": "vite --config ../../config/build/vite.config.ts",
    "build": "vite build --config ../../config/build/vite.config.ts",
    "preview": "vite preview --config ../../config/build/vite.config.ts",
    "type-check": "tsc --noEmit",
    "test": "vitest run",
    "test:watch": "vitest",
    "lint": "eslint src --ext ts,tsx"
  },
  "dependencies": {
    "@abe-stack/shared": "workspace:*",
    "@abe-stack/ui": "workspace:*",
    "@tanstack/react-query": "^5.59.9",
    "react": "^19.2.3",
    "react-dom": "^19.2.3",
    "react-router-dom": "^7.11.0"
  },
  "devDependencies": {
    "@types/react": "^19.2.7",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.2",
    "@vitest/coverage-v8": "^4.0.16",
    "eslint-plugin-react": "^7.37.5",
    "eslint-plugin-react-hooks": "^7.0.1",
    "typescript": "^5.9.3",
    "vite": "^7.3.0",
    "vite-tsconfig-paths": "^6.0.3",
    "vitest": "^4.0.16"
  }
}
```

#### apps/web/src/App.tsx

```tsx
import React from "react";
import { BrowserRouter } from "react-router-dom";

import { AuthProvider } from "./contexts/AuthContext";
import { AppRoutes } from "./routes";

export const App: React.FC = () => {
  return (
    <BrowserRouter>
      <AuthProvider>
        <AppRoutes />
      </AuthProvider>
    </BrowserRouter>
  );
};
```

#### apps/web/src/api/auth.api.ts

```ts
// Base API URL
const API_URL = "/api";

// Auth API response types
export interface AuthResponse {
  success: boolean;
  message?: string;
  user?: any;
  accessToken?: string;
  requireMfa?: boolean;
  requireEmailVerification?: boolean;
}

// Auth API client
const authApi = {
  // Login function
  async login(email: string, password: string): Promise<AuthResponse> {
    try {
      console.log("Attempting login with:", { email });

      const response = await fetch(`${API_URL}/auth/login`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ email, password }),
        credentials: "include",
      });

      const data = await response.json();

      if (!response.ok) {
        return {
          success: false,
          message: data.error || "Login failed",
        };
      }

      return {
        success: true,
        user: data.user,
        accessToken: data.accessToken,
        requireMfa: data.requireMfa,
        message: data.message,
      };
    } catch (error) {
      console.error("Login error:", error);
      return {
        success: false,
        message: "Unable to connect to server",
      };
    }
  },

  // Register function
  async register(userData: {
    email: string;
    password: string;
    firstName?: string;
    lastName?: string;
    username?: string;
  }): Promise<AuthResponse> {
    try {
      console.log("Attempting registration with:", userData.email);

      const response = await fetch(`${API_URL}/auth/register`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(userData),
        credentials: "include",
      });

      const data = await response.json();

      if (!response.ok) {
        return {
          success: false,
          message: data.error || "Registration failed",
        };
      }

      return {
        success: true,
        user: data.user,
        accessToken: data.accessToken,
        requireEmailVerification: data.requireEmailVerification,
        message: data.message,
      };
    } catch (error) {
      console.error("Registration error:", error);
      return {
        success: false,
        message: "Unable to connect to server",
      };
    }
  },

  // Logout function
  async logout(): Promise<AuthResponse> {
    try {
      console.log("Attempting logout");

      const response = await fetch(`${API_URL}/auth/logout`, {
        method: "POST",
        credentials: "include",
      });

      const data = await response.json();

      if (!response.ok) {
        return {
          success: false,
          message: data.error || "Logout failed",
        };
      }

      return {
        success: true,
        message: data.message || "Logged out successfully",
      };
    } catch (error) {
      console.error("Logout error:", error);
      return {
        success: false,
        message: "Logout failed",
      };
    }
  },

  // Refresh token function
  async refreshToken(): Promise<AuthResponse> {
    try {
      console.log("Attempting token refresh");

      const response = await fetch(`${API_URL}/auth/refresh-token`, {
        method: "POST",
        credentials: "include",
      });

      const data = await response.json();

      if (!response.ok) {
        return {
          success: false,
          message: data.error || "Token refresh failed",
        };
      }

      return {
        success: true,
        accessToken: data.accessToken,
        message: data.message,
      };
    } catch (error) {
      console.error("Token refresh error:", error);
      return {
        success: false,
        message: "Token refresh failed",
      };
    }
  },

  // Get current user function
  async getCurrentUser(): Promise<AuthResponse> {
    try {
      console.log("Getting current user");

      const response = await fetch(`${API_URL}/auth/me`, {
        credentials: "include",
      });

      const data = await response.json();

      if (!response.ok) {
        return {
          success: false,
          message: data.error || "Not authenticated",
        };
      }

      return {
        success: true,
        user: data,
      };
    } catch (error) {
      console.error("Get current user error:", error);
      return {
        success: false,
        message: "Not authenticated",
      };
    }
  },
};

export default authApi;
```

#### apps/web/src/api/index.ts

```ts
import authApi from "./auth.api";

export default authApi;

export { default as authApi } from "./auth.api";
```

#### apps/web/src/components/Design.tsx

```tsx
import { useClientEnvironment } from "../services/ClientEnvironment";

export function Design({ page }: { page: string }) {
  const environment = useClientEnvironment();

  return (
    <div style={{ padding: "2rem" }}>
      <h1>Design System</h1>

      <div style={{ marginBottom: "2rem" }}>
        <button
          onClick={() => environment.router.navigate("/")}
          style={{
            padding: "8px 16px",
            backgroundColor: "var(--blue)",
            color: "white",
            border: "none",
            borderRadius: "4px",
            cursor: "pointer",
          }}
        >
          Back to Home
        </button>
      </div>

      {renderPage(page)}
    </div>
  );
}

function renderPage(page: string) {
  switch (page) {
    case "colors":
      return <ColorsPage />;
    case "typography":
      return <TypographyPage />;
    case "buttons":
      return <ButtonsPage />;
    default:
      return (
        <div>
          <h2>Design System Pages</h2>
          <ul>
            <li>
              <a href="/design/colors" style={{ color: "var(--blue)" }}>
                Colors
              </a>
            </li>
            <li>
              <a href="/design/typography" style={{ color: "var(--blue)" }}>
                Typography
              </a>
            </li>
            <li>
              <a href="/design/buttons" style={{ color: "var(--blue)" }}>
                Buttons
              </a>
            </li>
          </ul>
        </div>
      );
  }
}

function ColorsPage() {
  return (
    <div>
      <h2>Colors</h2>
      <div style={{ display: "flex", flexWrap: "wrap", gap: "1rem" }}>
        {["blue", "green", "red", "orange", "purple", "teal"].map((color) => (
          <div key={color} style={{ width: "150px" }}>
            <div
              style={{
                height: "100px",
                backgroundColor: `var(--${color})`,
                borderRadius: "4px",
                marginBottom: "0.5rem",
              }}
            />
            <div>{color}</div>
          </div>
        ))}
      </div>
    </div>
  );
}

function TypographyPage() {
  return (
    <div>
      <h2>Typography</h2>
      <h1>Heading 1</h1>
      <h2>Heading 2</h2>
      <h3>Heading 3</h3>
      <h4>Heading 4</h4>
      <p>Regular paragraph text</p>
      <p>
        <small>Small text</small>
      </p>
      <p>
        <strong>Bold text</strong>
      </p>
      <p>
        <em>Italic text</em>
      </p>
    </div>
  );
}

function ButtonsPage() {
  return (
    <div>
      <h2>Buttons</h2>
      <div style={{ display: "flex", gap: "1rem", marginBottom: "1rem" }}>
        <button
          style={{
            padding: "8px 16px",
            backgroundColor: "var(--blue)",
            color: "white",
            border: "none",
            borderRadius: "4px",
            cursor: "pointer",
          }}
        >
          Primary
        </button>
        <button
          style={{
            padding: "8px 16px",
            backgroundColor: "transparent",
            color: "var(--blue)",
            border: "1px solid var(--blue)",
            borderRadius: "4px",
            cursor: "pointer",
          }}
        >
          Secondary
        </button>
        <button
          style={{
            padding: "8px 16px",
            backgroundColor: "var(--red)",
            color: "white",
            border: "none",
            borderRadius: "4px",
            cursor: "pointer",
          }}
        >
          Danger
        </button>
      </div>
    </div>
  );
}
```

#### apps/web/src/components/Link.tsx

```tsx
import React, { ComponentPropsWithoutRef } from "react";
import { useNavigate } from "react-router-dom";

interface LinkProps extends ComponentPropsWithoutRef<"a"> {
  to: string;
}

export function Link({ to, onClick, ...props }: LinkProps) {
  const navigate = useNavigate();

  const handleClick = (event: React.MouseEvent<HTMLAnchorElement>) => {
    event.preventDefault();
    if (onClick) {
      onClick(event);
    }
    void navigate(to);
  };

  return <a {...props} href={to} onClick={handleClick} />;
}
```

#### apps/web/src/components/ProtectedRoute.tsx

```tsx
import React from "react";
import { Navigate, useLocation } from "react-router-dom";

import { useAuth } from "../contexts/AuthContext";

interface ProtectedRouteProps {
  children: React.ReactNode;
}

export const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ children }) => {
  const { isAuthenticated, isLoading } = useAuth();
  const location = useLocation();

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-blue-500"></div>
      </div>
    );
  }

  if (!isAuthenticated) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  return <>{children}</>;
};
```

#### apps/web/src/components/Root.tsx

```tsx
import { Suspense } from "react";

import { AuthProvider } from "./auth";
import { ConfirmEmail } from "./auth/ConfirmEmail";
import MainLayout from "../layouts/MainLayout";
import {
  ClientEnvironment,
  ClientEnvironmentProvider,
} from "../services/ClientEnvironment";
import { useRoute } from "../services/Router";
import { ResendVerification } from "./auth/ResendVerification";
import { Design } from "./Design";
import { DashboardPage } from "./pages/DashboardPage";
import { ExplorePage } from "./pages/ExplorePage";
import { HomePage } from "./pages/HomePage";
import { MediaPage } from "./pages/MediaPage";
import { NotificationsPage } from "./pages/NotificationsPage";
import { ProfilePage } from "./pages/ProfilePage";
import { SettingsPage } from "./pages/SettingsPage";
import { UploadPage } from "./pages/UploadPage";
import { ThemeProvider } from "./theme";

type BaseRoute = {
  url: string;
};

type Route =
  | (BaseRoute & {
      type:
        | "root"
        | "dashboard"
        | "profile"
        | "upload"
        | "explore"
        | "notifications"
        | "media"
        | "settings"
        | "home"
        | "social"
        | "unknown";
    })
  | (BaseRoute & { type: "design"; page: string })
  | (BaseRoute & { type: "auth"; action: string; token?: string });

export function Root(props: { environment: ClientEnvironment }) {
  return (
    <ClientEnvironmentProvider value={props.environment}>
      <ThemeProvider>
        <AuthProvider>
          <Suspense fallback={<Loading />}>
            <Router />
          </Suspense>
        </AuthProvider>
      </ThemeProvider>
    </ClientEnvironmentProvider>
  );
}

function Loading() {
  return (
    <div style={{ textAlign: "center", marginTop: "33vh" }}>
      <div className="spinner"></div>
    </div>
  );
}

function Router() {
  const route = useRoute();

  // Only design routes and auth routes don't use the main layout
  if (route.type === "design" || route.type === "auth") {
    return renderRouteContent(route);
  }

  // All other routes, including root, use the main layout
  return <MainLayout>{renderRouteContent(route)}</MainLayout>;
}

function renderRouteContent(route: Route) {
  switch (route.type) {
    case "root":
      return <HomePage />;
    case "design":
      return <Design page={route.page} />;
    case "dashboard":
      return <DashboardPage />;
    case "profile":
      return <ProfilePage />;
    case "upload":
      return <UploadPage />;
    case "explore":
      return <ExplorePage />;
    case "notifications":
      return <NotificationsPage />;
    case "media":
      return <MediaPage />;
    case "settings":
      return <SettingsPage />;
    case "home":
      return <HomePage />;
    case "auth":
      // Handle auth routes
      switch (route.action) {
        case "confirm-email":
          return <ConfirmEmail />;
        case "resend-confirmation":
          return <ResendVerification />;
        default:
          return <div>Auth page not found</div>;
      }
    default:
      return <div>Page not found</div>;
  }
}
```

#### apps/web/src/components/auth/AuthContext.tsx

```tsx
import {
  createContext,
  ReactNode,
  useContext,
  useEffect,
  useState,
} from "react";

// Inline auth API to avoid import issues
const authApi = {
  // Base API URL - use relative path for Vite proxy
  baseUrl: "/api",

  async login(email: string, password: string) {
    console.log("Login attempt with:", email);

    // Try to connect to the backend through the Vite proxy
    try {
      const response = await fetch(`${this.baseUrl}/auth/login`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ email, password }),
        credentials: "include",
      });

      if (!response.ok) {
        const errorData = await response.json();
        console.error("Login failed:", errorData);
        return {
          success: false,
          message: errorData.error || "Login failed",
        };
      }

      const data = await response.json();
      return {
        success: true,
        user: data.user,
        accessToken: data.accessToken,
        requireMfa: data.requireMfa,
        message: data.message,
      };
    } catch (error) {
      console.error("API connection error:", error);

      // Fall back to mock data for development
      return {
        success: true,
        message: "Using mock data: backend connection failed",
        user: {
          id: "123",
          username: "testuser",
          email,
          displayName: "Test User",
          firstName: "Test",
          lastName: "User",
          bio: null,
          profileImage: null,
          bannerImage: null,
          role: "user",
          isVerified: true,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
        },
        accessToken: "dummy-token-123",
      };
    }
  },

  async testDatabaseConnection() {
    try {
      const response = await fetch(`${this.baseUrl}/auth/test-db`);

      if (!response.ok) {
        const errorData = await response.json();
        console.error("Database test failed:", errorData);
        return {
          success: false,
          connected: false,
          message: errorData.error || "Database test failed",
        };
      }

      const data = await response.json();
      return {
        success: true,
        connected: Boolean(data.connected),
        message: data.message,
      };
    } catch (error) {
      console.error("Database test error:", error);
      return {
        success: false,
        connected: false,
        message: error instanceof Error ? error.message : "Connection error",
      };
    }
  },

  async register(userData: any) {
    console.log("Register attempt with:", userData.email);

    try {
      // Make actual API call to backend
      console.log("Registration data:", userData);

      const response = await fetch(`${this.baseUrl}/auth/register`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          email: userData.email,
          password: userData.password,
          firstName: userData.firstName,
          lastName: userData.lastName,
          username: userData.username,
        }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.message || "Registration failed");
      }

      console.log("Registration successful:", data);
      console.log("Verification email sent to:", userData.email);

      return {
        success: data.success,
        message: data.message,
        requireEmailVerification: data.requireEmailVerification,
        userId: data.userId,
      };
    } catch (error) {
      console.error("Registration API error:", error);
      return {
        success: false,
        message: error instanceof Error ? error.message : "Registration failed",
      };
    }
  },

  async logout() {
    return { success: true };
  },

  async refreshToken() {
    return { success: true, accessToken: "new-dummy-token-456" };
  },

  async getCurrentUser() {
    const userData = localStorage.getItem("user");
    if (userData) {
      return { success: true, user: JSON.parse(userData) };
    }
    return { success: false, message: "Not authenticated" };
  },
};

// Define the user type
interface User {
  id: string;
  username: string;
  email: string;
  displayName: string | null;
  firstName: string | null;
  lastName: string | null;
  bio: string | null;
  profileImage: string | null;
  bannerImage: string | null;
  role: string;
  isVerified: boolean;
  createdAt: string;
  updatedAt: string;
}

// Define the auth context type
interface AuthContextType {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  login: (email: string, password: string) => Promise<void>;
  register: (
    username: string,
    firstName: string,
    lastName: string,
    email: string,
    password: string
  ) => Promise<{ success: boolean; requireVerification: boolean } | void>;
  logout: () => void;
  error: string | null;
  showVerificationModal: boolean;
  setShowVerificationModal: (show: boolean) => void;
  verificationEmail: string;
  setVerificationEmail: (email: string) => void;
  testDatabaseConnection: () => Promise<{
    success: boolean;
    connected: boolean;
    message: string;
  }>;
}

// Create the auth context with default values
const AuthContext = createContext<AuthContextType>({
  user: null,
  isAuthenticated: false,
  isLoading: true,
  login: async () => {},
  register: async () => {},
  logout: () => {},
  error: null,
  showVerificationModal: false,
  setShowVerificationModal: () => {},
  verificationEmail: "",
  setVerificationEmail: () => {},
  testDatabaseConnection: async () => ({
    success: false,
    connected: false,
    message: "",
  }),
});

// Custom hook to use the auth context
export const useAuth = () => useContext(AuthContext);

interface AuthProviderProps {
  children: ReactNode;
}

export function AuthProvider({ children }: AuthProviderProps) {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showVerificationModal, setShowVerificationModal] = useState(false);
  const [verificationEmail, setVerificationEmail] = useState("");

  // Check authentication status on component mount
  useEffect(() => {
    const checkAuthStatus = async () => {
      try {
        // First test the auth API connection
        try {
          const response = await fetch(`${authApi.baseUrl}/auth/test`);
          if (response.ok) {
            const data = await response.json();
            console.log("Auth API connected:", data);
          } else {
            console.warn(
              "Auth API test failed:",
              response.status,
              response.statusText
            );
          }
        } catch (error) {
          console.error("Failed to connect to Auth API:", error);
        }

        // Test database connection
        try {
          const dbResult = await authApi.testDatabaseConnection();
          console.log("Database connection test:", dbResult);
          if (dbResult.success && dbResult.connected) {
            console.log("✅ Database connection successful");
          } else {
            console.warn("⚠️ Database connection failed:", dbResult.message);
          }
        } catch (error) {
          console.error("Database test error:", error);
        }

        // Check if we have a token
        const token = localStorage.getItem("token");
        if (!token) {
          setIsLoading(false);
          return;
        }

        // Validate token with the server
        const result = await authApi.getCurrentUser();

        if (result.success && result.user) {
          setUser(result.user);
          localStorage.setItem("user", JSON.stringify(result.user));
        } else {
          // Token invalid, try to refresh
          const refreshResult = await authApi.refreshToken();

          if (refreshResult.success && refreshResult.accessToken) {
            localStorage.setItem("token", refreshResult.accessToken);

            // Try to get user data again
            const userResult = await authApi.getCurrentUser();
            if (userResult.success && userResult.user) {
              setUser(userResult.user);
              localStorage.setItem("user", JSON.stringify(userResult.user));
            } else {
              throw new Error("Could not get user data");
            }
          } else {
            throw new Error("Token refresh failed");
          }
        }
      } catch (error) {
        console.error("Auth check error:", error);
        // Clear invalid auth data
        localStorage.removeItem("user");
        localStorage.removeItem("token");
      } finally {
        setIsLoading(false);
      }
    };

    void checkAuthStatus();
  }, []);

  // Login function
  const login = async (email: string, password: string) => {
    setIsLoading(true);
    setError(null);

    try {
      const result = await authApi.login(email, password);

      if (!result.success) {
        throw new Error(result.message || "Login failed");
      }

      // Check if MFA is required
      if (result.requireMfa) {
        setError(
          "Multi-factor authentication is required but not implemented in this demo"
        );
        throw new Error("Multi-factor authentication required");
      }

      // Save user data to localStorage
      localStorage.setItem("user", JSON.stringify(result.user));
      if (result.accessToken) {
        localStorage.setItem("token", result.accessToken);
      }

      // Update state
      setUser(result.user);
    } catch (error) {
      console.error("Login error:", error);
      setError(
        error instanceof Error
          ? error.message
          : "Login failed. Please try again."
      );
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  // Register function
  const register = async (
    username: string,
    firstName: string,
    lastName: string,
    email: string,
    password: string
  ) => {
    setIsLoading(true);
    setError(null);

    try {
      const result = await authApi.register({
        email,
        password,
        firstName,
        lastName,
        username,
      });

      if (!result.success) {
        throw new Error(result.message || "Registration failed");
      }

      // Always show verification email modal
      setVerificationEmail(email);
      setShowVerificationModal(true);

      return { success: true, requireVerification: true };
    } catch (error) {
      console.error("Registration error:", error);
      setError(
        error instanceof Error
          ? error.message
          : "Registration failed. Please try again."
      );
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  // Logout function
  const logout = async () => {
    try {
      await authApi.logout();
    } catch (error) {
      console.error("Logout error:", error);
    } finally {
      // Remove user data from localStorage
      localStorage.removeItem("user");
      localStorage.removeItem("token");

      // Update state
      setUser(null);
    }
  };

  // Create the context value
  const value = {
    user,
    isAuthenticated: !!user,
    isLoading,
    login,
    register,
    logout,
    error,
    showVerificationModal,
    setShowVerificationModal,
    verificationEmail,
    setVerificationEmail,
    testDatabaseConnection: authApi.testDatabaseConnection,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}
```

#### apps/web/src/components/auth/AuthModal.tsx

```tsx
import React, { useState } from "react";

import { useAuth } from "./AuthContext";
import { LoginModal } from "./LoginModal";
import { RegisterModal } from "./RegisterModal";
import { VerificationModal } from "./VerificationModal";

export type AuthModalType = "login" | "register" | null;

interface AuthModalProps {
  isOpen: boolean;
  modalType: AuthModalType;
  onClose: () => void;
}

export function AuthModal({ isOpen, modalType, onClose }: AuthModalProps) {
  const [activeModal, setActiveModal] = useState<AuthModalType>(modalType);
  const {
    login,
    register,
    showVerificationModal,
    setShowVerificationModal,
    verificationEmail,
  } = useAuth();

  // Reset active modal when props change
  React.useEffect(() => {
    setActiveModal(modalType);
  }, [modalType]);

  const handleSwitchToLogin = () => {
    setActiveModal("login");
  };

  const handleSwitchToRegister = () => {
    setActiveModal("register");
  };

  const handleLogin = async (email: string, password: string) => {
    try {
      await login(email, password);
      onClose();
    } catch (error) {
      // Error is handled in the AuthContext
      console.error("Login failed:", error);
    }
  };

  const handleRegister = async (
    username: string,
    firstName: string,
    lastName: string,
    email: string,
    password: string,
  ) => {
    try {
      await register(username, firstName, lastName, email, password);
      // Don't close the modal if verification is needed
      // The verification modal will be shown instead
      if (!showVerificationModal) {
        onClose();
      }
    } catch (error) {
      // Error is handled in the AuthContext
      console.error("Registration failed:", error);
    }
  };

  // Void-returning wrappers for event handlers
  const handleLoginWrapper = (email: string, password: string): void => {
    void handleLogin(email, password);
  };

  const handleRegisterWrapper = (
    username: string,
    firstName: string,
    lastName: string,
    email: string,
    password: string,
  ): void => {
    void handleRegister(username, firstName, lastName, email, password);
  };

  const handleCloseVerificationModal = () => {
    setShowVerificationModal(false);
    onClose();
  };

  if (!isOpen && !showVerificationModal) return null;

  return (
    <>
      <LoginModal
        isOpen={activeModal === "login" && isOpen}
        onClose={onClose}
        onSwitchToRegister={handleSwitchToRegister}
        onLogin={handleLoginWrapper}
      />

      <RegisterModal
        isOpen={activeModal === "register" && isOpen}
        onClose={onClose}
        onSwitchToLogin={handleSwitchToLogin}
        onRegister={handleRegisterWrapper}
      />

      <VerificationModal
        isOpen={showVerificationModal}
        onClose={handleCloseVerificationModal}
        email={verificationEmail}
      />
    </>
  );
}
```

#### apps/web/src/components/auth/ConfirmEmail.tsx

```tsx
import React, { useEffect, useMemo, useState } from "react";

import { AuthClient } from "../../services/AuthClient";
import { useRouter } from "../../services/Router";
import { Button } from "../ui/Button";
import { Card } from "../ui/Card";
import { Spinner } from "../ui/Spinner";

interface ApiResponse {
  success: boolean;
  error?: string;
}

// Define response type
interface EmailConfirmationResponse {
  status: "success" | "error";
  message?: string;
}

/**
 * Email confirmation component
 * Handles email verification using token from URL
 */
export const ConfirmEmail: React.FC = () => {
  const [status, setStatus] = useState<"loading" | "success" | "error">(
    "loading",
  );
  const [message, setMessage] = useState("Verifying your email...");
  const router = useRouter();

  // Use useMemo to create the authClient instance
  const authClient = useMemo(() => new AuthClient(), []);

  useEffect(() => {
    const confirmEmail = async () => {
      try {
        // Get token from URL
        const urlParams = new URLSearchParams(window.location.search);
        const token = urlParams.get("token");

        if (!token) {
          setStatus("error");
          setMessage("Invalid verification link. No token provided.");
          return;
        }

        // Call API to verify email
        const response = (await authClient.confirmEmail(token)) as ApiResponse;

        // Convert response to expected type
        const typedResponse: EmailConfirmationResponse = {
          status: response.success ? "success" : "error",
          message: response.error,
        };

        if (typedResponse.status === "success") {
          setStatus("success");
          setMessage("Your email has been verified successfully!");

          // Redirect to login after 3 seconds
          setTimeout(() => {
            router.navigate("/auth/login");
          }, 3000);
        } else {
          setStatus("error");
          setMessage(
            typedResponse.message ||
              "Failed to verify email. Please try again.",
          );
        }
      } catch (error) {
        setStatus("error");
        setMessage("An error occurred during verification. Please try again.");
        console.error("Email verification error:", error);
      }
    };

    void confirmEmail();
  }, [router, authClient]);

  return (
    <div className="flex justify-center items-center min-h-screen bg-gray-100">
      <Card className="w-full max-w-md p-8">
        <div className="text-center">
          <h1 className="text-2xl font-bold mb-6">Email Verification</h1>

          {status === "loading" && (
            <div className="flex flex-col items-center">
              <div className="mb-4">
                <Spinner size="lg" />
              </div>
              <p>{message}</p>
            </div>
          )}

          {status === "success" && (
            <div className="text-center">
              <div className="text-green-500 text-5xl mb-4">✓</div>
              <p className="mb-6">{message}</p>
              <p className="text-sm text-gray-500">
                Redirecting to login page...
              </p>
            </div>
          )}

          {status === "error" && (
            <div className="text-center">
              <div className="text-red-500 text-5xl mb-4">✗</div>
              <p className="mb-6">{message}</p>
              <Button
                onClick={() => router.navigate("/auth/login")}
                variant="primary"
                className="w-full"
              >
                Go to Login
              </Button>
            </div>
          )}
        </div>
      </Card>
    </div>
  );
};
```

#### apps/web/src/components/auth/LoginModal.tsx

```tsx
import React, { useState } from "react";

interface LoginModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSwitchToRegister: () => void;
  onLogin: (email: string, password: string) => void;
}

export function LoginModal({
  isOpen,
  onClose,
  onSwitchToRegister,
  onLogin,
}: LoginModalProps) {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState<string | null>(null);

  if (!isOpen) return null;

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();

    // Basic validation
    if (!email.trim()) {
      setError("Email is required");
      return;
    }

    if (!password.trim()) {
      setError("Password is required");
      return;
    }

    // Clear any previous errors
    setError(null);

    // Call the login function
    onLogin(email, password);
  };

  return (
    <div
      style={{
        position: "fixed",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: "rgba(0, 0, 0, 0.5)",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        zIndex: 1000,
      }}
      onClick={onClose}
    >
      <div
        onClick={(e) => e.stopPropagation()}
        style={{
          position: "relative",
          backgroundColor: "var(--surface)",
          color: "var(--text-primary)",
          borderRadius: "8px",
          padding: "24px",
          width: "400px",
          maxWidth: "90%",
          maxHeight: "90vh",
          overflowY: "auto",
          boxShadow: "0 4px 12px rgba(0, 0, 0, 0.15)",
        }}
      >
        <h2 style={{ marginTop: 0, color: "var(--accent)" }}>Log In</h2>

        {error && (
          <div
            style={{
              backgroundColor: "rgba(255, 0, 0, 0.1)",
              color: "red",
              padding: "10px",
              borderRadius: "4px",
              marginBottom: "16px",
            }}
          >
            {error}
          </div>
        )}

        <form onSubmit={handleSubmit}>
          <div style={{ marginBottom: "16px" }}>
            <label
              htmlFor="email"
              style={{
                display: "block",
                marginBottom: "6px",
                fontWeight: "bold",
              }}
            >
              Email
            </label>
            <input
              id="email"
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              style={{
                width: "100%",
                padding: "10px",
                borderRadius: "4px",
                border: "1px solid var(--border-color)",
                fontSize: "16px",
                backgroundColor: "var(--input-bg)",
                color: "var(--text-primary)",
              }}
              placeholder="Enter your email"
            />
          </div>

          <div style={{ marginBottom: "16px" }}>
            <label
              htmlFor="password"
              style={{
                display: "block",
                marginBottom: "6px",
                fontWeight: "bold",
              }}
            >
              Password
            </label>
            <input
              id="password"
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              style={{
                width: "100%",
                padding: "10px",
                borderRadius: "4px",
                border: "1px solid var(--border-color)",
                fontSize: "16px",
                backgroundColor: "var(--input-bg)",
                color: "var(--text-primary)",
              }}
              placeholder="Enter your password"
            />
          </div>

          <button
            type="submit"
            style={{
              width: "100%",
              padding: "12px",
              backgroundColor: "var(--accent)",
              color: "white",
              border: "none",
              borderRadius: "4px",
              fontSize: "16px",
              cursor: "pointer",
              marginBottom: "16px",
            }}
          >
            Log In
          </button>
        </form>

        <div style={{ textAlign: "center" }}>
          <p>
            Don&apos;t have an account?{" "}
            <button
              onClick={onSwitchToRegister}
              style={{
                background: "none",
                border: "none",
                color: "var(--accent)",
                cursor: "pointer",
                padding: 0,
                fontSize: "inherit",
                textDecoration: "underline",
              }}
            >
              Register
            </button>
          </p>
        </div>

        <button
          onClick={onClose}
          style={{
            position: "absolute",
            top: "16px",
            right: "16px",
            background: "none",
            border: "none",
            fontSize: "24px",
            cursor: "pointer",
            color: "var(--text-secondary)",
          }}
        >
          &times;
        </button>
      </div>
    </div>
  );
}
```

#### apps/web/src/components/auth/RegisterModal.tsx

```tsx
import React, { useState } from "react";

interface RegisterModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSwitchToLogin: () => void;
  onRegister: (
    username: string,
    firstName: string,
    lastName: string,
    email: string,
    password: string,
  ) => void;
}

export function RegisterModal({
  isOpen,
  onClose,
  onSwitchToLogin,
  onRegister,
}: RegisterModalProps) {
  const [username, setUsername] = useState("");
  const [firstName, setFirstName] = useState("");
  const [lastName, setLastName] = useState("");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");
  const [error, setError] = useState<string | null>(null);

  if (!isOpen) return null;

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();

    // Basic validation
    if (!username.trim()) {
      setError("Username is required");
      return;
    }

    if (!firstName.trim()) {
      setError("First name is required");
      return;
    }

    if (!lastName.trim()) {
      setError("Last name is required");
      return;
    }

    if (!email.trim()) {
      setError("Email is required");
      return;
    }

    if (!password.trim()) {
      setError("Password is required");
      return;
    }

    if (password !== confirmPassword) {
      setError("Passwords do not match");
      return;
    }

    // Validate username format
    if (!/^[a-zA-Z0-9_-]+$/.test(username)) {
      setError(
        "Username can only contain letters, numbers, underscores, and hyphens",
      );
      return;
    }

    // Clear any previous errors
    setError(null);

    // Call the register function
    onRegister(username, firstName, lastName, email, password);
  };

  return (
    <div
      style={{
        position: "fixed",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: "rgba(0, 0, 0, 0.5)",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        zIndex: 1000,
      }}
      onClick={onClose}
    >
      <div
        onClick={(e) => e.stopPropagation()}
        style={{
          position: "relative",
          backgroundColor: "var(--surface)",
          color: "var(--text-primary)",
          borderRadius: "8px",
          padding: "24px",
          width: "400px",
          maxWidth: "90%",
          maxHeight: "90vh",
          overflowY: "auto",
          boxShadow: "0 4px 12px rgba(0, 0, 0, 0.15)",
        }}
      >
        <h2 style={{ marginTop: 0, color: "var(--accent)" }}>Create Account</h2>

        {error && (
          <div
            style={{
              backgroundColor: "rgba(255, 0, 0, 0.1)",
              color: "red",
              padding: "10px",
              borderRadius: "4px",
              marginBottom: "16px",
            }}
          >
            {error}
          </div>
        )}

        <form onSubmit={handleSubmit}>
          <div style={{ marginBottom: "16px" }}>
            <label
              htmlFor="username"
              style={{
                display: "block",
                marginBottom: "6px",
                fontWeight: "bold",
              }}
            >
              Username
            </label>
            <input
              id="username"
              type="text"
              value={username}
              onChange={(e) => setUsername(e.target.value)}
              style={{
                width: "100%",
                padding: "10px",
                borderRadius: "4px",
                border: "1px solid var(--border-color)",
                fontSize: "16px",
                backgroundColor: "var(--input-bg)",
                color: "var(--text-primary)",
              }}
              placeholder="Choose a username"
            />
          </div>

          <div style={{ marginBottom: "16px" }}>
            <label
              htmlFor="firstName"
              style={{
                display: "block",
                marginBottom: "6px",
                fontWeight: "bold",
              }}
            >
              First Name
            </label>
            <input
              id="firstName"
              type="text"
              value={firstName}
              onChange={(e) => setFirstName(e.target.value)}
              style={{
                width: "100%",
                padding: "10px",
                borderRadius: "4px",
                border: "1px solid var(--border-color)",
                fontSize: "16px",
                backgroundColor: "var(--input-bg)",
                color: "var(--text-primary)",
              }}
              placeholder="Enter your first name"
            />
          </div>

          <div style={{ marginBottom: "16px" }}>
            <label
              htmlFor="lastName"
              style={{
                display: "block",
                marginBottom: "6px",
                fontWeight: "bold",
              }}
            >
              Last Name
            </label>
            <input
              id="lastName"
              type="text"
              value={lastName}
              onChange={(e) => setLastName(e.target.value)}
              style={{
                width: "100%",
                padding: "10px",
                borderRadius: "4px",
                border: "1px solid var(--border-color)",
                fontSize: "16px",
                backgroundColor: "var(--input-bg)",
                color: "var(--text-primary)",
              }}
              placeholder="Enter your last name"
            />
          </div>

          <div style={{ marginBottom: "16px" }}>
            <label
              htmlFor="email"
              style={{
                display: "block",
                marginBottom: "6px",
                fontWeight: "bold",
              }}
            >
              Email
            </label>
            <input
              id="email"
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              style={{
                width: "100%",
                padding: "10px",
                borderRadius: "4px",
                border: "1px solid var(--border-color)",
                fontSize: "16px",
                backgroundColor: "var(--input-bg)",
                color: "var(--text-primary)",
              }}
              placeholder="Enter your email"
            />
          </div>

          <div style={{ marginBottom: "16px" }}>
            <label
              htmlFor="password"
              style={{
                display: "block",
                marginBottom: "6px",
                fontWeight: "bold",
              }}
            >
              Password
            </label>
            <input
              id="password"
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              style={{
                width: "100%",
                padding: "10px",
                borderRadius: "4px",
                border: "1px solid var(--border-color)",
                fontSize: "16px",
                backgroundColor: "var(--input-bg)",
                color: "var(--text-primary)",
              }}
              placeholder="Create a password"
            />
          </div>

          <div style={{ marginBottom: "16px" }}>
            <label
              htmlFor="confirmPassword"
              style={{
                display: "block",
                marginBottom: "6px",
                fontWeight: "bold",
              }}
            >
              Confirm Password
            </label>
            <input
              id="confirmPassword"
              type="password"
              value={confirmPassword}
              onChange={(e) => setConfirmPassword(e.target.value)}
              style={{
                width: "100%",
                padding: "10px",
                borderRadius: "4px",
                border: "1px solid var(--border-color)",
                fontSize: "16px",
                backgroundColor: "var(--input-bg)",
                color: "var(--text-primary)",
              }}
              placeholder="Confirm your password"
            />
          </div>

          <button
            type="submit"
            style={{
              width: "100%",
              padding: "12px",
              backgroundColor: "var(--accent)",
              color: "white",
              border: "none",
              borderRadius: "4px",
              fontSize: "16px",
              cursor: "pointer",
              marginBottom: "16px",
            }}
          >
            Create Account
          </button>
        </form>

        <div style={{ textAlign: "center" }}>
          <p>
            Already have an account?{" "}
            <button
              onClick={onSwitchToLogin}
              style={{
                background: "none",
                border: "none",
                color: "var(--accent)",
                cursor: "pointer",
                padding: 0,
                fontSize: "inherit",
                textDecoration: "underline",
              }}
            >
              Log In
            </button>
          </p>
        </div>

        <button
          onClick={onClose}
          style={{
            position: "absolute",
            top: "16px",
            right: "16px",
            background: "none",
            border: "none",
            fontSize: "24px",
            cursor: "pointer",
            color: "var(--text-secondary)",
          }}
        >
          &times;
        </button>
      </div>
    </div>
  );
}
```

#### apps/web/src/components/auth/ResendVerification.tsx

```tsx
import React, { useState } from "react";

import { AuthClient } from "../../services/AuthClient";
import { Button } from "../ui/Button";
import { Card } from "../ui/Card";
import { Input } from "../ui/Input";
import { Spinner } from "../ui/Spinner";

// Define response type
interface VerificationResponse {
  status: "success" | "error";
  message?: string;
}

interface ApiResponse {
  success: boolean;
  error?: string;
}

// Define error response type
interface ApiError {
  response?: {
    status: number;
    data?: {
      message?: string;
    };
  };
  message: string;
}

/**
 * ResendVerification component
 * Allows users to request a new verification email
 */
export const ResendVerification: React.FC = () => {
  const [email, setEmail] = useState("");
  const [status, setStatus] = useState<
    "idle" | "loading" | "success" | "error"
  >("idle");
  const [message, setMessage] = useState("");
  const [countdown, setCountdown] = useState(0);
  const authClient = new AuthClient();

  const handleSubmitAsync = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!email) {
      setStatus("error");
      setMessage("Please enter your email address");
      return;
    }

    try {
      setStatus("loading");
      setMessage("Sending verification email...");

      const response = (await authClient.resendConfirmationEmail(
        email,
      )) as ApiResponse;
      const typedResponse: VerificationResponse = {
        status: response.success ? "success" : "error",
      };

      if (typedResponse.status === "success") {
        setStatus("success");
        setMessage("Verification email sent! Please check your inbox.");

        // Start countdown for rate limiting (60 seconds)
        setCountdown(60);
        const timer = setInterval(() => {
          setCountdown((prev) => {
            if (prev <= 1) {
              clearInterval(timer);
              return 0;
            }
            return prev - 1;
          });
        }, 1000);
      } else {
        setStatus("error");
        setMessage(
          response.error ||
            "Failed to send verification email. Please try again.",
        );
      }
    } catch (error) {
      const err = error as ApiError;
      setStatus("error");

      // Handle rate limiting error
      if (err.response?.status === 429) {
        setMessage("Please wait before requesting another email.");

        // Extract time from error message if available
        const timeMatch = err.response?.data?.message?.match(/(\d+)/);
        if (timeMatch && timeMatch[1]) {
          const seconds = parseInt(timeMatch[1], 10);
          setCountdown(seconds);

          const timer = setInterval(() => {
            setCountdown((prev) => {
              if (prev <= 1) {
                clearInterval(timer);
                return 0;
              }
              return prev - 1;
            });
          }, 1000);
        }
      } else {
        setMessage("An error occurred. Please try again later.");
      }

      console.error("Resend verification error:", err);
    }
  };

  // Wrapper function that returns void
  const handleSubmit = (e: React.FormEvent): void => {
    void handleSubmitAsync(e);
  };

  return (
    <div className="flex justify-center items-center min-h-screen bg-gray-100">
      <Card className="w-full max-w-md p-8">
        <div className="text-center mb-6">
          <h1 className="text-2xl font-bold">Resend Verification Email</h1>
          <p className="text-gray-600 mt-2">
            Enter your email address to receive a new verification link
          </p>
        </div>

        <form onSubmit={handleSubmit}>
          <div className="mb-4">
            <Input
              type="email"
              placeholder="Email address"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              disabled={status === "loading" || countdown > 0}
              required
            />
          </div>

          {status === "error" && (
            <div className="mb-4 p-3 bg-red-100 text-red-700 rounded">
              {message}
            </div>
          )}

          {status === "success" && (
            <div className="mb-4 p-3 bg-green-100 text-green-700 rounded">
              {message}
            </div>
          )}

          <Button
            type="submit"
            variant="primary"
            className="w-full"
            disabled={status === "loading" || countdown > 0}
          >
            {status === "loading" ? (
              <div className="mr-2">
                <Spinner size="sm" />
              </div>
            ) : countdown > 0 ? (
              `Resend (${countdown}s)`
            ) : (
              "Send Verification Email"
            )}
          </Button>
        </form>
      </Card>
    </div>
  );
};
```

#### apps/web/src/components/auth/VerificationModal.tsx

```tsx
import { useState } from "react";

import { AuthClient } from "../../services/AuthClient";

// Define response type
interface VerificationResponse {
  success: boolean;
  message?: string;
}

// Define error response type
interface ApiError {
  response?: {
    status: number;
    data?: {
      message?: string;
    };
  };
  message: string;
}

interface VerificationModalProps {
  isOpen: boolean;
  onClose: () => void;
  email: string;
}

export function VerificationModal({
  isOpen,
  onClose,
  email,
}: VerificationModalProps) {
  const [isResending, setIsResending] = useState(false);
  const [resendStatus, setResendStatus] = useState<
    "idle" | "success" | "error"
  >("idle");
  const [message, setMessage] = useState("");
  const [countdown, setCountdown] = useState(0);
  const authClient = new AuthClient();

  if (!isOpen) return null;

  const handleResendEmailAsync = async () => {
    if (isResending || countdown > 0) return;

    setIsResending(true);
    setResendStatus("idle");
    setMessage("");

    try {
      const response = (await authClient.resendConfirmationEmail(
        email,
      )) as VerificationResponse;

      if (response.success) {
        setResendStatus("success");
        setMessage("Verification email sent! Please check your inbox.");

        // Start countdown for rate limiting (60 seconds)
        setCountdown(60);
        const timer = setInterval(() => {
          setCountdown((prev) => {
            if (prev <= 1) {
              clearInterval(timer);
              return 0;
            }
            return prev - 1;
          });
        }, 1000);
      } else {
        setResendStatus("error");
        setMessage(
          response.message ||
            "Failed to send verification email. Please try again.",
        );
      }
    } catch (error) {
      const err = error as ApiError;
      setResendStatus("error");

      // Handle rate limiting error
      if (err.response?.status === 429) {
        setMessage("Please wait before requesting another email.");

        // Extract time from error message if available
        const timeMatch = err.response?.data?.message?.match(/(\d+)/);
        if (timeMatch && timeMatch[1]) {
          const seconds = parseInt(timeMatch[1], 10);
          setCountdown(seconds);

          const timer = setInterval(() => {
            setCountdown((prev) => {
              if (prev <= 1) {
                clearInterval(timer);
                return 0;
              }
              return prev - 1;
            });
          }, 1000);
        }
      } else {
        setMessage("An error occurred. Please try again later.");
      }

      console.error("Resend verification error:", err);
    } finally {
      setIsResending(false);
    }
  };

  // Wrapper function that returns void
  const handleResendEmail = (): void => {
    void handleResendEmailAsync();
  };

  return (
    <div
      style={{
        position: "fixed",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: "rgba(0, 0, 0, 0.5)",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        zIndex: 1000,
      }}
      onClick={onClose}
    >
      <div
        onClick={(e) => e.stopPropagation()}
        style={{
          position: "relative",
          backgroundColor: "var(--surface)",
          color: "var(--text-primary)",
          borderRadius: "8px",
          padding: "24px",
          width: "400px",
          maxWidth: "90%",
          maxHeight: "90vh",
          overflowY: "auto",
          boxShadow: "0 4px 12px rgba(0, 0, 0, 0.15)",
        }}
      >
        <h2 style={{ marginTop: 0, color: "var(--accent)" }}>
          Verify Your Email
        </h2>

        <div style={{ marginBottom: "20px" }}>
          <p>
            We&apos;ve sent a verification email to <strong>{email}</strong>.
            Please check your inbox and click the verification link to activate
            your account.
          </p>
          <p>If you don&apos;t see the email, please check your spam folder.</p>
        </div>

        {resendStatus === "success" && (
          <div
            style={{
              backgroundColor: "rgba(0, 255, 0, 0.1)",
              color: "green",
              padding: "10px",
              borderRadius: "4px",
              marginBottom: "16px",
            }}
          >
            {message}
          </div>
        )}

        {resendStatus === "error" && (
          <div
            style={{
              backgroundColor: "rgba(255, 0, 0, 0.1)",
              color: "red",
              padding: "10px",
              borderRadius: "4px",
              marginBottom: "16px",
            }}
          >
            {message}
          </div>
        )}

        <div
          style={{
            display: "flex",
            justifyContent: "space-between",
            marginTop: "20px",
          }}
        >
          <button
            onClick={onClose}
            style={{
              padding: "10px 16px",
              borderRadius: "4px",
              border: "1px solid var(--border-color)",
              backgroundColor: "transparent",
              color: "var(--text-primary)",
              cursor: "pointer",
              fontSize: "14px",
            }}
          >
            Close
          </button>

          <button
            onClick={handleResendEmail}
            disabled={isResending || countdown > 0}
            style={{
              padding: "10px 16px",
              borderRadius: "4px",
              border: "none",
              backgroundColor:
                isResending || countdown > 0
                  ? "var(--accent-disabled)"
                  : "var(--accent)",
              color: "white",
              cursor: isResending || countdown > 0 ? "not-allowed" : "pointer",
              fontSize: "14px",
            }}
          >
            {isResending
              ? "Sending..."
              : countdown > 0
                ? `Resend (${countdown}s)`
                : "Resend Email"}
          </button>
        </div>
      </div>
    </div>
  );
}
```

#### apps/web/src/components/auth/index.tsx

```tsx
export { AuthProvider, useAuth } from "./AuthContext";
export { AuthModal } from "./AuthModal";
export type { AuthModalType } from "./AuthModal";
export { VerificationModal } from "./VerificationModal";
```

#### apps/web/src/components/debug/DbTest.tsx

```tsx
import React, { useState } from "react";

import { useAuth } from "../auth/AuthContext";

export const DbTest: React.FC = () => {
  const { testDatabaseConnection } = useAuth();
  const [result, setResult] = useState<{
    success?: boolean;
    connected?: boolean;
    message?: string;
    timestamp?: string;
  }>({});
  const [loading, setLoading] = useState(false);

  const handleTestConnection = async () => {
    setLoading(true);
    try {
      const response = await testDatabaseConnection();
      setResult({
        ...response,
        timestamp: new Date().toISOString(),
      });
    } catch (error) {
      setResult({
        success: false,
        connected: false,
        message: error instanceof Error ? error.message : "Unknown error",
        timestamp: new Date().toISOString(),
      });
    } finally {
      setLoading(false);
    }
  };

  return (
    <div
      style={{
        padding: "15px",
        border: "1px solid #ccc",
        borderRadius: "5px",
        margin: "10px 0",
        backgroundColor: "#f8f9fa",
      }}
    >
      <h3>Database Connection Test</h3>
      <button
        onClick={handleTestConnection}
        disabled={loading}
        style={{
          padding: "8px 15px",
          backgroundColor: loading ? "#cccccc" : "#007bff",
          color: "white",
          border: "none",
          borderRadius: "4px",
          cursor: loading ? "not-allowed" : "pointer",
        }}
      >
        {loading ? "Testing..." : "Test Database Connection"}
      </button>

      {result.timestamp && (
        <div style={{ marginTop: "15px" }}>
          <div
            style={{
              padding: "10px",
              backgroundColor: result.connected ? "#d4edda" : "#f8d7da",
              border: `1px solid ${result.connected ? "#c3e6cb" : "#f5c6cb"}`,
              borderRadius: "4px",
              marginBottom: "10px",
            }}
          >
            <p>
              <strong>Status:</strong>{" "}
              {result.connected ? "Connected ✅" : "Failed to connect ❌"}
            </p>
            <p>
              <strong>Message:</strong> {result.message}
            </p>
            <p>
              <strong>Timestamp:</strong> {result.timestamp}
            </p>
          </div>
          <p>
            <small>Connection to: localhost:5432</small>
          </p>
        </div>
      )}
    </div>
  );
};
```

#### apps/web/src/components/debug/index.ts

```ts
export { DbTest } from "./DbTest";
```

#### apps/web/src/components/media/AudioPlayer.tsx

```tsx
import React, { useCallback, useEffect, useRef, useState } from "react";

import { formatDuration } from "../../helpers/formatters";

interface AudioPlayerProps {
  trackUrl: string;
  trackTitle: string;
  artistName: string;
  coverArtUrl?: string;
  autoplay?: boolean;
  onEnded?: () => void;
  onPlay?: () => void;
  onPause?: () => void;
}

const AudioPlayer: React.FC<AudioPlayerProps> = ({
  trackUrl,
  trackTitle,
  artistName,
  coverArtUrl,
  autoplay = false,
  onEnded,
  onPlay,
  onPause,
}) => {
  const [isPlaying, setIsPlaying] = useState(false);
  const [duration, setDuration] = useState(0);
  const [currentTime, setCurrentTime] = useState(0);
  const [volume, setVolume] = useState(0.8);

  const audioRef = useRef<HTMLAudioElement>(null);
  const progressRef = useRef<HTMLDivElement>(null);

  const playAudio = useCallback(() => {
    if (audioRef.current) {
      audioRef.current
        .play()
        .then(() => {
          setIsPlaying(true);
          if (onPlay) onPlay();
        })
        .catch((error) => {
          console.error("Play failed:", error);
        });
    }
  }, [onPlay]);

  const pauseAudio = useCallback(() => {
    if (audioRef.current) {
      audioRef.current.pause();
      setIsPlaying(false);
      if (onPause) onPause();
    }
  }, [onPause]);

  useEffect(() => {
    if (audioRef.current) {
      const audio = audioRef.current;

      const handleLoadedMetadata = () => {
        setDuration(audio.duration);
      };

      const handleTimeUpdate = () => {
        setCurrentTime(audio.currentTime);
      };

      const handleEnded = () => {
        setIsPlaying(false);
        if (onEnded) onEnded();
      };

      // Add event listeners
      audio.addEventListener("loadedmetadata", handleLoadedMetadata);
      audio.addEventListener("timeupdate", handleTimeUpdate);
      audio.addEventListener("ended", handleEnded);

      // Set volume
      audio.volume = volume;

      // Handle autoplay
      if (autoplay) {
        playAudio();
      }

      // Clean up
      return () => {
        audio.removeEventListener("loadedmetadata", handleLoadedMetadata);
        audio.removeEventListener("timeupdate", handleTimeUpdate);
        audio.removeEventListener("ended", handleEnded);
      };
    }
  }, [trackUrl, autoplay, playAudio, pauseAudio, volume, onEnded]);

  const togglePlay = () => {
    if (isPlaying) {
      pauseAudio();
    } else {
      playAudio();
    }
  };

  const handleProgressClick = (e: React.MouseEvent<HTMLDivElement>) => {
    if (progressRef.current && audioRef.current) {
      const progressRect = progressRef.current.getBoundingClientRect();
      const clickPosition = e.clientX - progressRect.left;
      const percentageClicked = clickPosition / progressRect.width;
      const newTime = duration * percentageClicked;

      audioRef.current.currentTime = newTime;
      setCurrentTime(newTime);
    }
  };

  const handleVolumeChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newVolume = parseFloat(e.target.value);
    setVolume(newVolume);

    if (audioRef.current) {
      audioRef.current.volume = newVolume;
    }
  };

  return (
    <div style={styles.audioPlayer}>
      <audio ref={audioRef} src={trackUrl} preload="metadata" />

      <div className="player-container">
        {coverArtUrl && (
          <div className="cover-art">
            <img src={coverArtUrl} alt={`${trackTitle} by ${artistName}`} />
          </div>
        )}

        <div className="player-controls">
          <div className="track-info">
            <h3 className="track-title">{trackTitle}</h3>
            <p className="artist-name">{artistName}</p>
          </div>

          <div className="controls">
            <button
              className="skip-back"
              aria-label="Skip back 15 seconds"
              onClick={() => {
                if (audioRef.current) {
                  audioRef.current.currentTime = Math.max(0, currentTime - 15);
                }
              }}
            >
              ⏪
            </button>

            <button
              className="play-pause"
              aria-label={isPlaying ? "Pause" : "Play"}
              onClick={togglePlay}
            >
              {isPlaying ? "⏸️" : "▶️"}
            </button>

            <button
              className="skip-forward"
              aria-label="Skip forward 15 seconds"
              onClick={() => {
                if (audioRef.current) {
                  audioRef.current.currentTime = Math.min(
                    duration,
                    currentTime + 15,
                  );
                }
              }}
            >
              ⏩
            </button>
          </div>

          <div className="progress-container">
            <div className="time-display">{formatDuration(currentTime)}</div>

            <div
              className="progress-bar"
              ref={progressRef}
              onClick={handleProgressClick}
            >
              <div
                className="progress-fill"
                style={{ width: `${(currentTime / duration) * 100}%` }}
              ></div>
            </div>

            <div className="time-display">{formatDuration(duration)}</div>
          </div>

          <div className="volume-control">
            <span className="volume-icon">🔊</span>
            <input
              type="range"
              min="0"
              max="1"
              step="0.01"
              value={volume}
              onChange={handleVolumeChange}
              className="volume-slider"
            />
          </div>
        </div>
      </div>
    </div>
  );
};

const styles = {
  audioPlayer: {
    width: "100%",
    maxWidth: "600px",
    background: "var(--background2)",
    borderRadius: "12px",
    padding: "20px",
    boxShadow: "0 4px 12px rgba(0, 0, 0, 0.1)",
    margin: "20px auto",
  },
  playerContainer: {
    display: "flex",
    alignItems: "center",
  },
  coverArt: {
    width: "100px",
    height: "100px",
    marginRight: "20px",
    flexShrink: 0,
  },
  coverArtImg: {
    width: "100%",
    height: "100%",
    objectFit: "cover",
    borderRadius: "8px",
  },
  playerControls: {
    flexGrow: 1,
  },
  trackTitle: {
    margin: "0 0 5px 0",
    fontSize: "18px",
    color: "var(--text-color)",
  },
  artistName: {
    margin: 0,
    fontSize: "14px",
    color: "var(--text-color2)",
  },
  controls: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    margin: "15px 0",
  },
  controlsButton: {
    background: "transparent",
    border: "none",
    cursor: "pointer",
    fontSize: "24px",
    padding: "5px 15px",
    borderRadius: "50%",
    transition: "background-color 0.2s",
  },
  controlsButtonHover: {
    backgroundColor: "var(--hover)",
  },
  playPause: {
    margin: "0 15px",
  },
  progressContainer: {
    display: "flex",
    alignItems: "center",
    marginBottom: "15px",
  },
  timeDisplay: {
    fontSize: "12px",
    color: "var(--text-color2)",
    width: "45px",
  },
  progressBar: {
    flexGrow: 1,
    height: "6px",
    backgroundColor: "var(--transparent2)",
    borderRadius: "3px",
    margin: "0 10px",
    cursor: "pointer",
    position: "relative",
  },
  progressFill: {
    position: "absolute",
    top: 0,
    left: 0,
    height: "100%",
    backgroundColor: "var(--blue)",
    borderRadius: "3px",
  },
  volumeControl: {
    display: "flex",
    alignItems: "center",
  },
  volumeIcon: {
    marginRight: "10px",
    fontSize: "16px",
  },
  volumeSlider: {
    "-webkit-appearance": "none",
    width: "100px",
    height: "4px",
    background: "var(--transparent2)",
    borderRadius: "2px",
    outline: "none",
  },
  volumeSliderThumb: {
    "-webkit-appearance": "none",
    width: "12px",
    height: "12px",
    borderRadius: "50%",
    background: "var(--blue)",
    cursor: "pointer",
  },
};

export default AudioPlayer;
```

#### apps/web/src/components/media/ImageGallery.tsx

```tsx
import React, { useCallback, useEffect, useRef, useState } from "react";

import { imageGalleryStyles } from "../../styles";
import { mergeStyles } from "../../utils/styleUtils";

// Define interface for document with vendor prefixed fullscreen properties
interface DocumentWithFullscreen extends Document {
  webkitFullscreenElement?: Element | null;
  mozFullScreenElement?: Element | null;
  webkitExitFullscreen?: () => Promise<void>;
  mozCancelFullScreen?: () => Promise<void>;
}

interface ElementWithFullscreen extends HTMLElement {
  webkitRequestFullscreen?: () => Promise<void>;
  mozRequestFullScreen?: () => Promise<void>;
}

interface ImageItem {
  src: string;
  width: number;
  height: number;
  alt?: string;
}

interface ImageGalleryProps {
  images: ImageItem[];
  aspectRatio?: number; // width/height ratio, default 1:1 (square)
  showThumbnails?: boolean;
  showNavigation?: boolean;
  initialIndex?: number;
  autoPlay?: boolean;
  autoPlayInterval?: number; // in milliseconds
  onImageChange?: (index: number) => void;
  onClick?: (index: number) => void;
}

const ImageGallery: React.FC<ImageGalleryProps> = ({
  images,
  aspectRatio = 1,
  showThumbnails = true,
  showNavigation = true,
  initialIndex = 0,
  autoPlay = false,
  autoPlayInterval = 3000,
  onImageChange,
  onClick,
}) => {
  const [currentIndex, setCurrentIndex] = useState(initialIndex);
  const [touchStartX, setTouchStartX] = useState(0);
  const [isSwiping, setIsSwiping] = useState(false);
  const [swipeDistance, setSwipeDistance] = useState(0);
  const [isFullscreen, setIsFullscreen] = useState(false);

  const galleryRef = useRef<HTMLDivElement>(null);
  const autoPlayRef = useRef<NodeJS.Timeout | null>(null);

  const isSingleImage = images.length === 1;

  // Reset current index if images change
  useEffect(() => {
    setCurrentIndex(initialIndex < images.length ? initialIndex : 0);
  }, [images, initialIndex]);

  const goToNextImage = useCallback(() => {
    setCurrentIndex((prevIndex) => {
      const nextIndex = (prevIndex + 1) % images.length;
      if (onImageChange) onImageChange(nextIndex);
      return nextIndex;
    });
  }, [images.length, onImageChange]);

  // Handle autoplay
  useEffect(() => {
    if (autoPlayRef.current) {
      clearInterval(autoPlayRef.current);
      autoPlayRef.current = null;
    }

    if (autoPlay && images.length > 1) {
      autoPlayRef.current = setInterval(() => {
        goToNextImage();
      }, autoPlayInterval);
    }

    return () => {
      if (autoPlayRef.current) {
        clearInterval(autoPlayRef.current);
      }
    };
  }, [autoPlay, autoPlayInterval, currentIndex, images.length, goToNextImage]);

  // Handle fullscreen changes
  useEffect(() => {
    const handleFullscreenChange = () => {
      setIsFullscreen(
        Boolean(
          document.fullscreenElement ||
            (document as DocumentWithFullscreen).webkitFullscreenElement ||
            (document as DocumentWithFullscreen).mozFullScreenElement,
        ),
      );
    };

    document.addEventListener("fullscreenchange", handleFullscreenChange);
    document.addEventListener("webkitfullscreenchange", handleFullscreenChange);
    document.addEventListener("mozfullscreenchange", handleFullscreenChange);

    return () => {
      document.removeEventListener("fullscreenchange", handleFullscreenChange);
      document.removeEventListener(
        "webkitfullscreenchange",
        handleFullscreenChange,
      );
      document.removeEventListener(
        "mozfullscreenchange",
        handleFullscreenChange,
      );
    };
  }, []);

  const goToPrevImage = () => {
    setCurrentIndex((prevIndex) => {
      const nextIndex = (prevIndex - 1 + images.length) % images.length;
      if (onImageChange) onImageChange(nextIndex);
      return nextIndex;
    });
  };

  const handleThumbnailClick = (index: number) => {
    setCurrentIndex(index);
    if (onImageChange) onImageChange(index);
  };

  const handleTouchStart = (e: React.TouchEvent) => {
    setTouchStartX(e.touches[0].clientX);
    setIsSwiping(true);
    setSwipeDistance(0);
  };

  const handleTouchMove = (e: React.TouchEvent) => {
    if (!isSwiping) return;

    const currentX = e.touches[0].clientX;
    const distance = currentX - touchStartX;
    setSwipeDistance(distance);
  };

  const handleTouchEnd = () => {
    if (!isSwiping) return;

    if (swipeDistance > 50) {
      goToPrevImage();
    } else if (swipeDistance < -50) {
      goToNextImage();
    }

    setIsSwiping(false);
    setSwipeDistance(0);
  };

  const handleImageClick = () => {
    if (onClick) {
      onClick(currentIndex);
    } else if (images.length > 1 && !isFullscreen) {
      goToNextImage();
    }
  };

  const toggleFullscreen = () => {
    if (!galleryRef.current) return;

    if (isFullscreen) {
      if (document.exitFullscreen) {
        void document.exitFullscreen();
      } else if ((document as DocumentWithFullscreen).webkitExitFullscreen) {
        void (document as DocumentWithFullscreen).webkitExitFullscreen?.();
      } else if ((document as DocumentWithFullscreen).mozCancelFullScreen) {
        void (document as DocumentWithFullscreen).mozCancelFullScreen?.();
      }
    } else {
      if (galleryRef.current.requestFullscreen) {
        void galleryRef.current.requestFullscreen();
      } else if (
        (galleryRef.current as ElementWithFullscreen).webkitRequestFullscreen
      ) {
        void (
          galleryRef.current as ElementWithFullscreen
        ).webkitRequestFullscreen?.();
      } else if (
        (galleryRef.current as ElementWithFullscreen).mozRequestFullScreen
      ) {
        void (
          galleryRef.current as ElementWithFullscreen
        ).mozRequestFullScreen?.();
      }
    }
  };

  // If no images, return nothing
  if (!images.length) return null;

  return (
    <div style={{ position: "relative", width: "100%", maxWidth: "100%" }}>
      <div
        ref={galleryRef}
        style={mergeStyles(
          imageGalleryStyles.imageGallery as React.CSSProperties,
          { aspectRatio: aspectRatio.toString() },
          isFullscreen
            ? (imageGalleryStyles.imageGalleryFullscreen as React.CSSProperties)
            : {},
        )}
      >
        <div
          style={imageGalleryStyles.galleryMain as React.CSSProperties}
          onTouchStart={handleTouchStart}
          onTouchMove={handleTouchMove}
          onTouchEnd={handleTouchEnd}
        >
          {images.map((image, index) => (
            <div
              key={index}
              style={mergeStyles(
                imageGalleryStyles.galleryImageContainer as React.CSSProperties,
                {
                  transform: isSwiping
                    ? `translateX(calc(-${currentIndex * 100}% + ${swipeDistance}px))`
                    : `translateX(-${currentIndex * 100}%)`,
                },
              )}
            >
              <img
                src={image.src}
                alt={image.alt || `Image ${index + 1}`}
                style={mergeStyles(
                  imageGalleryStyles.galleryImage as React.CSSProperties,
                  isFullscreen
                    ? (imageGalleryStyles.imageGalleryFullscreenImage as React.CSSProperties)
                    : {},
                )}
                onClick={handleImageClick}
              />
            </div>
          ))}

          {!isSingleImage && showNavigation && (
            <>
              <button
                style={mergeStyles(
                  imageGalleryStyles.galleryNav as React.CSSProperties,
                  imageGalleryStyles.galleryPrev as React.CSSProperties,
                )}
                onClick={goToPrevImage}
                aria-label="Previous image"
                onMouseOver={(e) => {
                  e.currentTarget.style.opacity = "1";
                }}
                onMouseOut={(e) => {
                  e.currentTarget.style.opacity = "0.7";
                }}
              >
                ◀
              </button>
              <button
                style={mergeStyles(
                  imageGalleryStyles.galleryNav as React.CSSProperties,
                  imageGalleryStyles.galleryNext as React.CSSProperties,
                )}
                onClick={goToNextImage}
                aria-label="Next image"
                onMouseOver={(e) => {
                  e.currentTarget.style.opacity = "1";
                }}
                onMouseOut={(e) => {
                  e.currentTarget.style.opacity = "0.7";
                }}
              >
                ▶
              </button>
            </>
          )}

          <button
            style={imageGalleryStyles.galleryFullscreen as React.CSSProperties}
            onClick={toggleFullscreen}
            aria-label={isFullscreen ? "Exit fullscreen" : "Enter fullscreen"}
            onMouseOver={(e) => {
              e.currentTarget.style.opacity = "1";
            }}
            onMouseOut={(e) => {
              e.currentTarget.style.opacity = "0.7";
            }}
          >
            {isFullscreen ? "↙️" : "↗️"}
          </button>
        </div>

        {!isSingleImage && showThumbnails && (
          <div
            style={imageGalleryStyles.galleryThumbnails as React.CSSProperties}
          >
            {images.map((image, index) => (
              <div
                key={index}
                style={mergeStyles(
                  imageGalleryStyles.galleryThumbnail as React.CSSProperties,
                  index === currentIndex
                    ? (imageGalleryStyles.galleryThumbnailActive as React.CSSProperties)
                    : {},
                )}
                onClick={() => handleThumbnailClick(index)}
                onMouseOver={(e) => {
                  if (index !== currentIndex) {
                    e.currentTarget.style.opacity = "0.9";
                  }
                }}
                onMouseOut={(e) => {
                  if (index !== currentIndex) {
                    e.currentTarget.style.opacity = "0.7";
                  }
                }}
              >
                <img
                  src={image.src}
                  alt={`Thumbnail ${index + 1}`}
                  style={
                    imageGalleryStyles.galleryThumbnailImg as React.CSSProperties
                  }
                />
              </div>
            ))}
          </div>
        )}

        {!isSingleImage && (
          <div
            style={imageGalleryStyles.galleryIndicators as React.CSSProperties}
          >
            {images.map((_, index) => (
              <button
                key={index}
                style={mergeStyles(
                  imageGalleryStyles.galleryIndicator as React.CSSProperties,
                  index === currentIndex
                    ? (imageGalleryStyles.galleryIndicatorActive as React.CSSProperties)
                    : {},
                )}
                onClick={() => handleThumbnailClick(index)}
                aria-label={`Go to image ${index + 1}`}
              />
            ))}
          </div>
        )}
      </div>
    </div>
  );
};

export default ImageGallery;
```

#### apps/web/src/components/media/MediaGallery.tsx

```tsx
import React, { useCallback, useEffect, useRef, useState } from "react";

interface MediaItem {
  id: string;
  src: string;
  type: "image" | "video" | "audio";
  title?: string;
  thumbnail?: string;
  description?: string;
  duration?: number;
}

interface MediaGalleryProps {
  items: MediaItem[];
  columns?: number;
  gap?: number;
  className?: string;
}

export const MediaGallery: React.FC<MediaGalleryProps> = ({
  items,
  columns = 3,
  gap = 16,
  className,
}) => {
  const [selectedItem, setSelectedItem] = useState<MediaItem | null>(null);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [isPlaying, setIsPlaying] = useState(false);
  const [volume, setVolume] = useState(1);
  const [isMuted, setIsMuted] = useState(false);
  const [_isFullscreen, setIsFullscreen] = useState(false);
  const videoRef = useRef<HTMLVideoElement>(null);
  const audioRef = useRef<HTMLAudioElement>(null);
  const mediaRef = selectedItem?.type === "video" ? videoRef : audioRef;

  const styles = {
    gallery: {
      display: "grid",
      gridTemplateColumns: `repeat(${columns}, 1fr)`,
      gap: `${gap}px`,
      padding: "16px",
      ...(className && { className }),
    },
    item: {
      position: "relative" as const,
      aspectRatio: "1",
      cursor: "pointer",
      overflow: "hidden",
      borderRadius: "8px",
      backgroundColor: "#f5f5f5",
      transition: "transform 0.2s ease",
      "&:hover": {
        transform: "scale(1.02)",
      },
    },
    thumbnail: {
      width: "100%",
      height: "100%",
      objectFit: "cover" as const,
    },
    overlay: {
      position: "absolute" as const,
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: "rgba(0, 0, 0, 0.5)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      opacity: 0,
      transition: "opacity 0.2s ease",
      "&:hover": {
        opacity: 1,
      },
    },
    title: {
      color: "white",
      fontSize: "1rem",
      fontWeight: 500,
      textAlign: "center" as const,
      padding: "8px",
    },
    modal: {
      position: "fixed" as const,
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: "rgba(0, 0, 0, 0.9)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      zIndex: 1000,
    },
    modalContent: {
      position: "relative" as const,
      maxWidth: "90vw",
      maxHeight: "90vh",
      backgroundColor: "#fff",
      borderRadius: "8px",
      overflow: "hidden",
    },
    closeButton: {
      position: "absolute" as const,
      top: "16px",
      right: "16px",
      backgroundColor: "rgba(0, 0, 0, 0.5)",
      color: "white",
      border: "none",
      borderRadius: "50%",
      width: "32px",
      height: "32px",
      cursor: "pointer",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      transition: "background-color 0.2s",
      "&:hover": {
        backgroundColor: "rgba(0, 0, 0, 0.7)",
      },
    },
    media: {
      maxWidth: "100%",
      maxHeight: "90vh",
      objectFit: "contain" as const,
    },
    controls: {
      position: "absolute" as const,
      bottom: 0,
      left: 0,
      right: 0,
      padding: "16px",
      backgroundColor: "rgba(0, 0, 0, 0.7)",
      display: "flex",
      alignItems: "center",
      gap: "16px",
    },
    playButton: {
      backgroundColor: "transparent",
      border: "none",
      color: "white",
      cursor: "pointer",
      padding: "8px",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
    },
    timeSlider: {
      flex: 1,
      height: "4px",
      backgroundColor: "rgba(255, 255, 255, 0.3)",
      borderRadius: "2px",
      cursor: "pointer",
      "&:hover": {
        backgroundColor: "rgba(255, 255, 255, 0.5)",
      },
    },
    timeFill: {
      height: "100%",
      backgroundColor: "#2196f3",
      borderRadius: "2px",
      width: `${(currentTime / duration) * 100}%`,
    },
    volumeControl: {
      display: "flex",
      alignItems: "center",
      gap: "8px",
    },
    volumeSlider: {
      width: "100px",
      height: "4px",
      backgroundColor: "rgba(255, 255, 255, 0.3)",
      borderRadius: "2px",
      cursor: "pointer",
      "&:hover": {
        backgroundColor: "rgba(255, 255, 255, 0.5)",
      },
    },
    volumeFill: {
      height: "100%",
      backgroundColor: "#2196f3",
      borderRadius: "2px",
      width: `${volume * 100}%`,
    },
    timeDisplay: {
      color: "white",
      fontSize: "0.875rem",
      minWidth: "100px",
    },
  };

  useEffect(() => {
    if (selectedItem) {
      setIsPlaying(false);
      setCurrentTime(0);
      setDuration(0);
      setVolume(1);
      setIsMuted(false);
      setIsFullscreen(false);
    }
  }, [selectedItem]);

  const handleTimeUpdate = useCallback(() => {
    if (mediaRef.current) {
      setCurrentTime(mediaRef.current.currentTime);
    }
  }, [mediaRef]);

  const handleLoadedMetadata = useCallback(() => {
    if (mediaRef.current) {
      setDuration(mediaRef.current.duration);
    }
  }, [mediaRef]);

  const handleEnded = useCallback(() => {
    setIsPlaying(false);
    setCurrentTime(0);
  }, []);

  useEffect(() => {
    const currentMedia = mediaRef.current;

    if (currentMedia) {
      currentMedia.addEventListener("timeupdate", handleTimeUpdate);
      currentMedia.addEventListener("loadedmetadata", handleLoadedMetadata);
      currentMedia.addEventListener("ended", handleEnded);
    }

    return () => {
      if (currentMedia) {
        currentMedia.removeEventListener("timeupdate", handleTimeUpdate);
        currentMedia.removeEventListener(
          "loadedmetadata",
          handleLoadedMetadata,
        );
        currentMedia.removeEventListener("ended", handleEnded);
      }
    };
  }, [mediaRef, handleTimeUpdate, handleLoadedMetadata, handleEnded]);

  const togglePlay = () => {
    if (mediaRef.current) {
      if (isPlaying) {
        void mediaRef.current.pause();
      } else {
        void mediaRef.current.play();
      }
      setIsPlaying(!isPlaying);
    }
  };

  const toggleMute = () => {
    if (mediaRef.current) {
      mediaRef.current.muted = !isMuted;
      setIsMuted(!isMuted);
    }
  };

  const formatTime = (time: number): string => {
    const minutes = Math.floor(time / 60);
    const seconds = Math.floor(time % 60);
    return `${minutes}:${seconds.toString().padStart(2, "0")}`;
  };

  return (
    <>
      <div style={styles.gallery}>
        {items.map((item) => (
          <div
            key={item.id}
            style={styles.item}
            onClick={() => setSelectedItem(item)}
          >
            <img
              src={item.thumbnail || item.src}
              alt={item.title || ""}
              style={styles.thumbnail}
            />
            <div style={styles.overlay}>
              <h3 style={styles.title}>{item.title}</h3>
            </div>
          </div>
        ))}
      </div>

      {selectedItem && (
        <div style={styles.modal} onClick={() => setSelectedItem(null)}>
          <div style={styles.modalContent} onClick={(e) => e.stopPropagation()}>
            <button
              style={styles.closeButton}
              onClick={() => setSelectedItem(null)}
            >
              ×
            </button>

            {selectedItem.type === "image" ? (
              <img
                src={selectedItem.src}
                alt={selectedItem.title || ""}
                style={styles.media}
              />
            ) : selectedItem.type === "video" ? (
              <video
                ref={videoRef}
                src={selectedItem.src}
                style={styles.media}
                onTimeUpdate={handleTimeUpdate}
                onLoadedMetadata={handleLoadedMetadata}
                onEnded={handleEnded}
              />
            ) : (
              <audio
                ref={audioRef}
                src={selectedItem.src}
                onTimeUpdate={handleTimeUpdate}
                onLoadedMetadata={handleLoadedMetadata}
                onEnded={handleEnded}
              />
            )}

            {(selectedItem.type === "video" ||
              selectedItem.type === "audio") && (
              <div style={styles.controls}>
                <button style={styles.playButton} onClick={togglePlay}>
                  {isPlaying ? "⏸" : "▶"}
                </button>

                <div style={styles.timeSlider}>
                  <div style={styles.timeFill} />
                </div>

                <div style={styles.timeDisplay}>
                  {formatTime(currentTime)} / {formatTime(duration)}
                </div>

                <div style={styles.volumeControl}>
                  <button style={styles.playButton} onClick={toggleMute}>
                    {isMuted ? "🔇" : "🔊"}
                  </button>
                  <div style={styles.volumeSlider}>
                    <div
                      style={{
                        ...styles.volumeFill,
                        width: `${volume * 100}%`,
                      }}
                    />
                  </div>
                </div>
              </div>
            )}
          </div>
        </div>
      )}
    </>
  );
};
```

#### apps/web/src/components/media/VideoPlayer.tsx

```tsx
import React, { useEffect, useRef, useState } from "react";

import { formatDuration } from "../../helpers/formatters";
import { videoPlayerStyles } from "../../styles";
import { mergeStyles } from "../../utils/styleUtils";

// Define interface for document with vendor-specific fullscreen properties
interface DocumentWithFullscreen extends Document {
  webkitFullscreenElement?: Element | null;
  mozFullScreenElement?: Element | null;
  webkitExitFullscreen?: () => Promise<void>;
  mozCancelFullScreen?: () => Promise<void>;
}

// Define interface for element with vendor-specific fullscreen methods
interface ElementWithFullscreen extends HTMLDivElement {
  webkitRequestFullscreen?: () => Promise<void>;
  mozRequestFullScreen?: () => Promise<void>;
}

interface VideoSource {
  src: string;
  quality: string;
  type: string;
}

interface VideoPlayerProps {
  sources: VideoSource[];
  poster?: string;
  title?: string;
  autoplay?: boolean;
  loop?: boolean;
  muted?: boolean;
  controls?: boolean;
  width?: number | string;
  height?: number | string;
  onPlay?: () => void;
  onPause?: () => void;
  onEnded?: () => void;
  onTimeUpdate?: (currentTime: number) => void;
  onQualityChange?: (quality: string) => void;
}

const VideoPlayer: React.FC<VideoPlayerProps> = ({
  sources,
  poster,
  title,
  autoplay = false,
  loop = false,
  muted = false,
  controls = true,
  width = "100%",
  height = "auto",
  onPlay,
  onPause,
  onEnded,
  onTimeUpdate,
  onQualityChange,
}) => {
  const [playing, setPlaying] = useState(autoplay);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [volume, setVolume] = useState(muted ? 0 : 1);
  const [showControls, setShowControls] = useState(false);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [selectedQuality, setSelectedQuality] = useState<string>(
    sources[0]?.quality || "auto",
  );
  const [showQualityMenu, setShowQualityMenu] = useState(false);

  const videoRef = useRef<HTMLVideoElement>(null);
  const playerRef = useRef<HTMLDivElement>(null);
  const progressRef = useRef<HTMLDivElement>(null);

  // Sort sources by quality (high to low)
  const sortedSources = [...sources].sort((a, b) => {
    // Extract numeric value from quality string (e.g., '720p' -> 720)
    const qualityA = parseInt(a.quality.replace(/[^\d]/g, ""), 10) || 0;
    const qualityB = parseInt(b.quality.replace(/[^\d]/g, ""), 10) || 0;
    return qualityB - qualityA;
  });

  // Get active source based on selected quality
  const activeSource =
    sortedSources.find((source) => source.quality === selectedQuality) ||
    sortedSources[0];

  useEffect(() => {
    const video = videoRef.current;
    if (!video) return;

    const handleTimeUpdate = () => {
      setCurrentTime(video.currentTime);
      if (onTimeUpdate) onTimeUpdate(video.currentTime);
    };

    const handleLoadedMetadata = () => {
      setDuration(video.duration);
    };

    const handlePlay = () => {
      setPlaying(true);
      if (onPlay) onPlay();
    };

    const handlePause = () => {
      setPlaying(false);
      if (onPause) onPause();
    };

    const handleEnded = () => {
      setPlaying(false);
      if (onEnded) onEnded();
    };

    // Set up event listeners
    video.addEventListener("timeupdate", handleTimeUpdate);
    video.addEventListener("loadedmetadata", handleLoadedMetadata);
    video.addEventListener("play", handlePlay);
    video.addEventListener("pause", handlePause);
    video.addEventListener("ended", handleEnded);

    // Set initial volume
    video.volume = volume;

    // Clean up event listeners
    return () => {
      video.removeEventListener("timeupdate", handleTimeUpdate);
      video.removeEventListener("loadedmetadata", handleLoadedMetadata);
      video.removeEventListener("play", handlePlay);
      video.removeEventListener("pause", handlePause);
      video.removeEventListener("ended", handleEnded);
    };
  }, [onPlay, onPause, onEnded, onTimeUpdate, volume]);

  // Handle fullscreen
  useEffect(() => {
    const handleFullscreenChange = () => {
      const doc = document as DocumentWithFullscreen;
      setIsFullscreen(
        Boolean(
          document.fullscreenElement ||
            doc.webkitFullscreenElement ||
            doc.mozFullScreenElement,
        ),
      );
    };

    document.addEventListener("fullscreenchange", handleFullscreenChange);
    document.addEventListener("webkitfullscreenchange", handleFullscreenChange);
    document.addEventListener("mozfullscreenchange", handleFullscreenChange);

    return () => {
      document.removeEventListener("fullscreenchange", handleFullscreenChange);
      document.removeEventListener(
        "webkitfullscreenchange",
        handleFullscreenChange,
      );
      document.removeEventListener(
        "mozfullscreenchange",
        handleFullscreenChange,
      );
    };
  }, []);

  const togglePlay = () => {
    if (!videoRef.current) return;

    if (playing) {
      videoRef.current.pause();
    } else {
      void videoRef.current.play();
    }
  };

  const seekTo = (e: React.MouseEvent<HTMLDivElement>) => {
    if (!progressRef.current || !videoRef.current) return;

    const progressRect = progressRef.current.getBoundingClientRect();
    const clickPosition = e.clientX - progressRect.left;
    const seekPercentage = clickPosition / progressRect.width;
    const seekTime = duration * seekPercentage;

    videoRef.current.currentTime = seekTime;
    setCurrentTime(seekTime);
  };

  const changeVolume = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newVolume = parseFloat(e.target.value);
    setVolume(newVolume);

    if (videoRef.current) {
      videoRef.current.volume = newVolume;
      videoRef.current.muted = newVolume === 0;
    }
  };

  const toggleMute = () => {
    if (!videoRef.current) return;

    if (volume === 0) {
      // Unmute and restore last volume
      const newVolume = 0.5;
      setVolume(newVolume);
      videoRef.current.volume = newVolume;
      videoRef.current.muted = false;
    } else {
      // Mute
      setVolume(0);
      videoRef.current.volume = 0;
      videoRef.current.muted = true;
    }
  };

  const toggleFullscreen = () => {
    if (!playerRef.current) return;

    if (isFullscreen) {
      const doc = document as DocumentWithFullscreen;
      if (document.exitFullscreen) {
        void document.exitFullscreen();
      } else if (doc.webkitExitFullscreen) {
        void doc.webkitExitFullscreen();
      } else if (doc.mozCancelFullScreen) {
        void doc.mozCancelFullScreen();
      }
    } else {
      const element = playerRef.current as ElementWithFullscreen;
      if (element.requestFullscreen) {
        void element.requestFullscreen();
      } else if (element.webkitRequestFullscreen) {
        void element.webkitRequestFullscreen();
      } else if (element.mozRequestFullScreen) {
        void element.mozRequestFullScreen();
      }
    }
  };

  const changeQuality = (quality: string) => {
    // Remember current playback time
    const currentPlaybackTime = videoRef.current?.currentTime || 0;
    const isPlaying = !videoRef.current?.paused;

    setSelectedQuality(quality);
    setShowQualityMenu(false);

    if (onQualityChange) {
      onQualityChange(quality);
    }

    // Let the video load and then restore playback state
    setTimeout(() => {
      if (videoRef.current) {
        videoRef.current.currentTime = currentPlaybackTime;
        if (isPlaying) {
          void videoRef.current.play();
        }
      }
    }, 0);
  };

  // Format buffered time for the progress bar
  const getBufferedTime = () => {
    if (!videoRef.current) return 0;

    const video = videoRef.current;
    if (video.buffered.length === 0) return 0;

    // Return the end time of the last buffered range
    return video.buffered.end(video.buffered.length - 1);
  };

  return (
    <div
      style={mergeStyles(videoPlayerStyles.videoPlayer as React.CSSProperties, {
        width,
        height,
      })}
      ref={playerRef}
      onMouseEnter={() => setShowControls(true)}
      onMouseLeave={() => setShowControls(false)}
    >
      <div style={videoPlayerStyles.videoContainer as React.CSSProperties}>
        <video
          ref={videoRef}
          style={videoPlayerStyles.videoElement as React.CSSProperties}
          poster={poster}
          autoPlay={autoplay}
          loop={loop}
          muted={muted}
          playsInline
        >
          <source src={activeSource.src} type={activeSource.type} />
          Your browser does not support the video tag.
        </video>

        <div
          style={mergeStyles(
            videoPlayerStyles.videoOverlay as React.CSSProperties,
            showControls || !playing
              ? (videoPlayerStyles.videoOverlayVisible as React.CSSProperties)
              : {},
          )}
          onClick={togglePlay}
        >
          {!playing && (
            <button
              style={videoPlayerStyles.playButton as React.CSSProperties}
              onClick={togglePlay}
              onMouseOver={(e) => {
                Object.assign(e.currentTarget.style, {
                  transform: "scale(1.1)",
                  background: "rgba(0, 0, 0, 0.8)",
                });
              }}
              onMouseOut={(e) => {
                Object.assign(e.currentTarget.style, {
                  transform: "scale(1)",
                  background: "rgba(0, 0, 0, 0.7)",
                });
              }}
            >
              ▶
            </button>
          )}
        </div>

        {controls && (
          <div
            style={mergeStyles(
              videoPlayerStyles.controls as React.CSSProperties,
              showControls || !playing
                ? (videoPlayerStyles.controlsVisible as React.CSSProperties)
                : {},
            )}
            onClick={(e) => e.stopPropagation()}
          >
            <div
              style={videoPlayerStyles.progressContainer as React.CSSProperties}
              ref={progressRef}
              onClick={seekTo}
            >
              <div
                style={mergeStyles(
                  videoPlayerStyles.progressBar as React.CSSProperties,
                  {
                    width: `${(currentTime / duration) * 100}%`,
                  },
                )}
              />
              <div
                style={mergeStyles(
                  videoPlayerStyles.progressBar as React.CSSProperties,
                  {
                    width: `${(getBufferedTime() / duration) * 100}%`,
                    opacity: 0.3,
                  },
                )}
              />
            </div>

            <div style={videoPlayerStyles.controlsRow as React.CSSProperties}>
              <div
                style={videoPlayerStyles.controlsGroup as React.CSSProperties}
              >
                <button
                  style={videoPlayerStyles.controlButton as React.CSSProperties}
                  onClick={togglePlay}
                  onMouseOver={(e) => {
                    e.currentTarget.style.opacity = "1";
                  }}
                  onMouseOut={(e) => {
                    e.currentTarget.style.opacity = "0.8";
                  }}
                >
                  {playing ? "⏸" : "▶"}
                </button>

                <div
                  style={
                    videoPlayerStyles.volumeContainer as React.CSSProperties
                  }
                >
                  <button
                    style={
                      videoPlayerStyles.controlButton as React.CSSProperties
                    }
                    onClick={toggleMute}
                    onMouseOver={(e) => {
                      e.currentTarget.style.opacity = "1";
                    }}
                    onMouseOut={(e) => {
                      e.currentTarget.style.opacity = "0.8";
                    }}
                  >
                    {volume === 0 ? "🔇" : volume < 0.5 ? "🔉" : "🔊"}
                  </button>
                  <input
                    type="range"
                    min="0"
                    max="1"
                    step="0.1"
                    value={volume}
                    onChange={changeVolume}
                    style={
                      videoPlayerStyles.volumeSlider as React.CSSProperties
                    }
                  />
                </div>

                <span
                  style={videoPlayerStyles.timeDisplay as React.CSSProperties}
                >
                  {formatDuration(currentTime)} / {formatDuration(duration)}
                </span>
              </div>

              <div
                style={videoPlayerStyles.controlsGroup as React.CSSProperties}
              >
                {sources.length > 1 && (
                  <div style={{ position: "relative" }}>
                    <button
                      style={
                        videoPlayerStyles.controlButton as React.CSSProperties
                      }
                      onClick={() => setShowQualityMenu(!showQualityMenu)}
                      onMouseOver={(e) => {
                        e.currentTarget.style.opacity = "1";
                      }}
                      onMouseOut={(e) => {
                        e.currentTarget.style.opacity = "0.8";
                      }}
                    >
                      {selectedQuality} ⚙️
                    </button>

                    {showQualityMenu && (
                      <div
                        style={{
                          position: "absolute",
                          bottom: "40px",
                          right: "0",
                          background: "rgba(0, 0, 0, 0.8)",
                          borderRadius: "4px",
                          padding: "8px",
                          zIndex: 10,
                        }}
                      >
                        {sortedSources.map((source) => (
                          <div
                            key={source.quality}
                            style={{
                              padding: "5px 10px",
                              cursor: "pointer",
                              color:
                                source.quality === selectedQuality
                                  ? "var(--blue, #1a73e8)"
                                  : "white",
                              fontWeight:
                                source.quality === selectedQuality
                                  ? "bold"
                                  : "normal",
                            }}
                            onClick={() => changeQuality(source.quality)}
                          >
                            {source.quality}
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                )}

                <button
                  style={mergeStyles(
                    videoPlayerStyles.controlButton as React.CSSProperties,
                    videoPlayerStyles.fullscreenButton as React.CSSProperties,
                  )}
                  onClick={toggleFullscreen}
                  onMouseOver={(e) => {
                    e.currentTarget.style.opacity = "1";
                  }}
                  onMouseOut={(e) => {
                    e.currentTarget.style.opacity = "0.8";
                  }}
                >
                  {isFullscreen ? "↙️" : "↗️"}
                </button>
              </div>
            </div>
          </div>
        )}
      </div>

      {title && (
        <div
          style={{
            padding: "10px",
            fontSize: "1rem",
            fontWeight: "bold",
            color: "var(--text-color)",
          }}
        >
          {title}
        </div>
      )}
    </div>
  );
};

export default VideoPlayer;
```

#### apps/web/src/components/media/mediaPlayer.tsx

```tsx
// Import built-in modules first, then external packages
import React, { useEffect, useRef, useState } from "react";
// Import Plyr CSS
import "plyr/dist/plyr.css";

// Define interfaces for the player types
interface PlyrInstance {
  on(event: string, callback: (...args: unknown[]) => void): void;
  destroy(): void;
  currentTime?: number;
}

interface HlsInstance {
  loadSource(src: string): void;
  attachMedia(media: HTMLMediaElement): void;
  on(event: string, callback: (...args: unknown[]) => void): void;
  startLoad(): void;
  recoverMediaError(): void;
  destroy(): void;
}

// For dynamic imports and type safety
interface HlsConstructor {
  new (config?: Record<string, unknown>): HlsInstance;
  isSupported(): boolean;
}

// Dynamic imports for the actual implementations
const loadPlyr = () => import("plyr").then((m) => m.default);
const loadHls = () =>
  import("hls.js").then((m) => {
    const Hls = m.default as unknown as HlsConstructor;
    return { Hls, Events: m.Events };
  });

interface MediaPlayerProps {
  src: string;
  type: "video" | "audio";
  poster?: string;
  title?: string;
  autoplay?: boolean;
  muted?: boolean;
  crossOrigin?: "anonymous" | "use-credentials";
  onReady?: () => void;
  onPlay?: () => void;
  onPause?: () => void;
  onEnded?: () => void;
  onTimeUpdate?: (currentTime: number) => void;
  onError?: (error: unknown) => void;
  className?: string;
}

interface HlsError {
  type: string;
  fatal: boolean;
  details: string;
}

export const MediaPlayer: React.FC<MediaPlayerProps> = ({
  src,
  type,
  poster,
  title,
  autoplay = false,
  muted = false,
  crossOrigin = "anonymous",
  onReady,
  onPlay,
  onPause,
  onEnded,
  onTimeUpdate,
  onError,
  className,
}: MediaPlayerProps) => {
  const mediaRef = useRef<HTMLVideoElement | HTMLAudioElement>(null);
  const playerRef = useRef<PlyrInstance | null>(null);
  const hlsRef = useRef<HlsInstance | null>(null);

  const [_isReady, setIsReady] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!mediaRef.current) return;

    // Initialize Plyr
    void loadPlyr().then((PlyrConstructor) => {
      if (!mediaRef.current) return;

      playerRef.current = new PlyrConstructor(mediaRef.current, {
        controls: [
          "play-large",
          "play",
          "progress",
          "current-time",
          "mute",
          "volume",
          "captions",
          "settings",
          "pip",
          "airplay",
          "fullscreen",
        ],
        settings: ["quality", "speed", "loop"],
        quality: {
          default: 720,
          options: [1080, 720, 480, 360, 240],
        },
        speed: {
          selected: 1,
          options: [0.5, 0.75, 1, 1.25, 1.5, 2],
        },
      });

      // Set up event listeners
      playerRef.current.on("ready", () => {
        setIsReady(true);
        onReady?.();
      });

      playerRef.current.on("play", () => onPlay?.());
      playerRef.current.on("pause", () => onPause?.());
      playerRef.current.on("ended", () => onEnded?.());
      playerRef.current.on("timeupdate", () => {
        onTimeUpdate?.(playerRef.current?.currentTime || 0);
      });
      playerRef.current.on("error", (error: unknown) => {
        setError(error instanceof Error ? error.message : "Unknown error");
        onError?.(error);
      });
    });

    return () => {
      if (hlsRef.current) {
        hlsRef.current.destroy();
      }
      if (playerRef.current) {
        playerRef.current.destroy();
      }
    };
  }, [onEnded, onError, onPause, onPlay, onReady, onTimeUpdate]);

  useEffect(() => {
    if (!mediaRef.current || !src) return;

    const setupHLS = async () => {
      const { Hls, Events } = await loadHls();
      if (Hls.isSupported()) {
        hlsRef.current = new Hls({
          maxLoadingDelay: 4,
          maxMaxBufferLength: 30,
          lowLatencyMode: true,
        });

        if (mediaRef.current && hlsRef.current) {
          hlsRef.current.loadSource(src);
          hlsRef.current.attachMedia(mediaRef.current);

          hlsRef.current.on(Events.MANIFEST_PARSED, () => {
            if (autoplay && mediaRef.current) {
              mediaRef.current.play().catch(() => {
                // Autoplay failed, do nothing
              });
            }
          });

          hlsRef.current.on(Events.ERROR, (...args: unknown[]) => {
            const data = args[1] as HlsError;
            if (data.fatal) {
              switch (data.type) {
                case "networkError":
                  hlsRef.current?.startLoad();
                  break;
                case "mediaError":
                  hlsRef.current?.recoverMediaError();
                  break;
                default:
                  setError("Fatal HLS error");
                  onError?.(data);
                  break;
              }
            }
          });
        }
      } else if (
        mediaRef.current?.canPlayType("application/vnd.apple.mpegurl")
      ) {
        // Native HLS support (Safari)
        mediaRef.current.src = src;
      }
    };

    // Clean up previous instances
    if (hlsRef.current) {
      hlsRef.current.destroy();
      hlsRef.current = null;
    }

    // Set up new source
    if (src.includes(".m3u8")) {
      void setupHLS();
    } else {
      mediaRef.current.src = src;
    }
  }, [src, autoplay, onError]);

  const containerStyle: React.CSSProperties = {
    position: "relative",
    width: "100%",
    maxWidth: "100%",
    backgroundColor: "#000",
    aspectRatio: type === "video" ? "16/9" : "auto",
  };

  const mediaStyle: React.CSSProperties = {
    width: "100%",
    height: type === "video" ? "100%" : "auto",
  };

  const errorStyle: React.CSSProperties = {
    position: "absolute",
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)",
    color: "#fff",
    backgroundColor: "rgba(0, 0, 0, 0.7)",
    padding: "1rem",
    borderRadius: "4px",
    textAlign: "center",
  };

  return (
    <div style={containerStyle} className={className}>
      {type === "video" ? (
        <video
          ref={mediaRef as React.LegacyRef<HTMLVideoElement>}
          poster={poster}
          muted={muted}
          crossOrigin={crossOrigin}
          style={mediaStyle}
          title={title}
        >
          {error && <div style={errorStyle}>{error}</div>}
        </video>
      ) : (
        <audio
          ref={mediaRef as React.LegacyRef<HTMLAudioElement>}
          muted={muted}
          crossOrigin={crossOrigin}
          style={mediaStyle}
          title={title}
        >
          {error && <div style={errorStyle}>{error}</div>}
        </audio>
      )}
    </div>
  );
};
```

#### apps/web/src/components/media/mediaUpload.tsx

```tsx
// src/client/components/media/MediaUpload.tsx
import React, { useCallback, useState } from "react";

interface MediaUploadProps {
  onUpload: (file: File) => Promise<void>;
  acceptedTypes?: string[];
  maxSize?: number; // in bytes
  className?: string;
}

export const MediaUpload: React.FC<MediaUploadProps> = ({
  onUpload,
  acceptedTypes = ["image/*", "audio/*", "video/*"],
  maxSize = 100 * 1024 * 1024, // 100MB default
  className,
}) => {
  const [isDragging, setIsDragging] = useState(false);
  const [isUploading, setIsUploading] = useState(false);
  const [progress, setProgress] = useState(0);
  const [error, setError] = useState<string | null>(null);
  const [preview, setPreview] = useState<string | null>(null);

  const handleDragEnter = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(true);
  }, []);

  const handleDragLeave = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(false);
  }, []);

  const handleDragOver = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
  }, []);

  const validateFile = useCallback(
    (file: File): string | null => {
      if (file.size > maxSize) {
        return `File size exceeds ${maxSize / (1024 * 1024)}MB limit`;
      }

      if (
        !acceptedTypes.some((type) => {
          if (type.endsWith("/*")) {
            const baseType = type.slice(0, -2);
            return file.type.startsWith(baseType);
          }
          return file.type === type;
        })
      ) {
        return "File type not accepted";
      }

      return null;
    },
    [maxSize, acceptedTypes],
  );

  const createPreview = (file: File) => {
    const reader = new FileReader();
    reader.onload = () => {
      setPreview(reader.result as string);
    };
    reader.readAsDataURL(file);
  };

  const handleUpload = useCallback(
    async (file: File) => {
      try {
        setIsUploading(true);
        setProgress(0);
        await onUpload(file);
        setProgress(100);
      } catch (err) {
        setError(err instanceof Error ? err.message : "Upload failed");
      } finally {
        setIsUploading(false);
      }
    },
    [onUpload],
  );

  const handleDrop = useCallback(
    async (e: React.DragEvent) => {
      e.preventDefault();
      e.stopPropagation();
      setIsDragging(false);

      const file = e.dataTransfer.files[0];
      if (!file) return;

      const validationError = validateFile(file);
      if (validationError) {
        setError(validationError);
        return;
      }

      setError(null);
      createPreview(file);
      await handleUpload(file);
    },
    [validateFile, handleUpload],
  );

  const handleFileSelect = useCallback(
    async (e: React.ChangeEvent<HTMLInputElement>) => {
      const file = e.target.files?.[0];
      if (!file) return;

      const validationError = validateFile(file);
      if (validationError) {
        setError(validationError);
        return;
      }

      setError(null);
      createPreview(file);
      await handleUpload(file);
    },
    [validateFile, handleUpload],
  );

  const getMediaIcon = () => {
    if (!preview)
      return (
        <svg className="media-upload-icon" viewBox="0 0 24 24">
          <path
            fill="currentColor"
            d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z"
          />
        </svg>
      );

    const type = preview.split(";")[0].split("/")[0];
    switch (type) {
      case "image":
        return (
          <svg className="media-upload-icon" viewBox="0 0 24 24">
            <path
              fill="currentColor"
              d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"
            />
          </svg>
        );
      case "audio":
        return (
          <svg className="media-upload-icon" viewBox="0 0 24 24">
            <path
              fill="currentColor"
              d="M12 3v18c-4.97 0-9-4.03-9-9s4.03-9 9-9zm0-2c-6.07 0-11 4.93-11 11s4.93 11 11 11 11-4.93 11-11S18.07 1 12 1zm-1 14h2V7h-2v8z"
            />
          </svg>
        );
      case "video":
        return (
          <svg className="media-upload-icon" viewBox="0 0 24 24">
            <path
              fill="currentColor"
              d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"
            />
          </svg>
        );
      default:
        return (
          <svg className="media-upload-icon" viewBox="0 0 24 24">
            <path
              fill="currentColor"
              d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z"
            />
          </svg>
        );
    }
  };

  const styles = {
    upload: {
      border: "2px dashed #ccc",
      borderRadius: "8px",
      padding: "24px",
      textAlign: "center" as const,
      backgroundColor: "#fff",
      transition: "all 0.2s ease",
      position: "relative" as const,
      ...(isDragging && {
        borderColor: "#2196f3",
        backgroundColor: "rgba(33, 150, 243, 0.05)",
      }),
    },
    input: {
      display: "none",
    },
    content: {
      display: "flex",
      flexDirection: "column" as const,
      alignItems: "center",
      gap: "16px",
    },
    icon: {
      width: "48px",
      height: "48px",
      color: "#666",
    },
    title: {
      margin: 0,
      fontSize: "1.25rem",
      fontWeight: 500,
      color: "#333",
    },
    text: {
      margin: 0,
      color: "#666",
    },
    button: {
      display: "inline-block",
      padding: "8px 16px",
      backgroundColor: "#2196f3",
      color: "white",
      borderRadius: "4px",
      cursor: "pointer",
      transition: "background-color 0.2s",
    },
    buttonHover: {
      backgroundColor: "#1976d2",
    },
    hint: {
      margin: 0,
      fontSize: "0.875rem",
      color: "#666",
    },
    error: {
      margin: 0,
      color: "#d32f2f",
    },
    progress: {
      width: "100%",
      maxWidth: "200px",
    },
    progressBar: {
      width: "100%",
      height: "4px",
      backgroundColor: "#e0e0e0",
      borderRadius: "2px",
      overflow: "hidden",
    },
    progressFill: {
      height: "100%",
      backgroundColor: "#2196f3",
      transition: "width 0.2s ease",
      width: `${progress}%`,
    },
    progressText: {
      margin: "4px 0 0",
      fontSize: "0.875rem",
      color: "#666",
    },
    preview: {
      marginTop: "16px",
      maxWidth: "100%",
      maxHeight: "200px",
      overflow: "hidden",
      borderRadius: "4px",
    },
    previewImage: {
      maxWidth: "100%",
      maxHeight: "200px",
      objectFit: "contain" as const,
    },
    previewVideo: {
      maxWidth: "100%",
      maxHeight: "200px",
    },
    previewAudio: {
      width: "100%",
      maxWidth: "300px",
    },
  };

  return (
    <div
      style={styles.upload}
      className={className}
      onDragEnter={handleDragEnter}
      onDragLeave={handleDragLeave}
      onDragOver={handleDragOver}
      onDrop={handleDrop as (e: React.DragEvent) => void}
    >
      <input
        type="file"
        accept={acceptedTypes.join(",")}
        onChange={
          handleFileSelect as (e: React.ChangeEvent<HTMLInputElement>) => void
        }
        style={styles.input}
        id="media-upload-input"
      />

      <div style={styles.content}>
        {getMediaIcon()}

        <h3 style={styles.title}>
          {isUploading ? "Uploading..." : "Drag & drop media here"}
        </h3>

        <p style={styles.text}>or</p>

        <label
          htmlFor="media-upload-input"
          style={styles.button}
          onMouseEnter={(e) =>
            (e.currentTarget.style.backgroundColor = "#1976d2")
          }
          onMouseLeave={(e) =>
            (e.currentTarget.style.backgroundColor = "#2196f3")
          }
        >
          Select File
        </label>

        <p style={styles.hint}>Supported formats: {acceptedTypes.join(", ")}</p>

        {error && <p style={styles.error}>{error}</p>}

        {isUploading && (
          <div style={styles.progress}>
            <div style={styles.progressBar}>
              <div style={styles.progressFill} />
            </div>
            <p style={styles.progressText}>{progress}%</p>
          </div>
        )}
      </div>

      {preview && !isUploading && (
        <div style={styles.preview}>
          {preview.startsWith("data:image/") ? (
            <img src={preview} alt="Preview" style={styles.previewImage} />
          ) : preview.startsWith("data:video/") ? (
            <video src={preview} controls style={styles.previewVideo} />
          ) : preview.startsWith("data:audio/") ? (
            <audio src={preview} controls style={styles.previewAudio} />
          ) : null}
        </div>
      )}
    </div>
  );
};
```

#### apps/web/src/components/media/mediaView.tsx

```tsx
interface MediaViewProps {
  filename: string;
  type?: "audio" | "video" | "image";
  controls?: boolean;
  autoPlay?: boolean;
  width?: string | number;
  height?: string | number;
}

export function MediaView({
  filename,
  type,
  controls = true,
  autoPlay = false,
  width = "100%",
  height = "auto",
}: MediaViewProps) {
  // Construct media URL
  const mediaUrl = `/api/stream?filename=${encodeURIComponent(filename)}`;

  // Automatically detect type from filename extension if not provided
  const detectType = (): "audio" | "video" | "image" => {
    const ext = filename.split(".").pop()?.toLowerCase();

    if (["mp3", "wav", "ogg", "m4a", "flac"].includes(ext || ""))
      return "audio";
    if (["mp4", "webm", "mov", "avi"].includes(ext || "")) return "video";
    if (["jpg", "jpeg", "png", "gif", "webp", "svg"].includes(ext || ""))
      return "image";

    return "video"; // Default fallback
  };

  const mediaType = type || detectType();

  if (mediaType === "audio") {
    return (
      <audio
        src={mediaUrl}
        controls={controls}
        autoPlay={autoPlay}
        style={{ width }}
      />
    );
  }

  if (mediaType === "video") {
    return (
      <video
        src={mediaUrl}
        controls={controls}
        autoPlay={autoPlay}
        style={{ width, height }}
      />
    );
  }

  if (mediaType === "image") {
    return <img src={mediaUrl} alt={filename} style={{ width, height }} />;
  }

  return <div>Unsupported media type</div>;
}
```

#### apps/web/src/components/pages/DashboardPage.tsx

```tsx
import { PageContent } from "../../layouts/PageContent";

// Dashboard page styles
const styles = {
  grid: {
    display: "grid",
    gridTemplateColumns: "repeat(auto-fill, minmax(300px, 1fr))",
    gap: "20px",
    marginTop: "20px",
  },
  card: {
    backgroundColor: "var(--card-bg)",
    borderRadius: "8px",
    padding: "20px",
    boxShadow: "var(--shadow)",
    border: "1px solid var(--border-color)",
  },
  statsGrid: {
    display: "grid",
    gridTemplateColumns: "1fr 1fr",
    gap: "15px",
  },
  statLabel: {
    fontSize: "14px",
    color: "var(--text-secondary)",
  },
  statValue: {
    fontSize: "24px",
    fontWeight: "bold",
    color: "var(--text-primary)",
  },
  activityItem: {
    padding: "10px",
    backgroundColor: "var(--surface)",
    borderRadius: "4px",
  },
  activityTitle: {
    fontWeight: "bold",
    color: "var(--text-primary)",
  },
  activityTime: {
    fontSize: "14px",
    color: "var(--text-secondary)",
    marginTop: "5px",
  },
  actionButton: {
    padding: "10px",
    backgroundColor: "var(--blue)",
    color: "white",
    border: "none",
    borderRadius: "4px",
    cursor: "pointer",
    textAlign: "left" as const,
  },
  actionButtonOutline: {
    padding: "10px",
    backgroundColor: "var(--card-bg)",
    color: "var(--blue)",
    border: "1px solid var(--blue)",
    borderRadius: "4px",
    cursor: "pointer",
    textAlign: "left" as const,
  },
  eventItem: {
    padding: "10px",
    borderLeft: "3px solid",
    backgroundColor: "var(--surface)",
  },
  eventTitle: {
    fontWeight: "bold",
    color: "var(--text-primary)",
  },
  eventTime: {
    fontSize: "14px",
    marginTop: "5px",
    color: "var(--text-primary)",
  },
  flexColumn: {
    display: "flex",
    flexDirection: "column" as const,
    gap: "10px",
  },
  sectionTitle: {
    margin: "0 0 15px 0",
  },
};

export function DashboardPage() {
  return (
    <PageContent
      title="Dashboard"
      description="Welcome to your personalized dashboard."
    >
      <div style={styles.grid}>
        {/* Stats Card */}
        <div style={styles.card}>
          <h3 style={styles.sectionTitle}>Statistics</h3>
          <div style={styles.statsGrid}>
            <div>
              <div style={styles.statLabel}>Views</div>
              <div style={styles.statValue}>1,254</div>
            </div>
            <div>
              <div style={styles.statLabel}>Likes</div>
              <div style={styles.statValue}>423</div>
            </div>
            <div>
              <div style={styles.statLabel}>Comments</div>
              <div style={styles.statValue}>97</div>
            </div>
            <div>
              <div style={styles.statLabel}>Shares</div>
              <div style={styles.statValue}>56</div>
            </div>
          </div>
        </div>

        {/* Recent Activity Card */}
        <div style={styles.card}>
          <h3 style={styles.sectionTitle}>Recent Activity</h3>
          <div style={styles.flexColumn}>
            <div style={styles.activityItem}>
              <div style={styles.activityTitle}>New comment on your post</div>
              <div style={styles.activityTime}>2 minutes ago</div>
            </div>
            <div style={styles.activityItem}>
              <div style={styles.activityTitle}>Your post was featured</div>
              <div style={styles.activityTime}>1 hour ago</div>
            </div>
            <div style={styles.activityItem}>
              <div style={styles.activityTitle}>New follower: JaneDoe</div>
              <div style={styles.activityTime}>3 hours ago</div>
            </div>
          </div>
        </div>

        {/* Quick Actions Card */}
        <div style={styles.card}>
          <h3 style={styles.sectionTitle}>Quick Actions</h3>
          <div style={styles.flexColumn}>
            <button style={styles.actionButton}>Create New Post</button>
            <button style={styles.actionButtonOutline}>Upload Media</button>
            <button style={styles.actionButtonOutline}>Edit Profile</button>
          </div>
        </div>

        {/* Upcoming Events Card */}
        <div style={styles.card}>
          <h3 style={styles.sectionTitle}>Upcoming Events</h3>
          <div style={styles.flexColumn}>
            <div
              style={{ ...styles.eventItem, borderLeftColor: "var(--blue)" }}
            >
              <div style={styles.eventTitle}>Team Meeting</div>
              <div style={styles.eventTime}>Tomorrow, 10:00 AM</div>
            </div>
            <div
              style={{ ...styles.eventItem, borderLeftColor: "var(--green)" }}
            >
              <div style={styles.eventTitle}>Project Deadline</div>
              <div style={styles.eventTime}>Friday, 5:00 PM</div>
            </div>
            <div
              style={{ ...styles.eventItem, borderLeftColor: "var(--purple)" }}
            >
              <div style={styles.eventTitle}>Webinar: New Features</div>
              <div style={styles.eventTime}>Next Monday, 2:00 PM</div>
            </div>
          </div>
        </div>
      </div>
    </PageContent>
  );
}
```

#### apps/web/src/components/pages/DesignPage.tsx

```tsx
import { PageContent } from "../../layouts/PageContent";

export function DesignPage() {
  return (
    <PageContent
      title="Design System"
      description="This page showcases the design system components available in the ABE Stack."
    >
      <div style={{ marginTop: "20px" }}>
        <h2>Color Palette</h2>
        <div
          style={{
            display: "flex",
            gap: "10px",
            flexWrap: "wrap",
            marginTop: "10px",
          }}
        >
          <div
            style={{
              width: "100px",
              height: "100px",
              backgroundColor: "var(--blue)",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              color: "white",
              borderRadius: "4px",
            }}
          >
            Blue
          </div>
          <div
            style={{
              width: "100px",
              height: "100px",
              backgroundColor: "var(--green)",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              color: "white",
              borderRadius: "4px",
            }}
          >
            Green
          </div>
          <div
            style={{
              width: "100px",
              height: "100px",
              backgroundColor: "var(--red)",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              color: "white",
              borderRadius: "4px",
            }}
          >
            Red
          </div>
          <div
            style={{
              width: "100px",
              height: "100px",
              backgroundColor: "var(--yellow)",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              color: "black",
              borderRadius: "4px",
            }}
          >
            Yellow
          </div>
          <div
            style={{
              width: "100px",
              height: "100px",
              backgroundColor: "var(--purple)",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              color: "white",
              borderRadius: "4px",
            }}
          >
            Purple
          </div>
        </div>
      </div>

      <div style={{ marginTop: "30px" }}>
        <h2>Typography</h2>
        <div style={{ marginTop: "10px" }}>
          <h1 style={{ margin: "10px 0" }}>Heading 1</h1>
          <h2 style={{ margin: "10px 0" }}>Heading 2</h2>
          <h3 style={{ margin: "10px 0" }}>Heading 3</h3>
          <h4 style={{ margin: "10px 0" }}>Heading 4</h4>
          <p style={{ margin: "10px 0" }}>Regular paragraph text</p>
          <p style={{ margin: "10px 0", fontWeight: "bold" }}>Bold text</p>
          <p style={{ margin: "10px 0", fontStyle: "italic" }}>Italic text</p>
        </div>
      </div>

      <div style={{ marginTop: "30px" }}>
        <h2>Buttons</h2>
        <div
          style={{
            display: "flex",
            gap: "10px",
            flexWrap: "wrap",
            marginTop: "10px",
          }}
        >
          <button
            style={{
              padding: "8px 16px",
              backgroundColor: "var(--blue)",
              color: "white",
              border: "none",
              borderRadius: "4px",
              cursor: "pointer",
            }}
          >
            Primary
          </button>
          <button
            style={{
              padding: "8px 16px",
              backgroundColor: "white",
              color: "var(--blue)",
              border: "1px solid var(--blue)",
              borderRadius: "4px",
              cursor: "pointer",
            }}
          >
            Secondary
          </button>
          <button
            style={{
              padding: "8px 16px",
              backgroundColor: "var(--green)",
              color: "white",
              border: "none",
              borderRadius: "4px",
              cursor: "pointer",
            }}
          >
            Success
          </button>
          <button
            style={{
              padding: "8px 16px",
              backgroundColor: "var(--red)",
              color: "white",
              border: "none",
              borderRadius: "4px",
              cursor: "pointer",
            }}
          >
            Danger
          </button>
          <button
            style={{
              padding: "8px 16px",
              backgroundColor: "var(--yellow)",
              color: "black",
              border: "none",
              borderRadius: "4px",
              cursor: "pointer",
            }}
          >
            Warning
          </button>
          <button
            style={{
              padding: "8px 16px",
              backgroundColor: "#ccc",
              color: "#666",
              border: "none",
              borderRadius: "4px",
              cursor: "not-allowed",
            }}
          >
            Disabled
          </button>
        </div>
      </div>

      <div style={{ marginTop: "30px" }}>
        <h2>Form Elements</h2>
        <div
          style={{
            display: "flex",
            flexDirection: "column",
            gap: "15px",
            marginTop: "10px",
            maxWidth: "400px",
          }}
        >
          <div>
            <label style={{ display: "block", marginBottom: "5px" }}>
              Text Input
            </label>
            <input
              type="text"
              placeholder="Enter text"
              style={{
                width: "100%",
                padding: "8px",
                borderRadius: "4px",
                border: "1px solid #ccc",
              }}
            />
          </div>
          <div>
            <label style={{ display: "block", marginBottom: "5px" }}>
              Select
            </label>
            <select
              style={{
                width: "100%",
                padding: "8px",
                borderRadius: "4px",
                border: "1px solid #ccc",
              }}
            >
              <option>Option 1</option>
              <option>Option 2</option>
              <option>Option 3</option>
            </select>
          </div>
          <div>
            <label style={{ display: "block", marginBottom: "5px" }}>
              Textarea
            </label>
            <textarea
              placeholder="Enter longer text"
              style={{
                width: "100%",
                padding: "8px",
                borderRadius: "4px",
                border: "1px solid #ccc",
                minHeight: "100px",
              }}
            ></textarea>
          </div>
          <div>
            <label
              style={{
                display: "flex",
                alignItems: "center",
                gap: "8px",
                cursor: "pointer",
              }}
            >
              <input type="checkbox" />
              <span>Checkbox option</span>
            </label>
          </div>
          <div style={{ display: "flex", flexDirection: "column", gap: "8px" }}>
            <label
              style={{
                display: "flex",
                alignItems: "center",
                gap: "8px",
                cursor: "pointer",
              }}
            >
              <input type="radio" name="radioGroup" />
              <span>Radio option 1</span>
            </label>
            <label
              style={{
                display: "flex",
                alignItems: "center",
                gap: "8px",
                cursor: "pointer",
              }}
            >
              <input type="radio" name="radioGroup" />
              <span>Radio option 2</span>
            </label>
          </div>
        </div>
      </div>

      <div style={{ marginTop: "30px" }}>
        <h2>Cards</h2>
        <div
          style={{
            display: "flex",
            gap: "20px",
            flexWrap: "wrap",
            marginTop: "10px",
          }}
        >
          <div
            style={{
              width: "250px",
              border: "1px solid #ddd",
              borderRadius: "8px",
              overflow: "hidden",
            }}
          >
            <div
              style={{
                height: "150px",
                backgroundColor: "var(--blue)",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                color: "white",
              }}
            >
              Image Placeholder
            </div>
            <div style={{ padding: "15px" }}>
              <h3 style={{ marginTop: 0 }}>Card Title</h3>
              <p>This is a basic card with an image, title, and description.</p>
              <button
                style={{
                  padding: "6px 12px",
                  backgroundColor: "var(--blue)",
                  color: "white",
                  border: "none",
                  borderRadius: "4px",
                  cursor: "pointer",
                  marginTop: "10px",
                }}
              >
                Action
              </button>
            </div>
          </div>

          <div
            style={{
              width: "250px",
              border: "1px solid #ddd",
              borderRadius: "8px",
              padding: "15px",
            }}
          >
            <h3 style={{ marginTop: 0 }}>Simple Card</h3>
            <p>This is a simpler card without an image, just text content.</p>
            <div style={{ display: "flex", gap: "10px", marginTop: "10px" }}>
              <button
                style={{
                  padding: "6px 12px",
                  backgroundColor: "white",
                  color: "var(--blue)",
                  border: "1px solid var(--blue)",
                  borderRadius: "4px",
                  cursor: "pointer",
                }}
              >
                Cancel
              </button>
              <button
                style={{
                  padding: "6px 12px",
                  backgroundColor: "var(--blue)",
                  color: "white",
                  border: "none",
                  borderRadius: "4px",
                  cursor: "pointer",
                }}
              >
                Confirm
              </button>
            </div>
          </div>
        </div>
      </div>
    </PageContent>
  );
}
```

#### apps/web/src/components/pages/ExplorePage.tsx

```tsx
import { useState } from "react";

import { PageContent } from "../../layouts/PageContent";

// Explore page styles
const styles = {
  categories: {
    marginTop: "20px",
    borderBottom: "1px solid var(--border-color)",
    paddingBottom: "10px",
  },
  categoryButtons: {
    display: "flex",
    gap: "10px",
    overflowX: "auto" as const,
    paddingBottom: "5px",
  },
  categoryButton: {
    padding: "8px 16px",
    borderRadius: "20px",
    cursor: "pointer",
    whiteSpace: "nowrap" as const,
  },
  categoryButtonActive: {
    backgroundColor: "var(--blue)",
    color: "white",
    border: "none",
  },
  categoryButtonInactive: {
    backgroundColor: "transparent",
    color: "var(--blue)",
    border: "1px solid var(--blue)",
  },
  searchContainer: {
    marginTop: "20px",
    display: "flex",
    gap: "10px",
  },
  searchInput: {
    flex: 1,
    padding: "10px 15px",
    borderRadius: "4px",
    border: "1px solid var(--border-color)",
    fontSize: "16px",
    backgroundColor: "var(--surface)",
    color: "var(--text-primary)",
  },
  searchButton: {
    padding: "10px 20px",
    backgroundColor: "var(--blue)",
    color: "white",
    border: "none",
    borderRadius: "4px",
    cursor: "pointer",
  },
  contentSection: {
    marginTop: "30px",
  },
  contentTitle: {
    color: "var(--text-primary)",
  },
  contentGrid: {
    display: "grid",
    gridTemplateColumns: "repeat(auto-fill, minmax(300px, 1fr))",
    gap: "20px",
    marginTop: "15px",
  },
  contentCard: {
    border: "1px solid var(--border-color)",
    borderRadius: "8px",
    overflow: "hidden",
    transition: "transform 0.2s ease, box-shadow 0.2s ease",
    cursor: "pointer",
    backgroundColor: "var(--card-bg)",
    boxShadow: "var(--shadow)",
  },
  contentCardHover: {
    transform: "translateY(-5px)",
    boxShadow: "0 5px 15px rgba(0, 0, 0, 0.2)",
  },
  contentImage: {
    height: "160px",
    backgroundColor: "var(--blue)",
    position: "relative" as const,
  },
  contentViews: {
    position: "absolute" as const,
    bottom: "10px",
    right: "10px",
    backgroundColor: "rgba(0, 0, 0, 0.6)",
    color: "white",
    padding: "3px 8px",
    borderRadius: "4px",
    fontSize: "12px",
  },
  contentDetails: {
    padding: "15px",
  },
  contentItemTitle: {
    margin: "0 0 5px 0",
    fontSize: "18px",
    color: "var(--text-primary)",
  },
  contentAuthor: {
    color: "var(--text-secondary)",
    fontSize: "14px",
    marginBottom: "10px",
  },
  contentFooter: {
    display: "flex",
    justifyContent: "space-between",
    alignItems: "center",
  },
  contentLikes: {
    display: "flex",
    alignItems: "center",
    gap: "5px",
    color: "var(--text-secondary)",
    fontSize: "14px",
  },
  pagination: {
    marginTop: "30px",
    display: "flex",
    justifyContent: "center",
    gap: "5px",
  },
  paginationButton: {
    width: "40px",
    height: "40px",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    border: "1px solid var(--border-color)",
    borderRadius: "4px",
    backgroundColor: "var(--card-bg)",
    cursor: "pointer",
    color: "var(--text-primary)",
  },
  paginationButtonActive: {
    border: "none",
    backgroundColor: "var(--blue)",
    color: "white",
  },
};

export function ExplorePage() {
  const [activeCategory, setActiveCategory] = useState("all");
  const [hoveredCard, setHoveredCard] = useState<number | null>(null);

  const categories = [
    { id: "all", name: "All" },
    { id: "trending", name: "Trending" },
    { id: "new", name: "New" },
    { id: "popular", name: "Popular" },
    { id: "following", name: "Following" },
  ];

  // Mock content items
  const contentItems = [
    {
      id: 1,
      title: "Getting Started with React",
      author: "Jane Smith",
      views: "1.2K",
      likes: 245,
      category: "popular",
    },
    {
      id: 2,
      title: "Advanced TypeScript Patterns",
      author: "John Doe",
      views: "856",
      likes: 178,
      category: "trending",
    },
    {
      id: 3,
      title: "Building Responsive UIs",
      author: "Alice Johnson",
      views: "3.4K",
      likes: 412,
      category: "popular",
    },
    {
      id: 4,
      title: "State Management in 2023",
      author: "Bob Wilson",
      views: "921",
      likes: 156,
      category: "new",
    },
    {
      id: 5,
      title: "API Design Best Practices",
      author: "Carol Taylor",
      views: "1.8K",
      likes: 267,
      category: "trending",
    },
    {
      id: 6,
      title: "Performance Optimization Tips",
      author: "Dave Martin",
      views: "2.3K",
      likes: 389,
      category: "popular",
    },
    {
      id: 7,
      title: "Intro to Web Components",
      author: "Eve Anderson",
      views: "745",
      likes: 132,
      category: "new",
    },
    {
      id: 8,
      title: "Accessibility for Developers",
      author: "Frank Thomas",
      views: "1.5K",
      likes: 203,
      category: "trending",
    },
  ];

  const filteredItems =
    activeCategory === "all"
      ? contentItems
      : contentItems.filter((item) => item.category === activeCategory);

  return (
    <PageContent
      title="Explore Content"
      description="Discover trending and popular content from creators."
    >
      {/* Categories */}
      <div style={styles.categories}>
        <div style={styles.categoryButtons}>
          {categories.map((category) => (
            <button
              key={category.id}
              onClick={() => setActiveCategory(category.id)}
              style={{
                ...styles.categoryButton,
                ...(activeCategory === category.id
                  ? styles.categoryButtonActive
                  : styles.categoryButtonInactive),
              }}
            >
              {category.name}
            </button>
          ))}
        </div>
      </div>

      {/* Search Bar */}
      <div style={styles.searchContainer}>
        <input
          type="text"
          placeholder="Search content..."
          style={styles.searchInput}
        />
        <button style={styles.searchButton}>Search</button>
      </div>

      {/* Content Grid */}
      <div style={styles.contentSection}>
        <h2 style={styles.contentTitle}>
          {activeCategory === "all"
            ? "All Content"
            : categories.find((c) => c.id === activeCategory)?.name}
        </h2>
        <div style={styles.contentGrid}>
          {filteredItems.map((item) => (
            <div
              key={item.id}
              style={{
                ...styles.contentCard,
                ...(hoveredCard === item.id ? styles.contentCardHover : {}),
              }}
              onMouseEnter={() => setHoveredCard(item.id)}
              onMouseLeave={() => setHoveredCard(null)}
            >
              <div style={styles.contentImage}>
                <div style={styles.contentViews}>{item.views} views</div>
              </div>
              <div style={styles.contentDetails}>
                <h3 style={styles.contentItemTitle}>{item.title}</h3>
                <div style={styles.contentAuthor}>by {item.author}</div>
                <div style={styles.contentFooter}>
                  <div style={styles.contentLikes}>
                    <span>❤️ {item.likes}</span>
                  </div>
                  <div
                    style={{
                      backgroundColor:
                        item.category === "trending"
                          ? "#ffecb3"
                          : item.category === "new"
                            ? "#e3f2fd"
                            : item.category === "popular"
                              ? "#e8f5e9"
                              : "#f5f5f5",
                      padding: "3px 8px",
                      borderRadius: "4px",
                      fontSize: "12px",
                      color:
                        item.category === "trending"
                          ? "#ff6f00"
                          : item.category === "new"
                            ? "#0277bd"
                            : item.category === "popular"
                              ? "#2e7d32"
                              : "#616161",
                    }}
                  >
                    {item.category}
                  </div>
                </div>
              </div>
            </div>
          ))}
        </div>
      </div>

      {/* Pagination */}
      <div style={styles.pagination}>
        <button style={styles.paginationButton}>&lt;</button>
        {[1, 2, 3, 4, 5].map((page) => (
          <button
            key={page}
            style={{
              ...styles.paginationButton,
              ...(page === 1 ? styles.paginationButtonActive : {}),
            }}
          >
            {page}
          </button>
        ))}
        <button style={styles.paginationButton}>&gt;</button>
      </div>
    </PageContent>
  );
}
```

#### apps/web/src/components/pages/HomePage.tsx

```tsx
import { PageContent } from "../../layouts/PageContent";
import { useClientEnvironment } from "../../services/ClientEnvironment";

export function HomePage() {
  const environment = useClientEnvironment();

  // Function to handle navigation using the custom router
  const handleNavigate = (path: string) => {
    environment.router.navigate(path);
  };

  return (
    <PageContent
      title="Welcome to ABE Stack"
      description="A modern, full-stack TypeScript boilerplate for building web applications"
    >
      <div style={{ maxWidth: "800px", margin: "0 auto" }}>
        {/* Credit Banner */}
        <div
          style={{
            backgroundColor: "var(--accent)",
            color: "white",
            padding: "15px 20px",
            borderRadius: "8px",
            marginBottom: "30px",
            boxShadow: "var(--shadow)",
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            textAlign: "center",
          }}
        >
          <h2 style={{ margin: "0 0 10px 0", fontSize: "1.4rem" }}>
            Built on Chet Stack
          </h2>
          <p
            style={{
              margin: "0 0 10px 0",
              fontSize: "1.1rem",
              lineHeight: "1.5",
            }}
          >
            ABE Stack is proudly built upon the excellent foundation provided by
            <a
              href="https://github.com/ccorcos/chet-stack"
              target="_blank"
              rel="noopener noreferrer"
              style={{
                color: "white",
                textDecoration: "underline",
                fontWeight: "bold",
                marginLeft: "5px",
              }}
            >
              Chet Stack
            </a>{" "}
            by Chet Corcos.
          </p>
          <a
            href="https://github.com/ccorcos/chet-stack"
            target="_blank"
            rel="noopener noreferrer"
            style={{
              backgroundColor: "white",
              color: "var(--accent)",
              padding: "8px 16px",
              borderRadius: "4px",
              textDecoration: "none",
              fontWeight: "bold",
              marginTop: "5px",
            }}
          >
            Visit Chet Stack Repository
          </a>
        </div>

        <section style={{ marginBottom: "40px" }}>
          <h2
            style={{
              borderBottom: "1px solid var(--border-color)",
              paddingBottom: "10px",
              marginBottom: "20px",
            }}
          >
            What is ABE Stack?
          </h2>
          <p
            style={{
              fontSize: "1.1rem",
              lineHeight: "1.6",
              marginBottom: "20px",
            }}
          >
            <strong>ABE Stack</strong> (Authentication, Backend, and Everything)
            is a comprehensive boilerplate designed to accelerate web
            application development. It extends the powerful foundation of Chet
            Stack with additional features, UI components, and ready-to-use
            patterns.
          </p>
          <p
            style={{
              fontSize: "1.1rem",
              lineHeight: "1.6",
              marginBottom: "20px",
            }}
          >
            Whether you&apos;re building a social platform, content management
            system, or any modern web application, ABE Stack provides the
            essential building blocks so you can focus on your unique business
            logic rather than reinventing the wheel.
          </p>
        </section>

        <section style={{ marginBottom: "40px" }}>
          <h2
            style={{
              borderBottom: "1px solid var(--border-color)",
              paddingBottom: "10px",
              marginBottom: "20px",
            }}
          >
            Core Architecture
          </h2>
          <div
            style={{
              display: "grid",
              gridTemplateColumns: "repeat(auto-fill, minmax(300px, 1fr))",
              gap: "20px",
            }}
          >
            <FeatureCard
              title="Full-Stack TypeScript"
              description="End-to-end type safety with TypeScript on both client and server. The shared type definitions between frontend and backend eliminate type mismatches and provide excellent developer experience."
            />
            <FeatureCard
              title="Vite + React"
              description="Lightning-fast development with Vite and modern React patterns. Enjoy hot module replacement, optimized builds, and a component-based architecture using React hooks and context."
            />
            <FeatureCard
              title="PostgreSQL + Migrations"
              description="Robust database integration with PostgreSQL, including a migration system, query builders, and type-safe database access patterns inherited from Chet Stack."
            />
            <FeatureCard
              title="WebSocket Integration"
              description="Real-time communication between client and server using WebSockets. This enables live updates, notifications, and collaborative features without complex setup."
            />
          </div>
        </section>

        <section style={{ marginBottom: "40px" }}>
          <h2
            style={{
              borderBottom: "1px solid var(--border-color)",
              paddingBottom: "10px",
              marginBottom: "20px",
            }}
          >
            Extended Features
          </h2>
          <p
            style={{
              fontSize: "1.1rem",
              lineHeight: "1.6",
              marginBottom: "20px",
            }}
          >
            While Chet Stack provides an excellent foundation, ABE Stack extends
            it with additional features and components:
          </p>
          <div
            style={{
              display: "grid",
              gridTemplateColumns: "repeat(auto-fill, minmax(300px, 1fr))",
              gap: "20px",
              marginBottom: "20px",
            }}
          >
            <FeatureCard
              title="Authentication System"
              description="Complete user authentication flow with registration, login, profile management, and secure session handling."
            />
            <FeatureCard
              title="Responsive UI Components"
              description="A library of pre-built, responsive UI components that work across all device sizes, from mobile to desktop."
            />
            <FeatureCard
              title="Theme System"
              description="Built-in theme support with light/dark modes, system preference detection, and user customization options."
            />
            <FeatureCard
              title="Notifications Framework"
              description="Real-time notification system with different notification types, read status tracking, and user preferences."
            />
          </div>
          <div
            style={{
              display: "grid",
              gridTemplateColumns: "repeat(auto-fill, minmax(300px, 1fr))",
              gap: "20px",
            }}
          >
            <FeatureCard
              title="Media Management"
              description="Infrastructure for handling images, videos, and other media types with upload, storage, and delivery capabilities."
            />
            <FeatureCard
              title="Social Components"
              description="Building blocks for social features like profiles, connections, activity feeds, and interactions."
            />
            <FeatureCard
              title="Layout System"
              description="Flexible layout components with responsive behavior, including sidebar, content areas, and navigation elements."
            />
            <FeatureCard
              title="Form Handling"
              description="Comprehensive form components with validation, error handling, and submission management."
            />
          </div>
        </section>

        <section style={{ marginBottom: "40px" }}>
          <h2
            style={{
              borderBottom: "1px solid var(--border-color)",
              paddingBottom: "10px",
              marginBottom: "20px",
            }}
          >
            Technical Details
          </h2>
          <div
            style={{
              backgroundColor: "var(--card-bg)",
              padding: "20px",
              borderRadius: "8px",
              border: "1px solid var(--border-color)",
            }}
          >
            <h3 style={{ margin: "0 0 15px 0", color: "var(--accent)" }}>
              Chet Stack Foundation
            </h3>
            <p
              style={{
                fontSize: "1.05rem",
                lineHeight: "1.6",
                marginBottom: "15px",
              }}
            >
              The core architecture of ABE Stack is built on Chet Stack, which
              provides:
            </p>
            <ul
              style={{
                paddingLeft: "20px",
                fontSize: "1.05rem",
                lineHeight: "1.6",
                marginBottom: "20px",
              }}
            >
              <li style={{ marginBottom: "8px" }}>
                Type-safe database access patterns
              </li>
              <li style={{ marginBottom: "8px" }}>
                Migration system for database schema evolution
              </li>
              <li style={{ marginBottom: "8px" }}>
                WebSocket infrastructure for real-time communication
              </li>
              <li style={{ marginBottom: "8px" }}>
                Client-side routing with code splitting
              </li>
              <li style={{ marginBottom: "8px" }}>
                Development tooling and production optimization
              </li>
            </ul>

            <h3 style={{ margin: "0 0 15px 0", color: "var(--accent)" }}>
              ABE Stack Extensions
            </h3>
            <p
              style={{
                fontSize: "1.05rem",
                lineHeight: "1.6",
                marginBottom: "15px",
              }}
            >
              ABE Stack extends this foundation with:
            </p>
            <ul
              style={{
                paddingLeft: "20px",
                fontSize: "1.05rem",
                lineHeight: "1.6",
              }}
            >
              <li style={{ marginBottom: "8px" }}>
                Comprehensive UI component library
              </li>
              <li style={{ marginBottom: "8px" }}>
                Authentication and user management
              </li>
              <li style={{ marginBottom: "8px" }}>
                Theme system with light/dark mode support
              </li>
              <li style={{ marginBottom: "8px" }}>
                Responsive design patterns for all device sizes
              </li>
              <li style={{ marginBottom: "8px" }}>
                Media handling capabilities
              </li>
              <li style={{ marginBottom: "8px" }}>
                Social features and interaction patterns
              </li>
            </ul>
          </div>
        </section>

        <section style={{ marginBottom: "40px" }}>
          <h2
            style={{
              borderBottom: "1px solid var(--border-color)",
              paddingBottom: "10px",
              marginBottom: "20px",
            }}
          >
            Explore the Stack
          </h2>
          <p
            style={{
              fontSize: "1.1rem",
              lineHeight: "1.6",
              marginBottom: "20px",
            }}
          >
            The best way to understand ABE Stack is to explore its features. Use
            the navigation menu to check out different sections:
          </p>
          <div
            style={{
              display: "grid",
              gridTemplateColumns: "repeat(auto-fill, minmax(200px, 1fr))",
              gap: "15px",
            }}
          >
            <ExploreCard
              title="Dashboard"
              _path="/dashboard"
              description="Overview of application capabilities"
              onClick={() => handleNavigate("/dashboard")}
            />
            <ExploreCard
              title="Profile"
              _path="/profile"
              description="User profile management"
              onClick={() => handleNavigate("/profile")}
            />
            <ExploreCard
              title="Explore"
              _path="/explore"
              description="Content discovery interface"
              onClick={() => handleNavigate("/explore")}
            />
            <ExploreCard
              title="Notifications"
              _path="/notifications"
              description="Notification system demo"
              onClick={() => handleNavigate("/notifications")}
            />
            <ExploreCard
              title="Settings"
              _path="/settings"
              description="Application preferences"
              onClick={() => handleNavigate("/settings")}
            />
          </div>
        </section>

        <section style={{ marginBottom: "40px" }}>
          <h2
            style={{
              borderBottom: "1px solid var(--border-color)",
              paddingBottom: "10px",
              marginBottom: "20px",
            }}
          >
            Getting Started
          </h2>
          <p
            style={{
              fontSize: "1.1rem",
              lineHeight: "1.6",
              marginBottom: "20px",
            }}
          >
            To use ABE Stack for your own project:
          </p>
          <ol
            style={{
              paddingLeft: "25px",
              fontSize: "1.05rem",
              lineHeight: "1.6",
            }}
          >
            <li style={{ marginBottom: "10px" }}>Clone the repository</li>
            <li style={{ marginBottom: "10px" }}>
              Install dependencies with{" "}
              <code
                style={{
                  backgroundColor: "var(--code-bg)",
                  padding: "2px 5px",
                  borderRadius: "3px",
                }}
              >
                npm install
              </code>
            </li>
            <li style={{ marginBottom: "10px" }}>
              Set up your PostgreSQL database
            </li>
            <li style={{ marginBottom: "10px" }}>
              Configure environment variables
            </li>
            <li style={{ marginBottom: "10px" }}>
              Run migrations with{" "}
              <code
                style={{
                  backgroundColor: "var(--code-bg)",
                  padding: "2px 5px",
                  borderRadius: "3px",
                }}
              >
                npm run migrate
              </code>
            </li>
            <li style={{ marginBottom: "10px" }}>
              Start development server with{" "}
              <code
                style={{
                  backgroundColor: "var(--code-bg)",
                  padding: "2px 5px",
                  borderRadius: "3px",
                }}
              >
                npm run dev
              </code>
            </li>
          </ol>
        </section>

        <footer
          style={{
            borderTop: "1px solid var(--border-color)",
            paddingTop: "20px",
            marginTop: "40px",
            textAlign: "center",
            color: "var(--text-secondary)",
            fontSize: "0.9rem",
          }}
        >
          <p style={{ marginBottom: "10px" }}>
            ABE Stack is built upon{" "}
            <a
              href="https://github.com/ccorcos/chet-stack"
              target="_blank"
              rel="noopener noreferrer"
              style={{
                color: "var(--accent)",
                textDecoration: "none",
                fontWeight: "bold",
              }}
            >
              Chet Stack
            </a>{" "}
            by Chet Corcos.
          </p>
          <p>
            We are grateful for the excellent foundation provided by Chet Stack,
            which made this extended boilerplate possible.
          </p>
        </footer>
      </div>
    </PageContent>
  );
}

// Feature card component for displaying features in a grid
function FeatureCard({
  title,
  description,
}: {
  title: string;
  description: string;
}) {
  return (
    <div
      style={{
        backgroundColor: "var(--card-bg)",
        borderRadius: "8px",
        padding: "20px",
        boxShadow: "var(--shadow)",
        border: "1px solid var(--border-color)",
        transition: "transform 0.2s ease, box-shadow 0.2s ease",
        height: "100%",
      }}
    >
      <h3
        style={{ marginTop: 0, marginBottom: "10px", color: "var(--accent)" }}
      >
        {title}
      </h3>
      <p
        style={{ margin: 0, color: "var(--text-secondary)", lineHeight: "1.5" }}
      >
        {description}
      </p>
    </div>
  );
}

// Explore card component for navigation links
function ExploreCard({
  title,
  _path: _path,
  description,
  onClick,
}: {
  title: string;
  _path: string;
  description: string;
  onClick: () => void;
}) {
  return (
    <div
      onClick={onClick}
      style={{
        backgroundColor: "var(--card-bg)",
        borderRadius: "8px",
        padding: "15px",
        boxShadow: "var(--shadow)",
        border: "1px solid var(--border-color)",
        transition: "transform 0.2s ease, box-shadow 0.2s ease",
        height: "100%",
        cursor: "pointer",
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        textAlign: "center",
      }}
    >
      <h3 style={{ marginTop: 0, marginBottom: "8px", color: "var(--accent)" }}>
        {title}
      </h3>
      <p
        style={{
          margin: 0,
          color: "var(--text-secondary)",
          fontSize: "0.9rem",
        }}
      >
        {description}
      </p>
    </div>
  );
}
```

#### apps/web/src/components/pages/MediaPage.tsx

```tsx
import { PageContent } from "../../layouts/PageContent";

export function MediaPage() {
  return (
    <PageContent
      title="Media Page"
      description="This page demonstrates the multimedia capabilities of the ABE Stack."
    >
      <div style={{ marginTop: "20px" }}>
        <h2>Media Features</h2>
        <ul>
          <li>Video streaming with HLS/DASH support</li>
          <li>Audio playback with waveform visualization</li>
          <li>Image galleries with lazy loading</li>
          <li>File uploads with progress tracking</li>
          <li>Media metadata extraction</li>
          <li>Responsive media players</li>
        </ul>
      </div>

      {/* Example media player placeholder */}
      <div
        style={{
          width: "100%",
          maxWidth: "640px",
          height: "360px",
          backgroundColor: "#222",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          marginTop: "20px",
          borderRadius: "8px",
        }}
      >
        <p style={{ color: "white" }}>Media Player Placeholder</p>
      </div>
    </PageContent>
  );
}
```

#### apps/web/src/components/pages/NotificationsPage.tsx

```tsx
import { useState } from "react";

import { PageContent } from "../../layouts/PageContent";

// Notifications page styles
const styles = {
  tabs: {
    marginTop: "20px",
    borderBottom: "1px solid var(--border-color)",
  },
  tabButtons: {
    display: "flex",
    gap: "10px",
    overflowX: "auto" as const,
  },
  tabButton: {
    padding: "10px 15px",
    backgroundColor: "transparent",
    border: "none",
    cursor: "pointer",
    textTransform: "capitalize" as const,
    color: "var(--text-primary)",
  },
  tabButtonActive: {
    color: "var(--blue)",
    borderBottom: "2px solid var(--blue)",
    fontWeight: "bold",
  },
  container: {
    marginTop: "20px",
  },
  empty: {
    padding: "40px 20px",
    textAlign: "center" as const,
    backgroundColor: "var(--surface)",
    borderRadius: "8px",
    color: "var(--text-secondary)",
  },
  list: {
    display: "flex",
    flexDirection: "column" as const,
    gap: "10px",
  },
  item: {
    padding: "15px",
    borderRadius: "8px",
    border: "1px solid var(--border-color)",
    display: "flex",
    alignItems: "center",
    gap: "15px",
  },
  itemUnread: {
    backgroundColor: "rgba(0, 120, 255, 0.05)",
  },
  itemRead: {
    backgroundColor: "var(--card-bg)",
  },
  icon: {
    width: "40px",
    height: "40px",
    borderRadius: "50%",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    fontSize: "18px",
  },
  iconUnread: {
    backgroundColor: "var(--blue)",
    color: "white",
  },
  iconRead: {
    backgroundColor: "var(--surface)",
    color: "var(--text-secondary)",
  },
  content: {
    flex: 1,
  },
  text: {
    color: "var(--text-primary)",
  },
  textUnread: {
    fontWeight: "bold",
  },
  username: {
    fontWeight: "bold",
    color: "var(--text-primary)",
  },
  time: {
    fontSize: "14px",
    color: "var(--text-secondary)",
    marginTop: "5px",
  },
  menuButton: {
    backgroundColor: "transparent",
    border: "none",
    cursor: "pointer",
    color: "var(--text-secondary)",
    padding: "5px",
    borderRadius: "50%",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
  },
  actions: {
    marginTop: "30px",
    display: "flex",
    justifyContent: "space-between",
  },
  actionButton: {
    padding: "10px 20px",
    backgroundColor: "var(--card-bg)",
    borderRadius: "4px",
    cursor: "pointer",
  },
  actionPrimary: {
    color: "var(--blue)",
    border: "1px solid var(--blue)",
  },
  actionSecondary: {
    color: "var(--text-secondary)",
    border: "1px solid var(--border-color)",
  },
};

export function NotificationsPage() {
  const [activeTab, setActiveTab] = useState("all");

  // Mock notifications data
  const notifications = [
    {
      id: 1,
      type: "comment",
      user: "Jane Smith",
      content: "commented on your post",
      time: "2 minutes ago",
      read: false,
    },
    {
      id: 2,
      type: "like",
      user: "John Doe",
      content: "liked your photo",
      time: "15 minutes ago",
      read: false,
    },
    {
      id: 3,
      type: "follow",
      user: "Alice Johnson",
      content: "started following you",
      time: "1 hour ago",
      read: false,
    },
    {
      id: 4,
      type: "mention",
      user: "Bob Wilson",
      content: "mentioned you in a comment",
      time: "3 hours ago",
      read: true,
    },
    {
      id: 5,
      type: "system",
      user: "ABE Stack",
      content: "Your account was successfully verified",
      time: "1 day ago",
      read: true,
    },
    {
      id: 6,
      type: "comment",
      user: "Carol Taylor",
      content: "replied to your comment",
      time: "2 days ago",
      read: true,
    },
  ];

  const filteredNotifications =
    activeTab === "all"
      ? notifications
      : activeTab === "unread"
        ? notifications.filter((n) => !n.read)
        : notifications.filter((n) => n.type === activeTab);

  const getNotificationIcon = (type: string) => {
    switch (type) {
      case "comment":
        return "💬";
      case "like":
        return "❤️";
      case "follow":
        return "👤";
      case "mention":
        return "@️";
      case "system":
        return "🔔";
      default:
        return "📣";
    }
  };

  return (
    <PageContent
      title="Notifications"
      description="Stay updated with your latest activity and interactions."
    >
      {/* Tabs */}
      <div style={styles.tabs}>
        <div style={styles.tabButtons}>
          {["all", "unread", "comment", "like", "follow", "mention"].map(
            (tab) => (
              <button
                key={tab}
                onClick={() => setActiveTab(tab)}
                style={{
                  ...styles.tabButton,
                  ...(activeTab === tab ? styles.tabButtonActive : {}),
                }}
              >
                {tab}
              </button>
            ),
          )}
        </div>
      </div>

      {/* Notifications List */}
      <div style={styles.container}>
        {filteredNotifications.length === 0 ? (
          <div style={styles.empty}>No notifications to display</div>
        ) : (
          <div style={styles.list}>
            {filteredNotifications.map((notification) => (
              <div
                key={notification.id}
                style={{
                  ...styles.item,
                  ...(notification.read ? styles.itemRead : styles.itemUnread),
                }}
              >
                <div
                  style={{
                    ...styles.icon,
                    ...(notification.read
                      ? styles.iconRead
                      : styles.iconUnread),
                  }}
                >
                  {getNotificationIcon(notification.type)}
                </div>
                <div style={styles.content}>
                  <div
                    style={{
                      ...styles.text,
                      ...(notification.read ? {} : styles.textUnread),
                    }}
                  >
                    <span style={styles.username}>{notification.user}</span>{" "}
                    {notification.content}
                  </div>
                  <div style={styles.time}>{notification.time}</div>
                </div>
                <button style={styles.menuButton}>•••</button>
              </div>
            ))}
          </div>
        )}
      </div>

      {/* Actions */}
      <div style={styles.actions}>
        <button style={{ ...styles.actionButton, ...styles.actionPrimary }}>
          Mark all as read
        </button>
        <button style={{ ...styles.actionButton, ...styles.actionSecondary }}>
          Notification settings
        </button>
      </div>
    </PageContent>
  );
}
```

#### apps/web/src/components/pages/ProfilePage.tsx

```tsx
import React, { useEffect, useState } from "react";

import { PageContent } from "../../layouts/PageContent";
import { socialService } from "../../services/social";
import { CommentSection } from "../social/CommentSection";
import { PostCard } from "../social/PostCard";

interface User {
  id: string;
  username: string;
  displayName: string;
  avatar: string;
  bio: string;
  followersCount: number;
  followingCount: number;
  postsCount: number;
  isFollowing: boolean;
}

interface Post {
  id: string;
  userId: string;
  username: string;
  userAvatar: string;
  content: string;
  media?: {
    type: "image" | "video" | "audio";
    url: string;
    thumbnail?: string;
  };
  likesCount: number;
  commentsCount: number;
  sharesCount: number;
  isLiked: boolean;
  createdAt: string;
}

export function ProfilePage() {
  const [user, setUser] = useState<User | null>(null);
  const [posts, setPosts] = useState<Post[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isFollowing, setIsFollowing] = useState(false);
  const [followersCount, setFollowersCount] = useState(0);
  const [activeCommentPostId, setActiveCommentPostId] = useState<string | null>(
    null,
  );
  const [activeTab, setActiveTab] = useState<"posts" | "media">("posts");

  // Get userId from URL
  // Extract userId from the current URL path
  const currentUrl = window.location.pathname;
  const userId = currentUrl.startsWith("/profile/")
    ? currentUrl.substring("/profile/".length)
    : "current"; // Default to 'current' if no userId in URL

  // Define fetch functions with useCallback to avoid dependency issues
  const fetchUserProfile = React.useCallback(async () => {
    setIsLoading(true);
    try {
      const userData = await socialService.getUserProfile(userId);
      setUser(userData);
      setIsFollowing(userData.isFollowing);
      setFollowersCount(userData.followersCount);
    } catch (error) {
      console.error("Error fetching user profile:", error);
    } finally {
      setIsLoading(false);
    }
  }, [userId]);

  const fetchUserPosts = React.useCallback(async () => {
    try {
      const response = await socialService.getFeed("profile", userId);
      setPosts(response.posts);
    } catch (error) {
      console.error("Error fetching user posts:", error);
    }
  }, [userId]);

  useEffect(() => {
    void fetchUserProfile();
    void fetchUserPosts();
  }, [fetchUserProfile, fetchUserPosts]);

  const handleFollowToggle = async () => {
    if (!user) return;

    try {
      if (isFollowing) {
        await socialService.unfollowUser(user.id);
        setIsFollowing(false);
        setFollowersCount((prev) => prev - 1);
      } else {
        await socialService.followUser(user.id);
        setIsFollowing(true);
        setFollowersCount((prev) => prev + 1);
      }
    } catch (error) {
      console.error("Error toggling follow:", error);
    }
  };

  const handleCommentClick = (postId: string) => {
    setActiveCommentPostId(postId);
  };

  // Void-returning wrapper for handleFollowToggle
  const handleFollowToggleWrapper = () => {
    void handleFollowToggle();
  };

  const handleRefresh = () => {
    void fetchUserPosts();
  };

  const filteredPosts =
    activeTab === "posts" ? posts : posts.filter((post) => post.media);

  if (isLoading) {
    return (
      <PageContent title="Profile" description="Loading user profile...">
        <div style={{ textAlign: "center", padding: "40px" }}>
          Loading profile...
        </div>
      </PageContent>
    );
  }

  if (!user) {
    return (
      <PageContent
        title="Profile Not Found"
        description="User profile not found"
      >
        <div style={{ textAlign: "center", padding: "40px" }}>
          User not found
        </div>
      </PageContent>
    );
  }

  return (
    <PageContent
      title={`${user.displayName}'s Profile`}
      description={`View ${user.displayName}'s profile and posts`}
    >
      <div style={{ maxWidth: "800px", margin: "0 auto", padding: "20px 0" }}>
        <div
          style={{
            backgroundColor: "white",
            borderRadius: "8px",
            border: "1px solid #e0e0e0",
            padding: "24px",
            marginBottom: "24px",
          }}
        >
          <div style={{ display: "flex", alignItems: "center" }}>
            <img
              src={user.avatar || "/default-avatar.png"}
              alt={user.displayName}
              style={{
                width: "120px",
                height: "120px",
                borderRadius: "50%",
                marginRight: "24px",
                objectFit: "cover",
              }}
            />
            <div style={{ flex: 1 }}>
              <h2 style={{ margin: "0 0 8px 0" }}>{user.displayName}</h2>
              <div style={{ color: "#666", marginBottom: "12px" }}>
                @{user.username}
              </div>
              <div style={{ marginBottom: "16px" }}>{user.bio}</div>
              <div style={{ display: "flex", gap: "24px", color: "#666" }}>
                <div>
                  <strong>{user.postsCount}</strong> posts
                </div>
                <div>
                  <strong>{followersCount}</strong> followers
                </div>
                <div>
                  <strong>{user.followingCount}</strong> following
                </div>
              </div>
            </div>
            <div>
              <button
                onClick={handleFollowToggleWrapper}
                style={{
                  padding: "10px 20px",
                  backgroundColor: isFollowing ? "white" : "var(--accent)",
                  color: isFollowing ? "var(--accent)" : "white",
                  border: isFollowing ? "1px solid var(--accent)" : "none",
                  borderRadius: "20px",
                  cursor: "pointer",
                  fontWeight: "bold",
                }}
              >
                {isFollowing ? "Unfollow" : "Follow"}
              </button>
            </div>
          </div>
        </div>

        <div
          style={{
            display: "flex",
            borderBottom: "1px solid #e0e0e0",
            marginBottom: "24px",
          }}
        >
          <button
            onClick={() => setActiveTab("posts")}
            style={{
              padding: "12px 24px",
              backgroundColor: "transparent",
              border: "none",
              borderBottom:
                activeTab === "posts" ? "2px solid var(--accent)" : "none",
              color: activeTab === "posts" ? "var(--accent)" : "inherit",
              fontWeight: activeTab === "posts" ? "bold" : "normal",
              cursor: "pointer",
            }}
          >
            Posts
          </button>
          <button
            onClick={() => setActiveTab("media")}
            style={{
              padding: "12px 24px",
              backgroundColor: "transparent",
              border: "none",
              borderBottom:
                activeTab === "media" ? "2px solid var(--accent)" : "none",
              color: activeTab === "media" ? "var(--accent)" : "inherit",
              fontWeight: activeTab === "media" ? "bold" : "normal",
              cursor: "pointer",
            }}
          >
            Media
          </button>
        </div>

        {filteredPosts.length === 0 ? (
          <div
            style={{
              textAlign: "center",
              padding: "40px",
              backgroundColor: "white",
              borderRadius: "8px",
              border: "1px solid #e0e0e0",
            }}
          >
            <h3>No {activeTab} yet</h3>
            <p>
              {activeTab === "posts"
                ? "User has not created any posts yet."
                : "User has not shared any media yet."}
            </p>
          </div>
        ) : (
          <>
            {filteredPosts.map((post) => (
              <PostCard
                key={post.id}
                post={post}
                onCommentClick={handleCommentClick}
                onRefresh={handleRefresh}
              />
            ))}
          </>
        )}
      </div>

      {activeCommentPostId && (
        <CommentSection
          postId={activeCommentPostId}
          onClose={() => setActiveCommentPostId(null)}
        />
      )}
    </PageContent>
  );
}
```

#### apps/web/src/components/pages/SettingsPage.tsx

```tsx
import { PageContent } from "../../layouts/PageContent";
import { useTheme } from "../theme";

export function SettingsPage() {
  const {
    theme,
    toggleTheme,
    useSystemTheme: enableSystemTheme,
    isUsingSystemTheme,
    setTheme,
  } = useTheme();

  // Function to disable system theme
  const disableSystemTheme = () => {
    // Keep current theme but disable system theme
    setTheme(theme);
  };

  // Handler for system theme toggle
  const handleSystemThemeToggle = () => {
    if (isUsingSystemTheme) {
      disableSystemTheme();
    } else {
      enableSystemTheme();
    }
  };

  // Define styles as a TypeScript object
  const styles = {
    container: {
      maxWidth: "800px",
      margin: "0 auto",
    },
    section: {
      backgroundColor: "var(--card-bg)",
      borderRadius: "8px",
      padding: "20px",
      marginBottom: "24px",
      boxShadow: "var(--shadow)",
      border: "1px solid var(--border-color)",
    },
    sectionTitle: {
      marginTop: 0,
      marginBottom: "16px",
      color: "var(--text-primary)",
      fontSize: "1.2rem",
      fontWeight: 600,
      borderBottom: "1px solid var(--border-color)",
      paddingBottom: "8px",
    },
    option: {
      marginBottom: "16px",
    },
    optionLast: {
      marginBottom: 0,
    },
    optionLabel: {
      display: "block",
      marginBottom: "8px",
      fontWeight: 500,
      color: "var(--text-primary)",
    },
    toggleContainer: {
      display: "flex",
      alignItems: "center",
      gap: "12px",
    },
    themeLabel: {
      color: "var(--text-secondary)",
      fontSize: "0.9rem",
    },
    systemNote: {
      color: "var(--text-secondary)",
      fontSize: "0.8rem",
      fontStyle: "italic",
      marginLeft: "4px",
    },
    // Toggle Switch styles
    switch: {
      position: "relative" as const,
      display: "inline-block",
      width: "60px",
      height: "34px",
    },
    switchInput: {
      opacity: 0,
      width: 0,
      height: 0,
    },
    slider: {
      position: "absolute" as const,
      cursor: "pointer",
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: "var(--surface-variant)",
      transition: ".4s",
      borderRadius: "34px",
    },
    sliderBefore: {
      position: "absolute" as const,
      content: '""',
      height: "26px",
      width: "26px",
      left: "4px",
      bottom: "4px",
      backgroundColor: "white",
      transition: ".4s",
      borderRadius: "50%",
    },
    sliderChecked: {
      backgroundColor: "var(--accent)",
    },
    sliderBeforeChecked: {
      transform: "translateX(26px)",
    },
    sliderDisabled: {
      opacity: 0.6,
      cursor: "not-allowed",
    },
    sliderBeforeDisabled: {
      backgroundColor: "#f0f0f0",
    },
  };

  return (
    <PageContent
      title="Settings"
      description="Customize your application preferences"
    >
      <div style={styles.container}>
        <div style={styles.section}>
          <h2 style={styles.sectionTitle}>Appearance</h2>
          <div style={styles.option}>
            <label htmlFor="system-theme" style={styles.optionLabel}>
              Use System Theme
            </label>
            <div style={styles.toggleContainer}>
              <label style={styles.switch}>
                <input
                  type="checkbox"
                  id="system-theme"
                  checked={isUsingSystemTheme}
                  onChange={handleSystemThemeToggle}
                  style={styles.switchInput}
                />
                <span
                  style={{
                    ...styles.slider,
                    ...(isUsingSystemTheme ? styles.sliderChecked : {}),
                  }}
                >
                  <span
                    style={{
                      ...styles.sliderBefore,
                      ...(isUsingSystemTheme ? styles.sliderBeforeChecked : {}),
                    }}
                  ></span>
                </span>
              </label>
              <span style={styles.themeLabel}>
                Follow system light/dark preference
              </span>
            </div>
          </div>

          <div style={styles.option}>
            <label htmlFor="theme-toggle" style={styles.optionLabel}>
              Theme
            </label>
            <div style={styles.toggleContainer}>
              <span style={styles.themeLabel}>Light</span>
              <label style={styles.switch}>
                <input
                  type="checkbox"
                  id="theme-toggle"
                  checked={theme === "dark"}
                  onChange={toggleTheme}
                  disabled={isUsingSystemTheme}
                  style={styles.switchInput}
                />
                <span
                  style={{
                    ...styles.slider,
                    ...(theme === "dark" ? styles.sliderChecked : {}),
                    ...(isUsingSystemTheme ? styles.sliderDisabled : {}),
                  }}
                >
                  <span
                    style={{
                      ...styles.sliderBefore,
                      ...(theme === "dark" ? styles.sliderBeforeChecked : {}),
                      ...(isUsingSystemTheme
                        ? styles.sliderBeforeDisabled
                        : {}),
                    }}
                  ></span>
                </span>
              </label>
              <span style={styles.themeLabel}>Dark</span>
              {isUsingSystemTheme && (
                <span style={styles.systemNote}>(Controlled by system)</span>
              )}
            </div>
          </div>
        </div>

        <div style={styles.section}>
          <h2 style={styles.sectionTitle}>Account</h2>
          <div style={{ ...styles.option, ...styles.optionLast }}>
            <p>Account settings will be available soon.</p>
          </div>
        </div>

        <div style={styles.section}>
          <h2 style={styles.sectionTitle}>Notifications</h2>
          <div style={{ ...styles.option, ...styles.optionLast }}>
            <p>Notification settings will be available soon.</p>
          </div>
        </div>

        <div style={styles.section}>
          <h2 style={styles.sectionTitle}>Privacy</h2>
          <div style={{ ...styles.option, ...styles.optionLast }}>
            <p>Privacy settings will be available soon.</p>
          </div>
        </div>
      </div>
    </PageContent>
  );
}
```

#### apps/web/src/components/pages/SocialPage.tsx

```tsx
import { useCallback, useEffect, useState } from "react";

import { PageContent } from "../../layouts/PageContent";
import { socialService } from "../../services/social";
import { CommentSection } from "../social/CommentSection";
import { CreatePostForm } from "../social/CreatePostForm";
import { PostCard } from "../social/PostCard";
import { UserProfileCard } from "../social/UserProfileCard";

interface User {
  id: string;
  username: string;
  displayName: string;
  avatar: string;
  bio: string;
  followersCount: number;
  followingCount: number;
  postsCount: number;
  isFollowing: boolean;
}

interface Post {
  id: string;
  userId: string;
  username: string;
  userAvatar: string;
  content: string;
  media?: {
    type: "image" | "video" | "audio";
    url: string;
    thumbnail?: string;
  };
  likesCount: number;
  commentsCount: number;
  sharesCount: number;
  isLiked: boolean;
  createdAt: string;
}

export function SocialPage() {
  const [posts, setPosts] = useState<Post[]>([]);
  const [suggestedUsers, setSuggestedUsers] = useState<User[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [hasMore, setHasMore] = useState(false);
  const [offset, setOffset] = useState(0);
  const [activeCommentPostId, setActiveCommentPostId] = useState<string | null>(
    null,
  );

  const fetchFeed = useCallback(async () => {
    setIsLoading(true);
    try {
      const response = await socialService.getFeed("home", undefined, offset);
      if (offset === 0) {
        setPosts(response.posts);
      } else {
        setPosts((prev) => [...prev, ...response.posts]);
      }
      setHasMore(response.hasMore);
    } catch (error) {
      console.error("Error fetching feed:", error);
    } finally {
      setIsLoading(false);
    }
  }, [offset]);

  const fetchSuggestedUsers = useCallback(() => {
    try {
      // This is a mock implementation - in a real app, you'd have an API endpoint for this
      // For now, we'll create some dummy users
      const dummyUsers: User[] = [
        {
          id: "1",
          username: "johndoe",
          displayName: "John Doe",
          avatar: "https://randomuser.me/api/portraits/men/1.jpg",
          bio: "Software developer and tech enthusiast",
          followersCount: 245,
          followingCount: 123,
          postsCount: 42,
          isFollowing: false,
        },
        {
          id: "2",
          username: "janedoe",
          displayName: "Jane Doe",
          avatar: "https://randomuser.me/api/portraits/women/1.jpg",
          bio: "UX Designer | Coffee lover",
          followersCount: 532,
          followingCount: 231,
          postsCount: 87,
          isFollowing: false,
        },
        {
          id: "3",
          username: "alexsmith",
          displayName: "Alex Smith",
          avatar: "https://randomuser.me/api/portraits/men/2.jpg",
          bio: "Photographer and traveler",
          followersCount: 1245,
          followingCount: 342,
          postsCount: 156,
          isFollowing: false,
        },
      ];

      setSuggestedUsers(dummyUsers);
    } catch (error) {
      console.error("Error fetching suggested users:", error);
    }
  }, []);

  useEffect(() => {
    void fetchFeed();
    void fetchSuggestedUsers();
  }, [fetchFeed, fetchSuggestedUsers]);

  const handleLoadMore = () => {
    setOffset((prev) => prev + 10);
    void fetchFeed();
  };

  const handleRefresh = () => {
    setOffset(0);
    void fetchFeed();
    void fetchSuggestedUsers();
  };

  const handleCommentClick = (postId: string) => {
    setActiveCommentPostId(postId);
  };

  return (
    <PageContent
      title="Social Feed"
      description="Connect with friends and share your thoughts."
    >
      <div
        style={{
          display: "grid",
          gridTemplateColumns: "1fr 300px",
          gap: "24px",
          maxWidth: "1200px",
          margin: "0 auto",
          padding: "20px 0",
        }}
      >
        <div>
          <CreatePostForm onPostCreated={handleRefresh} />

          {posts.length === 0 && !isLoading ? (
            <div
              style={{
                textAlign: "center",
                padding: "40px",
                backgroundColor: "white",
                borderRadius: "8px",
                border: "1px solid #e0e0e0",
              }}
            >
              <h3>No posts yet</h3>
              <p>
                Create a post or follow users to see their posts in your feed.
              </p>
            </div>
          ) : (
            <>
              {posts.map((post) => (
                <PostCard
                  key={post.id}
                  post={post}
                  onCommentClick={handleCommentClick}
                  onRefresh={handleRefresh}
                />
              ))}

              {hasMore && (
                <div
                  style={{
                    textAlign: "center",
                    marginTop: "24px",
                    marginBottom: "24px",
                  }}
                >
                  <button
                    onClick={handleLoadMore}
                    disabled={isLoading}
                    style={{
                      padding: "10px 24px",
                      backgroundColor: "var(--accent)",
                      color: "white",
                      border: "none",
                      borderRadius: "20px",
                      cursor: "pointer",
                      opacity: isLoading ? 0.7 : 1,
                    }}
                  >
                    {isLoading ? "Loading..." : "Load More"}
                  </button>
                </div>
              )}
            </>
          )}
        </div>

        <div>
          <div
            style={{
              backgroundColor: "white",
              borderRadius: "8px",
              border: "1px solid #e0e0e0",
              padding: "16px",
              marginBottom: "24px",
            }}
          >
            <h3 style={{ marginTop: 0, marginBottom: "16px" }}>
              Suggested Users
            </h3>
            {suggestedUsers.map((user) => (
              <UserProfileCard key={user.id} user={user} />
            ))}
          </div>

          <div
            style={{
              backgroundColor: "white",
              borderRadius: "8px",
              border: "1px solid #e0e0e0",
              padding: "16px",
            }}
          >
            <h3 style={{ marginTop: 0, marginBottom: "16px" }}>About</h3>
            <p>
              This social feed demonstrates the integration of server-side
              social features with the client-side UI.
            </p>
            <p>Features include:</p>
            <ul>
              <li>Creating posts with text and media</li>
              <li>Liking and commenting on posts</li>
              <li>Following other users</li>
              <li>Real-time updates</li>
            </ul>
          </div>
        </div>
      </div>

      {activeCommentPostId && (
        <CommentSection
          postId={activeCommentPostId}
          onClose={() => setActiveCommentPostId(null)}
        />
      )}
    </PageContent>
  );
}
```

#### apps/web/src/components/pages/UploadPage.tsx

```tsx
import React, { useState } from "react";

import { PageContent } from "../../layouts/PageContent";

export function UploadPage() {
  const [uploadProgress, setUploadProgress] = useState(0);
  const [isUploading, setIsUploading] = useState(false);
  const [selectedFile, setSelectedFile] = useState<File | null>(null);

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files.length > 0) {
      setSelectedFile(e.target.files[0]);
    }
  };

  const simulateUpload = () => {
    if (!selectedFile) return;

    setIsUploading(true);
    setUploadProgress(0);

    const interval = setInterval(() => {
      setUploadProgress((prev) => {
        const newProgress = prev + 5;
        if (newProgress >= 100) {
          clearInterval(interval);
          setTimeout(() => {
            setIsUploading(false);
            setSelectedFile(null);
            // Reset file input
            const fileInput = document.getElementById(
              "file-upload",
            ) as HTMLInputElement;
            if (fileInput) fileInput.value = "";
          }, 500);
          return 100;
        }
        return newProgress;
      });
    }, 200);
  };

  return (
    <PageContent
      title="Upload Media"
      description="Share your videos, images, or audio files with your audience."
    >
      <div
        style={{
          maxWidth: "800px",
          margin: "30px auto",
          border: "1px solid #ddd",
          borderRadius: "8px",
          padding: "20px",
        }}
      >
        <h2>Upload New Media</h2>

        <div style={{ marginTop: "20px" }}>
          <div
            style={{
              border: "2px dashed #ccc",
              borderRadius: "8px",
              padding: "40px 20px",
              textAlign: "center",
              backgroundColor: "#f9f9f9",
              cursor: "pointer",
            }}
            onClick={() => document.getElementById("file-upload")?.click()}
          >
            <input
              type="file"
              id="file-upload"
              style={{ display: "none" }}
              onChange={handleFileChange}
              accept="image/*,video/*,audio/*"
            />
            <div style={{ fontSize: "48px", marginBottom: "10px" }}>📁</div>
            <p>Click to select or drag and drop your file here</p>
            <p style={{ fontSize: "14px", color: "#666" }}>
              Supports images, videos, and audio files
            </p>
          </div>
        </div>

        {selectedFile && (
          <div style={{ marginTop: "20px" }}>
            <h3>Selected File</h3>
            <div
              style={{
                display: "flex",
                alignItems: "center",
                gap: "10px",
                padding: "10px",
                border: "1px solid #eee",
                borderRadius: "4px",
              }}
            >
              <div style={{ fontSize: "24px" }}>
                {selectedFile.type.startsWith("image/")
                  ? "🖼️"
                  : selectedFile.type.startsWith("video/")
                    ? "🎬"
                    : selectedFile.type.startsWith("audio/")
                      ? "🎵"
                      : "📄"}
              </div>
              <div style={{ flexGrow: 1 }}>
                <div>{selectedFile.name}</div>
                <div style={{ fontSize: "14px", color: "#666" }}>
                  {(selectedFile.size / 1024 / 1024).toFixed(2)} MB •{" "}
                  {selectedFile.type}
                </div>
              </div>
            </div>
          </div>
        )}

        {isUploading && (
          <div style={{ marginTop: "20px" }}>
            <h3>Uploading...</h3>
            <div
              style={{
                height: "8px",
                backgroundColor: "#eee",
                borderRadius: "4px",
                overflow: "hidden",
              }}
            >
              <div
                style={{
                  height: "100%",
                  width: `${uploadProgress}%`,
                  backgroundColor: "var(--blue)",
                  transition: "width 0.2s ease-in-out",
                }}
              />
            </div>
            <div style={{ textAlign: "center", marginTop: "5px" }}>
              {uploadProgress}%
            </div>
          </div>
        )}

        <div style={{ marginTop: "20px" }}>
          <button
            onClick={simulateUpload}
            disabled={!selectedFile || isUploading}
            style={{
              padding: "8px 16px",
              backgroundColor:
                !selectedFile || isUploading ? "#ccc" : "var(--blue)",
              color: "white",
              border: "none",
              borderRadius: "4px",
              cursor: !selectedFile || isUploading ? "not-allowed" : "pointer",
            }}
          >
            {isUploading ? "Uploading..." : "Upload File"}
          </button>
        </div>
      </div>

      <div style={{ maxWidth: "800px", margin: "30px auto" }}>
        <h2>Upload History</h2>
        <table style={{ width: "100%", borderCollapse: "collapse" }}>
          <thead>
            <tr style={{ borderBottom: "1px solid #ddd" }}>
              <th style={{ textAlign: "left", padding: "10px" }}>File</th>
              <th style={{ textAlign: "left", padding: "10px" }}>Type</th>
              <th style={{ textAlign: "left", padding: "10px" }}>Size</th>
              <th style={{ textAlign: "left", padding: "10px" }}>Date</th>
              <th style={{ textAlign: "left", padding: "10px" }}>Status</th>
            </tr>
          </thead>
          <tbody>
            <tr style={{ borderBottom: "1px solid #ddd" }}>
              <td style={{ padding: "10px" }}>vacation.mp4</td>
              <td style={{ padding: "10px" }}>Video</td>
              <td style={{ padding: "10px" }}>24.5 MB</td>
              <td style={{ padding: "10px" }}>2023-03-15</td>
              <td style={{ padding: "10px" }}>
                <span style={{ color: "green" }}>Completed</span>
              </td>
            </tr>
            <tr style={{ borderBottom: "1px solid #ddd" }}>
              <td style={{ padding: "10px" }}>profile-pic.jpg</td>
              <td style={{ padding: "10px" }}>Image</td>
              <td style={{ padding: "10px" }}>1.2 MB</td>
              <td style={{ padding: "10px" }}>2023-03-10</td>
              <td style={{ padding: "10px" }}>
                <span style={{ color: "green" }}>Completed</span>
              </td>
            </tr>
            <tr style={{ borderBottom: "1px solid #ddd" }}>
              <td style={{ padding: "10px" }}>podcast-episode.mp3</td>
              <td style={{ padding: "10px" }}>Audio</td>
              <td style={{ padding: "10px" }}>18.7 MB</td>
              <td style={{ padding: "10px" }}>2023-03-05</td>
              <td style={{ padding: "10px" }}>
                <span style={{ color: "green" }}>Completed</span>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </PageContent>
  );
}
```

#### apps/web/src/components/social/CommentSection.tsx

```tsx
import React, { useCallback, useEffect, useState } from "react";

import { formatDate } from "../../../server/infrastructure/utils/dateHelpers";
import { socialService } from "../../services/social";

interface Comment {
  id: string;
  userId: string;
  username: string;
  userAvatar: string;
  content: string;
  likesCount: number;
  isLiked: boolean;
  createdAt: string;
  replies?: Comment[];
}

interface CommentSectionProps {
  postId: string;
  onClose: () => void;
}

export const CommentSection: React.FC<CommentSectionProps> = ({
  postId,
  onClose,
}) => {
  const [comments, setComments] = useState<Comment[]>([]);
  const [newComment, setNewComment] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [hasMore, setHasMore] = useState(false);
  const [offset, setOffset] = useState(0);

  const fetchComments = useCallback(async () => {
    setIsLoading(true);
    try {
      const response = await socialService.getComments(postId, offset);
      if (offset === 0) {
        setComments(response.comments);
      } else {
        setComments((prev) => [...prev, ...response.comments]);
      }
      setHasMore(response.hasMore);
    } catch (error) {
      console.error("Error fetching comments:", error);
    } finally {
      setIsLoading(false);
    }
  }, [postId, offset]);

  useEffect(() => {
    void fetchComments();
  }, [fetchComments]);

  const handleLoadMore = () => {
    setOffset((prev) => prev + 10);
    void fetchComments();
  };

  const handleSubmitComment = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!newComment.trim() || isLoading) return;

    setIsLoading(true);
    try {
      const comment = await socialService.createComment(postId, newComment);
      setComments((prev) => [comment, ...prev]);
      setNewComment("");
    } catch (error) {
      console.error("Error creating comment:", error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleLikeComment = async (commentId: string, isLiked: boolean) => {
    try {
      if (isLiked) {
        await socialService.unlikeComment(commentId);
      } else {
        await socialService.likeComment(commentId);
      }

      setComments((prev) =>
        prev.map((comment) =>
          comment.id === commentId
            ? {
                ...comment,
                isLiked: !isLiked,
                likesCount: isLiked
                  ? comment.likesCount - 1
                  : comment.likesCount + 1,
              }
            : comment,
        ),
      );
    } catch (error) {
      console.error("Error toggling comment like:", error);
    }
  };

  // Create void-returning wrapper functions for event handlers
  const handleLikeCommentWrapper = (commentId: string, isLiked: boolean) => {
    void handleLikeComment(commentId, isLiked);
  };

  const handleSubmitCommentWrapper = (e: React.FormEvent) => {
    void handleSubmitComment(e);
  };

  return (
    <div
      style={{
        position: "fixed",
        top: 0,
        right: 0,
        bottom: 0,
        width: "400px",
        backgroundColor: "white",
        boxShadow: "-2px 0 10px rgba(0,0,0,0.1)",
        zIndex: 1000,
        display: "flex",
        flexDirection: "column",
      }}
    >
      <div
        style={{
          padding: "16px",
          borderBottom: "1px solid #e0e0e0",
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
        }}
      >
        <h3 style={{ margin: 0 }}>Comments</h3>
        <button
          onClick={onClose}
          style={{
            background: "none",
            border: "none",
            fontSize: "1.5rem",
            cursor: "pointer",
          }}
        >
          ×
        </button>
      </div>

      <div
        style={{
          flex: 1,
          overflowY: "auto",
          padding: "16px",
        }}
      >
        {comments.length === 0 && !isLoading ? (
          <div style={{ textAlign: "center", padding: "20px", color: "#666" }}>
            No comments yet. Be the first to comment!
          </div>
        ) : (
          <>
            {comments.map((comment) => (
              <div
                key={comment.id}
                style={{
                  marginBottom: "16px",
                  padding: "12px",
                  backgroundColor: "#f9f9f9",
                  borderRadius: "8px",
                }}
              >
                <div
                  style={{
                    display: "flex",
                    alignItems: "center",
                    marginBottom: "8px",
                  }}
                >
                  <img
                    src={comment.userAvatar || "/default-avatar.png"}
                    alt={comment.username}
                    style={{
                      width: "32px",
                      height: "32px",
                      borderRadius: "50%",
                      marginRight: "8px",
                      objectFit: "cover",
                    }}
                  />
                  <div>
                    <div style={{ fontWeight: "bold", fontSize: "0.9rem" }}>
                      {comment.username}
                    </div>
                    <div style={{ fontSize: "0.7rem", color: "#666" }}>
                      {formatDate(comment.createdAt)}
                    </div>
                  </div>
                </div>

                <div style={{ marginBottom: "8px" }}>{comment.content}</div>

                <div style={{ display: "flex", alignItems: "center" }}>
                  <button
                    onClick={() =>
                      handleLikeCommentWrapper(comment.id, comment.isLiked)
                    }
                    style={{
                      background: "none",
                      border: "none",
                      display: "flex",
                      alignItems: "center",
                      color: comment.isLiked ? "var(--accent)" : "inherit",
                      fontWeight: comment.isLiked ? "bold" : "normal",
                      cursor: "pointer",
                      fontSize: "0.8rem",
                    }}
                  >
                    <span style={{ marginRight: "4px" }}>
                      {comment.isLiked ? "❤️" : "🤍"}
                    </span>
                    {comment.likesCount}
                  </button>
                </div>
              </div>
            ))}

            {hasMore && (
              <div style={{ textAlign: "center", marginTop: "16px" }}>
                <button
                  onClick={handleLoadMore}
                  disabled={isLoading}
                  style={{
                    padding: "8px 16px",
                    backgroundColor: "var(--accent)",
                    color: "white",
                    border: "none",
                    borderRadius: "4px",
                    cursor: "pointer",
                    opacity: isLoading ? 0.7 : 1,
                  }}
                >
                  {isLoading ? "Loading..." : "Load More"}
                </button>
              </div>
            )}
          </>
        )}
      </div>

      <form
        onSubmit={handleSubmitCommentWrapper}
        style={{
          padding: "16px",
          borderTop: "1px solid #e0e0e0",
          display: "flex",
        }}
      >
        <input
          type="text"
          value={newComment}
          onChange={(e) => setNewComment(e.target.value)}
          placeholder="Write a comment..."
          style={{
            flex: 1,
            padding: "8px 12px",
            border: "1px solid #e0e0e0",
            borderRadius: "20px",
            marginRight: "8px",
          }}
        />
        <button
          type="submit"
          disabled={!newComment.trim() || isLoading}
          style={{
            padding: "8px 16px",
            backgroundColor: "var(--accent)",
            color: "white",
            border: "none",
            borderRadius: "20px",
            cursor: "pointer",
            opacity: !newComment.trim() || isLoading ? 0.7 : 1,
          }}
        >
          {isLoading ? "..." : "Post"}
        </button>
      </form>
    </div>
  );
};
```

#### apps/web/src/components/social/Comments.tsx

```tsx
import React, { useCallback, useEffect, useRef, useState } from "react";

interface Comment {
  id: string;
  userId: string;
  username: string;
  userAvatar: string;
  content: string;
  likesCount: number;
  isLiked: boolean;
  createdAt: string;
  replies?: Comment[];
}

// Define API response interfaces
interface CommentsResponse {
  comments: Comment[];
  hasMore: boolean;
}

interface CommentsProps {
  postId: string;
  onLoadMore?: () => Promise<void>;
  className?: string;
}

export const Comments: React.FC<CommentsProps> = ({
  postId,
  onLoadMore,
  className,
}) => {
  const [comments, setComments] = useState<Comment[]>([]);
  const [newComment, setNewComment] = useState("");
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [hasMore, setHasMore] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const observer = useRef<IntersectionObserver | null>(null);
  const lastCommentRef = useRef<HTMLDivElement>(null);
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  const fetchComments = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);
      // TODO: Replace with actual API call
      const response = await fetch(`/api/posts/${postId}/comments`);
      if (!response.ok) throw new Error("Failed to fetch comments");
      const data = (await response.json()) as CommentsResponse;
      setComments(data.comments);
      setHasMore(data.hasMore);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to load comments");
    } finally {
      setIsLoading(false);
    }
  }, [postId]);

  useEffect(() => {
    void fetchComments();
  }, [fetchComments]);

  const loadMore = useCallback(async () => {
    if (!hasMore || isLoading) return;

    try {
      setIsLoading(true);
      await onLoadMore?.();
      // TODO: Replace with actual API call
      const response = await fetch(
        `/api/posts/${postId}/comments?offset=${comments.length}`,
      );
      if (!response.ok) throw new Error("Failed to fetch more comments");
      const data = (await response.json()) as CommentsResponse;
      setComments((prev) => [...prev, ...data.comments]);
      setHasMore(data.hasMore);
    } catch (err) {
      setError(
        err instanceof Error ? err.message : "Failed to load more comments",
      );
    } finally {
      setIsLoading(false);
    }
  }, [hasMore, isLoading, onLoadMore, postId, comments.length]);

  useEffect(() => {
    observer.current = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting && hasMore && !isLoading) {
          void loadMore();
        }
      },
      { threshold: 0.5 },
    );

    if (lastCommentRef.current) {
      observer.current.observe(lastCommentRef.current);
    }

    return () => {
      if (observer.current) {
        observer.current.disconnect();
      }
    };
  }, [hasMore, isLoading, loadMore]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!newComment.trim()) return;

    try {
      setIsSubmitting(true);
      setError(null);
      // TODO: Replace with actual API call
      const response = await fetch(`/api/posts/${postId}/comments`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ content: newComment.trim() }),
      });

      if (!response.ok) throw new Error("Failed to post comment");

      const comment = (await response.json()) as Comment;
      setComments((prev) => [comment, ...prev]);
      setNewComment("");
      if (textareaRef.current) {
        textareaRef.current.style.height = "auto";
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to post comment");
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleLike = async (commentId: string) => {
    try {
      // TODO: Replace with actual API call
      const response = await fetch(`/api/comments/${commentId}/like`, {
        method: "POST",
      });
      if (!response.ok) throw new Error("Failed to like comment");

      setComments((prev) =>
        prev.map((comment) =>
          comment.id === commentId
            ? {
                ...comment,
                isLiked: !comment.isLiked,
                likesCount: comment.isLiked
                  ? comment.likesCount - 1
                  : comment.likesCount + 1,
              }
            : comment,
        ),
      );
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to like comment");
    }
  };

  // Void-returning wrapper for handleSubmit
  const handleSubmitWrapper = (e: React.FormEvent) => {
    void handleSubmit(e);
  };

  // Void-returning wrapper for handleLike
  const handleLikeWrapper = (commentId: string) => {
    void handleLike(commentId);
  };

  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    const now = new Date();
    const diff = now.getTime() - date.getTime();

    if (diff < 60000) return "just now";
    if (diff < 3600000) return `${Math.floor(diff / 60000)}m ago`;
    if (diff < 86400000) return `${Math.floor(diff / 3600000)}h ago`;
    return date.toLocaleDateString();
  };

  const styles = {
    container: {
      display: "flex",
      flexDirection: "column" as const,
      gap: "16px",
    },
    comment: {
      display: "flex",
      gap: "12px",
      padding: "12px",
      backgroundColor: "#f8f9fa",
      borderRadius: "8px",
    },
    avatar: {
      width: "40px",
      height: "40px",
      borderRadius: "50%",
      objectFit: "cover" as const,
    },
    content: {
      flex: 1,
    },
    header: {
      display: "flex",
      alignItems: "center",
      gap: "8px",
      marginBottom: "4px",
    },
    username: {
      fontSize: "14px",
      fontWeight: 600,
      color: "#1a1a1a",
    },
    timestamp: {
      fontSize: "12px",
      color: "#666",
    },
    text: {
      fontSize: "14px",
      lineHeight: "1.5",
      color: "#333",
      margin: "0 0 8px",
    },
    actions: {
      display: "flex",
      gap: "16px",
    },
    actionButton: {
      display: "flex",
      alignItems: "center",
      gap: "4px",
      background: "none",
      border: "none",
      color: "#666",
      cursor: "pointer",
      padding: "4px 8px",
      borderRadius: "4px",
      fontSize: "14px",
      transition: "background-color 0.2s",
      "&:hover": {
        backgroundColor: "#e9ecef",
      },
    },
    actionButtonLiked: {
      color: "#e91e63",
    },
    form: {
      display: "flex",
      gap: "12px",
      marginBottom: "16px",
    },
    textarea: {
      flex: 1,
      minHeight: "40px",
      maxHeight: "120px",
      padding: "8px 12px",
      border: "1px solid #ddd",
      borderRadius: "20px",
      fontSize: "14px",
      lineHeight: "1.5",
      resize: "none" as const,
      fontFamily: "inherit",
      "&:focus": {
        outline: "none",
        borderColor: "#2196f3",
      },
    },
    submitButton: {
      padding: "8px 16px",
      backgroundColor: "#2196f3",
      color: "#fff",
      border: "none",
      borderRadius: "20px",
      fontSize: "14px",
      fontWeight: 500,
      cursor: "pointer",
      transition: "background-color 0.2s",
      "&:hover": {
        backgroundColor: "#1976d2",
      },
      "&:disabled": {
        backgroundColor: "#ccc",
        cursor: "not-allowed",
      },
    },
    loading: {
      textAlign: "center" as const,
      padding: "16px",
      color: "#666",
    },
    error: {
      color: "#d32f2f",
      textAlign: "center" as const,
      padding: "16px",
    },
    replies: {
      marginLeft: "52px",
      borderLeft: "2px solid #e9ecef",
      paddingLeft: "12px",
    },
  };

  if (error) {
    return <div style={styles.error}>{error}</div>;
  }

  return (
    <div style={styles.container} className={className}>
      <form onSubmit={handleSubmitWrapper} style={styles.form}>
        <textarea
          ref={textareaRef}
          value={newComment}
          onChange={(e) => {
            setNewComment(e.target.value);
            e.target.style.height = "auto";
            e.target.style.height = `${e.target.scrollHeight}px`;
          }}
          placeholder="Write a comment..."
          style={styles.textarea}
        />
        <button
          type="submit"
          style={{
            ...styles.submitButton,
            ...(isSubmitting && { opacity: 0.7 }),
          }}
          disabled={isSubmitting || !newComment.trim()}
          onMouseEnter={(e) =>
            (e.currentTarget.style.backgroundColor = "#1976d2")
          }
          onMouseLeave={(e) =>
            (e.currentTarget.style.backgroundColor = "#2196f3")
          }
        >
          {isSubmitting ? "Posting..." : "Post"}
        </button>
      </form>

      {comments.map((comment, index) => (
        <div
          key={comment.id}
          ref={index === comments.length - 1 ? lastCommentRef : undefined}
          style={styles.comment}
        >
          <img
            src={comment.userAvatar}
            alt={comment.username}
            style={styles.avatar}
          />
          <div style={styles.content}>
            <div style={styles.header}>
              <span style={styles.username}>{comment.username}</span>
              <span style={styles.timestamp}>
                {formatDate(comment.createdAt)}
              </span>
            </div>
            <p style={styles.text}>{comment.content}</p>
            <div style={styles.actions}>
              <button
                style={{
                  ...styles.actionButton,
                  ...(comment.isLiked && styles.actionButtonLiked),
                }}
                onClick={() => handleLikeWrapper(comment.id)}
                onMouseEnter={(e) =>
                  (e.currentTarget.style.backgroundColor = "#e9ecef")
                }
                onMouseLeave={(e) =>
                  (e.currentTarget.style.backgroundColor = "transparent")
                }
              >
                {comment.isLiked ? "❤️" : "🤍"}
                <span>{comment.likesCount}</span>
              </button>
              <button
                style={styles.actionButton}
                onMouseEnter={(e) =>
                  (e.currentTarget.style.backgroundColor = "#e9ecef")
                }
                onMouseLeave={(e) =>
                  (e.currentTarget.style.backgroundColor = "transparent")
                }
              >
                💬 Reply
              </button>
            </div>

            {comment.replies && comment.replies.length > 0 && (
              <div style={styles.replies}>
                {comment.replies.map((reply) => (
                  <div key={reply.id} style={styles.comment}>
                    <img
                      src={reply.userAvatar}
                      alt={reply.username}
                      style={styles.avatar}
                    />
                    <div style={styles.content}>
                      <div style={styles.header}>
                        <span style={styles.username}>{reply.username}</span>
                        <span style={styles.timestamp}>
                          {formatDate(reply.createdAt)}
                        </span>
                      </div>
                      <p style={styles.text}>{reply.content}</p>
                      <div style={styles.actions}>
                        <button
                          style={{
                            ...styles.actionButton,
                            ...(reply.isLiked && styles.actionButtonLiked),
                          }}
                          onClick={() => handleLikeWrapper(reply.id)}
                          onMouseEnter={(e) =>
                            (e.currentTarget.style.backgroundColor = "#e9ecef")
                          }
                          onMouseLeave={(e) =>
                            (e.currentTarget.style.backgroundColor =
                              "transparent")
                          }
                        >
                          {reply.isLiked ? "❤️" : "🤍"}
                          <span>{reply.likesCount}</span>
                        </button>
                        <button
                          style={styles.actionButton}
                          onMouseEnter={(e) =>
                            (e.currentTarget.style.backgroundColor = "#e9ecef")
                          }
                          onMouseLeave={(e) =>
                            (e.currentTarget.style.backgroundColor =
                              "transparent")
                          }
                        >
                          💬 Reply
                        </button>
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
        </div>
      ))}

      {isLoading && <div style={styles.loading}>Loading more comments...</div>}
    </div>
  );
};
```

#### apps/web/src/components/social/CreatePost.tsx

```tsx
import React, { useRef, useState } from "react";

import { MediaUpload } from "../media/mediaUpload";

interface CreatePostProps {
  onSubmit: (post: { content: string; media?: File }) => Promise<void>;
  className?: string;
}

export const CreatePost: React.FC<CreatePostProps> = ({
  onSubmit,
  className,
}) => {
  const [content, setContent] = useState("");
  const [media, setMedia] = useState<File | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!content.trim() && !media) return;

    try {
      setIsSubmitting(true);
      setError(null);
      await onSubmit({
        content: content.trim(),
        media: media || undefined,
      });
      setContent("");
      setMedia(null);
      if (textareaRef.current) {
        textareaRef.current.style.height = "auto";
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to create post");
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleContentChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setContent(e.target.value);
    e.target.style.height = "auto";
    e.target.style.height = `${e.target.scrollHeight}px`;
  };

  const handleMediaUpload = async (file: File): Promise<void> => {
    setMedia(file);
    return Promise.resolve();
  };

  // Void-returning wrapper for handleSubmit
  const handleSubmitWrapper = (e: React.FormEvent) => {
    void handleSubmit(e);
  };

  const styles = {
    container: {
      backgroundColor: "#fff",
      borderRadius: "8px",
      boxShadow: "0 2px 4px rgba(0,0,0,0.1)",
      padding: "16px",
    },
    form: {
      display: "flex",
      flexDirection: "column" as const,
      gap: "16px",
    },
    textarea: {
      width: "100%",
      minHeight: "100px",
      padding: "12px",
      border: "1px solid #ddd",
      borderRadius: "4px",
      fontSize: "16px",
      lineHeight: "1.5",
      resize: "none" as const,
      fontFamily: "inherit",
      "&:focus": {
        outline: "none",
        borderColor: "#2196f3",
      },
    },
    mediaPreview: {
      marginTop: "16px",
      maxWidth: "100%",
      maxHeight: "300px",
      borderRadius: "4px",
      overflow: "hidden",
    },
    mediaImage: {
      maxWidth: "100%",
      maxHeight: "300px",
      objectFit: "contain" as const,
    },
    actions: {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
    },
    submitButton: {
      padding: "8px 24px",
      backgroundColor: "#2196f3",
      color: "#fff",
      border: "none",
      borderRadius: "20px",
      fontSize: "16px",
      fontWeight: 500,
      cursor: "pointer",
      transition: "background-color 0.2s",
      "&:hover": {
        backgroundColor: "#1976d2",
      },
      "&:disabled": {
        backgroundColor: "#ccc",
        cursor: "not-allowed",
      },
    },
    error: {
      color: "#d32f2f",
      fontSize: "14px",
      marginTop: "8px",
    },
  };

  return (
    <div style={styles.container} className={className}>
      <form onSubmit={handleSubmitWrapper} style={styles.form}>
        <textarea
          ref={textareaRef}
          value={content}
          onChange={handleContentChange}
          placeholder="What's on your mind?"
          style={styles.textarea}
        />

        {media && (
          <div style={styles.mediaPreview}>
            {media.type.startsWith("image/") ? (
              <img
                src={URL.createObjectURL(media)}
                alt="Preview"
                style={styles.mediaImage}
              />
            ) : (
              <MediaUpload
                onUpload={handleMediaUpload}
                acceptedTypes={[media.type]}
                maxSize={media.size}
              />
            )}
          </div>
        )}

        <div style={styles.actions}>
          <MediaUpload
            onUpload={handleMediaUpload}
            acceptedTypes={["image/*", "video/*", "audio/*"]}
            maxSize={100 * 1024 * 1024} // 100MB
          />
          <button
            type="submit"
            style={{
              ...styles.submitButton,
              ...(isSubmitting && { opacity: 0.7 }),
            }}
            disabled={isSubmitting || (!content.trim() && !media)}
            onMouseEnter={(e) =>
              (e.currentTarget.style.backgroundColor = "#1976d2")
            }
            onMouseLeave={(e) =>
              (e.currentTarget.style.backgroundColor = "#2196f3")
            }
          >
            {isSubmitting ? "Posting..." : "Post"}
          </button>
        </div>

        {error && <div style={styles.error}>{error}</div>}
      </form>
    </div>
  );
};
```

#### apps/web/src/components/social/CreatePostForm.tsx

```tsx
import React, { useRef, useState } from "react";

import { socialService } from "../../services/social";

interface CreatePostFormProps {
  onPostCreated: () => void;
}

export const CreatePostForm: React.FC<CreatePostFormProps> = ({
  onPostCreated,
}) => {
  const [content, setContent] = useState("");
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [previewUrl, setPreviewUrl] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files.length > 0) {
      const file = e.target.files[0];
      setSelectedFile(file);

      // Create preview URL for images
      if (file.type.startsWith("image/")) {
        const reader = new FileReader();
        reader.onloadend = () => {
          setPreviewUrl(reader.result as string);
        };
        reader.readAsDataURL(file);
      } else {
        setPreviewUrl(null);
      }
    }
  };

  const handleRemoveFile = () => {
    setSelectedFile(null);
    setPreviewUrl(null);
    if (fileInputRef.current) {
      fileInputRef.current.value = "";
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if ((!content.trim() && !selectedFile) || isLoading) return;

    setIsLoading(true);
    try {
      await socialService.createPost(content, selectedFile || undefined);
      setContent("");
      setSelectedFile(null);
      setPreviewUrl(null);
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
      onPostCreated();
    } catch (error) {
      console.error("Error creating post:", error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div
      style={{
        border: "1px solid #e0e0e0",
        borderRadius: "8px",
        padding: "16px",
        marginBottom: "24px",
        backgroundColor: "white",
        boxShadow: "0 1px 3px rgba(0,0,0,0.1)",
      }}
    >
      <form onSubmit={handleSubmit as (e: React.FormEvent) => void}>
        <textarea
          value={content}
          onChange={(e) => setContent(e.target.value)}
          placeholder="What's on your mind?"
          style={{
            width: "100%",
            minHeight: "100px",
            padding: "12px",
            border: "1px solid #e0e0e0",
            borderRadius: "8px",
            resize: "vertical",
            marginBottom: "12px",
          }}
        />

        {previewUrl && (
          <div style={{ position: "relative", marginBottom: "12px" }}>
            <img
              src={previewUrl}
              alt="Preview"
              style={{
                maxWidth: "100%",
                maxHeight: "300px",
                borderRadius: "8px",
                objectFit: "cover",
              }}
            />
            <button
              type="button"
              onClick={handleRemoveFile}
              style={{
                position: "absolute",
                top: "8px",
                right: "8px",
                width: "24px",
                height: "24px",
                borderRadius: "50%",
                backgroundColor: "rgba(0,0,0,0.5)",
                color: "white",
                border: "none",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                cursor: "pointer",
              }}
            >
              ×
            </button>
          </div>
        )}

        {selectedFile && !previewUrl && (
          <div
            style={{
              display: "flex",
              alignItems: "center",
              backgroundColor: "#f5f5f5",
              padding: "8px 12px",
              borderRadius: "4px",
              marginBottom: "12px",
            }}
          >
            <div style={{ flex: 1 }}>
              <div style={{ fontWeight: "bold" }}>{selectedFile.name}</div>
              <div style={{ fontSize: "0.8rem", color: "#666" }}>
                {(selectedFile.size / 1024 / 1024).toFixed(2)} MB
              </div>
            </div>
            <button
              type="button"
              onClick={handleRemoveFile}
              style={{
                background: "none",
                border: "none",
                color: "#666",
                cursor: "pointer",
                fontSize: "1.2rem",
              }}
            >
              ×
            </button>
          </div>
        )}

        <div
          style={{
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
          }}
        >
          <div>
            <input
              type="file"
              id="file-input"
              ref={fileInputRef}
              onChange={handleFileChange}
              accept="image/*,video/*,audio/*"
              style={{ display: "none" }}
            />
            <button
              type="button"
              onClick={() => fileInputRef.current?.click()}
              style={{
                background: "none",
                border: "none",
                color: "var(--accent)",
                cursor: "pointer",
                display: "flex",
                alignItems: "center",
              }}
            >
              <span style={{ marginRight: "4px" }}>📎</span>
              Add Media
            </button>
          </div>

          <button
            type="submit"
            disabled={(!content.trim() && !selectedFile) || isLoading}
            style={{
              padding: "8px 24px",
              backgroundColor: "var(--accent)",
              color: "white",
              border: "none",
              borderRadius: "20px",
              cursor: "pointer",
              opacity:
                (!content.trim() && !selectedFile) || isLoading ? 0.7 : 1,
            }}
          >
            {isLoading ? "Posting..." : "Post"}
          </button>
        </div>
      </form>
    </div>
  );
};
```

#### apps/web/src/components/social/Feed.tsx

```tsx
import React, { useCallback, useEffect, useRef, useState } from "react";

import { MediaPlayer } from "../media/mediaPlayer";

interface Post {
  id: string;
  userId: string;
  username: string;
  userAvatar: string;
  content: string;
  media?: {
    type: "image" | "video" | "audio";
    url: string;
    thumbnail?: string;
  };
  likesCount: number;
  commentsCount: number;
  sharesCount: number;
  isLiked: boolean;
  createdAt: string;
}

// Add API response type definitions
interface FeedResponse {
  posts: Post[];
  hasMore: boolean;
}

interface FeedProps {
  type: "home" | "profile" | "explore";
  userId?: string;
  onLoadMore?: () => Promise<void>;
  className?: string;
}

export const Feed: React.FC<FeedProps> = ({
  type,
  userId,
  onLoadMore,
  className,
}) => {
  const [posts, setPosts] = useState<Post[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [hasMore, setHasMore] = useState(true);
  const observer = useRef<IntersectionObserver | null>(null);
  const lastPostRef = useRef<HTMLDivElement>(null);

  const fetchPosts = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);
      // TODO: Replace with actual API call
      const response = await fetch(
        `/api/feed?type=${type}${userId ? `&userId=${userId}` : ""}`,
      );
      if (!response.ok) throw new Error("Failed to fetch posts");
      const data = (await response.json()) as FeedResponse;
      setPosts(data.posts);
      setHasMore(data.hasMore);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to load posts");
    } finally {
      setIsLoading(false);
    }
  }, [type, userId]);

  const loadMore = useCallback(async () => {
    if (!hasMore || isLoading) return;

    try {
      setIsLoading(true);
      await onLoadMore?.();
      // TODO: Replace with actual API call
      const response = await fetch(
        `/api/feed?type=${type}${userId ? `&userId=${userId}` : ""}&offset=${posts.length}`,
      );
      if (!response.ok) throw new Error("Failed to fetch more posts");
      const data = (await response.json()) as FeedResponse;
      setPosts((prev) => [...prev, ...data.posts]);
      setHasMore(data.hasMore);
    } catch (err) {
      setError(
        err instanceof Error ? err.message : "Failed to load more posts",
      );
    } finally {
      setIsLoading(false);
    }
  }, [hasMore, isLoading, onLoadMore, posts.length, type, userId]);

  useEffect(() => {
    void fetchPosts();
  }, [fetchPosts, type, userId]);

  useEffect(() => {
    observer.current = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting && hasMore && !isLoading) {
          void loadMore();
        }
      },
      { threshold: 0.5 },
    );

    if (lastPostRef.current) {
      observer.current.observe(lastPostRef.current);
    }

    return () => {
      if (observer.current) {
        observer.current.disconnect();
      }
    };
  }, [loadMore, hasMore, isLoading]);

  const handleLike = async (postId: string) => {
    try {
      // TODO: Replace with actual API call
      const response = await fetch(`/api/posts/${postId}/like`, {
        method: "POST",
      });
      if (!response.ok) throw new Error("Failed to like post");

      setPosts((prev) =>
        prev.map((post) =>
          post.id === postId
            ? {
                ...post,
                isLiked: !post.isLiked,
                likesCount: post.isLiked
                  ? post.likesCount - 1
                  : post.likesCount + 1,
              }
            : post,
        ),
      );
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to like post");
    }
  };

  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    const now = new Date();
    const diff = now.getTime() - date.getTime();

    if (diff < 60000) return "just now";
    if (diff < 3600000) return `${Math.floor(diff / 60000)}m ago`;
    if (diff < 86400000) return `${Math.floor(diff / 3600000)}h ago`;
    return date.toLocaleDateString();
  };

  const styles = {
    container: {
      display: "flex",
      flexDirection: "column" as const,
      gap: "16px",
      maxWidth: "600px",
      margin: "0 auto",
      padding: "16px",
    },
    post: {
      backgroundColor: "#fff",
      borderRadius: "8px",
      boxShadow: "0 2px 4px rgba(0,0,0,0.1)",
      overflow: "hidden",
    },
    postHeader: {
      display: "flex",
      alignItems: "center",
      padding: "12px",
      gap: "12px",
    },
    avatar: {
      width: "40px",
      height: "40px",
      borderRadius: "50%",
      objectFit: "cover" as const,
    },
    userInfo: {
      flex: 1,
    },
    username: {
      fontSize: "16px",
      fontWeight: 600,
      color: "#1a1a1a",
      margin: 0,
    },
    timestamp: {
      fontSize: "14px",
      color: "#666",
      margin: "4px 0 0",
    },
    content: {
      padding: "0 12px 12px",
      fontSize: "16px",
      lineHeight: "1.5",
      color: "#333",
    },
    media: {
      width: "100%",
      maxHeight: "600px",
      objectFit: "cover" as const,
    },
    actions: {
      display: "flex",
      padding: "12px",
      gap: "16px",
      borderTop: "1px solid #eee",
    },
    actionButton: {
      display: "flex",
      alignItems: "center",
      gap: "8px",
      background: "none",
      border: "none",
      color: "#666",
      cursor: "pointer",
      padding: "4px 8px",
      borderRadius: "4px",
      transition: "background-color 0.2s",
      "&:hover": {
        backgroundColor: "#f5f5f5",
      },
    },
    actionButtonLiked: {
      color: "#e91e63",
    },
    actionCount: {
      fontSize: "14px",
    },
    loading: {
      textAlign: "center" as const,
      padding: "24px",
      color: "#666",
    },
    error: {
      color: "#d32f2f",
      textAlign: "center" as const,
      padding: "16px",
    },
  };

  if (error) {
    return <div style={styles.error}>{error}</div>;
  }

  return (
    <div style={styles.container} className={className}>
      {posts.map((post, index) => (
        <div
          key={post.id}
          ref={index === posts.length - 1 ? lastPostRef : undefined}
          style={styles.post}
        >
          <div style={styles.postHeader}>
            <img
              src={post.userAvatar}
              alt={post.username}
              style={styles.avatar}
            />
            <div style={styles.userInfo}>
              <p style={styles.username}>{post.username}</p>
              <p style={styles.timestamp}>{formatDate(post.createdAt)}</p>
            </div>
          </div>

          <p style={styles.content}>{post.content}</p>

          {post.media &&
            (post.media.type === "image" ? (
              <img src={post.media.url} alt="Post media" style={styles.media} />
            ) : (
              <MediaPlayer
                src={post.media.url}
                type={post.media.type}
                poster={post.media.thumbnail}
              />
            ))}

          <div style={styles.actions}>
            <button
              style={{
                ...styles.actionButton,
                ...(post.isLiked && styles.actionButtonLiked),
              }}
              onClick={() => void handleLike(post.id)}
              onMouseEnter={(e) =>
                (e.currentTarget.style.backgroundColor = "#f5f5f5")
              }
              onMouseLeave={(e) =>
                (e.currentTarget.style.backgroundColor = "transparent")
              }
            >
              {post.isLiked ? "❤️" : "🤍"}
              <span style={styles.actionCount}>{post.likesCount}</span>
            </button>
            <button
              style={styles.actionButton}
              onMouseEnter={(e) =>
                (e.currentTarget.style.backgroundColor = "#f5f5f5")
              }
              onMouseLeave={(e) =>
                (e.currentTarget.style.backgroundColor = "transparent")
              }
            >
              💬
              <span style={styles.actionCount}>{post.commentsCount}</span>
            </button>
            <button
              style={styles.actionButton}
              onMouseEnter={(e) =>
                (e.currentTarget.style.backgroundColor = "#f5f5f5")
              }
              onMouseLeave={(e) =>
                (e.currentTarget.style.backgroundColor = "transparent")
              }
            >
              🔄
              <span style={styles.actionCount}>{post.sharesCount}</span>
            </button>
          </div>
        </div>
      ))}

      {isLoading && <div style={styles.loading}>Loading more posts...</div>}
    </div>
  );
};
```

#### apps/web/src/components/social/PostCard.tsx

```tsx
import React, { useState } from "react";

import { formatDate } from "@/client/helpers/formatters";

import { socialService } from "../../services/social";

interface Post {
  id: string;
  userId: string;
  username: string;
  userAvatar: string;
  content: string;
  media?: {
    type: "image" | "video" | "audio";
    url: string;
    thumbnail?: string;
  };
  likesCount: number;
  commentsCount: number;
  sharesCount: number;
  isLiked: boolean;
  createdAt: string;
}

interface PostCardProps {
  post: Post;
  onCommentClick: (postId: string) => void;
  onRefresh: () => void;
}

export const PostCard: React.FC<PostCardProps> = ({
  post,
  onCommentClick,
  onRefresh,
}) => {
  const [isLiked, setIsLiked] = useState(post.isLiked);
  const [likesCount, setLikesCount] = useState(post.likesCount);
  const [isLoading, setIsLoading] = useState(false);

  const handleLikeToggle = async () => {
    if (isLoading) return;

    setIsLoading(true);
    try {
      if (isLiked) {
        await socialService.unlikePost(post.id);
        setIsLiked(false);
        setLikesCount((prev) => prev - 1);
      } else {
        await socialService.likePost(post.id);
        setIsLiked(true);
        setLikesCount((prev) => prev + 1);
      }
    } catch (error) {
      console.error("Error toggling like:", error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleShare = async () => {
    if (isLoading) return;

    setIsLoading(true);
    try {
      await socialService.sharePost(post.id);
      onRefresh();
    } catch (error) {
      console.error("Error sharing post:", error);
    } finally {
      setIsLoading(false);
    }
  };

  const renderMedia = () => {
    if (!post.media) return null;

    switch (post.media.type) {
      case "image":
        return (
          <div style={{ marginTop: "12px" }}>
            <img
              src={post.media.url}
              alt="Post media"
              style={{
                maxWidth: "100%",
                borderRadius: "8px",
                maxHeight: "400px",
                objectFit: "cover",
              }}
            />
          </div>
        );
      case "video":
        return (
          <div style={{ marginTop: "12px" }}>
            <video
              src={post.media.url}
              controls
              poster={post.media.thumbnail}
              style={{
                maxWidth: "100%",
                borderRadius: "8px",
                maxHeight: "400px",
              }}
            />
          </div>
        );
      case "audio":
        return (
          <div style={{ marginTop: "12px" }}>
            <audio src={post.media.url} controls style={{ width: "100%" }} />
          </div>
        );
      default:
        return null;
    }
  };

  return (
    <div
      style={{
        border: "1px solid #e0e0e0",
        borderRadius: "8px",
        padding: "16px",
        marginBottom: "16px",
        backgroundColor: "white",
        boxShadow: "0 1px 3px rgba(0,0,0,0.1)",
      }}
    >
      <div
        style={{ display: "flex", alignItems: "center", marginBottom: "12px" }}
      >
        <img
          src={post.userAvatar || "/default-avatar.png"}
          alt={post.username}
          style={{
            width: "40px",
            height: "40px",
            borderRadius: "50%",
            marginRight: "12px",
            objectFit: "cover",
          }}
        />
        <div>
          <div style={{ fontWeight: "bold" }}>{post.username}</div>
          <div style={{ fontSize: "0.8rem", color: "#666" }}>
            {formatDate(post.createdAt)}
          </div>
        </div>
      </div>

      <div style={{ marginBottom: "12px" }}>{post.content}</div>

      {renderMedia()}

      <div
        style={{
          display: "flex",
          justifyContent: "space-between",
          marginTop: "16px",
          padding: "8px 0",
          borderTop: "1px solid #f0f0f0",
        }}
      >
        <div style={{ display: "flex", alignItems: "center" }}>
          <button
            onClick={() => void handleLikeToggle()}
            style={{
              background: "none",
              border: "none",
              display: "flex",
              alignItems: "center",
              color: isLiked ? "var(--accent)" : "inherit",
              fontWeight: isLiked ? "bold" : "normal",
              cursor: "pointer",
            }}
          >
            <span style={{ marginRight: "4px" }}>{isLiked ? "❤️" : "🤍"}</span>
            {likesCount}
          </button>
        </div>

        <div>
          <button
            onClick={() => onCommentClick(post.id)}
            style={{
              background: "none",
              border: "none",
              display: "flex",
              alignItems: "center",
              cursor: "pointer",
              marginRight: "16px",
            }}
          >
            <span style={{ marginRight: "4px" }}>💬</span>
            {post.commentsCount}
          </button>
        </div>

        <div>
          <button
            onClick={() => void handleShare()}
            style={{
              background: "none",
              border: "none",
              display: "flex",
              alignItems: "center",
              cursor: "pointer",
            }}
          >
            <span style={{ marginRight: "4px" }}>🔄</span>
            {post.sharesCount}
          </button>
        </div>
      </div>
    </div>
  );
};
```

#### apps/web/src/components/social/SocialFeed.tsx

```tsx
import React, { useEffect, useState } from "react";

import { formatRelativeTime } from "../../helpers/formatters";
import { socialFeedStyles } from "../../styles";
import { mergeStyles } from "../../utils/styleUtils";
import AudioPlayer from "../media/AudioPlayer";
import ImageGallery from "../media/ImageGallery";
import VideoPlayer from "../media/VideoPlayer";

// Types for different media content
interface TrackData {
  id: string;
  title: string;
  artist: string;
  coverArt: string;
  audioUrl: string;
}

interface ImageData {
  src: string;
  width: number;
  height: number;
  alt?: string;
}

interface VideoData {
  sources: Array<{
    src: string;
    quality: string;
    type: string;
  }>;
  poster?: string;
  title?: string;
  duration?: number;
}

interface PostData {
  id: string;
  userId: string;
  username: string;
  userAvatar: string;
  content: string;
  mediaType?: "image" | "video" | "audio" | "carousel";
  track?: TrackData;
  image?: ImageData;
  video?: VideoData;
  carousel?: ImageData[];
  likesCount: number;
  commentsCount: number;
  sharesCount: number;
  viewsCount?: number;
  isLiked: boolean;
  tags?: string[];
  location?: string;
  createdAt: string;
}

interface SocialFeedProps {
  initialPosts?: PostData[];
  onLikePost?: (postId: string, isLiked: boolean) => void;
  onCommentPost?: (postId: string, comment: string) => void;
  onSharePost?: (postId: string) => void;
  onViewPost?: (postId: string) => void;
}

const SocialFeed: React.FC<SocialFeedProps> = ({
  initialPosts = [],
  onLikePost,
  onCommentPost,
  onSharePost,
  onViewPost,
}) => {
  const [posts, setPosts] = useState<PostData[]>(initialPosts);
  const [newComment, setNewComment] = useState<string>("");
  const [activePostId, setActivePostId] = useState<string | null>(null);
  const [expandedCaption, setExpandedCaption] = useState<string | null>(null);

  useEffect(() => {
    // In a real app, you would fetch posts from an API
    if (initialPosts.length === 0) {
      // Mock data for demonstration
      const mockPosts: PostData[] = [
        {
          id: "1",
          userId: "user1",
          username: "JohnDoe",
          userAvatar: "/images/avatars/user1.jpg",
          content:
            "Check out this awesome new track I discovered! #newmusic #recommended",
          mediaType: "audio",
          track: {
            id: "track1",
            title: "Awesome Track",
            artist: "Amazing Artist",
            coverArt: "/images/covers/track1.jpg",
            audioUrl: "/audio/track1.mp3",
          },
          likesCount: 42,
          commentsCount: 7,
          sharesCount: 3,
          isLiked: false,
          tags: ["newmusic", "recommended"],
          createdAt: new Date(Date.now() - 3600000).toISOString(), // 1 hour ago
        },
        {
          id: "2",
          userId: "user2",
          username: "TravelLover",
          userAvatar: "/images/avatars/user2.jpg",
          content:
            "Amazing view from my hotel this morning! #travel #vacation #sunrise",
          mediaType: "image",
          image: {
            src: "/images/posts/travel1.jpg",
            width: 1080,
            height: 1350,
            alt: "Sunrise view from hotel balcony",
          },
          likesCount: 128,
          commentsCount: 14,
          sharesCount: 5,
          isLiked: true,
          location: "Bali, Indonesia",
          tags: ["travel", "vacation", "sunrise"],
          createdAt: new Date(Date.now() - 86400000).toISOString(), // 1 day ago
        },
        {
          id: "3",
          userId: "user3",
          username: "FoodieChef",
          userAvatar: "/images/avatars/user3.jpg",
          content:
            "Made this delicious pasta dish yesterday! Swipe to see the process 👨‍🍳 #homemade #cooking #pasta",
          mediaType: "carousel",
          carousel: [
            {
              src: "/images/posts/food1.jpg",
              width: 1080,
              height: 1080,
              alt: "Finished pasta dish",
            },
            {
              src: "/images/posts/food2.jpg",
              width: 1080,
              height: 1080,
              alt: "Cooking process",
            },
            {
              src: "/images/posts/food3.jpg",
              width: 1080,
              height: 1080,
              alt: "Ingredients",
            },
          ],
          likesCount: 89,
          commentsCount: 9,
          sharesCount: 2,
          isLiked: false,
          tags: ["homemade", "cooking", "pasta"],
          createdAt: new Date(Date.now() - 172800000).toISOString(), // 2 days ago
        },
        {
          id: "4",
          userId: "user4",
          username: "FilmCreator",
          userAvatar: "/images/avatars/user4.jpg",
          content:
            "Just finished editing my latest short film! Check it out and let me know what you think 🎬 #shortfilm #filmmaker #cinematography",
          mediaType: "video",
          video: {
            sources: [
              {
                src: "/videos/film1.mp4",
                quality: "720p",
                type: "video/mp4",
              },
              {
                src: "/videos/film1-480p.mp4",
                quality: "480p",
                type: "video/mp4",
              },
            ],
            poster: "/images/posts/film1-poster.jpg",
            title: "My Short Film",
          },
          likesCount: 215,
          commentsCount: 32,
          sharesCount: 18,
          viewsCount: 1240,
          isLiked: false,
          tags: ["shortfilm", "filmmaker", "cinematography"],
          createdAt: new Date(Date.now() - 259200000).toISOString(), // 3 days ago
        },
      ];

      setPosts(mockPosts);
    }
  }, [initialPosts]);

  const handleLike = (postId: string) => {
    setPosts((prevPosts) =>
      prevPosts.map((post) => {
        if (post.id === postId) {
          const newIsLiked = !post.isLiked;
          const likeDelta = newIsLiked ? 1 : -1;

          if (onLikePost) {
            onLikePost(postId, newIsLiked);
          }

          return {
            ...post,
            isLiked: newIsLiked,
            likesCount: post.likesCount + likeDelta,
          };
        }
        return post;
      }),
    );
  };

  const handleComment = (postId: string) => {
    if (!newComment.trim()) return;

    if (onCommentPost) {
      onCommentPost(postId, newComment);
    }

    setPosts((prevPosts) =>
      prevPosts.map((post) => {
        if (post.id === postId) {
          return {
            ...post,
            commentsCount: post.commentsCount + 1,
          };
        }
        return post;
      }),
    );

    setNewComment("");
    setActivePostId(null);
  };

  const handleShare = (postId: string) => {
    if (onSharePost) {
      onSharePost(postId);
    }

    setPosts((prevPosts) =>
      prevPosts.map((post) => {
        if (post.id === postId) {
          return {
            ...post,
            sharesCount: post.sharesCount + 1,
          };
        }
        return post;
      }),
    );
  };

  const handleView = (postId: string) => {
    if (onViewPost) {
      onViewPost(postId);
    }
  };

  const toggleCaption = (postId: string) => {
    setExpandedCaption(expandedCaption === postId ? null : postId);
  };

  const renderTags = (tags?: string[]) => {
    if (!tags || tags.length === 0) return null;

    return (
      <div className="post-tags">
        {tags.map((tag) => (
          <a
            key={tag}
            href={`/tag/${tag}`}
            className="tag"
            onClick={(e) => {
              e.preventDefault();
              // Handle tag click
            }}
          >
            #{tag}
          </a>
        ))}
      </div>
    );
  };

  const renderMediaContent = (post: PostData) => {
    switch (post.mediaType) {
      case "audio":
        if (!post.track) return null;
        return (
          <div className="post-media post-audio">
            <AudioPlayer
              trackUrl={post.track.audioUrl}
              trackTitle={post.track.title}
              artistName={post.track.artist}
              coverArtUrl={post.track.coverArt}
              onPlay={() => handleView(post.id)}
            />
          </div>
        );

      case "image":
        if (!post.image) return null;
        return (
          <div className="post-media post-image">
            <ImageGallery
              images={[post.image]}
              showThumbnails={false}
              showNavigation={false}
              aspectRatio={post.image.width / post.image.height}
              onClick={() => handleView(post.id)}
            />
          </div>
        );

      case "video":
        if (!post.video) return null;
        return (
          <div className="post-media post-video">
            <VideoPlayer
              sources={post.video.sources}
              poster={post.video.poster}
              title={post.video.title}
              onPlay={() => handleView(post.id)}
            />
            {post.viewsCount !== undefined && (
              <div className="view-count">
                {post.viewsCount.toLocaleString()} views
              </div>
            )}
          </div>
        );

      case "carousel":
        if (!post.carousel || post.carousel.length === 0) return null;
        return (
          <div className="post-media post-carousel">
            <ImageGallery
              images={post.carousel}
              showThumbnails={false}
              aspectRatio={post.carousel[0].width / post.carousel[0].height}
              onClick={() => handleView(post.id)}
            />
          </div>
        );

      default:
        return null;
    }
  };

  return (
    <div style={socialFeedStyles.socialFeed as React.CSSProperties}>
      <div style={socialFeedStyles.feedHeader as React.CSSProperties}>
        <h2 style={socialFeedStyles.feedTitle as React.CSSProperties}>Feed</h2>
        <div style={socialFeedStyles.feedFilter as React.CSSProperties}>
          <button
            style={mergeStyles(
              socialFeedStyles.filterButton as React.CSSProperties,
              socialFeedStyles.filterButtonActive as React.CSSProperties,
            )}
          >
            For You
          </button>
          <button
            style={socialFeedStyles.filterButton as React.CSSProperties}
            onMouseOver={(e) => {
              e.currentTarget.style.background = "var(--hover)";
            }}
            onMouseOut={(e) => {
              e.currentTarget.style.background = "var(--background2)";
            }}
          >
            Following
          </button>
          <button
            style={socialFeedStyles.filterButton as React.CSSProperties}
            onMouseOver={(e) => {
              e.currentTarget.style.background = "var(--hover)";
            }}
            onMouseOut={(e) => {
              e.currentTarget.style.background = "var(--background2)";
            }}
          >
            Popular
          </button>
        </div>
      </div>

      {posts.length === 0 ? (
        <div style={socialFeedStyles.emptyFeed as React.CSSProperties}>
          No posts to display
        </div>
      ) : (
        <div style={socialFeedStyles.postList as React.CSSProperties}>
          {posts.map((post) => (
            <div
              key={post.id}
              style={socialFeedStyles.postCard as React.CSSProperties}
            >
              <div style={socialFeedStyles.postHeader as React.CSSProperties}>
                <div style={socialFeedStyles.postAvatar as React.CSSProperties}>
                  <img
                    src={post.userAvatar}
                    alt={`${post.username}'s avatar`}
                    style={
                      socialFeedStyles.postAvatarImg as React.CSSProperties
                    }
                  />
                </div>
                <div
                  style={socialFeedStyles.postUserInfo as React.CSSProperties}
                >
                  <h3
                    style={socialFeedStyles.postUsername as React.CSSProperties}
                  >
                    {post.username}
                  </h3>
                  <p style={socialFeedStyles.postTime as React.CSSProperties}>
                    {formatRelativeTime(new Date(post.createdAt))}
                    {post.location && ` • ${post.location}`}
                  </p>
                </div>
                <button
                  style={socialFeedStyles.postOptions as React.CSSProperties}
                  onMouseOver={(e) => {
                    e.currentTarget.style.background = "var(--hover)";
                  }}
                  onMouseOut={(e) => {
                    e.currentTarget.style.background = "transparent";
                  }}
                >
                  ⋮
                </button>
              </div>

              {post.mediaType && (
                <div style={socialFeedStyles.postMedia as React.CSSProperties}>
                  {renderMediaContent(post)}
                </div>
              )}

              <div style={socialFeedStyles.postContent as React.CSSProperties}>
                {post.content.length > 150 && expandedCaption !== post.id ? (
                  <>
                    {post.content.substring(0, 150)}...{" "}
                    <button
                      onClick={() => toggleCaption(post.id)}
                      style={{
                        background: "transparent",
                        border: "none",
                        color: "var(--text-color2)",
                        cursor: "pointer",
                        padding: 0,
                      }}
                    >
                      more
                    </button>
                  </>
                ) : (
                  <>
                    {post.content}
                    {post.content.length > 150 && (
                      <button
                        onClick={() => toggleCaption(post.id)}
                        style={{
                          background: "transparent",
                          border: "none",
                          color: "var(--text-color2)",
                          cursor: "pointer",
                          padding: 0,
                          marginLeft: "5px",
                        }}
                      >
                        less
                      </button>
                    )}
                  </>
                )}

                {post.tags && post.tags.length > 0 && (
                  <div style={{ marginTop: "8px" }}>
                    {renderTags(post.tags)}
                  </div>
                )}
              </div>

              <div style={socialFeedStyles.postActions as React.CSSProperties}>
                <button
                  style={mergeStyles(
                    socialFeedStyles.postAction as React.CSSProperties,
                    post.isLiked
                      ? (socialFeedStyles.postActionLiked as React.CSSProperties)
                      : {},
                  )}
                  onClick={() => handleLike(post.id)}
                  onMouseOver={(e) => {
                    if (!post.isLiked) {
                      e.currentTarget.style.background = "var(--hover)";
                    }
                  }}
                  onMouseOut={(e) => {
                    if (!post.isLiked) {
                      e.currentTarget.style.background = "transparent";
                    }
                  }}
                >
                  {post.isLiked ? "❤️" : "🤍"} {post.likesCount}
                </button>

                <button
                  style={socialFeedStyles.postAction as React.CSSProperties}
                  onClick={() =>
                    setActivePostId(activePostId === post.id ? null : post.id)
                  }
                  onMouseOver={(e) => {
                    e.currentTarget.style.background = "var(--hover)";
                  }}
                  onMouseOut={(e) => {
                    e.currentTarget.style.background = "transparent";
                  }}
                >
                  💬 {post.commentsCount}
                </button>

                <button
                  style={socialFeedStyles.postAction as React.CSSProperties}
                  onClick={() => handleShare(post.id)}
                  onMouseOver={(e) => {
                    e.currentTarget.style.background = "var(--hover)";
                  }}
                  onMouseOut={(e) => {
                    e.currentTarget.style.background = "transparent";
                  }}
                >
                  🔄 {post.sharesCount}
                </button>

                {post.viewsCount && (
                  <span
                    style={{
                      marginLeft: "auto",
                      color: "var(--text-color2)",
                      fontSize: "0.9rem",
                    }}
                  >
                    👁️ {post.viewsCount}
                  </span>
                )}
              </div>

              {activePostId === post.id && (
                <div
                  style={{
                    padding: "10px 15px",
                    display: "flex",
                    gap: "10px",
                    borderTop: "1px solid var(--separator)",
                  }}
                >
                  <input
                    type="text"
                    placeholder="Add a comment..."
                    value={newComment}
                    onChange={(e) => setNewComment(e.target.value)}
                    style={{
                      flex: 1,
                      padding: "8px 12px",
                      borderRadius: "20px",
                      border: "1px solid var(--separator)",
                      background: "var(--background3)",
                    }}
                    onKeyPress={(e) => {
                      if (e.key === "Enter") {
                        handleComment(post.id);
                      }
                    }}
                  />
                  <button
                    onClick={() => handleComment(post.id)}
                    disabled={!newComment.trim()}
                    style={{
                      padding: "8px 15px",
                      borderRadius: "20px",
                      border: "none",
                      background: newComment.trim()
                        ? "var(--blue)"
                        : "var(--gray4)",
                      color: newComment.trim() ? "white" : "var(--text-color3)",
                      cursor: newComment.trim() ? "pointer" : "not-allowed",
                    }}
                  >
                    Post
                  </button>
                </div>
              )}
            </div>
          ))}
        </div>
      )}

      <button
        style={socialFeedStyles.loadMore as React.CSSProperties}
        onClick={() => {
          // In a real app, this would load more posts
          console.log("Load more posts");
        }}
        onMouseOver={(e) => {
          e.currentTarget.style.background = "var(--hover)";
        }}
        onMouseOut={(e) => {
          e.currentTarget.style.background = "var(--background2)";
        }}
      >
        Load More
      </button>
    </div>
  );
};

export default SocialFeed;
```

#### apps/web/src/components/social/UserProfile.tsx

```tsx
import React, { useCallback, useEffect, useState } from "react";

interface User {
  id: string;
  username: string;
  displayName: string;
  avatar: string;
  bio: string;
  followersCount: number;
  followingCount: number;
  postsCount: number;
  isFollowing: boolean;
}

interface UserProfileProps {
  userId: string;
  onFollow?: (userId: string) => Promise<void>;
  onUnfollow?: (userId: string) => Promise<void>;
  className?: string;
}

export const UserProfile: React.FC<UserProfileProps> = ({
  userId,
  onFollow,
  onUnfollow,
  className,
}) => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchUserProfile = useCallback(async () => {
    try {
      setIsLoading(true);
      // TODO: Replace with actual API call
      const response = await fetch(`/api/users/${userId}`);
      if (!response.ok) throw new Error("Failed to fetch user profile");
      const data = (await response.json()) as User;
      setUser(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to load profile");
    } finally {
      setIsLoading(false);
    }
  }, [userId]);

  useEffect(() => {
    void fetchUserProfile();
  }, [fetchUserProfile]);

  const handleFollowToggle = async () => {
    if (!user) return;

    try {
      if (user.isFollowing) {
        await onUnfollow?.(userId);
        setUser((prev) =>
          prev
            ? {
                ...prev,
                isFollowing: false,
                followersCount: prev.followersCount - 1,
              }
            : null,
        );
      } else {
        await onFollow?.(userId);
        setUser((prev) =>
          prev
            ? {
                ...prev,
                isFollowing: true,
                followersCount: prev.followersCount + 1,
              }
            : null,
        );
      }
    } catch (err) {
      setError(
        err instanceof Error ? err.message : "Failed to update follow status",
      );
    }
  };

  const styles = {
    container: {
      padding: "24px",
      backgroundColor: "#fff",
      borderRadius: "8px",
      boxShadow: "0 2px 4px rgba(0,0,0,0.1)",
    },
    header: {
      display: "flex",
      alignItems: "center",
      gap: "24px",
      marginBottom: "24px",
    },
    avatar: {
      width: "120px",
      height: "120px",
      borderRadius: "50%",
      objectFit: "cover" as const,
    },
    info: {
      flex: 1,
    },
    name: {
      fontSize: "24px",
      fontWeight: 600,
      margin: "0 0 8px",
      color: "#1a1a1a",
    },
    username: {
      fontSize: "16px",
      color: "#666",
      margin: "0 0 16px",
    },
    bio: {
      fontSize: "16px",
      lineHeight: "1.5",
      color: "#333",
      margin: "0 0 16px",
    },
    stats: {
      display: "flex",
      gap: "24px",
      marginBottom: "24px",
    },
    stat: {
      display: "flex",
      flexDirection: "column" as const,
      alignItems: "center",
    },
    statValue: {
      fontSize: "20px",
      fontWeight: 600,
      color: "#1a1a1a",
    },
    statLabel: {
      fontSize: "14px",
      color: "#666",
    },
    followButton: {
      padding: "8px 24px",
      borderRadius: "20px",
      border: "none",
      fontSize: "16px",
      fontWeight: 500,
      cursor: "pointer",
      transition: "background-color 0.2s",
      backgroundColor: user?.isFollowing ? "#e0e0e0" : "#2196f3",
      color: user?.isFollowing ? "#333" : "#fff",
      "&:hover": {
        backgroundColor: user?.isFollowing ? "#d0d0d0" : "#1976d2",
      },
    },
    loading: {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      minHeight: "200px",
    },
    error: {
      color: "#d32f2f",
      textAlign: "center" as const,
      padding: "16px",
    },
  };

  if (isLoading) {
    return <div style={styles.loading}>Loading...</div>;
  }

  if (error) {
    return <div style={styles.error}>{error}</div>;
  }

  if (!user) {
    return <div style={styles.error}>User not found</div>;
  }

  return (
    <div style={styles.container} className={className}>
      <div style={styles.header}>
        <img src={user.avatar} alt={user.displayName} style={styles.avatar} />
        <div style={styles.info}>
          <h1 style={styles.name}>{user.displayName}</h1>
          <p style={styles.username}>@{user.username}</p>
          <p style={styles.bio}>{user.bio}</p>
          <button
            style={styles.followButton}
            onClick={() => void handleFollowToggle()}
            onMouseEnter={(e) =>
              (e.currentTarget.style.backgroundColor = user.isFollowing
                ? "#d0d0d0"
                : "#1976d2")
            }
            onMouseLeave={(e) =>
              (e.currentTarget.style.backgroundColor = user.isFollowing
                ? "#e0e0e0"
                : "#2196f3")
            }
          >
            {user.isFollowing ? "Following" : "Follow"}
          </button>
        </div>
      </div>

      <div style={styles.stats}>
        <div style={styles.stat}>
          <span style={styles.statValue}>{user.postsCount}</span>
          <span style={styles.statLabel}>Posts</span>
        </div>
        <div style={styles.stat}>
          <span style={styles.statValue}>{user.followersCount}</span>
          <span style={styles.statLabel}>Followers</span>
        </div>
        <div style={styles.stat}>
          <span style={styles.statValue}>{user.followingCount}</span>
          <span style={styles.statLabel}>Following</span>
        </div>
      </div>
    </div>
  );
};
```

#### apps/web/src/components/social/UserProfileCard.tsx

```tsx
import React, { useState } from "react";

import { useClientEnvironment } from "../../services/ClientEnvironment";
import { socialService } from "../../services/social";

interface User {
  id: string;
  username: string;
  displayName: string;
  avatar: string;
  bio: string;
  followersCount: number;
  followingCount: number;
  postsCount: number;
  isFollowing: boolean;
}

interface UserProfileCardProps {
  user: User;
}

export const UserProfileCard: React.FC<UserProfileCardProps> = ({ user }) => {
  const environment = useClientEnvironment();
  const [isFollowing, setIsFollowing] = useState(user.isFollowing);
  const [followersCount, setFollowersCount] = useState(user.followersCount);
  const [isLoading, setIsLoading] = useState(false);

  const handleFollowToggle = async () => {
    if (isLoading) return;

    setIsLoading(true);
    try {
      if (isFollowing) {
        await socialService.unfollowUser(user.id);
        setIsFollowing(false);
        setFollowersCount((prev) => prev - 1);
      } else {
        await socialService.followUser(user.id);
        setIsFollowing(true);
        setFollowersCount((prev) => prev + 1);
      }
    } catch (error) {
      console.error("Error toggling follow:", error);
    } finally {
      setIsLoading(false);
    }
  };

  const navigateToProfile = () => {
    environment.router.navigate(`/profile/${user.id}`);
  };

  return (
    <div
      style={{
        border: "1px solid #e0e0e0",
        borderRadius: "8px",
        padding: "16px",
        marginBottom: "16px",
        backgroundColor: "white",
        boxShadow: "0 1px 3px rgba(0,0,0,0.1)",
      }}
    >
      <div style={{ display: "flex", alignItems: "center" }}>
        <img
          src={user.avatar || "/default-avatar.png"}
          alt={user.displayName}
          style={{
            width: "80px",
            height: "80px",
            borderRadius: "50%",
            marginRight: "16px",
            objectFit: "cover",
            cursor: "pointer",
          }}
          onClick={navigateToProfile}
        />
        <div style={{ flex: 1 }}>
          <div
            style={{
              fontWeight: "bold",
              fontSize: "1.2rem",
              cursor: "pointer",
            }}
            onClick={navigateToProfile}
          >
            {user.displayName}
          </div>
          <div style={{ color: "#666", marginBottom: "8px" }}>
            @{user.username}
          </div>
          <div style={{ marginBottom: "12px" }}>{user.bio}</div>
          <div
            style={{
              display: "flex",
              gap: "16px",
              color: "#666",
              fontSize: "0.9rem",
            }}
          >
            <div>
              <strong>{user.postsCount}</strong> posts
            </div>
            <div>
              <strong>{followersCount}</strong> followers
            </div>
            <div>
              <strong>{user.followingCount}</strong> following
            </div>
          </div>
        </div>
        <div>
          <button
            onClick={() => void handleFollowToggle()}
            disabled={isLoading}
            style={{
              padding: "8px 16px",
              backgroundColor: isFollowing ? "white" : "var(--accent)",
              color: isFollowing ? "var(--accent)" : "white",
              border: isFollowing ? "1px solid var(--accent)" : "none",
              borderRadius: "20px",
              cursor: "pointer",
              fontWeight: "bold",
              opacity: isLoading ? 0.7 : 1,
            }}
          >
            {isLoading ? "..." : isFollowing ? "Unfollow" : "Follow"}
          </button>
        </div>
      </div>
    </div>
  );
};
```

#### apps/web/src/components/theme/ThemeContext.tsx

```tsx
import {
  createContext,
  ReactNode,
  useContext,
  useEffect,
  useState,
} from "react";

type ThemeMode = "light" | "dark";

interface ThemeContextType {
  theme: ThemeMode;
  toggleTheme: () => void;
  setTheme: (theme: ThemeMode) => void;
  useSystemTheme: () => void;
  isUsingSystemTheme: boolean;
}

const ThemeContext = createContext<ThemeContextType>({
  theme: "light",
  toggleTheme: () => {},
  setTheme: () => {},
  useSystemTheme: () => {},
  isUsingSystemTheme: false,
});

export const useTheme = () => useContext(ThemeContext);

interface ThemeProviderProps {
  children: ReactNode;
}

// Helper function to get system preference
const getSystemThemePreference = (): ThemeMode => {
  if (
    window.matchMedia &&
    window.matchMedia("(prefers-color-scheme: dark)").matches
  ) {
    return "dark";
  }
  return "light";
};

export function ThemeProvider({ children }: ThemeProviderProps) {
  // Track if we're using system theme
  const [isUsingSystemTheme, setIsUsingSystemTheme] = useState<boolean>(() => {
    return localStorage.getItem("useSystemTheme") === "true";
  });

  // Initialize theme from localStorage or system preference
  const [theme, setThemeState] = useState<ThemeMode>(() => {
    // Check if we should use system theme
    if (localStorage.getItem("useSystemTheme") === "true") {
      return getSystemThemePreference();
    }

    // Check if theme is stored in localStorage
    const savedTheme = localStorage.getItem("theme") as ThemeMode;
    if (savedTheme && (savedTheme === "light" || savedTheme === "dark")) {
      return savedTheme;
    }

    // Default to system preference
    setIsUsingSystemTheme(true);
    return getSystemThemePreference();
  });

  // Listen for system theme changes
  useEffect(() => {
    const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");

    const handleChange = (e: MediaQueryListEvent) => {
      if (isUsingSystemTheme) {
        setThemeState(e.matches ? "dark" : "light");
      }
    };

    // Modern browsers
    if (mediaQuery.addEventListener) {
      mediaQuery.addEventListener("change", handleChange);
    } else {
      // Fallback for older browsers
      mediaQuery.addListener(handleChange);
    }

    return () => {
      if (mediaQuery.removeEventListener) {
        mediaQuery.removeEventListener("change", handleChange);
      } else {
        mediaQuery.removeListener(handleChange);
      }
    };
  }, [isUsingSystemTheme]);

  // Apply theme to document when it changes
  useEffect(() => {
    document.documentElement.setAttribute("data-theme", theme);

    // Only save to localStorage if not using system theme
    if (!isUsingSystemTheme) {
      localStorage.setItem("theme", theme);
    }
  }, [theme, isUsingSystemTheme]);

  // Toggle between light and dark mode
  const toggleTheme = () => {
    setIsUsingSystemTheme(false);
    localStorage.setItem("useSystemTheme", "false");
    setThemeState((prevTheme) => (prevTheme === "light" ? "dark" : "light"));
  };

  // Set theme directly
  const setTheme = (newTheme: ThemeMode) => {
    setIsUsingSystemTheme(false);
    localStorage.setItem("useSystemTheme", "false");
    setThemeState(newTheme);
  };

  // Use system theme
  const useSystemTheme = () => {
    setIsUsingSystemTheme(true);
    localStorage.setItem("useSystemTheme", "true");
    setThemeState(getSystemThemePreference());
  };

  return (
    <ThemeContext.Provider
      value={{
        theme,
        toggleTheme,
        setTheme,
        useSystemTheme,
        isUsingSystemTheme,
      }}
    >
      {children}
    </ThemeContext.Provider>
  );
}
```

#### apps/web/src/components/theme/index.ts

```ts
export { ThemeProvider, useTheme } from "./ThemeContext";
```

#### apps/web/src/components/ui/Badge.tsx

```tsx
import React from "react";

export function Badge(props: {
  children: React.ReactNode;
  style?: React.CSSProperties;
  onClick?: React.MouseEventHandler;
  onKeyDown?: React.KeyboardEventHandler;
  tabIndex?: 0 | -1;
}) {
  return (
    <div
      style={{
        display: "inline-block",
        fontSize: "0.8em",
        padding: "0.2em 0.4em",
        borderRadius: "0.2em",
        backgroundColor: "var(--gray3)",
        ...props.style,
      }}
      tabIndex={props.tabIndex}
      onClick={props.onClick}
      onKeyDown={props.onKeyDown}
    >
      {props.children}
    </div>
  );
}
```

#### apps/web/src/components/ui/Button.tsx

```tsx
import { ComponentPropsWithoutRef, forwardRef } from "react";
import "./button.css";

interface ButtonProps extends ComponentPropsWithoutRef<"button"> {
  variant?: "primary" | "secondary" | "text";
  size?: "small" | "medium" | "large";
}

const Button = forwardRef<HTMLButtonElement, ButtonProps>((props, ref) => {
  const {
    variant = "primary",
    size = "medium",
    className = "",
    ...rest
  } = props;
  const buttonClass = `btn btn-${variant} btn-${size} ${className}`;

  return <button ref={ref} className={buttonClass} {...rest} />;
});

Button.displayName = "Button";

export { Button };
export default Button;
```

#### apps/web/src/components/ui/Card.tsx

```tsx
import React from "react";

interface CardProps extends React.HTMLAttributes<HTMLDivElement> {
  children: React.ReactNode;
  className?: string;
}

export const Card: React.FC<CardProps> = ({
  children,
  className = "",
  ...props
}) => {
  return (
    <div
      className={`bg-white shadow-md rounded-lg overflow-hidden ${className}`}
      {...props}
    >
      {children}
    </div>
  );
};
```

#### apps/web/src/components/ui/ComboBox.tsx

```tsx
import React, {
  useEffect,
  useLayoutEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { Button } from "./Button";
import { FuzzyString } from "./FuzzyString";
import { Input } from "./Input";
import { MenuItem } from "./MenuItem";
import { Popup, PopupFrame } from "./Popup";
import { fuzzyMatch } from "../../../server/shared/utils";
import { useRefPrevious } from "../../hooks/useRefPrevious";
import { isShortcut } from "../../hooks/useShortcut";

interface ComboBoxProps<T> {
  items: T[];
  renderItem: (item: T) => React.ReactNode;
  onSelect: (item: T) => void;
  value?: T;
  placeholder?: string;
  onChange?: (value: T) => void;
}

export function ComboBox<T>({
  items,
  renderItem,
  onSelect,
  value,
  placeholder,
  onChange,
}: ComboBoxProps<T>) {
  const [open, setOpen] = useState(false);
  const [search, setSearch] = useState("");
  const buttonRef = useRef<HTMLButtonElement>(null);
  const [hoveredIndex, setHoveredIndex] = useState<number | null>(null);

  const filteredItems = items.filter((item) => {
    const renderedItem = renderItem(item);
    if (typeof renderedItem === "string") {
      return renderedItem.toLowerCase().includes(search.toLowerCase());
    }
    return true; // Skip filtering for non-string items
  });

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        buttonRef.current &&
        !buttonRef.current.contains(event.target as Node)
      ) {
        setOpen(false);
      }
    };

    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, []);

  const handleSelect = (item: T) => {
    onSelect(item);
    onChange?.(item);
    setOpen(false);
    setSearch("");
  };

  return (
    <div>
      <Button ref={buttonRef} onClick={() => setOpen(!open)}>
        {value ? renderItem(value) : placeholder || "Select..."}
      </Button>
      {open && buttonRef.current && (
        <Popup
          open={open}
          anchor={buttonRef.current}
          onDismiss={() => setOpen(false)}
        >
          <div
            style={{
              padding: "0.5rem",
              backgroundColor: "white",
              borderRadius: "0.25rem",
              boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)",
            }}
          >
            <div style={{ marginBottom: "0.5rem" }}>
              <Input
                value={search}
                onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
                  setSearch(e.target.value)
                }
                placeholder="Search..."
              />
            </div>
            <div style={{ maxHeight: "200px", overflowY: "auto" }}>
              {filteredItems.map((item, index) => (
                <div
                  key={index}
                  onClick={() => handleSelect(item)}
                  onMouseEnter={() => setHoveredIndex(index)}
                  onMouseLeave={() => setHoveredIndex(null)}
                  style={{
                    padding: "0.5rem",
                    cursor: "pointer",
                    backgroundColor:
                      value === item || hoveredIndex === index
                        ? "#e2e8f0"
                        : "transparent",
                    transition: "background-color 0.2s ease",
                  }}
                >
                  {renderItem(item)}
                </div>
              ))}
            </div>
          </div>
        </Popup>
      )}
    </div>
  );
}

export function ComboBoxSelect(props: {
  items: string[];
  placeholder: string;
  value: string | undefined;
  onChange: (value: string) => void;
}) {
  const [open, setOpen] = React.useState(false);
  const buttonRef = useRef<HTMLButtonElement>(null);
  const prevOpen = useRefPrevious(open);

  useLayoutEffect(() => {
    if (prevOpen.current && !open) {
      buttonRef.current?.focus();
    }
  }, [prevOpen, open]);

  if (open) {
    return (
      <ComboBoxSearch
        autoFocus
        items={props.items}
        value={props.value}
        onChange={(newValue: string) => {
          props.onChange(newValue);
          setOpen(false);
        }}
        onDismiss={() => {
          setOpen(false);
        }}
      />
    );
  }

  return (
    <Button
      ref={buttonRef}
      onClick={() => setOpen(true)}
      style={{ textAlign: "left" }}
    >
      {props.value || (
        <span style={{ color: "var(--text-color2" }}>{props.placeholder} </span>
      )}{" "}
      <span style={{ fontSize: "0.7rem", verticalAlign: "middle" }}>▼</span>
    </Button>
  );
}

export function ComboBoxSearch(props: {
  items: string[];
  value: string | undefined;
  onChange: (value: string) => void;
  onDismiss?: () => void;
  autoFocus?: boolean;
  notice?: React.ReactNode;
}) {
  const inputRef = useRef<HTMLInputElement>(null);
  const [focused, setFocused] = useState(false);

  useEffect(() => {
    if (props.autoFocus) inputRef.current?.focus();
  }, [props.autoFocus]);

  const [text, setText] = useState("");

  const filteredItems = useMemo(() => {
    return props.items
      .map((str) => ({ value: str, match: fuzzyMatch(text, str) || undefined }))
      .filter(({ match }) => Boolean(match));
  }, [text, props.items]);

  const [selectedIndex, setSelectedIndex] = useState(0);

  const handleKeydown = (event: React.KeyboardEvent) => {
    if (isShortcut("down", event.nativeEvent)) {
      event.preventDefault();
      setSelectedIndex((i) => {
        if (i >= filteredItems.length - 1) return filteredItems.length - 1;
        else return i + 1;
      });
      return;
    }
    if (isShortcut("up", event.nativeEvent)) {
      event.preventDefault();
      setSelectedIndex((i) => {
        if (i === 0) return i;
        else return i - 1;
      });
      return;
    }
    if (isShortcut("enter", event.nativeEvent)) {
      event.preventDefault();
      if (filteredItems[selectedIndex]) {
        props.onChange(filteredItems[selectedIndex].value);
      }
      return;
    }
    if (isShortcut("escape", event.nativeEvent)) {
      event.preventDefault();
      props.onDismiss?.();
      return;
    }
  };

  // TODO: filter selected on key change to maintain selectedIndex position?
  return (
    <>
      <Input
        ref={inputRef}
        onFocus={() => setFocused(true)}
        onBlur={() => {
          setFocused(false);
          props.onDismiss?.();
        }}
        value={text}
        onChange={(e) => {
          setText(e.target.value);
          setSelectedIndex(0);
        }}
        onKeyDown={handleKeydown}
      />

      <Popup
        open={focused && filteredItems.length > 0}
        anchor={inputRef.current}
        onDismiss={props.onDismiss}
      >
        <PopupFrame>
          {props.notice}
          {filteredItems.map((item, i) => (
            <MenuItem
              key={item.value}
              selected={selectedIndex === i}
              onClick={() => props.onChange(item.value)}
              onMouseDown={(e) => e.preventDefault()}
              onMouseEnter={() => setSelectedIndex(i)}
            >
              <FuzzyString match={item.match} />
            </MenuItem>
          ))}
        </PopupFrame>
      </Popup>
    </>
  );
}
```

#### apps/web/src/components/ui/DropdownMenu.tsx

```tsx
import React, { CSSProperties } from "react";

import { usePopper } from "../../hooks/usePopper";

interface DropdownMenuProps {
  style?: CSSProperties;
  items: Array<{
    label: string;
    onClick: () => void;
  }>;
  onClose: () => void;
}

export function DropdownMenu({ style, items, onClose }: DropdownMenuProps) {
  const [referenceElement, _setReferenceElement] =
    React.useState<HTMLElement | null>(null);
  const [popperElement, setPopperElement] = React.useState<HTMLElement | null>(
    null,
  );
  const [selectedIndex, setSelectedIndex] = React.useState(0);
  const [hoveredIndex, setHoveredIndex] = React.useState<number | null>(null);

  const popperInstance = usePopper(referenceElement, popperElement, {
    placement: "bottom-start",
    modifiers: [
      {
        name: "offset",
        options: {
          offset: [0, 4],
        },
      },
    ],
  }) as unknown as {
    styles: { popper: CSSProperties };
    attributes: { popper: Record<string, string> };
  };

  // Default empty styles and attributes if they don't exist
  const styles = popperInstance.styles || {};
  const attributes = popperInstance.attributes || {};

  React.useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        popperElement &&
        !popperElement.contains(event.target as Node) &&
        referenceElement &&
        !referenceElement.contains(event.target as Node)
      ) {
        onClose();
      }
    };

    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [popperElement, referenceElement, onClose]);

  const handleKeyDown = (event: React.KeyboardEvent) => {
    switch (event.key) {
      case "ArrowDown":
        event.preventDefault();
        setSelectedIndex((i) => (i + 1) % items.length);
        break;
      case "ArrowUp":
        event.preventDefault();
        setSelectedIndex((i) => (i - 1 + items.length) % items.length);
        break;
      case "Enter":
        event.preventDefault();
        items[selectedIndex].onClick();
        onClose();
        break;
      case "Escape":
        event.preventDefault();
        onClose();
        break;
    }
  };

  return (
    <div style={style} onKeyDown={handleKeyDown}>
      <div ref={setPopperElement} style={styles.popper} {...attributes.popper}>
        {items.map((item, i) => (
          <div
            key={i}
            onClick={() => {
              item.onClick();
              onClose();
            }}
            onMouseEnter={() => setHoveredIndex(i)}
            onMouseLeave={() => setHoveredIndex(null)}
            style={{
              padding: "0.5rem 1rem",
              cursor: "pointer",
              backgroundColor:
                i === selectedIndex || i === hoveredIndex
                  ? "#e2e8f0"
                  : "transparent",
              transition: "background-color 0.2s ease",
            }}
          >
            {item.label}
          </div>
        ))}
      </div>
    </div>
  );
}
```

#### apps/web/src/components/ui/FileUpload.tsx

```tsx
import React, {
  ChangeEvent,
  ComponentPropsWithoutRef,
  DragEvent,
  useRef,
  useState,
} from "react";

import { DeferredPromise } from "@infrastructure/promises";
import { randomId } from "@infrastructure/utils/randomId";

import { passthroughRef } from "../../helpers/passthroughRef";

interface Upload {
  id: string;
  file: File;
  promise: DeferredPromise<void>;
  uploaded?: boolean;
}

interface FileUploadProps extends ComponentPropsWithoutRef<"div"> {
  onFileSelect: (file: File) => void;
  accept?: string;
  multiple?: boolean;
}

export function FileUpload({
  onFileSelect,
  accept,
  multiple,
  ...props
}: FileUploadProps) {
  const [isDragging, setIsDragging] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleDragOver = (event: DragEvent<HTMLDivElement>) => {
    event.preventDefault();
    setIsDragging(true);
  };

  const handleDragLeave = (event: DragEvent<HTMLDivElement>) => {
    event.preventDefault();
    setIsDragging(false);
  };

  const handleDrop = (event: DragEvent<HTMLDivElement>) => {
    event.preventDefault();
    setIsDragging(false);

    const files = Array.from(event.dataTransfer.files);
    if (files.length > 0) {
      onFileSelect(files[0]);
    }
  };

  const handleClick = () => {
    fileInputRef.current?.click();
  };

  const handleFileChange = (event: ChangeEvent<HTMLInputElement>) => {
    const files = event.target.files;
    if (files && files.length > 0) {
      onFileSelect(files[0]);
    }
  };

  return (
    <div
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
      onDrop={handleDrop}
      onClick={handleClick}
      style={{
        border: `2px dashed ${isDragging ? "#3b82f6" : "#e2e8f0"}`,
        borderRadius: "0.5rem",
        padding: "2rem",
        textAlign: "center",
        cursor: "pointer",
        backgroundColor: isDragging ? "rgba(59, 130, 246, 0.1)" : "transparent",
        transition: "all 0.2s ease",
        ...props.style,
      }}
      {...props}
    >
      <input
        ref={fileInputRef}
        type="file"
        accept={accept}
        multiple={multiple}
        onChange={handleFileChange}
        style={{ display: "none" }}
      />
      {isDragging ? "Drop files here" : "Click or drag files here to upload"}
    </div>
  );
}

export default FileUpload;

export function useFileUpload(
  onUpload: (
    file: File,
    onProgress: (progress: number) => void,
  ) => Promise<void>,
) {
  const [uploads, setUploads] = useState<Upload[]>([]);

  const handleDrop = async (event: DragEvent<HTMLDivElement>) => {
    event.preventDefault();
    const files = Array.from(event.dataTransfer.files);
    for (const file of files) {
      const upload: Upload = {
        id: randomId(),
        file,
        promise: new DeferredPromise(),
      };
      setUploads((uploads) => [...uploads, upload]);
      try {
        await onUpload(file, (_progress) => {
          // Update progress
        });
        upload.uploaded = true;
        upload.promise.resolve();
      } catch (error) {
        upload.promise.reject(error);
      }
    }
  };

  return {
    uploads,
    handleDrop,
  };
}

export function UploadPreview({ file, uploaded }: Upload) {
  const [preview, setPreview] = useState<string | null>(null);

  React.useEffect(() => {
    const reader = new FileReader();
    reader.onloadend = () => {
      setPreview(reader.result as string);
    };
    reader.readAsDataURL(file);
  }, [file]);

  return (
    <div
      style={{
        display: "flex",
        alignItems: "center",
        gap: "1rem",
        padding: "0.5rem",
        borderRadius: "0.25rem",
        backgroundColor: "#f8fafc",
      }}
    >
      {preview && (
        <img
          src={preview}
          alt={file.name}
          style={{
            width: "2rem",
            height: "2rem",
            objectFit: "cover",
            borderRadius: "0.25rem",
          }}
        />
      )}
      <div style={{ flex: 1 }}>{file.name}</div>
      <div>{uploaded ? "✅" : "❌"}</div>
    </div>
  );
}

export const FileUploadDropZone = passthroughRef(
  (
    props: ComponentPropsWithoutRef<"div"> & {
      selected?: boolean;
    },
  ) => {
    const [isDragging, setIsDragging] = useState(false);

    const handleDragEnter = (e: React.DragEvent<HTMLDivElement>) => {
      e.preventDefault();
      setIsDragging(true);
    };

    const handleDragExit = (e: React.DragEvent<HTMLDivElement>) => {
      e.preventDefault();
      setIsDragging(false);
    };

    const handleDragOver = (e: React.DragEvent<HTMLDivElement>) => {
      e.preventDefault();
    };

    const handleDrop = (e: React.DragEvent<HTMLDivElement>) => {
      setIsDragging(false);
      props.onDrop?.(e);
    };

    return (
      <div
        {...props}
        onDragEnter={handleDragEnter}
        onDragExit={handleDragExit}
        onDragOver={handleDragOver}
        onDrop={handleDrop}
        style={{
          border: isDragging
            ? "3px dashed var(--blue)"
            : "3px solid transparent",
          ...props.style,
        }}
      />
    );
  },
);

export async function uploadFile(
  file: File,
  url: string,
  onProgress: (progress: number) => void,
) {
  const xhr = new XMLHttpRequest();
  xhr.open("PUT", url, true);

  // Update progress
  xhr.upload.addEventListener("progress", (event) => {
    if (!event.lengthComputable) return;
    const progress = Math.round((event.loaded / event.total) * 100);
    onProgress(progress);
  });

  const deferred = new DeferredPromise<void>();

  // Handle errors
  xhr.onerror = (error) => {
    deferred.reject(error);
  };

  xhr.onreadystatechange = () => {
    if (xhr.readyState === XMLHttpRequest.DONE) {
      if (xhr.status === 200) {
        deferred.resolve();
      } else {
        const error = new Error(`UploadError: ${xhr.status} ${xhr.statusText}`);
        deferred.reject(error);
      }
    }
  };

  xhr.send(file);

  return deferred.promise;
}

const MB = 1024 * 1024;

export async function _renderPreview(file: File) {
  const deferred = new DeferredPromise<string | undefined>();

  if (file.type.startsWith("image/") && file.size <= 10 * MB) {
    const reader = new FileReader();
    reader.onload = (e) => {
      const preview = e.target?.result as string;
      deferred.resolve(preview);
    };
    reader.readAsDataURL(file);
  } else {
    deferred.resolve(undefined);
  }

  return deferred.promise;
}

export function FileUploadArea(
  props: ComponentPropsWithoutRef<"div"> & {
    onFileSelect: (files: FileList) => void;
    accept?: string;
    multiple?: boolean;
  },
): React.ReactElement {
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleClick = () => {
    fileInputRef.current?.click();
  };

  const handleFileChange = (event: ChangeEvent<HTMLInputElement>) => {
    const files = event.target.files;
    if (files) {
      props.onFileSelect(files);
    }
  };

  return (
    <div
      onClick={handleClick}
      style={{
        border: "2px dashed var(--border-color)",
        borderRadius: "0.5rem",
        padding: "2rem",
        textAlign: "center",
        cursor: "pointer",
        ...props.style,
      }}
      {...props}
    >
      <input
        ref={fileInputRef}
        type="file"
        accept={props.accept}
        multiple={props.multiple}
        onChange={handleFileChange}
        style={{ display: "none" }}
      />
      Click to select files
    </div>
  );
}
```

#### apps/web/src/components/ui/FuzzyString.tsx

```tsx
import { FuzzyMatchResult } from "../../../server/shared/utils";

interface FuzzyStringProps {
  match?: FuzzyMatchResult[];
  text?: string;
}

export function FuzzyString({ match, text }: FuzzyStringProps) {
  if (!match) {
    return <span>{text}</span>;
  }

  return (
    <span>
      {match.map((item, i) => (
        <span
          key={i}
          style={{
            fontWeight: "match" in item ? "bold" : "normal",
            color: "match" in item ? "#3b82f6" : "inherit",
          }}
        >
          {"match" in item ? item.match : item.skip}
        </span>
      ))}
    </span>
  );
}
```

#### apps/web/src/components/ui/Input.tsx

```tsx
import { ComponentPropsWithoutRef, forwardRef } from "react";

export const Input = forwardRef<
  HTMLInputElement,
  ComponentPropsWithoutRef<"input">
>((props, ref) => {
  return (
    <input
      ref={ref}
      {...props}
      style={{
        padding: "0.5rem",
        border: "1px solid #e2e8f0",
        borderRadius: "0.25rem",
        outline: "none",
        width: "100%",
        ...props.style,
      }}
    />
  );
});

Input.displayName = "Input";

// Also export as default for backward compatibility
export default Input;
```

#### apps/web/src/components/ui/Link.tsx

```tsx
import React from "react";

import { useClientEnvironment } from "../../services/ClientEnvironment";
import { Route, useRoute } from "../../services/Router";

interface LinkProps extends React.AnchorHTMLAttributes<HTMLAnchorElement> {
  to: string;
  activeStyle?: React.CSSProperties;
  activeClass?: string;
}

export function Link({
  to,
  activeStyle,
  activeClass,
  style,
  className,
  onClick,
  ...props
}: LinkProps) {
  const environment = useClientEnvironment();
  const route = useRoute();

  // Determine if this link is active based on the current route
  const isActive = isLinkActive(route, to);

  const handleClick = (event: React.MouseEvent<HTMLAnchorElement>) => {
    event.preventDefault();
    if (onClick) {
      onClick(event);
    }
    environment.router.navigate(to);
  };

  return (
    <a
      {...props}
      href={to}
      onClick={handleClick}
      style={{
        ...style,
        ...(isActive ? activeStyle : {}),
      }}
      className={`${className || ""} ${isActive ? activeClass || "" : ""}`}
    />
  );
}

// Helper function to determine if a link is active based on the current route
function isLinkActive(route: Route, to: string): boolean {
  if (to === "/" && route.type === "root") {
    return true;
  }

  if (to === "/home" && route.type === "home") {
    return true;
  }

  if (to === "/media" && route.type === "media") {
    return true;
  }

  if (to === "/social" && route.type === "social") {
    return true;
  }

  if (to === "/settings" && route.type === "settings") {
    return true;
  }

  if (to === "/dashboard" && route.type === "dashboard") {
    return true;
  }

  if (to === "/profile" && route.type === "profile") {
    return true;
  }

  if (to === "/upload" && route.type === "upload") {
    return true;
  }

  if (to === "/explore" && route.type === "explore") {
    return true;
  }

  if (to === "/notifications" && route.type === "notifications") {
    return true;
  }

  if (to.startsWith("/design/") && route.type === "design") {
    return to.slice("/design/".length) === route.page;
  }

  return false;
}
```

#### apps/web/src/components/ui/ListBox.tsx

```tsx
import React, { ComponentPropsWithoutRef } from "react";

interface ListBoxProps<T> {
  items: T[];
  selectedIndex: number;
  onSelectIndex: (index: number) => void;
  children: (item: T, props: ListItemProps) => React.ReactNode;
  autoFocus?: boolean;
}

interface ListItemProps extends ComponentPropsWithoutRef<"div"> {
  selected?: boolean;
}

export function ListBox<T>({
  items,
  selectedIndex,
  onSelectIndex,
  children,
  autoFocus,
}: ListBoxProps<T>) {
  const containerRef = React.useRef<HTMLDivElement>(null);

  React.useEffect(() => {
    if (autoFocus) {
      containerRef.current?.focus();
    }
  }, [autoFocus]);

  const handleKeyDown = (event: React.KeyboardEvent) => {
    switch (event.key) {
      case "ArrowDown":
        event.preventDefault();
        onSelectIndex((selectedIndex + 1) % items.length);
        break;
      case "ArrowUp":
        event.preventDefault();
        onSelectIndex((selectedIndex - 1 + items.length) % items.length);
        break;
      case "Enter":
        event.preventDefault();
        // Handle selection
        break;
    }
  };

  return (
    <div
      ref={containerRef}
      tabIndex={0}
      onKeyDown={handleKeyDown}
      style={{
        outline: "none",
      }}
    >
      {items.map((item, index) =>
        children(item, {
          key: index,
          onClick: () => onSelectIndex(index),
          selected: index === selectedIndex,
        }),
      )}
    </div>
  );
}

export function ListItem({ selected, style, ...props }: ListItemProps) {
  return (
    <div
      {...props}
      style={{
        cursor: "pointer",
        backgroundColor: selected ? "#e2e8f0" : "transparent",
        transition: "background-color 0.2s ease",
        ...style,
      }}
    />
  );
}
```

#### apps/web/src/components/ui/MenuItem.tsx

```tsx
import React, { ComponentPropsWithoutRef } from "react";

interface MenuItemProps extends ComponentPropsWithoutRef<"div"> {
  selected?: boolean;
  onSubmit?: () => void;
}

export function MenuItem({
  selected,
  onSubmit,
  style,
  ...props
}: MenuItemProps) {
  const handleKeyDown = (event: React.KeyboardEvent) => {
    if (event.key === "Enter" && onSubmit) {
      event.preventDefault();
      onSubmit();
    }
  };

  return (
    <div
      role="menuitem"
      tabIndex={0}
      onKeyDown={handleKeyDown}
      style={{
        padding: "0.5rem 1rem",
        cursor: "pointer",
        backgroundColor: selected ? "#e2e8f0" : "transparent",
        transition: "background-color 0.2s ease",
        ...style,
      }}
      {...props}
    />
  );
}
```

#### apps/web/src/components/ui/OfflineBadge.tsx

```tsx
import { Badge } from "./Badge";
import { useOnline } from "../../hooks/useOnline";

export function OfflineBadge() {
  const online = useOnline();
  return (
    <Badge style={{ backgroundColor: online ? undefined : "var(--orange)" }}>
      {online ? "Online" : <strong>Offline</strong>}
    </Badge>
  );
}
```

#### apps/web/src/components/ui/Popup.tsx

```tsx
import React, { useLayoutEffect, useMemo } from "react";
import { createPortal } from "react-dom";

import { passthroughRef } from "../../helpers/passthroughRef";
import { Placement, createPopper } from "../../hooks/usePopper";
import { useShortcut } from "../../hooks/useShortcut";

export function Popup(props: {
  open: boolean;
  anchor: HTMLElement | undefined | null;
  placement?: Placement;
  children?: React.ReactNode;
  onDismiss?: () => void;
}) {
  // Create the overlay div.
  const container = useMemo(() => {
    const div = document.createElement("div");
    document.body.appendChild(div);
    return div;
  }, []);

  useMemo(() => {
    container.style.visibility = props.open ? "visible" : "hidden";
  }, [container.style, props.open]);

  // Cleanup
  useLayoutEffect(() => {
    return () => {
      document.body.removeChild(container);
    };
  }, [container]);

  // Render the popup
  useLayoutEffect(() => {
    if (!props.anchor) return;
    if (!props.open) return;

    const popupDiv = (
      props.onDismiss ? container.children[1] : container.children[0]
    ) as HTMLElement;

    const popper = createPopper(props.anchor, popupDiv, {
      placement: props.placement || "bottom-start",
      modifiers: [
        {
          name: "offset",
          options: {
            offset: [0, 8],
          },
        },
      ],
    });
    return () => {
      popper.destroy();
    };
  }, [
    container.children,
    props.onDismiss,
    props.placement,
    props.anchor,
    props.open,
  ]);

  const { onDismiss } = props;

  useShortcut("escape", () => onDismiss?.());

  // Render the portal
  if (!props.open) return false;
  else
    return createPortal(
      <>
        {onDismiss && (
          <div
            style={{ position: "fixed", top: 0, left: 0, right: 0, bottom: 0 }}
            onClick={() => onDismiss()}
          />
        )}
        {props.children}
      </>,
      container,
    );
}

export const PopupFrame = passthroughRef(
  (props: React.HTMLProps<HTMLDivElement>) => {
    return (
      <div
        {...props}
        className="popup"
        style={{
          background: "var(--popup-background)",
          boxShadow: "var(--shadow)",
          padding: 4,
          borderRadius: 4,
          ...props.style,
        }}
      />
    );
  },
);
```

#### apps/web/src/components/ui/Spinner.tsx

```tsx
/** Consider using <Loading/> instead. */
export function Spinner(props: { size?: string }) {
  return (
    <span
      style={{ height: props.size, width: props.size }}
      className="spinner"
    ></span>
  );
}
```

#### apps/web/src/components/ui/Throttle.tsx

```tsx
import React, { useEffect, useRef, useState } from "react";

// TODO: I don't think this thing works very well.

/**
 * Don't show the spinner unless we have a very slow request.
 * If we show the spinner, hold it for a moment.
 * Hold previous children while we wait for the spinner.
 */
export function Throttle(props: {
  showSpinner: boolean;
  showDelay?: number;
  showHold?: number;
  spinner: React.ReactNode;
  children: React.ReactNode;
}) {
  const showDelay = typeof props.showDelay === "number" ? props.showDelay : 300;
  const showHold = typeof props.showHold === "number" ? props.showHold : 300;

  const [showSpinner, setShowSpinner] = useState(false);

  useEffect(() => {
    let canceled = false;

    if (props.showSpinner && !showSpinner) {
      setTimeout(() => {
        if (canceled) return;
        setShowSpinner(true);
      }, showDelay);
    }

    if (!props.showSpinner && showSpinner) {
      setTimeout(() => {
        if (canceled) return;
        setShowSpinner(false);
      }, showHold);
    }

    return () => {
      canceled = true;
    };
  }, [showDelay, showHold, showSpinner, props.showSpinner]);

  const prevChildrenRef = useRef(props.children);
  const prevChildren = prevChildrenRef.current;
  prevChildrenRef.current = props.children;

  // If we're blocking the spinner, show previous children.
  if (props.showSpinner && !showSpinner) return prevChildren;
  if (showSpinner) return props.spinner;
  return props.children;
}
```

#### apps/web/src/components/ui/demos/BadgeDemo.tsx

```tsx
import { Badge } from "../Badge";

export function BadgeDemo() {
  return (
    <div style={{ display: "flex", gap: 4, padding: 12 }}>
      <Badge>Hello</Badge>
      <Badge style={{ background: "LightCoral", color: "white" }}>World</Badge>
      <Badge style={{ background: "PowderBlue" }}>Yay!</Badge>
    </div>
  );
}
```

#### apps/web/src/components/ui/demos/ButtonDemo.tsx

```tsx
import { Button } from "../Button";

export function ButtonDemo() {
  return (
    <div>
      <div style={{ marginBottom: 8 }}>
        <Button>Default Button</Button>
      </div>
      <div style={{ marginBottom: 8 }}>
        <Button variant="primary">Primary Button</Button>
      </div>
      <div style={{ marginBottom: 8 }}>
        <Button variant="text">Naked Button</Button>
      </div>
    </div>
  );
}
```

#### apps/web/src/components/ui/demos/CalendarDemo.tsx

```tsx
import { useMemo, useState } from "react";

// TODO: this is very much a work in progress!
export function CalendarDemo() {
  const initialDatetime = useMemo(() => {
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    tomorrow.setHours(9, 0, 0, 0);

    const tzOffset = tomorrow.getTimezoneOffset() * 60000;
    const localISOTime = new Date(tomorrow.getTime() - tzOffset);
    return localISOTime.toISOString().slice(0, "YYYY-MM-DDTHH:MM".length);
  }, []);

  const [datetime, setDatetime] = useState(initialDatetime);

  return (
    <div>
      <input
        type="datetime-local"
        value={datetime}
        onChange={(event) => setDatetime(event.target.value)}
      />
    </div>
  );
}
```

#### apps/web/src/components/ui/demos/ComboBoxDemo.tsx

```tsx
import { useState } from "react";

import { ComboBox } from "../ComboBox";

const items = [
  "Apple",
  "Banana",
  "Cherry",
  "Date",
  "Elderberry",
  "Fig",
  "Grape",
  "Honeydew",
  "Kiwi",
  "Lemon",
  "Mango",
  "Orange",
  "Papaya",
  "Quince",
  "Raspberry",
  "Strawberry",
  "Tangerine",
  "Ugli fruit",
  "Watermelon",
];

export function ComboBoxDemo() {
  const [value, setValue] = useState<string>();

  return (
    <div>
      <div style={{ marginBottom: 8 }}>
        <ComboBox
          items={items}
          renderItem={(item) => item}
          onSelect={setValue}
          value={value}
          placeholder="Select a fruit..."
        />
      </div>
      <div>Selected value: {value || "None"}</div>
    </div>
  );
}
```

#### apps/web/src/components/ui/demos/DropdownDemo.tsx

```tsx
import React, { useState } from "react";

import { Button } from "../Button";
import { DropdownMenu } from "../DropdownMenu";

export function DropdownDemo() {
  const [open, setOpen] = useState(false);
  const buttonRef = React.useRef<HTMLButtonElement>(null);

  return (
    <div>
      <Button ref={buttonRef} onClick={() => setOpen(true)}>
        Open Dropdown
      </Button>
      {open && (
        <DropdownMenu
          onClose={() => setOpen(false)}
          items={[
            { label: "Item 1", onClick: () => console.log("Item 1") },
            { label: "Item 2", onClick: () => console.log("Item 2") },
            { label: "Item 3", onClick: () => console.log("Item 3") },
          ]}
        />
      )}
    </div>
  );
}
```

#### apps/web/src/components/ui/demos/FileUploadDemo.tsx

```tsx
import { sleep } from "../../../../server/infrastructure/lifecycle/sleep";
import {
  FileUploadDropZone,
  UploadPreview,
  useFileUpload,
} from "../FileUpload";

export function FileUploadDemo() {
  const { uploads, handleDrop } = useFileUpload(async (_upload, onProgress) => {
    for (let i = 0; i < 100; i += Math.round(Math.random() * 10)) {
      await sleep(100);
      onProgress(i);
    }
  });

  return (
    <FileUploadDropZone
      onDrop={(files) => void handleDrop(files)}
      style={{ display: "inline-flex", flexWrap: "wrap", gap: 12, padding: 12 }}
    >
      {uploads.length === 0 && "Drop files here!"}
      {uploads.map((upload) => (
        <UploadPreview key={upload.id} {...upload} />
      ))}
    </FileUploadDropZone>
  );
}
```

#### apps/web/src/components/ui/demos/FormDemo.tsx

```tsx
import React, { useState } from "react";

import { ComboBox } from "../ComboBox";
import { Input } from "../Input";

const colors = ["Red", "Orange", "Yellow", "Green", "Blue", "Indigo", "Violet"];

// TODO: this is very much a work in progress!
export function FormDemo() {
  const [name, setName] = useState("");
  const [email, setEmail] = useState("");
  const [color, setColor] = useState<string>();

  return (
    <div>
      <div style={{ marginBottom: 8 }}>
        <label>
          Name:
          <Input
            value={name}
            onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
              setName(e.target.value)
            }
            placeholder="Enter your name"
          />
        </label>
      </div>
      <div style={{ marginBottom: 8 }}>
        <label>
          Email:
          <Input
            type="email"
            value={email}
            onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
              setEmail(e.target.value)
            }
            placeholder="Enter your email"
          />
        </label>
      </div>
      <div style={{ marginBottom: 8 }}>
        <label>
          Favorite Color:
          <ComboBox
            items={colors}
            renderItem={(item) => item}
            onSelect={setColor}
            value={color}
            placeholder="Select a color..."
          />
        </label>
      </div>
      <div>
        <div>Name: {name || "Not set"}</div>
        <div>Email: {email || "Not set"}</div>
        <div>Favorite Color: {color || "Not set"}</div>
      </div>
    </div>
  );
}
```

#### apps/web/src/components/ui/demos/FuzzyStringDemo.tsx

```tsx
import { useState } from "react";
import { FuzzyString } from "../FuzzyString";
import { Input } from "../Input";
import { fuzzyMatch } from "@/server/shared/utils";

const sampleTexts = [
  "hello world",
  "The quick brown fox jumps over the lazy dog",
  "Lorem ipsum dolor sit amet",
  "React is awesome",
  "TypeScript makes JavaScript better",
];

export function FuzzyStringDemo() {
  const [value, setValue] = useState("");

  return (
    <div>
      <div style={{ marginBottom: 8 }}>
        <Input
          value={value}
          onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
            setValue(e.target.value)
          }
          placeholder="Type to search..."
        />
      </div>
      <div style={{ display: "flex", flexDirection: "column", gap: "0.5rem" }}>
        {sampleTexts.map((text, i) => {
          const match = fuzzyMatch(value, text);
          return (
            <div key={i}>
              <FuzzyString match={match || undefined} text={text} />
            </div>
          );
        })}
      </div>
    </div>
  );
}
```

#### apps/web/src/components/ui/demos/ListBoxDemo.tsx

```tsx
import { useState } from "react";

import { ListBox, ListItem } from "../ListBox";

const items = ["Item 1", "Item 2", "Item 3", "Item 4", "Item 5"];

export function ListBoxDemo() {
  const [selectedIndex, setSelectedIndex] = useState(0);

  return (
    <div>
      <ListBox
        items={items}
        selectedIndex={selectedIndex}
        onSelectIndex={setSelectedIndex}
        autoFocus
      >
        {(item, props) => <ListItem {...props}>{item}</ListItem>}
      </ListBox>
      <div style={{ marginTop: 8 }}>Selected: {items[selectedIndex]}</div>
    </div>
  );
}
```

#### apps/web/src/components/ui/demos/PopupDemo.tsx

```tsx
import React, { useState } from "react";

import { Button } from "../Button";
import { Popup } from "../Popup";

export function PopupDemo() {
  const [open, setOpen] = useState(false);
  const buttonRef = React.useRef<HTMLButtonElement>(null);

  return (
    <div>
      <Button ref={buttonRef} onClick={() => setOpen(true)}>
        Open Popup
      </Button>
      <Popup
        open={open}
        anchor={buttonRef.current}
        onDismiss={() => setOpen(false)}
      >
        <div
          style={{
            padding: "1rem",
            backgroundColor: "white",
            borderRadius: "0.25rem",
            boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)",
          }}
        >
          This is a popup!
        </div>
      </Popup>
    </div>
  );
}
```

#### apps/web/src/components/ui/demos/SpinnerDemo.tsx

```tsx
import { Spinner } from "../Spinner";

// TODO: Throttle component
export function SpinnerDemo() {
  return (
    <div style={{ display: "flex", gap: 4, padding: 12 }}>
      <Spinner />
    </div>
  );
}
```

#### apps/web/src/components/ui/demos/TokenInputDemo.tsx

```tsx
export function TokenInputDemo() {
  return <div>Work in progress</div>;
}

// function TokenInput<T, V>(props: {
// 	tokens: T[]
// 	children: [
// 		(token: T, props: { selected: boolean }) => void,
// 		(value: V, props: { selected: boolean }) => void
// 	]

// 	text: string
// 	setText: (text: string) => void

// 	result:
// 		| { loading: true }
// 		| { loading: false; error: string }
// 		| { loading: false; error?: undefined; result: V[] }
// }) {
// 	return (
// 		<div>
// 			<ListBox items={[...props.tokens, "INPUT"]} selectedIndex={props.tokens.length} ></ListBox>

// 			{props.tokens.map((token) => props.children[0](token))}
// 			<span>
// 				<Input
// 					ref={inputRef}
// 					type="text"
// 					value={text}
// 					onChange={(e) => setText(e.target.value)}
// 					onFocus={() => setFocused(true)}
// 					onBlur={() => setFocused(false)}
// 				/>
// 				<Popup open={focused && text.length > 0} anchor={inputRef.current}>
// 					{error ? (
// 						<span style={{ color: "var(--red)" }}>{error}</span>
// 					) : !userIds ? (
// 						<Spinner />
// 					) : userIds.length === 0 ? (
// 						"No results..."
// 					) : (
// 						<ListBox items={userIds}>
// 							{(userId, { focused, selected }) => (
// 								<ListItem focused={focused} selected={selected}>
// 									<Username userId={userId} key={userId} />
// 								</ListItem>
// 							)}
// 						</ListBox>
// 					)}
// 				</Popup>
// 			</span>
// 		</div>
// 	)
// }
```

#### apps/web/src/components/ui/demos/autoindex.ts

```ts
/* WARNING: this file is generated! */

import * as BadgeDemo from "./BadgeDemo";
import * as ButtonDemo from "./ButtonDemo";
import * as CalendarDemo from "./CalendarDemo";
import * as ComboBoxDemo from "./ComboBoxDemo";
import * as DropdownDemo from "./DropdownDemo";
import * as FileUploadDemo from "./FileUploadDemo";
import * as FormDemo from "./FormDemo";
import * as FuzzyStringDemo from "./FuzzyStringDemo";
import * as ListBoxDemo from "./ListBoxDemo";
import * as PopupDemo from "./PopupDemo";
import * as SpinnerDemo from "./SpinnerDemo";
import * as TokenInputDemo from "./TokenInputDemo";

export {
  BadgeDemo,
  ButtonDemo,
  CalendarDemo,
  ComboBoxDemo,
  DropdownDemo,
  FileUploadDemo,
  FormDemo,
  FuzzyStringDemo,
  ListBoxDemo,
  PopupDemo,
  SpinnerDemo,
  TokenInputDemo,
};
```

#### apps/web/src/config/environment.ts

```ts
// src/client/config/environment.ts
// Client-side environment configuration

interface ImportMetaEnv {
  [key: string]: string | undefined;
}

declare global {
  interface ImportMeta {
    env: ImportMetaEnv;
  }
}

type NodeEnv = "development" | "production";

const env = import.meta.env;

const API_URL =
  env.VITE_API_URL ||
  (typeof window !== "undefined"
    ? `${window.location.protocol}//${window.location.host}/api`
    : "/api");

const WS_URL =
  env.VITE_WS_URL ||
  (typeof window !== "undefined"
    ? (window.location.protocol === "https:" ? "wss:" : "ws:") +
      "//" +
      window.location.host +
      "/ws"
    : "ws://localhost:8080/ws");

export interface ClientEnv {
  NODE_ENV: NodeEnv;
  API_URL: string;
  WS_URL: string;
  APP_TITLE: string;
}

export const clientEnv: ClientEnv = {
  NODE_ENV: (env.MODE as NodeEnv) || "development",
  API_URL,
  WS_URL,
  APP_TITLE: env.VITE_APP_TITLE || "ABE Stack Application",
};

// Freeze the config object to prevent modifications
Object.freeze(clientEnv);

export default clientEnv;
```

#### apps/web/src/contexts/AuthContext.tsx

```tsx
import React, { createContext, useContext, useEffect, useState } from "react";

interface User {
  id: string;
  username: string;
  email: string;
  displayName: string | null;
  profileImage: string | null;
}

interface AuthResponse {
  status: string;
  data: {
    user: User;
  };
}

interface ErrorResponse {
  status: string;
  message: string;
}

interface AuthContextType {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  login: (email: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
  checkAuth: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | null>(null);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  const checkAuth = async () => {
    try {
      const response = await fetch("/api/auth/me", {
        credentials: "include",
      });

      if (response.ok) {
        const data = (await response.json()) as AuthResponse;
        setUser(data.data.user);
      } else {
        setUser(null);
      }
    } catch {
      setUser(null);
    } finally {
      setIsLoading(false);
    }
  };

  const login = async (email: string, password: string) => {
    setIsLoading(true);
    try {
      const response = await fetch("/api/auth/login", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        credentials: "include",
        body: JSON.stringify({ email, password }),
      });

      if (!response.ok) {
        const errorData = (await response.json()) as ErrorResponse;
        throw new Error(errorData.message || "Login failed");
      }

      const data = (await response.json()) as AuthResponse;
      setUser(data.data.user);
    } finally {
      setIsLoading(false);
    }
  };

  const logout = async () => {
    try {
      await fetch("/api/auth/logout", {
        method: "POST",
        credentials: "include",
      });
      setUser(null);
    } catch (error) {
      console.error("Logout failed:", error);
    }
  };

  useEffect(() => {
    void checkAuth();
  }, []);

  return (
    <AuthContext.Provider
      value={{
        user,
        isAuthenticated: !!user,
        isLoading,
        login,
        logout,
        checkAuth,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
};
```

#### apps/web/src/contexts/SocialContext.tsx

```tsx
import React, {
  createContext,
  useCallback,
  useContext,
  useEffect,
  useState,
} from "react";

import { socialService } from "../services/social";

export interface User {
  id: string;
  username: string;
  displayName: string;
  avatar: string;
  bio: string;
  followersCount: number;
  followingCount: number;
  postsCount: number;
  isFollowing: boolean;
}

interface Post {
  id: string;
  userId: string;
  username: string;
  userAvatar: string;
  content: string;
  media?: {
    type: "image" | "video" | "audio";
    url: string;
    thumbnail?: string;
  };
  likesCount: number;
  commentsCount: number;
  sharesCount: number;
  isLiked: boolean;
  createdAt: string;
}

interface SocialContextType {
  currentUser: User | null;
  feed: Post[];
  isLoading: boolean;
  error: string | null;
  followUser: (userId: string) => Promise<void>;
  unfollowUser: (userId: string) => Promise<void>;
  likePost: (postId: string) => Promise<void>;
  unlikePost: (postId: string) => Promise<void>;
  sharePost: (postId: string) => Promise<void>;
  createPost: (content: string, media?: File) => Promise<void>;
  refreshFeed: () => Promise<void>;
}

const SocialContext = createContext<SocialContextType | null>(null);

export const useSocial = () => {
  const context = useContext(SocialContext);
  if (!context) {
    throw new Error("useSocial must be used within a SocialProvider");
  }
  return context;
};

interface SocialProviderProps {
  children: React.ReactNode;
}

export const SocialProvider: React.FC<SocialProviderProps> = ({ children }) => {
  const [currentUser, setCurrentUser] = useState<User | null>(null);
  const [feed, setFeed] = useState<Post[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const refreshFeed = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);
      const response = await socialService.getFeed("home");
      setFeed(response.posts);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to refresh feed");
    } finally {
      setIsLoading(false);
    }
  }, []);

  const initializeSocial = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);
      const user = await socialService.getUserProfile("current");
      setCurrentUser(user);
      await refreshFeed();
    } catch (err) {
      setError(
        err instanceof Error ? err.message : "Failed to initialize social",
      );
    } finally {
      setIsLoading(false);
    }
  }, [refreshFeed]);

  useEffect(() => {
    void initializeSocial();
  }, [initializeSocial]);

  const followUser = async (userId: string) => {
    try {
      setError(null);
      await socialService.followUser(userId);
      if (currentUser) {
        setCurrentUser({
          ...currentUser,
          followingCount: currentUser.followingCount + 1,
        });
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to follow user");
      throw err;
    }
  };

  const unfollowUser = async (userId: string) => {
    try {
      setError(null);
      await socialService.unfollowUser(userId);
      if (currentUser) {
        setCurrentUser({
          ...currentUser,
          followingCount: currentUser.followingCount - 1,
        });
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to unfollow user");
      throw err;
    }
  };

  const likePost = async (postId: string) => {
    try {
      setError(null);
      await socialService.likePost(postId);
      setFeed((prev) =>
        prev.map((post) =>
          post.id === postId
            ? { ...post, isLiked: true, likesCount: post.likesCount + 1 }
            : post,
        ),
      );
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to like post");
      throw err;
    }
  };

  const unlikePost = async (postId: string) => {
    try {
      setError(null);
      await socialService.unlikePost(postId);
      setFeed((prev) =>
        prev.map((post) =>
          post.id === postId
            ? { ...post, isLiked: false, likesCount: post.likesCount - 1 }
            : post,
        ),
      );
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to unlike post");
      throw err;
    }
  };

  const sharePost = async (postId: string) => {
    try {
      setError(null);
      await socialService.sharePost(postId);
      setFeed((prev) =>
        prev.map((post) =>
          post.id === postId
            ? { ...post, sharesCount: post.sharesCount + 1 }
            : post,
        ),
      );
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to share post");
      throw err;
    }
  };

  const createPost = async (content: string, media?: File) => {
    try {
      setError(null);
      const newPost = await socialService.createPost(content, media);
      setFeed((prev) => [newPost, ...prev]);
      if (currentUser) {
        setCurrentUser({
          ...currentUser,
          postsCount: currentUser.postsCount + 1,
        });
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to create post");
      throw err;
    }
  };

  const value = {
    currentUser,
    feed,
    isLoading,
    error,
    followUser,
    unfollowUser,
    likePost,
    unlikePost,
    sharePost,
    createPost,
    refreshFeed,
  };

  return (
    <SocialContext.Provider value={value}>{children}</SocialContext.Provider>
  );
};
```

#### apps/web/src/helpers/cookieHelpers.ts

```ts
import groupBy from "lodash/groupBy";
import mapValues from "lodash/mapValues";

export function parseCookies(cookie: string) {
  const entries = cookie
    .split(";")
    .map((line) => line.split("=").map((p) => p.trim()));
  const grouped = groupBy(entries, (entry) => entry[0]);
  const cookies = mapValues(grouped, (entries) =>
    entries.map((entry) => entry[1]),
  );
  return cookies;
}

export function deleteCookie(cookieName: string): void {
  const domain: string = window.location.hostname;
  const path: string = "/";
  document.cookie = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 GMT; domain=${domain}; path=${path}`;
}

export function getCurrentUserId() {
  const cookies = parseCookies(document.cookie);
  const userId = cookies.userId?.[0];
  return userId;
}

export function deleteLoginCookie() {
  deleteCookie("userId");
}
```

#### apps/web/src/helpers/focusHelpers.ts

```ts
function nextElement(element: Element): Element | undefined {
  // Start by looking for the first child.
  if (element.firstElementChild) {
    return element.firstElementChild;
  }

  return nextNonChildElement(element);
}

function nextNonChildElement(element: Element): Element | undefined {
  // If no children, look for next sibling.
  let currentElement: Element | undefined = element;
  while (currentElement) {
    if (currentElement.nextElementSibling) {
      return currentElement.nextElementSibling;
    }

    // If no next sibling, move up to the parent and look for its next sibling.
    currentElement = currentElement.parentElement || undefined;
  }
}

/** Does not yield container or start elements. */
export function* iterateNextElement(args: {
  container: Element;
  start: Element;
  wrap: boolean;
}) {
  const { container, start, wrap } = args;

  let cursor: Element | undefined = start;
  while ((cursor = nextElement(cursor))) {
    // Break if we escape the container.
    if (cursor === container || !container.contains(cursor)) break;
    yield cursor;
  }

  if (wrap) {
    // Start over from the beginning
    if (start === container) return;
    cursor = container;
    while ((cursor = nextElement(cursor))) {
      if (cursor === start) break;
      yield cursor;
    }
  }
}

function prevElement(element: Element): Element | undefined {
  // If element has a previous sibling, find its last descendant.
  const prevSibling = element.previousElementSibling;
  if (prevSibling) {
    return lastChildElement(prevSibling) || prevSibling;
  }

  // If no previous sibling, return the parent.
  return element.parentElement || undefined;
}

function lastChildElement(element: Element): Element | undefined {
  let lastChild = element.lastElementChild || undefined;
  if (!lastChild) return;
  while (lastChild.lastElementChild) {
    lastChild = lastChild.lastElementChild || undefined;
  }
  return lastChild;
}

/** Does not yield container or start elements. */
export function* iteratePrevElement(args: {
  container: Element;
  start: Element;
  wrap: boolean;
}) {
  const { container, start, wrap } = args;

  let cursor: Element | undefined = start;
  while ((cursor = prevElement(cursor))) {
    // Break if we escape the container.
    if (cursor === container || !container.contains(cursor)) break;
    yield cursor;
  }

  if (wrap || start === container) {
    // Start over from the end

    const last = lastChildElement(container);
    if (!last) return;
    if (last === start) return;
    yield last;

    cursor = last;
    while ((cursor = prevElement(cursor))) {
      if (cursor === start) break;
      yield cursor;
    }
  }
}

function getContainerFocus(container: Element) {
  if (!document.activeElement) return container;
  if (container.contains(document.activeElement)) return document.activeElement;
  return container;
}

export function nextFocusable(container: Element) {
  const start = getContainerFocus(container);
  for (const element of iterateNextElement({ container, start, wrap: false })) {
    if (isFocusable(element)) return element as HTMLElement;
  }
}

export function prevFocusable(container: Element) {
  const start = getContainerFocus(container);
  for (const element of iteratePrevElement({ container, start, wrap: false })) {
    if (isFocusable(element)) return element as HTMLElement;
  }
}

export function isFocusable(element: Element) {
  if (element.hasAttribute("tabindex")) return true;
  const tagName = element.tagName.toLowerCase();
  if (tagName === "input") return true;
  if (tagName === "button") return true;
}

/*


How to properly manage browser focus and keyboard events.

- set tabindex=0 if you want something to be focusable AND tabbable.
- set tabindex=-1 if you want something to be focusable and NOT tabbable, e.g. arrowing around a list box.
- element.focus() is slow and triggers a reflow!
	- hover and focus must be different, otherwise you'll kill your performance.
- listen to keyboard events on the element. leverage browser focus for events to bubble up so you don't have conflicting shortcuts.

*/
```

#### apps/web/src/helpers/formatters.ts

```ts
/**
 * Format duration in seconds to MM:SS format
 */
export function formatDuration(seconds: number): string {
  if (isNaN(seconds) || !isFinite(seconds)) {
    return "00:00";
  }

  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);

  return `${mins.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")}`;
}

/**
 * Format file size to human-readable format
 */
export function formatFileSize(bytes: number): string {
  if (bytes === 0) return "0 Bytes";

  const k = 1024;
  const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
  const i = Math.floor(Math.log(bytes) / Math.log(k));

  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
}

/**
 * Format a date to a human-readable format
 */
export function formatDate(date: Date | string): string {
  const d = new Date(date);
  return d.toLocaleDateString(undefined, {
    year: "numeric",
    month: "long",
    day: "numeric",
  });
}

/**
 * Format a relative time (e.g., "2 days ago")
 */
export function formatRelativeTime(date: Date | string): string {
  const now = new Date();
  const then = new Date(date);
  const diffMs = now.getTime() - then.getTime();
  const diffSecs = Math.floor(diffMs / 1000);
  const diffMins = Math.floor(diffSecs / 60);
  const diffHours = Math.floor(diffMins / 60);
  const diffDays = Math.floor(diffHours / 24);
  const diffWeeks = Math.floor(diffDays / 7);
  const diffMonths = Math.floor(diffDays / 30);
  const diffYears = Math.floor(diffDays / 365);

  if (diffSecs < 60) {
    return "just now";
  } else if (diffMins < 60) {
    return `${diffMins} minute${diffMins === 1 ? "" : "s"} ago`;
  } else if (diffHours < 24) {
    return `${diffHours} hour${diffHours === 1 ? "" : "s"} ago`;
  } else if (diffDays < 7) {
    return `${diffDays} day${diffDays === 1 ? "" : "s"} ago`;
  } else if (diffWeeks < 4) {
    return `${diffWeeks} week${diffWeeks === 1 ? "" : "s"} ago`;
  } else if (diffMonths < 12) {
    return `${diffMonths} month${diffMonths === 1 ? "" : "s"} ago`;
  } else {
    return `${diffYears} year${diffYears === 1 ? "" : "s"} ago`;
  }
}

/**
 * Format a number with commas (e.g., 1,234,567)
 */
export function formatNumber(num: number): string {
  return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}
```

#### apps/web/src/helpers/mergeEvents.ts

```ts
export function mergeEvents<T extends Event | React.UIEvent>(
  ...args: ((event: T) => boolean | undefined | void)[]
) {
  return (event: T) => {
    for (const fn of args) {
      if (fn(event) === false) break;
    }
  };
}
```

#### apps/web/src/helpers/passthroughRef.tsx

```tsx
import { ComponentType, forwardRef, PropsWithoutRef } from "react";

export function passthroughRef<P extends object, T = unknown>(
  Component: ComponentType<P>,
) {
  const ForwardedComponent = forwardRef<T, PropsWithoutRef<P>>((props, ref) => {
    return <Component {...(props as P)} ref={ref} />;
  });
  ForwardedComponent.displayName = `ForwardedRef(${Component.displayName || Component.name || "Component"})`;
  return ForwardedComponent;
}
```

#### apps/web/src/hooks/useAsync.ts

```ts
import isEqual from "lodash/isEqual";
import { useEffect, useRef, useState } from "react";

import { useRefCurrent } from "./useRefCurrent";
import { useRefPrevious } from "./useRefPrevious";

export function useAsync<T, Args extends unknown[]>(
  fn: (...args: Args) => Promise<T>,
  args: Args,
) {
  const [state, setState] = useState<T | undefined>(undefined);

  const currentFn = useRefCurrent(fn);

  const changeCount = useRef(0);
  const prevArgs = useRefPrevious(args);
  const same = isEqual(prevArgs.current, args);
  if (!same) changeCount.current += 1;

  useEffect(() => {
    const currentCount = changeCount.current;
    void currentFn.current(...args).then((result) => {
      if (changeCount.current === currentCount) {
        setState(result);
      }
    });
    return;
  }, [args, currentFn]);

  return state;
}
```

#### apps/web/src/hooks/useCounter.ts

```ts
import { useState } from "react";

// This is useful for forcing a re-render.
export function useCounter() {
  const [count, setCount] = useState(0);
  const inc = () => setCount((s) => s + 1);
  return [count, inc] as const;
}
```

#### apps/web/src/hooks/useOnline.ts

```ts
import { useEffect, useState } from "react";

// TODO: an improved online/offline detector would ping the server to see if its online.
// When the browser is online, but the server is down, this still says online.
// You can also monitor api requests or the websocket connection as well.
export function useOnline() {
  const [state, setState] = useState(navigator.onLine);
  useEffect(() => {
    const setOnline = () => setState(true);
    const setOffline = () => setState(false);
    window.addEventListener("online", setOnline);
    window.addEventListener("offline", setOffline);
    return () => {
      window.removeEventListener("online", setOnline);
      window.removeEventListener("offline", setOffline);
    };
  }, []);
  return state;
}
```

#### apps/web/src/hooks/usePopper.ts

```ts
import { useEffect, useRef } from "react";

// Define types similar to what popper.js provides
export type Placement =
  | "top"
  | "bottom"
  | "right"
  | "left"
  | "top-start"
  | "top-end"
  | "bottom-start"
  | "bottom-end"
  | "right-start"
  | "right-end"
  | "left-start"
  | "left-end";

export interface Options {
  placement?: Placement;
  modifiers?: Array<{ name: string; options?: Record<string, unknown> }>;
  strategy?: "absolute" | "fixed";
}

export interface Instance {
  destroy: () => void;
  update: () => Promise<{ placement: Placement }>;
  state: { placement: Placement };
}

// Simple positioning function to replace popper.js
function createSimplePopper(
  referenceElement: HTMLElement,
  popperElement: HTMLElement,
  options: Options = {},
): Instance {
  const placement = options.placement || "bottom";
  const strategy = options.strategy || "absolute";

  function update() {
    if (!referenceElement || !popperElement) {
      return Promise.resolve({ placement });
    }

    const refRect = referenceElement.getBoundingClientRect();

    popperElement.style.position = strategy;

    // Basic positioning based on placement
    switch (placement) {
      case "top":
        popperElement.style.bottom = `${window.innerHeight - refRect.top}px`;
        popperElement.style.left = `${refRect.left + refRect.width / 2 - popperElement.offsetWidth / 2}px`;
        break;
      case "bottom":
        popperElement.style.top = `${refRect.bottom}px`;
        popperElement.style.left = `${refRect.left + refRect.width / 2 - popperElement.offsetWidth / 2}px`;
        break;
      case "left":
        popperElement.style.right = `${window.innerWidth - refRect.left}px`;
        popperElement.style.top = `${refRect.top + refRect.height / 2 - popperElement.offsetHeight / 2}px`;
        break;
      case "right":
        popperElement.style.left = `${refRect.right}px`;
        popperElement.style.top = `${refRect.top + refRect.height / 2 - popperElement.offsetHeight / 2}px`;
        break;
      case "bottom-start":
        popperElement.style.top = `${refRect.bottom}px`;
        popperElement.style.left = `${refRect.left}px`;
        break;
      case "bottom-end":
        popperElement.style.top = `${refRect.bottom}px`;
        popperElement.style.left = `${refRect.right - popperElement.offsetWidth}px`;
        break;
      // Add other placements as needed
      default:
        popperElement.style.top = `${refRect.bottom}px`;
        popperElement.style.left = `${refRect.left}px`;
    }

    return Promise.resolve({ placement });
  }

  // Initial positioning
  void update();

  // Return an instance similar to popper.js
  return {
    destroy: () => {},
    update,
    state: { placement },
  };
}

export function usePopper(
  referenceElement: HTMLElement | null,
  popperElement: HTMLElement | null,
  options: Options = {},
) {
  const popperInstanceRef = useRef<Instance | null>(null);

  useEffect(() => {
    if (referenceElement && popperElement) {
      // Create new popper instance
      popperInstanceRef.current = createSimplePopper(
        referenceElement,
        popperElement,
        options,
      );

      // Clean up on unmount
      return () => {
        if (popperInstanceRef.current) {
          popperInstanceRef.current.destroy();
          popperInstanceRef.current = null;
        }
      };
    }
    return undefined;
  }, [referenceElement, popperElement, options]);

  return { update: () => popperInstanceRef.current?.update() };
}

export { createSimplePopper as createPopper };
```

#### apps/web/src/hooks/useRefCurrent.ts

```ts
import { useRef } from "react";

export function useRefCurrent<T>(value: T) {
  const ref = useRef<T>(value);
  ref.current = value;
  return ref;
}
```

#### apps/web/src/hooks/useRefPrevious.ts

```ts
import { useEffect, useRef } from "react";

export function useRefPrevious<T>(value: T) {
  const ref = useRef<T>(value);
  useEffect(() => {
    ref.current = value;
  });
  return ref;
}
```

#### apps/web/src/hooks/useShortcut.ts

```ts
// Adapted from https://github.com/marijnh/w3c-keyname
// The shift keycode map was removed so we can use Shift as a modifier.
// For example: "Shift-]" instead of "}

import capitalize from "lodash/capitalize";
import { useEffect } from "react";

import { useRefCurrent } from "./useRefCurrent";

const base: { [key: number]: string } = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'",
};

const chrome =
  typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
const safari =
  typeof navigator != "undefined" && /Apple Computer/.test(navigator.vendor);
const gecko =
  typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
const mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
const ie =
  typeof navigator != "undefined" &&
  /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
const brokenModifierNames =
  (chrome && (mac || +chrome[1] < 57)) || (gecko && mac);

// Fill in the digit keys
for (let i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);

// The function keys
for (let i = 1; i <= 24; i++) base[i + 111] = "F" + i;

// And the alphabetic keys
for (let i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
}

function keyName(event: KeyboardEvent) {
  const ignoreKey =
    (brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey)) ||
    ((safari || ie) && event.shiftKey && event.key && event.key.length == 1);
  let name =
    (!ignoreKey && event.key) ||
    base[event.keyCode] ||
    event.key ||
    "Unidentified";
  // Edge sometimes produces wrong names (Issue #3)
  if (name == "Esc") name = "Escape";
  if (name == "Del") name = "Delete";
  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/
  if (name == "Left") name = "ArrowLeft";
  if (name == "Up") name = "ArrowUp";
  if (name == "Right") name = "ArrowRight";
  if (name == "Down") name = "ArrowDown";
  return name;
}

// Aliases for various keyboard events, allowing shortcuts to be defined
// using some more colloquial terms.
const keyboardAliases: Record<string, string | undefined> = {
  ctrl: "control",
  mod: "meta",
  cmd: "meta",
  " ": "space",
  left: "arrowleft",
  right: "arrowright",
  down: "arrowdown",
  up: "arrowup",
  option: "alt",
  opt: "alt",
  delete: "backspace",
};

// Used for view test keyboard event mocking
export function shortcutToEvent(shortcut: string) {
  const keys = shortcut
    .split(/-(?!$)/)
    .map((str) => str.toLowerCase())
    .map((char) => keyboardAliases[char] || char);

  const parsed: ParsedShortcut = {};
  for (const key of keys) {
    if (key === "meta") parsed.metaKey = true;
    else if (key === "control") parsed.ctrlKey = true;
    else if (key === "alt") parsed.altKey = true;
    else if (key === "shift") parsed.shiftKey = true;
    // Used to emulate the behavior that all non-alphabetic keys in keyboard events
    // are capitalized:
    // https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_key_values
    else
      parsed.key = key.length === 1 ? key : key[0].toUpperCase() + key.slice(1);
  }

  return new KeyboardEvent("keydown", parsed);
}

interface ParsedShortcut {
  shiftKey?: boolean;
  altKey?: boolean;
  ctrlKey?: boolean;
  metaKey?: boolean;
  key?: string;
}

function parseShortcut(shortcut: string) {
  const keys = shortcut
    .split(/-(?!$)/)
    .map((str) => str.toLowerCase())
    .map((char) => keyboardAliases[char] || char);

  const parsed: ParsedShortcut = {};
  for (const key of keys) {
    if (key === "meta") parsed.metaKey = true;
    else if (key === "control") parsed.ctrlKey = true;
    else if (key === "alt") parsed.altKey = true;
    else if (key === "shift") parsed.shiftKey = true;
    else parsed.key = key.toLowerCase();
  }
  return parsed;
}

function formatShortcutKeys(parsed: ParsedShortcut) {
  const keys: Array<string> = [];
  if (parsed.shiftKey) keys.push("shift");
  if (parsed.altKey) keys.push("alt");
  if (parsed.ctrlKey) keys.push("control");
  if (parsed.metaKey) keys.push("meta");
  if (parsed.key) keys.push(parsed.key);
  return keys;
}

function formatShortcut(parsed: ParsedShortcut) {
  return formatShortcutKeys(parsed).join("-");
}

function normalizeShortcut(shortcut: string) {
  return formatShortcut(parseShortcut(shortcut));
}

const modifierCodes = new Set([
  "ControlLeft",
  "ControlRight",
  "ShiftLeft",
  "ShiftRight",
  "AltLeft",
  "AltRight",
  "MetaLeft",
  "MetaRight",
]);

function parseKeyboardEvent(event: KeyboardEvent) {
  const parsed: ParsedShortcut = {};
  if (event.shiftKey) parsed.shiftKey = true;
  if (event.altKey) parsed.altKey = true;
  if (event.ctrlKey) parsed.ctrlKey = true;
  if (event.metaKey) parsed.metaKey = true;
  if (!modifierCodes.has(event.code)) parsed.key = keyName(event).toLowerCase();
  return parsed;
}

function normalizeKeyboardShortcut(event: KeyboardEvent) {
  return formatShortcut(parseKeyboardEvent(event));
}

export function isShortcut(shortcut: string, event: KeyboardEvent) {
  return normalizeShortcut(shortcut) === normalizeKeyboardShortcut(event);
}

const isMac = true as boolean; // process.platform === "darwin"

const shortKeys: Record<string, string> = {
  meta: isMac ? "⌘" : "^",
  control: "^",
  alt: "⌥",
  shift: "⇧",
  enter: "↵",
  tab: "⇥",
  arrowleft: "←",
  arrowright: "→",
  arrowup: "↑",
  arrowdown: "↓",
};

export function displayShortcut(shortcut: string) {
  const parsed = parseShortcut(shortcut);
  const keys = formatShortcutKeys(parsed);
  return keys
    .map((char) => shortKeys[char] || char)
    .map((char) => capitalize(char))
    .join("");
}

type KeyboardEventHandler = (event: KeyboardEvent) => void;

/** Use with care. Prefer to put listeners on DOM elements to work better with focus. */
export function useShortcut(shortcut: string, fn: () => void) {
  const fnRef = useRefCurrent(fn);
  const shortcutRef = useRefCurrent(shortcut);

  useEffect(() => {
    const onKeydown: KeyboardEventHandler = (event) => {
      if (isShortcut(shortcutRef.current, event)) {
        event.preventDefault();
        fnRef.current();
      }
    };
    window.addEventListener("keydown", onKeydown);
    return () => {
      window.removeEventListener("keydown", onKeydown);
    };
  }, [fnRef, shortcutRef]);
}
```

#### apps/web/src/hooks/useSocialInteractions.ts

```ts
import { useCallback, useState } from "react";

import { useSocial, type User } from "../contexts/SocialContext";
import { socialService } from "../services/social";

interface UseSocialInteractionsProps {
  onError?: (error: Error) => void;
}

export type { User };
export const useSocialInteractions = ({
  onError,
}: UseSocialInteractionsProps = {}) => {
  const { currentUser, refreshFeed } = useSocial();
  const [isLoading, setIsLoading] = useState(false);

  const handleError = useCallback(
    (error: Error) => {
      onError?.(error);
    },
    [onError],
  );

  const followUser = useCallback(
    async (userId: string) => {
      try {
        setIsLoading(true);
        await socialService.followUser(userId);
        await refreshFeed();
      } catch (error) {
        handleError(
          error instanceof Error ? error : new Error("Failed to follow user"),
        );
        throw error;
      } finally {
        setIsLoading(false);
      }
    },
    [refreshFeed, handleError],
  );

  const unfollowUser = useCallback(
    async (userId: string) => {
      try {
        setIsLoading(true);
        await socialService.unfollowUser(userId);
        await refreshFeed();
      } catch (error) {
        handleError(
          error instanceof Error ? error : new Error("Failed to unfollow user"),
        );
        throw error;
      } finally {
        setIsLoading(false);
      }
    },
    [refreshFeed, handleError],
  );

  const likePost = useCallback(
    async (postId: string) => {
      try {
        setIsLoading(true);
        await socialService.likePost(postId);
        await refreshFeed();
      } catch (error) {
        handleError(
          error instanceof Error ? error : new Error("Failed to like post"),
        );
        throw error;
      } finally {
        setIsLoading(false);
      }
    },
    [refreshFeed, handleError],
  );

  const unlikePost = useCallback(
    async (postId: string) => {
      try {
        setIsLoading(true);
        await socialService.unlikePost(postId);
        await refreshFeed();
      } catch (error) {
        handleError(
          error instanceof Error ? error : new Error("Failed to unlike post"),
        );
        throw error;
      } finally {
        setIsLoading(false);
      }
    },
    [refreshFeed, handleError],
  );

  const sharePost = useCallback(
    async (postId: string) => {
      try {
        setIsLoading(true);
        await socialService.sharePost(postId);
        await refreshFeed();
      } catch (error) {
        handleError(
          error instanceof Error ? error : new Error("Failed to share post"),
        );
        throw error;
      } finally {
        setIsLoading(false);
      }
    },
    [refreshFeed, handleError],
  );

  const createPost = useCallback(
    async (content: string, media?: File) => {
      try {
        setIsLoading(true);
        await socialService.createPost(content, media);
        await refreshFeed();
      } catch (error) {
        handleError(
          error instanceof Error ? error : new Error("Failed to create post"),
        );
        throw error;
      } finally {
        setIsLoading(false);
      }
    },
    [refreshFeed, handleError],
  );

  const createComment = useCallback(
    async (postId: string, content: string) => {
      try {
        setIsLoading(true);
        await socialService.createComment(postId, content);
        await refreshFeed();
      } catch (error) {
        handleError(
          error instanceof Error
            ? error
            : new Error("Failed to create comment"),
        );
        throw error;
      } finally {
        setIsLoading(false);
      }
    },
    [refreshFeed, handleError],
  );

  const likeComment = useCallback(
    async (commentId: string) => {
      try {
        setIsLoading(true);
        await socialService.likeComment(commentId);
        await refreshFeed();
      } catch (error) {
        handleError(
          error instanceof Error ? error : new Error("Failed to like comment"),
        );
        throw error;
      } finally {
        setIsLoading(false);
      }
    },
    [refreshFeed, handleError],
  );

  const unlikeComment = useCallback(
    async (commentId: string) => {
      try {
        setIsLoading(true);
        await socialService.unlikeComment(commentId);
        await refreshFeed();
      } catch (error) {
        handleError(
          error instanceof Error
            ? error
            : new Error("Failed to unlike comment"),
        );
        throw error;
      } finally {
        setIsLoading(false);
      }
    },
    [refreshFeed, handleError],
  );

  const replyToComment = useCallback(
    async (commentId: string, content: string) => {
      try {
        setIsLoading(true);
        await socialService.replyToComment(commentId, content);
        await refreshFeed();
      } catch (error) {
        handleError(
          error instanceof Error
            ? error
            : new Error("Failed to reply to comment"),
        );
        throw error;
      } finally {
        setIsLoading(false);
      }
    },
    [refreshFeed, handleError],
  );

  return {
    currentUser,
    isLoading,
    followUser,
    unfollowUser,
    likePost,
    unlikePost,
    sharePost,
    createPost,
    createComment,
    likeComment,
    unlikeComment,
    replyToComment,
  };
};
```

#### apps/web/src/index.tsx

```tsx
import React from "react";
import { createRoot } from "react-dom/client";

import { Root } from "./components/Root";
import "./index.css";
import { createApi } from "./services/api";
import { Router } from "./services/Router";
import { WebsocketPubsubClient } from "./services/WebsocketPubsubClient";

// Function to get the server port
const getServerPort = (): number => {
  // In production, use the same port as the client
  if (process.env.NODE_ENV === "production") {
    return window.location.port ? parseInt(window.location.port) : 80;
  }

  // In development, try to find the server port
  // First, check if we can read the port from localStorage (set by previous successful connections)
  const savedPort = localStorage.getItem("server_port");
  if (savedPort) {
    return parseInt(savedPort);
  }

  // Default to 8080 for the server in development
  return 8080;
};

// Create client configuration
const clientConfig = {
  // Always use relative path in development to leverage Vite's proxy
  apiUrl: "/api",
  wsUrl:
    process.env.NODE_ENV === "production"
      ? `ws://${window.location.host}/ws`
      : `ws://${window.location.hostname}:${getServerPort()}/ws`,
  production: process.env.NODE_ENV === "production",
  host: window.location.host,
};

// Add a function to test API connectivity and update port if needed
const testApiConnectivity = async () => {
  if (process.env.NODE_ENV === "production") {
    return; // No need to test in production
  }

  // Try to connect to the API
  try {
    const response = await fetch(clientConfig.apiUrl);
    if (response.ok) {
      const data = await response.json();
      console.log("✅ Connected to backend API successfully:", data);
      document.body.style.setProperty("--api-connected", "true");
      return;
    }
  } catch (_error) {
    console.warn("Failed to connect to API, trying alternative ports...");
  }

  // If connection failed, try alternative ports
  // Try server ports first (8080-8085), then try client ports (3000-3005) in case server is running there
  const alternativePorts = [
    8080, 8081, 8082, 8083, 8084, 8085, 3000, 3001, 3002, 3003, 3004, 3005,
  ];

  for (const port of alternativePorts) {
    try {
      const testUrl = `${window.location.protocol}//${window.location.hostname}:${port}/api`;
      const response = await fetch(testUrl);

      if (response.ok) {
        // Found a working port, update config and save it
        console.log(`Connected to API on port ${port}`);
        clientConfig.apiUrl = testUrl;
        clientConfig.wsUrl = `ws://${window.location.hostname}:${port}/ws`;
        localStorage.setItem("server_port", port.toString());
        break;
      }
    } catch (_error) {
      console.warn(`Failed to connect on port ${port}`);
    }
  }
};

// Initialize services
const router = new Router();
const api = createApi();
const pubsub = new WebsocketPubsubClient({
  config: clientConfig,
  onStart: () => {
    console.log("WebSocket connected");
  },
  onChange: (key, value) => {
    console.log("Data changed:", key, value);
  },
});

// Test API connectivity when the app starts
void testApiConnectivity().then(() => {
  console.log("API connectivity test completed");
});

// Create client environment
const environment = {
  config: clientConfig,
  router,
  api,
  pubsub,
};

// Make environment available globally for debugging
interface WindowWithEnvironment extends Window {
  router: typeof router;
  api: typeof api;
  pubsub: typeof pubsub;
  environment: typeof environment;
}

(window as unknown as WindowWithEnvironment).router = router;
(window as unknown as WindowWithEnvironment).api = api;
(window as unknown as WindowWithEnvironment).pubsub = pubsub;
(window as unknown as WindowWithEnvironment).environment = environment;

// Find root element
const rootElement = document.getElementById("root");
if (!rootElement) throw new Error("Failed to find the root element");

// Render the app
const root = createRoot(rootElement);
root.render(
  <React.StrictMode>
    <Root environment={environment} />
  </React.StrictMode>
);
```

#### apps/web/src/layouts/MainLayout.tsx

```tsx
import React, { useEffect, useState } from "react";

import { AuthModal, AuthModalType, useAuth } from "../components/auth";
import { useTheme } from "../components/theme";
import { Button } from "../components/ui/Button";
import { Link } from "../components/ui/Link";
import "./main-layout.css";

export default function MainLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const [showSidebar, setShowSidebar] = useState(true);
  const [showRightPanel, setShowRightPanel] = useState(false);
  const [showTopbar, setShowTopbar] = useState(true);
  const [showBottomBar, setShowBottomBar] = useState(true);
  const [isMobile, setIsMobile] = useState(false);
  const [authModal, setAuthModal] = useState<{
    show: boolean;
    type: AuthModalType;
  }>({
    show: false,
    type: "login",
  });

  const { isAuthenticated, user, logout } = useAuth();
  const { theme, toggleTheme, isUsingSystemTheme } = useTheme();

  // Check if viewport is mobile size
  useEffect(() => {
    const checkIfMobile = () => {
      setIsMobile(window.innerWidth <= 768);
      // Auto-hide sidebar on mobile
      if (window.innerWidth <= 768) {
        setShowSidebar(false);
      } else {
        setShowSidebar(true);
      }
    };

    // Initial check
    checkIfMobile();

    // Add event listener
    window.addEventListener("resize", checkIfMobile);

    // Cleanup
    return () => window.removeEventListener("resize", checkIfMobile);
  }, []);

  const openLoginModal = () => {
    setAuthModal({ show: true, type: "login" });
  };

  const openRegisterModal = () => {
    setAuthModal({ show: true, type: "register" });
  };

  const closeAuthModal = () => {
    setAuthModal({ show: false, type: authModal.type });
  };

  const handleLogout = () => {
    logout();
  };

  // Get the appropriate theme icon
  const getThemeIcon = () => {
    if (isUsingSystemTheme) {
      return "🖥️";
    } else {
      return theme === "light" ? "🌙" : "☀️";
    }
  };

  // Handle theme button click
  const handleThemeButtonClick = () => {
    if (!isUsingSystemTheme) {
      toggleTheme();
    }
  };

  // Toggle sidebar for mobile
  const toggleMobileSidebar = () => {
    setShowSidebar(!showSidebar);
  };

  return (
    <div className="main-layout">
      {showTopbar && (
        <div className="top-bar">
          {isMobile && (
            <button
              className="mobile-menu-toggle"
              onClick={toggleMobileSidebar}
              aria-label={showSidebar ? "Close menu" : "Open menu"}
            >
              <span></span>
              <span></span>
              <span></span>
            </button>
          )}
          <Link
            to="/"
            style={{
              textDecoration: "none",
              display: "flex",
              alignItems: "center",
            }}
          >
            <div className="logo">ABE Stack</div>
          </Link>
          <div className="top-bar-actions">
            <button
              className={`theme-toggle-btn ${isUsingSystemTheme ? "system-theme" : ""}`}
              onClick={handleThemeButtonClick}
              aria-label={
                isUsingSystemTheme
                  ? "Using system theme preference"
                  : `Switch to ${theme === "light" ? "dark" : "light"} mode`
              }
              title={
                isUsingSystemTheme
                  ? "Using system theme preference (change in settings)"
                  : `Switch to ${theme === "light" ? "dark" : "light"} mode`
              }
            >
              {getThemeIcon()}
            </button>
            {isAuthenticated ? (
              <div className="user-profile">
                <div
                  style={{
                    width: "32px",
                    height: "32px",
                    borderRadius: "50%",
                    backgroundColor: "var(--accent)",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    color: "white",
                    fontWeight: "bold",
                  }}
                >
                  {user?.displayName?.charAt(0) || "U"}
                </div>
                {!isMobile && (
                  <span className="username">
                    {user?.displayName || "User"}
                  </span>
                )}
                <Button onClick={handleLogout}>Logout</Button>
              </div>
            ) : (
              <>
                <Button onClick={openLoginModal}>Log In</Button>
                <Button onClick={openRegisterModal}>Register</Button>
              </>
            )}
          </div>
        </div>
      )}

      <div className="content-area">
        {showSidebar && (
          <div className={`left-panel ${isMobile ? "mobile" : ""}`}>
            <nav className="main-nav">
              {isMobile && (
                <div className="mobile-nav-header">
                  <button
                    className="close-mobile-nav"
                    onClick={() => setShowSidebar(false)}
                    aria-label="Close menu"
                  >
                    &times;
                  </button>
                </div>
              )}
              <Link
                to="/"
                onClick={isMobile ? () => setShowSidebar(false) : undefined}
              >
                Home
              </Link>
              <Link
                to="/dashboard"
                onClick={isMobile ? () => setShowSidebar(false) : undefined}
              >
                Dashboard
              </Link>
              <Link
                to="/profile"
                onClick={isMobile ? () => setShowSidebar(false) : undefined}
              >
                Profile
              </Link>
              <Link
                to="/upload"
                onClick={isMobile ? () => setShowSidebar(false) : undefined}
              >
                Upload
              </Link>
              <Link
                to="/explore"
                onClick={isMobile ? () => setShowSidebar(false) : undefined}
              >
                Explore
              </Link>
              <Link
                to="/notifications"
                onClick={isMobile ? () => setShowSidebar(false) : undefined}
              >
                Notifications
              </Link>
              <Link
                to="/media"
                onClick={isMobile ? () => setShowSidebar(false) : undefined}
              >
                Media
              </Link>
              <Link
                to="/settings"
                onClick={isMobile ? () => setShowSidebar(false) : undefined}
              >
                Settings
              </Link>
            </nav>
          </div>
        )}

        <div className="main-content">{children}</div>

        {showRightPanel && (
          <div className="right-panel">
            <h3>Additional Info</h3>
            <p>
              This panel can contain contextual information, notifications, or
              other supplementary content.
            </p>
          </div>
        )}
      </div>

      {showBottomBar && (
        <div className="bottom-bar">
          <div>© 2023 ABE Stack</div>
          {!isMobile && (
            <div className="layout-controls">
              <button onClick={() => setShowSidebar(!showSidebar)}>
                {showSidebar ? "Hide" : "Show"} Left Panel
              </button>
              <button onClick={() => setShowRightPanel(!showRightPanel)}>
                {showRightPanel ? "Hide" : "Show"} Right Panel
              </button>
              <button onClick={() => setShowTopbar(!showTopbar)}>
                {showTopbar ? "Hide" : "Show"} Top Bar
              </button>
              <button onClick={() => setShowBottomBar(!showBottomBar)}>
                Hide Bottom Bar
              </button>
            </div>
          )}
        </div>
      )}

      {isMobile && showSidebar && (
        <div
          className="mobile-overlay"
          onClick={() => setShowSidebar(false)}
        ></div>
      )}

      <AuthModal
        isOpen={authModal.show}
        modalType={authModal.type}
        onClose={closeAuthModal}
      />
    </div>
  );
}
```

#### apps/web/src/layouts/PageContent.tsx

```tsx
import { ReactNode } from "react";
import "./page-content.css";

interface PageContentProps {
  children: ReactNode;
  title?: string;
  description?: string;
}

export function PageContent({
  children,
  title,
  description,
}: PageContentProps) {
  return (
    <div className="page-content">
      {title && <h1 className="page-title">{title}</h1>}
      {description && <p className="page-description">{description}</p>}
      <div
        className={`page-content-body ${!title && !description ? "no-header" : ""}`}
      >
        {children}
      </div>
    </div>
  );
}
```

#### apps/web/src/routes.tsx

```tsx
import React from "react";
import { Navigate, Route, Routes } from "react-router-dom";

import { LoginModal } from "./components/auth/LoginModal";
import { RegisterModal } from "./components/auth/RegisterModal";
import { HomePage } from "./components/pages/HomePage";
import { ProfilePage } from "./components/pages/ProfilePage";
import { ProtectedRoute } from "./components/ProtectedRoute";
import { useAuth } from "./contexts/AuthContext";

// Import your components

export const AppRoutes: React.FC = () => {
  const { isAuthenticated } = useAuth();

  return (
    <Routes>
      {/* Public routes */}
      <Route
        path="/login"
        element={
          isAuthenticated ? (
            <Navigate to="/" replace />
          ) : (
            <LoginModal
              isOpen={true}
              onClose={() => {}}
              onSwitchToRegister={() => {}}
              onLogin={() => {}}
            />
          )
        }
      />
      <Route
        path="/register"
        element={
          isAuthenticated ? (
            <Navigate to="/" replace />
          ) : (
            <RegisterModal
              isOpen={true}
              onClose={() => {}}
              onSwitchToLogin={() => {}}
              onRegister={() => {}}
            />
          )
        }
      />

      {/* Protected routes */}
      <Route
        path="/"
        element={
          <ProtectedRoute>
            <HomePage />
          </ProtectedRoute>
        }
      />
      <Route
        path="/profile"
        element={
          <ProtectedRoute>
            <ProfilePage />
          </ProtectedRoute>
        }
      />

      {/* Catch all route */}
      <Route path="*" element={<Navigate to="/" replace />} />
    </Routes>
  );
};
```

#### apps/web/src/service-worker.js

```js
const ASSETS_CACHE = "app-assets-v1";
const IMAGES_CACHE = "static-simages-v1"; // TODO
const cacheWhitelist = [ASSETS_CACHE, IMAGES_CACHE];

// Perform install steps
self.addEventListener("install", function (event) {
  event.waitUntil(
    caches.open(ASSETS_CACHE).then(function (cache) {
      // Fetch and cache these assets on the first install.
      return cache.addAll(["/", "/index.css", "/index.js"]);
    }),
  );
});

// Delete any old caches.
self.addEventListener("activate", function (event) {
  event.waitUntil(
    caches.keys().then(function (cacheNames) {
      return Promise.all(
        cacheNames.map(function (cacheName) {
          if (cacheWhitelist.indexOf(cacheName) === -1) {
            return caches.delete(cacheName);
          }
        }),
      );
    }),
  );
});

// TODO: add a request timeout.

// Always fetch when online, only use the cache as an offline fallback.
self.addEventListener("fetch", function (event) {
  event.respondWith(
    // Fetch from the network in case we're online.
    fetch(event.request)
      .then((response) => {
        // Don't cache bad responses.
        if (!response) return response;
        if (response.status !== 200) return response;
        if (response.type !== "basic") return response;

        // Only cache GET requests.
        if (event.request.method !== "GET") return response;

        // Only cache responses from the origin.
        // if (!event.request.url.startsWith(self.origin)) return response

        // Only cache the basic website assets.
        // TODO: favicon? fonts?
        const validMimeTypes = [
          "text/html",
          "application/javascript",
          "text/css",
        ];
        const contentType = response.headers.get("Content-Type");
        if (!contentType) return response;
        if (!validMimeTypes.some((mimeType) => contentType.includes(mimeType)))
          return response;

        // IMPORTANT: Clone the response. A response is a stream
        // and because we want the browser to consume the response
        // as well as the cache consuming the response, we need
        // to clone it so we have two streams.
        var responseToCache = response.clone();

        // Cache the response for offline.
        caches.open(ASSETS_CACHE).then(function (cache) {
          cache.put(event.request, responseToCache);
        });
        return response;
      })
      .catch(function (error) {
        // If we're offline return the cached response.
        return caches.match(event.request).then((cachedResponse) => {
          if (cachedResponse) return cachedResponse;

          // Check if request is for an HTML document (or navigation request)
          // appropriate for HTML5 routing used by single page applications.
          if (
            event.request.mode === "navigate" ||
            (event.request.method === "GET" &&
              event.request.headers.get("accept").includes("text/html"))
          ) {
            return caches.match("/");
          }

          return Promise.reject(error);
        });
      }),
  );
});
```

#### apps/web/src/service-worker.ts

```ts
/// <reference lib="webworker" />

// Type the service worker global scope
declare const self: ServiceWorkerGlobalScope;

const ASSETS_CACHE = "app-assets-v1";
const IMAGES_CACHE = "static-simages-v1"; // TODO
const cacheWhitelist: string[] = [ASSETS_CACHE, IMAGES_CACHE];

// Valid MIME types for caching
const validMimeTypes: string[] = [
  "text/html",
  "application/javascript",
  "text/css",
];

// Perform install steps
self.addEventListener("install", (event: ExtendableEvent): void => {
  event.waitUntil(
    caches.open(ASSETS_CACHE).then((cache: Cache): Promise<void> => {
      // Fetch and cache these assets on the first install.
      return cache.addAll(["/", "/index.css", "/index.js"]);
    })
  );
});

// Delete any old caches
self.addEventListener("activate", (event: ExtendableEvent): void => {
  event.waitUntil(
    caches.keys().then((cacheNames: string[]): Promise<(boolean | void)[]> => {
      return Promise.all(
        cacheNames.map((cacheName: string): Promise<boolean> | undefined => {
          if (cacheWhitelist.indexOf(cacheName) === -1) {
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});

// TODO: add a request timeout.

/**
 * Check if response should be cached
 */
function shouldCacheResponse(
  response: Response,
  request: Request
): boolean {
  // Don't cache bad responses
  if (!response) return false;
  if (response.status !== 200) return false;
  if (response.type !== "basic") return false;

  // Only cache GET requests
  if (request.method !== "GET") return false;

  // Only cache responses from the origin
  // if (!request.url.startsWith(self.origin)) return false;

  // Check MIME type
  const contentType = response.headers.get("Content-Type");
  if (!contentType) return false;
  if (!validMimeTypes.some((mimeType) => contentType.includes(mimeType))) {
    return false;
  }

  return true;
}

/**
 * Handle offline fallback for navigation requests
 */
function handleOfflineFallback(
  request: Request,
  error: Error
): Promise<Response> {
  return caches.match(request).then((cachedResponse: Response | undefined) => {
    if (cachedResponse) return cachedResponse;

    // Check if request is for an HTML document (or navigation request)
    // appropriate for HTML5 routing used by single page applications
    const acceptHeader = request.headers.get("accept");
    if (
      request.mode === "navigate" ||
      (request.method === "GET" && acceptHeader?.includes("text/html"))
    ) {
      return caches.match("/").then((indexResponse) => {
        if (indexResponse) return indexResponse;
        return Promise.reject(error);
      });
    }

    return Promise.reject(error);
  });
}

// Always fetch when online, only use the cache as an offline fallback
self.addEventListener("fetch", (event: FetchEvent): void => {
  event.respondWith(
    // Fetch from the network in case we're online
    fetch(event.request)
      .then((response: Response): Response => {
        // Check if we should cache this response
        if (!shouldCacheResponse(response, event.request)) {
          return response;
        }

        // IMPORTANT: Clone the response. A response is a stream
        // and because we want the browser to consume the response
        // as well as the cache consuming the response, we need
        // to clone it so we have two streams
        const responseToCache = response.clone();

        // Cache the response for offline use
        caches.open(ASSETS_CACHE).then((cache: Cache): void => {
          cache.put(event.request, responseToCache);
        });

        return response;
      })
      .catch((error: Error): Promise<Response> => {
        // If we're offline, return the cached response
        return handleOfflineFallback(event.request, error);
      })
  );
});
```

#### apps/web/src/services/AuthClient.ts

```ts
import { useCallback, useEffect, useMemo, useState } from "react";

// Remove unused import
// import { useClientEnvironment } from './ClientEnvironment';

// User types
export interface User {
  id: string;
  username: string;
  email: string;
  displayName: string;
  bio: string | null;
  profileImage: string | null;
  emailConfirmed: boolean;
  createdAt: string;
  updatedAt: string;
}

// API response types
interface ApiResponse<T> {
  status: "success" | "error";
  message?: string;
  data?: T;
  requireEmailConfirmation?: boolean;
}

interface UserResponse {
  user: User;
  token?: string;
  requireTwoFactor?: boolean;
  userId?: string;
}

export class AuthClient {
  // Get the server port
  private getServerPort(): number {
    // In production, use the same port as the client
    if (process.env.NODE_ENV === "production") {
      return window.location.port ? parseInt(window.location.port) : 80;
    }

    // In development, try to find the server port
    // First, check if we can read the port from localStorage (set by previous successful connections)
    const savedPort = localStorage.getItem("server_port");
    if (savedPort) {
      return parseInt(savedPort);
    }

    // Default to 8080 for the server in development
    return 8080;
  }

  // Get the base API URL
  getApiUrl() {
    // In development, use a direct URL to the server
    if (process.env.NODE_ENV === "development") {
      return `http://localhost:${this.getServerPort()}/api`;
    }

    // In production, use the current window location
    return `${window.location.protocol}//${window.location.host}/api`;
  }

  // Store token in localStorage
  setToken(token: string) {
    localStorage.setItem("auth_token", token);
  }

  getToken(): string | null {
    return localStorage.getItem("auth_token");
  }

  removeToken() {
    localStorage.removeItem("auth_token");
  }

  isAuthenticated(): boolean {
    return !!this.getToken();
  }

  getAuthHeaders() {
    const token = this.getToken();
    return token ? { Authorization: `Bearer ${token}` } : {};
  }

  // Email verification methods
  async confirmEmail(token: string): Promise<{ success: boolean }> {
    try {
      const response = await fetch(
        `${this.getApiUrl()}/auth/confirm-email?token=${token}`,
        {
          method: "GET",
          headers: {
            "Content-Type": "application/json",
          },
        },
      );

      return (await response.json()) as Promise<{ success: boolean }>;
    } catch (error) {
      console.error("Error confirming email:", error);
      throw error;
    }
  }

  async resendConfirmationEmail(email: string) {
    try {
      const response = await fetch(
        `${this.getApiUrl()}/auth/resend-confirmation`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ email }),
        },
      );

      return (await response.json()) as Promise<{ success: boolean }>;
    } catch (error) {
      console.error("Error resending confirmation email:", error);
      throw error;
    }
  }
}

// Static instance for non-hook usage
export const authClientInstance = new AuthClient();

// React hook for authentication
export function useAuth() {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Memoize the authClient instance
  const authClient = useMemo(() => new AuthClient(), []);

  const loadUser = useCallback(async () => {
    if (!authClient.isAuthenticated()) {
      setUser(null);
      setLoading(false);
      return;
    }

    try {
      setLoading(true);
      // Use fetch directly to avoid API structure issues
      const token = authClient.getToken();
      const response = await fetch("/api/auth/me", {
        headers: {
          Authorization: `Bearer ${token}`,
          "Content-Type": "application/json",
        },
      });

      const data = (await response.json()) as ApiResponse<UserResponse>;

      if (data.status === "success" && data.data?.user) {
        setUser(data.data.user);
      } else {
        // If we get a response but no user, token might be invalid
        authClient.removeToken();
        setUser(null);
      }
    } catch (err) {
      console.error("Failed to load user:", err);
      // Clear token on auth error
      authClient.removeToken();
      setUser(null);
      setError("Failed to authenticate");
    } finally {
      setLoading(false);
    }
  }, [authClient]);

  const login = async (email: string, password: string) => {
    try {
      setLoading(true);
      setError(null);

      const response = await fetch("/api/auth/login", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ email, password }),
      });

      const data = (await response.json()) as ApiResponse<UserResponse>;

      if (data.status === "success") {
        if (data.data?.requireTwoFactor) {
          // Return the 2FA requirement
          return { requireTwoFactor: true, userId: data.data.userId };
        }

        if (data.data?.token) {
          authClient.setToken(data.data.token);
        }
        if (data.data?.user) {
          setUser(data.data.user);
        }
        return { success: true };
      } else if (data.requireEmailConfirmation) {
        // Email not confirmed
        return {
          success: false,
          requireEmailConfirmation: true,
          email,
          error: data.message || "Email confirmation required",
        };
      } else {
        throw new Error(data.message || "Login failed");
      }
    } catch (err: unknown) {
      const errorMessage = err instanceof Error ? err.message : "Login failed";
      setError(errorMessage);
      return { success: false, error: errorMessage };
    } finally {
      setLoading(false);
    }
  };

  const register = async (userData: {
    username: string;
    email: string;
    password: string;
    displayName?: string;
    firstName: string;
    lastName: string;
  }) => {
    try {
      setLoading(true);
      setError(null);

      const response = await fetch(`${authClient.getApiUrl()}/auth/register`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(userData),
      });

      const data = (await response.json()) as ApiResponse<UserResponse>;

      if (data.status === "success" && data.data) {
        if (data.data.token) {
          authClient.setToken(data.data.token);
        }
        if (data.data.user) {
          setUser(data.data.user);
        }
        return {
          success: true,
          requireEmailConfirmation: !data.data.user.emailConfirmed,
          message: data.message || "Registration successful",
        };
      } else {
        throw new Error(data.message || "Registration failed");
      }
    } catch (err: unknown) {
      const errorMessage =
        err instanceof Error ? err.message : "Registration failed";
      setError(errorMessage);
      return { success: false, error: errorMessage };
    } finally {
      setLoading(false);
    }
  };

  const logout = () => {
    authClient.removeToken();
    setUser(null);
  };

  // Load user on mount and when token changes
  useEffect(() => {
    void loadUser();
  }, [loadUser]);

  return {
    user,
    loading,
    error,
    login,
    register,
    logout,
    isAuthenticated: !!user,
    refreshUser: loadUser,
    confirmEmail: authClient.confirmEmail.bind(authClient),
    resendConfirmationEmail:
      authClient.resendConfirmationEmail.bind(authClient),
  };
}
```

#### apps/web/src/services/ClientConfig.ts

```ts
// src/client/services/ClientConfig.ts
export type ClientConfig = {
  production: boolean;
  host: string;
};

// Add interface for window with config
interface WindowWithConfig extends Window {
  __config: ClientConfig;
}

const env = import.meta.env;
const isProd = env.MODE === "production";
const apiHost =
  env.VITE_API_HOST ||
  (typeof window !== "undefined" ? window.location.host : "localhost:5173");

export const clientConfig: ClientConfig = {
  production: isProd,
  host: apiHost,
};

// Use double assertion for window
(window as unknown as WindowWithConfig).__config = clientConfig;
```

#### apps/web/src/services/ClientEnvironment.tsx

```tsx
import React, { createContext, useContext } from "react";

import type { ClientApi } from "./api";
import type { Router } from "./Router";
import type { WebsocketPubsubClient } from "./WebsocketPubsubClient";

export type ClientConfig = {
  apiUrl: string;
  wsUrl: string;
  production: boolean;
};

export type ClientEnvironment = {
  config: ClientConfig;
  router: Router;
  api: ClientApi;
  pubsub: WebsocketPubsubClient;
};

const ClientEnvironmentContext = createContext<ClientEnvironment | undefined>(
  undefined,
);

export function ClientEnvironmentProvider(props: {
  value: ClientEnvironment;
  children: React.ReactNode;
}) {
  return (
    <ClientEnvironmentContext.Provider value={props.value}>
      {props.children}
    </ClientEnvironmentContext.Provider>
  );
}

export function useClientEnvironment(): ClientEnvironment {
  const clientEnvironment = useContext(ClientEnvironmentContext);
  if (!clientEnvironment) throw new Error("Missing ClientEnvironment");
  return clientEnvironment;
}
```

#### apps/web/src/services/Router.ts

```ts
import { useEffect, useState } from "react";

export type Route =
  | { type: "root"; url: string }
  | { type: "home"; url: string }
  | { type: "media"; url: string }
  | { type: "social"; url: string }
  | { type: "settings"; url: string }
  | { type: "dashboard"; url: string }
  | { type: "profile"; url: string }
  | { type: "upload"; url: string }
  | { type: "explore"; url: string }
  | { type: "notifications"; url: string }
  | { type: "design"; url: string; page: string }
  | { type: "auth"; url: string; action: string; token?: string }
  | { type: "unknown"; url: string };

// Define interface for window with router
interface WindowWithRouter extends Window {
  router?: Router;
}

export class Router {
  private listeners: Set<() => void> = new Set();
  private currentRoute: Route;

  constructor() {
    this.currentRoute = this.parseUrl(
      window.location.pathname + window.location.search,
    );

    // Listen for popstate events (back/forward buttons)
    window.addEventListener("popstate", () => {
      this.currentRoute = this.parseUrl(
        window.location.pathname + window.location.search,
      );
      this.notifyListeners();
    });
  }

  private parseUrl(url: string): Route {
    // Extract path and search params
    const [path, search] = url.split("?");
    const searchParams = new URLSearchParams(search ? `?${search}` : "");

    if (path === "/" || path === "") {
      return { type: "root", url: path };
    }

    if (path === "/home") {
      return { type: "home", url: path };
    }

    if (path === "/media") {
      return { type: "media", url: path };
    }

    if (path === "/social") {
      return { type: "social", url: path };
    }

    if (path === "/settings") {
      return { type: "settings", url: path };
    }

    if (path === "/dashboard") {
      return { type: "dashboard", url: path };
    }

    if (path === "/profile") {
      return { type: "profile", url: path };
    }

    if (path === "/upload") {
      return { type: "upload", url: path };
    }

    if (path === "/explore") {
      return { type: "explore", url: path };
    }

    if (path === "/notifications") {
      return { type: "notifications", url: path };
    }

    if (path.startsWith("/design/")) {
      const page = path.slice("/design/".length);
      return { type: "design", url: path, page };
    }

    // Auth routes
    if (path.startsWith("/auth/")) {
      const action = path.slice("/auth/".length);
      const token = searchParams.get("token") || undefined;
      return { type: "auth", url: path, action, token };
    }

    return { type: "unknown", url: path };
  }

  private notifyListeners() {
    this.listeners.forEach((listener) => listener());
  }

  public getCurrentRoute(): Route {
    return this.currentRoute;
  }

  public navigate(url: string) {
    window.history.pushState(null, "", url);
    this.currentRoute = this.parseUrl(url);
    this.notifyListeners();
  }

  public subscribe(listener: () => void): () => void {
    this.listeners.add(listener);
    return () => {
      this.listeners.delete(listener);
    };
  }
}

export function useRouter(): { route: Route; navigate: (url: string) => void } {
  const [route, setRoute] = useState<Route>(() => {
    // Access the router from the window object during development
    const router = (window as WindowWithRouter).router;
    return router
      ? router.getCurrentRoute()
      : { type: "unknown", url: window.location.pathname };
  });

  useEffect(() => {
    const router = (window as WindowWithRouter).router;
    if (!router) {
      console.error("Router not found on window object");
      return;
    }

    const unsubscribe = router.subscribe(() => {
      setRoute(router.getCurrentRoute());
    });

    return unsubscribe;
  }, []);

  const navigate = (url: string) => {
    const router = (window as WindowWithRouter).router;
    if (!router) {
      console.error("Router not found on window object");
      return;
    }
    router.navigate(url);
  };

  return { route, navigate };
}

export function useRoute(): Route {
  const { route } = useRouter();
  return route;
}
```

#### apps/web/src/services/WebsocketPubsubClient.ts

```ts
import {
  ClientPubsubMessage,
  ServerPubsubMessage,
} from "@infrastructure/pubsub";

import { sleep } from "@/server/infrastructure/lifecycle/sleep";

import { ClientConfig } from "./ClientConfig";
import { SecondMs } from "../../server/infrastructure/utils/dateHelpers";

// Define a type for pubsub values
type PubSubValue = unknown;

const debug = (...args: unknown[]) => console.log("pubsub:", ...args);

export class WebsocketPubsubClient {
  private ws!: WebSocket;
  private reconnectAttempt = 1;
  private subscriptions: Map<string, Set<(value: PubSubValue) => void>> =
    new Map();

  constructor(
    private args: {
      config: ClientConfig;
      onChange: (key: string, value: PubSubValue) => void;
      onStart: () => void;
    },
  ) {
    this.connect();

    window.addEventListener("online", () => {
      this.reconnectAttempt = 1;
      this.connect();
    });
  }

  private connect() {
    debug("connecting...");
    this.ws = new WebSocket(`ws://${this.args.config.host}`);

    this.ws.onopen = () => {
      debug("connected!");
      this.reconnectAttempt = 1;
      this.args.onStart();

      // Resubscribe to all previous subscriptions
      for (const key of this.subscriptions.keys()) {
        this.send({ type: "subscribe", key });
      }
    };

    this.ws.onmessage = (event) => {
      const message = JSON.parse(event.data as string) as ServerPubsubMessage;
      debug("<", message.type, message.key, message.value);

      // Call the global onChange handler
      this.args.onChange(message.key, message.value);

      // Call individual subscription callbacks
      const callbacks = this.subscriptions.get(message.key);
      if (callbacks) {
        for (const callback of callbacks) {
          callback(message.value);
        }
      }
    };

    this.ws.onerror = (error) => {
      debug("error", error);
    };

    this.ws.onclose = () => {
      debug("closed");
      void this.attemptReconnect();
    };
  }

  private async attemptReconnect() {
    if (!navigator.onLine) return;

    await sleep(2 ** this.reconnectAttempt * SecondMs);
    this.reconnectAttempt += 1;
    this.connect();
  }

  private send(message: ClientPubsubMessage) {
    if (this.ws.readyState === WebSocket.OPEN) {
      debug(">", message.type, message.key);
      this.ws.send(JSON.stringify(message));
    }
  }

  subscribe(key: string, callback?: (value: PubSubValue) => void) {
    // Add to subscriptions map
    if (callback) {
      if (!this.subscriptions.has(key)) {
        this.subscriptions.set(key, new Set());
      }
      this.subscriptions.get(key)?.add(callback);
    }

    // Send subscribe message
    this.send({ type: "subscribe", key });

    // Return unsubscribe function
    return () => this.unsubscribe(key, callback);
  }

  unsubscribe(key: string, callback?: (value: PubSubValue) => void) {
    // Remove from subscriptions map
    if (callback && this.subscriptions.has(key)) {
      this.subscriptions.get(key)?.delete(callback);
      if ((this.subscriptions.get(key)?.size ?? 0) === 0) {
        this.subscriptions.delete(key);
        // Only send unsubscribe if no more callbacks for this key
        this.send({ type: "unsubscribe", key });
      }
    } else if (!callback) {
      // If no callback provided, remove all subscriptions for this key
      this.subscriptions.delete(key);
      this.send({ type: "unsubscribe", key });
    }
  }

  close() {
    if (this.ws) {
      this.ws.close();
    }
  }
}
```

#### apps/web/src/services/api.ts

```ts
import { sleep } from "../../server/infrastructure/lifecycle/sleep";

// Define a minimal API schema type since we don't have a full API setup yet
type ApiSchema = Record<
  string,
  {
    input: Record<string, unknown>;
    output: unknown;
  }
>;

// https://github.com/microsoft/TypeScript/issues/55095
type StatusCode = 0 | 200 | 400 | 409 | 424 | 403 | 500;
type ErrorStatusCode = Exclude<StatusCode, 200>;
type ErrorResponse = { status: ErrorStatusCode; body?: unknown };

type ApiResponse<T> = {
  success: boolean;
  data?: T;
  error?: string;
};

const debug = (...args: unknown[]) => console.log("api:", ...args);

export async function apiRequest<T extends keyof ApiSchema>(
  name: T,
  args: ApiSchema[T]["input"],
): Promise<ApiResponse<Awaited<ApiSchema[T]["output"]>>> {
  debug(name, JSON.stringify(args));

  const result = await httpRequest(`/api/${String(name)}`, args);

  // Control how much loading spinners we see during development.
  await sleep(400);

  // Convert HttpResponse to ApiResponse
  if (result.status === 200) {
    return {
      success: true,
      data: result.body as Awaited<ApiSchema[T]["output"]>,
    };
  } else {
    return {
      success: false,
      error: formatResponseError(result as ErrorResponse),
    };
  }
}

export type ClientApi = {
  get: <T>(path: string) => Promise<ApiResponse<T>>;
  post: <T>(
    path: string,
    data?: Record<string, unknown>,
  ) => Promise<ApiResponse<T>>;
  put: <T>(
    path: string,
    data?: Record<string, unknown>,
  ) => Promise<ApiResponse<T>>;
  delete: <T>(path: string) => Promise<ApiResponse<T>>;
  upload: (path: string, file: File) => Promise<ApiResponse<string>>;
};

export function createApi(): ClientApi {
  const baseUrl = "/api";

  async function fetchApi<T>(
    method: string,
    path: string,
    data?: Record<string, unknown>,
  ): Promise<ApiResponse<T>> {
    const url = `${baseUrl}${path}`;
    const headers: HeadersInit = {
      "Content-Type": "application/json",
    };

    try {
      const response = await fetch(url, {
        method,
        headers,
        body: data ? JSON.stringify(data) : undefined,
      });

      if (!response.ok) {
        const errorData = (await response.json()) as { message?: string };
        return {
          success: false,
          error: errorData.message || `HTTP error ${response.status}`,
        };
      }

      const responseData = (await response.json()) as T;
      return {
        success: true,
        data: responseData,
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
      };
    }
  }

  async function uploadFile(
    path: string,
    file: File,
  ): Promise<ApiResponse<string>> {
    const url = `${baseUrl}${path}`;
    const formData = new FormData();
    formData.append("file", file);

    try {
      const response = await fetch(url, {
        method: "POST",
        body: formData,
      });

      if (!response.ok) {
        const errorData = (await response.json()) as { message?: string };
        return {
          success: false,
          error: errorData.message || `HTTP error ${response.status}`,
        };
      }

      const responseData = (await response.json()) as { url: string };
      return {
        success: true,
        data: responseData.url,
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
      };
    }
  }

  return {
    get: <T>(path: string) => fetchApi<T>("GET", path),
    post: <T>(path: string, data?: Record<string, unknown>) =>
      fetchApi<T>("POST", path, data),
    put: <T>(path: string, data?: Record<string, unknown>) =>
      fetchApi<T>("PUT", path, data),
    delete: <T>(path: string) => fetchApi<T>("DELETE", path),
    upload: (path: string, file: File) => uploadFile(path, file),
  };
}

export function formatResponseError(response: ErrorResponse) {
  const { status, body } = response;
  if (body === null) return `${status}: Unkown error.`;
  if (body === undefined) return `${status}: Unkown error.`;
  if (typeof body === "string") return body;
  if (typeof body === "object") {
    if ("message" in body) {
      if (typeof body.message === "string") {
        return body.message;
      }
    }
  }
  return `${status}: ${JSON.stringify(body)}`;
}

export type HttpResponse<Body = unknown> =
  | { status: 200; body: Body }
  | { status: number; body?: unknown };

// Only POST requests for now because this is only used for the API.
export async function httpRequest(
  url: string,
  args: unknown,
): Promise<HttpResponse> {
  let response: Response;
  try {
    response = await fetch(url, {
      method: "post",
      credentials: "same-origin",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(args),
    });
  } catch (_error) {
    // Offline
    return { status: 0 };
  }

  if (response.status === 200) {
    try {
      const body = (await response.json()) as unknown;
      return { status: 200, body };
    } catch (_error) {
      return { status: 200, body: {} };
    }
  }

  let body: unknown;
  try {
    body = await response.json();
  } catch (_error) {
    console.warn("Could not parse body of error response.");
  }

  return { status: response.status, body };
}
```

#### apps/web/src/services/social.ts

```ts
interface User {
  id: string;
  username: string;
  displayName: string;
  avatar: string;
  bio: string;
  followersCount: number;
  followingCount: number;
  postsCount: number;
  isFollowing: boolean;
}

interface Post {
  id: string;
  userId: string;
  username: string;
  userAvatar: string;
  content: string;
  media?: {
    type: "image" | "video" | "audio";
    url: string;
    thumbnail?: string;
  };
  likesCount: number;
  commentsCount: number;
  sharesCount: number;
  isLiked: boolean;
  createdAt: string;
}

interface Comment {
  id: string;
  userId: string;
  username: string;
  userAvatar: string;
  content: string;
  likesCount: number;
  isLiked: boolean;
  createdAt: string;
  replies?: Comment[];
}

interface FeedResponse {
  posts: Post[];
  hasMore: boolean;
}

interface CommentsResponse {
  comments: Comment[];
  hasMore: boolean;
}

class SocialService {
  private static instance: SocialService;
  private baseUrl: string;

  private constructor() {
    this.baseUrl = "/api";
  }

  public static getInstance(): SocialService {
    if (!SocialService.instance) {
      SocialService.instance = new SocialService();
    }
    return SocialService.instance;
  }

  // User-related methods
  async getUserProfile(userId: string): Promise<User> {
    const response = await fetch(`${this.baseUrl}/users/${userId}`);
    if (!response.ok) {
      throw new Error("Failed to fetch user profile");
    }
    return response.json() as Promise<User>;
  }

  async followUser(userId: string): Promise<void> {
    const response = await fetch(`${this.baseUrl}/users/${userId}/follow`, {
      method: "POST",
    });
    if (!response.ok) {
      throw new Error("Failed to follow user");
    }
  }

  async unfollowUser(userId: string): Promise<void> {
    const response = await fetch(`${this.baseUrl}/users/${userId}/unfollow`, {
      method: "POST",
    });
    if (!response.ok) {
      throw new Error("Failed to unfollow user");
    }
  }

  // Post-related methods
  async getFeed(
    type: "home" | "profile" | "explore",
    userId?: string,
    offset: number = 0,
  ): Promise<FeedResponse> {
    const url = new URL(`${this.baseUrl}/feed`);
    url.searchParams.append("type", type);
    if (userId) {
      url.searchParams.append("userId", userId);
    }
    if (offset > 0) {
      url.searchParams.append("offset", offset.toString());
    }

    const response = await fetch(url.toString());
    if (!response.ok) {
      throw new Error("Failed to fetch feed");
    }
    return response.json() as Promise<FeedResponse>;
  }

  async createPost(content: string, media?: File): Promise<Post> {
    const formData = new FormData();
    formData.append("content", content);
    if (media) {
      formData.append("media", media);
    }

    const response = await fetch(`${this.baseUrl}/posts`, {
      method: "POST",
      body: formData,
    });
    if (!response.ok) {
      throw new Error("Failed to create post");
    }
    return response.json() as Promise<Post>;
  }

  async likePost(postId: string): Promise<void> {
    const response = await fetch(`${this.baseUrl}/posts/${postId}/like`, {
      method: "POST",
    });
    if (!response.ok) {
      throw new Error("Failed to like post");
    }
  }

  async unlikePost(postId: string): Promise<void> {
    const response = await fetch(`${this.baseUrl}/posts/${postId}/unlike`, {
      method: "POST",
    });
    if (!response.ok) {
      throw new Error("Failed to unlike post");
    }
  }

  async sharePost(postId: string): Promise<void> {
    const response = await fetch(`${this.baseUrl}/posts/${postId}/share`, {
      method: "POST",
    });
    if (!response.ok) {
      throw new Error("Failed to share post");
    }
  }

  // Comment-related methods
  async getComments(
    postId: string,
    offset: number = 0,
  ): Promise<CommentsResponse> {
    const url = new URL(`${this.baseUrl}/posts/${postId}/comments`);
    if (offset > 0) {
      url.searchParams.append("offset", offset.toString());
    }

    const response = await fetch(url.toString());
    if (!response.ok) {
      throw new Error("Failed to fetch comments");
    }
    return response.json() as Promise<CommentsResponse>;
  }

  async createComment(postId: string, content: string): Promise<Comment> {
    const response = await fetch(`${this.baseUrl}/posts/${postId}/comments`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ content }),
    });
    if (!response.ok) {
      throw new Error("Failed to create comment");
    }
    return response.json() as Promise<Comment>;
  }

  async likeComment(commentId: string): Promise<void> {
    const response = await fetch(`${this.baseUrl}/comments/${commentId}/like`, {
      method: "POST",
    });
    if (!response.ok) {
      throw new Error("Failed to like comment");
    }
  }

  async unlikeComment(commentId: string): Promise<void> {
    const response = await fetch(
      `${this.baseUrl}/comments/${commentId}/unlike`,
      {
        method: "POST",
      },
    );
    if (!response.ok) {
      throw new Error("Failed to unlike comment");
    }
  }

  async replyToComment(commentId: string, content: string): Promise<Comment> {
    const response = await fetch(
      `${this.baseUrl}/comments/${commentId}/replies`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ content }),
      },
    );
    if (!response.ok) {
      throw new Error("Failed to create reply");
    }
    return response.json() as Promise<Comment>;
  }
}

export const socialService = SocialService.getInstance();
```

#### apps/web/src/services/types.ts

```ts
export type ClientConfig = {
  apiUrl: string;
  wsUrl: string;
  production: boolean;
};
```

#### apps/web/src/styles.ts

```ts
// Global styles for the application
export const globalStyles = {
  // Base styles
  body: {
    margin: "0px",
    padding: "0px",
    fontFamily:
      '-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"',
    background: "var(--background)",
    color: "var(--text-color)",
  },
  bodyInputButton: {
    fontSize: "18px",
  },
  boxSizing: {
    boxSizing: "border-box",
  },

  // Variables
  variables: {
    light: {
      background: "rgba(255, 255, 255, 1)",
      background2: "rgba(242, 242, 247, 1)",
      background3: "rgba(255, 255, 255, 1)",
      transparent1: "rgba(0, 0, 18, 0.1)",
      transparent2: "rgba(0, 0, 18, 0.2)",
      transparent3: "rgba(0, 0, 18, 0.3)",
      transparent4: "rgba(0, 0, 18, 0.4)",
      textColor: "rgba(0, 0, 0, 1)",
      textColor2: "rgba(61, 61, 66, 0.6)",
      textColor3: "rgba(61, 61, 66, 0.3)",
      textColor4: "rgba(61, 61, 66, 0.18)",
      placeholder: "rgba(61, 61, 66, 0.3)",
      separator: "rgba(61, 61, 66, 0.29)",
      separatorOpaque: "rgba(199, 199, 199, 1)",
      hover: "rgba(0, 122, 255, 0.3)",
      active: "rgba(0, 122, 255, 0.5)",
      blue: "rgba(0, 122, 255, 1)",
      green: "rgba(51, 199, 89, 1)",
      indigo: "rgba(89, 87, 214, 1)",
      orange: "rgba(255, 148, 0, 1)",
      pink: "rgba(255, 46, 84, 1)",
      purple: "rgba(176, 82, 222, 1)",
      red: "rgba(255, 59, 48, 1)",
      teal: "rgba(89, 199, 250, 1)",
      yellow: "rgba(255, 204, 0, 1)",
      gray: "rgba(143, 143, 148, 1)",
      gray2: "rgba(173, 173, 179, 1)",
      gray3: "rgba(199, 199, 204, 1)",
      gray4: "rgba(209, 209, 214, 1)",
      gray5: "rgba(230, 230, 235, 1)",
      gray6: "rgba(242, 242, 247, 1)",
      popupBackground: "var(--background)",
      shadow:
        "rgba(15, 15, 15, 0.05) 0px 0px 0px 1px, rgba(15, 15, 15, 0.1) 0px 3px 6px, rgba(15, 15, 15, 0.2) 0px 9px 24px",
    },
    dark: {
      background: "rgba(0, 0, 0, 1)",
      background2: "rgb(36, 36, 40)",
      background3: "rgb(48, 48, 52)",
      transparent1: "rgba(243, 243, 255, 0.1)",
      transparent2: "rgba(243, 243, 255, 0.2)",
      transparent3: "rgba(243, 243, 255, 0.3)",
      transparent4: "rgba(243, 243, 255, 0.4)",
      textColor: "rgba(255, 255, 255, 1)",
      textColor2: "rgba(235, 235, 245, 0.6)",
      textColor3: "rgba(235, 235, 245, 0.3)",
      textColor4: "rgba(235, 235, 245, 0.18)",
      placeholder: "rgba(235, 235, 245, 0.3)",
      separator: "rgba(84, 84, 89, 0.6)",
      separatorOpaque: "rgba(56, 56, 59, 1)",
      hover: "rgba(10, 133, 255, 0.3)",
      active: "rgba(10, 133, 255, 0.5)",
      blue: "rgba(10, 133, 255, 1)",
      green: "rgba(48, 209, 89, 1)",
      indigo: "rgba(94, 92, 230, 1)",
      orange: "rgba(255, 158, 10, 1)",
      pink: "rgba(255, 56, 94, 1)",
      purple: "rgba(191, 89, 242, 1)",
      red: "rgba(255, 69, 59, 1)",
      teal: "rgba(99, 209, 255, 1)",
      yellow: "rgba(255, 214, 10, 1)",
      gray: "rgba(143, 143, 148, 1)",
      gray2: "rgba(99, 99, 102, 1)",
      gray3: "rgba(71, 71, 74, 1)",
      gray4: "rgba(59, 59, 61, 1)",
      gray5: "rgba(43, 43, 46, 1)",
      gray6: "rgba(28, 28, 31, 1)",
      popupBackground: "var(--background2)",
      shadow:
        "rgba(255, 255, 255, 0.2) 0px 0px 0px 1px, rgba(15, 15, 15, 0.1) 0px 3px 6px, rgba(15, 15, 15, 0.2) 0px 9px 24px",
    },
  },

  // Form elements
  input: {
    color: "var(--text-color)",
    background: "transparent",
  },
  inputPlaceholder: {
    color: "var(--placeholder)",
  },
  button: {
    background: "transparent",
  },

  // Links
  a: {
    color: "var(--text-color2)",
  },

  // Feedback states
  feedbackHover: {
    backgroundColor: "var(--hover)",
  },
  feedbackActive: {
    backgroundColor: "var(--active)",
  },

  // Focus states
  focus: {
    outline: "2px solid var(--orange)",
    outlineOffset: "-2px",
  },

  // Spinner animation
  spinner: {
    width: "1.25em",
    height: "1.25em",
    border: "0.15em solid var(--text-color2)",
    borderBottomColor: "transparent",
    borderRadius: "100%",
    display: "inline-block",
    boxSizing: "border-box",
    animation: "rotation 800ms linear infinite",
  },
  keyframes: {
    rotation: {
      from: {
        transform: "rotate(0deg)",
      },
      to: {
        transform: "rotate(360deg)",
      },
    },
  },
};

// Image Gallery styles
export const imageGalleryStyles = {
  imageGallery: {
    position: "relative",
    width: "100%",
    maxWidth: "100%",
    overflow: "hidden",
    background: "var(--background3)",
    borderRadius: "8px",
    boxShadow: "0 2px 8px rgba(0, 0, 0, 0.1)",
  },
  galleryMain: {
    position: "relative",
    width: "100%",
    height: "100%",
    display: "flex",
    overflow: "hidden",
  },
  galleryImageContainer: {
    minWidth: "100%",
    height: "100%",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    transition: "transform 0.3s ease",
  },
  galleryImage: {
    maxWidth: "100%",
    maxHeight: "100%",
    objectFit: "contain",
    userSelect: "none",
  },
  galleryNav: {
    position: "absolute",
    top: "50%",
    transform: "translateY(-50%)",
    background: "rgba(0, 0, 0, 0.5)",
    color: "white",
    border: "none",
    width: "40px",
    height: "40px",
    borderRadius: "50%",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    cursor: "pointer",
    opacity: 0.7,
    transition: "opacity 0.2s",
    zIndex: 10,
  },
  galleryNavHover: {
    opacity: 1,
  },
  galleryPrev: {
    left: "10px",
  },
  galleryNext: {
    right: "10px",
  },
  galleryFullscreen: {
    position: "absolute",
    top: "10px",
    right: "10px",
    background: "rgba(0, 0, 0, 0.5)",
    color: "white",
    border: "none",
    width: "40px",
    height: "40px",
    borderRadius: "50%",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    cursor: "pointer",
    opacity: 0.7,
    transition: "opacity 0.2s",
    zIndex: 10,
  },
  galleryFullscreenHover: {
    opacity: 1,
  },
  galleryThumbnails: {
    display: "flex",
    padding: "10px",
    overflowX: "auto",
    scrollbarWidth: "thin",
  },
  galleryThumbnail: {
    width: "60px",
    height: "60px",
    flexShrink: 0,
    marginRight: "8px",
    borderRadius: "4px",
    overflow: "hidden",
    opacity: 0.7,
    cursor: "pointer",
    transition: "opacity 0.2s",
    border: "2px solid transparent",
  },
  galleryThumbnailHover: {
    opacity: 0.9,
  },
  galleryThumbnailActive: {
    opacity: 1,
    borderColor: "var(--blue, #1a73e8)",
  },
  galleryThumbnailImg: {
    width: "100%",
    height: "100%",
    objectFit: "cover",
  },
  galleryIndicators: {
    position: "absolute",
    bottom: "15px",
    left: "50%",
    transform: "translateX(-50%)",
    display: "flex",
    gap: "8px",
    zIndex: 10,
  },
  galleryIndicator: {
    width: "8px",
    height: "8px",
    borderRadius: "50%",
    background: "white",
    opacity: 0.5,
    border: "none",
    padding: 0,
    cursor: "pointer",
    transition: "opacity 0.2s, transform 0.2s",
  },
  galleryIndicatorActive: {
    opacity: 1,
    transform: "scale(1.2)",
  },
  imageGalleryFullscreen: {
    width: "100vw !important",
    height: "100vh !important",
    maxWidth: "100vw",
    maxHeight: "100vh",
    background: "black",
  },
  imageGalleryFullscreenImage: {
    maxHeight: "90vh",
  },
};

// Video Player styles
export const videoPlayerStyles = {
  videoPlayer: {
    position: "relative",
    width: "100%",
    maxWidth: "100%",
    background: "var(--background2)",
    borderRadius: "12px",
    overflow: "hidden",
    boxShadow: "0 4px 12px rgba(0, 0, 0, 0.1)",
  },
  videoContainer: {
    position: "relative",
    width: "100%",
    background: "#000",
  },
  videoElement: {
    width: "100%",
    display: "block",
  },
  videoOverlay: {
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    background: "rgba(0, 0, 0, 0.3)",
    opacity: 0,
    transition: "opacity 0.3s",
  },
  videoOverlayVisible: {
    opacity: 1,
  },
  playButton: {
    width: "60px",
    height: "60px",
    borderRadius: "50%",
    background: "rgba(0, 0, 0, 0.7)",
    border: "none",
    color: "white",
    fontSize: "24px",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    cursor: "pointer",
    transition: "transform 0.2s, background 0.2s",
  },
  playButtonHover: {
    transform: "scale(1.1)",
    background: "rgba(0, 0, 0, 0.8)",
  },
  controls: {
    position: "absolute",
    bottom: 0,
    left: 0,
    width: "100%",
    padding: "10px",
    background: "linear-gradient(transparent, rgba(0, 0, 0, 0.7))",
    display: "flex",
    flexDirection: "column",
    gap: "10px",
    opacity: 0,
    transition: "opacity 0.3s",
  },
  controlsVisible: {
    opacity: 1,
  },
  progressContainer: {
    width: "100%",
    height: "5px",
    background: "rgba(255, 255, 255, 0.3)",
    borderRadius: "3px",
    cursor: "pointer",
    position: "relative",
  },
  progressBar: {
    height: "100%",
    background: "var(--blue, #1a73e8)",
    borderRadius: "3px",
    position: "absolute",
    top: 0,
    left: 0,
  },
  controlsRow: {
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    color: "white",
  },
  controlsGroup: {
    display: "flex",
    alignItems: "center",
    gap: "15px",
  },
  controlButton: {
    background: "transparent",
    border: "none",
    color: "white",
    cursor: "pointer",
    width: "30px",
    height: "30px",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    fontSize: "16px",
    opacity: 0.8,
    transition: "opacity 0.2s",
  },
  controlButtonHover: {
    opacity: 1,
  },
  timeDisplay: {
    fontSize: "14px",
    opacity: 0.9,
  },
  volumeContainer: {
    display: "flex",
    alignItems: "center",
    gap: "5px",
  },
  volumeSlider: {
    width: "60px",
    height: "5px",
    WebkitAppearance: "none",
    background: "rgba(255, 255, 255, 0.3)",
    borderRadius: "3px",
    outline: "none",
  },
  volumeSliderThumb: {
    WebkitAppearance: "none",
    width: "12px",
    height: "12px",
    borderRadius: "50%",
    background: "white",
    cursor: "pointer",
  },
  fullscreenButton: {
    marginLeft: "10px",
  },
};

// Social Feed styles
export const socialFeedStyles = {
  socialFeed: {
    width: "100%",
    maxWidth: "600px",
    margin: "0 auto",
  },
  feedHeader: {
    display: "flex",
    alignItems: "center",
    justifyContent: "space-between",
    marginBottom: "20px",
  },
  feedTitle: {
    fontSize: "1.5rem",
    fontWeight: 600,
    color: "var(--text-color)",
  },
  feedFilter: {
    display: "flex",
    gap: "10px",
  },
  filterButton: {
    background: "var(--background2)",
    border: "none",
    padding: "8px 15px",
    borderRadius: "20px",
    fontSize: "0.9rem",
    color: "var(--text-color2)",
    cursor: "pointer",
    transition: "background-color 0.2s, color 0.2s",
  },
  filterButtonHover: {
    background: "var(--hover)",
  },
  filterButtonActive: {
    background: "var(--blue)",
    color: "white",
  },
  postList: {
    display: "flex",
    flexDirection: "column",
    gap: "20px",
  },
  postCard: {
    background: "var(--background2)",
    borderRadius: "12px",
    overflow: "hidden",
    boxShadow: "0 2px 8px rgba(0, 0, 0, 0.1)",
  },
  postHeader: {
    display: "flex",
    alignItems: "center",
    padding: "15px",
  },
  postAvatar: {
    width: "40px",
    height: "40px",
    borderRadius: "50%",
    overflow: "hidden",
    marginRight: "12px",
  },
  postAvatarImg: {
    width: "100%",
    height: "100%",
    objectFit: "cover",
  },
  postUserInfo: {
    flex: 1,
  },
  postUsername: {
    fontWeight: 600,
    color: "var(--text-color)",
    margin: 0,
  },
  postTime: {
    fontSize: "0.8rem",
    color: "var(--text-color2)",
    margin: 0,
  },
  postOptions: {
    color: "var(--text-color2)",
    background: "transparent",
    border: "none",
    cursor: "pointer",
    padding: "5px",
    borderRadius: "50%",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
  },
  postOptionsHover: {
    background: "var(--hover)",
  },
  postContent: {
    padding: "0 15px 15px",
    color: "var(--text-color)",
    whiteSpace: "pre-wrap",
  },
  postMedia: {
    width: "100%",
    maxHeight: "500px",
    overflow: "hidden",
    marginBottom: "15px",
  },
  postMediaImg: {
    width: "100%",
    objectFit: "contain",
  },
  postActions: {
    display: "flex",
    padding: "10px 15px",
    borderTop: "1px solid var(--border)",
  },
  postAction: {
    display: "flex",
    alignItems: "center",
    gap: "5px",
    marginRight: "20px",
    color: "var(--text-color2)",
    background: "transparent",
    border: "none",
    cursor: "pointer",
    padding: "5px",
    borderRadius: "5px",
    fontSize: "0.9rem",
  },
  postActionHover: {
    background: "var(--hover)",
  },
  postActionLiked: {
    color: "var(--red)",
  },
  loadMore: {
    background: "var(--background2)",
    border: "none",
    padding: "10px 20px",
    borderRadius: "20px",
    color: "var(--text-color)",
    cursor: "pointer",
    margin: "20px auto",
    display: "block",
    transition: "background-color 0.2s",
  },
  loadMoreHover: {
    background: "var(--hover)",
  },
  emptyFeed: {
    textAlign: "center",
    padding: "40px 0",
    color: "var(--text-color2)",
  },
  loadingIndicator: {
    textAlign: "center",
    padding: "20px 0",
    color: "var(--text-color2)",
  },
};
```

#### apps/web/src/utils/styleUtils.ts

```ts
/**
 * Merges multiple style objects together
 * @param styles Array of style objects to merge
 * @returns Merged style object
 */
export const mergeStyles = (
  ...styles: (React.CSSProperties | undefined)[]
): React.CSSProperties => {
  return Object.assign({}, ...styles.filter(Boolean)) as React.CSSProperties;
};

/**
 * Creates a conditional style object
 * @param condition Boolean condition
 * @param trueStyles Styles to apply if condition is true
 * @param falseStyles Optional styles to apply if condition is false
 * @returns Style object based on condition
 */
export const conditionalStyle = (
  condition: boolean,
  trueStyles: React.CSSProperties,
  falseStyles?: React.CSSProperties,
): React.CSSProperties => {
  return condition ? trueStyles : falseStyles || {};
};

/**
 * Applies styles based on hover state
 * @param isHovered Boolean indicating hover state
 * @param baseStyles Base styles
 * @param hoverStyles Styles to apply when hovered
 * @returns Combined style object
 */
export const applyHoverStyles = (
  isHovered: boolean,
  baseStyles: React.CSSProperties,
  hoverStyles: React.CSSProperties,
): React.CSSProperties => {
  return mergeStyles(baseStyles, conditionalStyle(isHovered, hoverStyles));
};

/**
 * Creates a CSS variable string from a variables object
 * @param variables Object containing CSS variable definitions
 * @returns CSS variables as a string
 */
export const createCSSVariables = (
  variables: Record<string, string>,
): string => {
  return Object.entries(variables)
    .map(([key, value]) => `--${key}: ${value};`)
    .join(" ");
};

/**
 * Injects global CSS variables into the document
 * @param lightVariables Light theme variables
 * @param darkVariables Dark theme variables
 */
export const injectGlobalCSSVariables = (
  lightVariables: Record<string, string>,
  darkVariables: Record<string, string>,
): void => {
  // Create style element
  const styleElement = document.createElement("style");

  // Create CSS content
  const cssContent = `
    :root {
      ${createCSSVariables(lightVariables)}
    }
    
    @media (prefers-color-scheme: dark) {
      :root {
        color-scheme: dark;
        ${createCSSVariables(darkVariables)}
      }
    }
    
    @keyframes rotation {
      from {
        transform: rotate(0deg);
      }
      to {
        transform: rotate(360deg);
      }
    }
  `;

  // Set style content
  styleElement.textContent = cssContent;

  // Append to head
  document.head.appendChild(styleElement);
};

/**
 * Creates a className string from conditional classes
 * @param baseClass Base class name
 * @param conditionalClasses Object with class names as keys and conditions as values
 * @returns Combined class name string
 */
export const classNames = (
  baseClass: string,
  conditionalClasses: Record<string, boolean> = {},
): string => {
  const classes = [baseClass];

  Object.entries(conditionalClasses).forEach(([className, condition]) => {
    if (condition) {
      classes.push(className);
    }
  });

  return classes.join(" ");
};
```

#### apps/web/tsconfig.json

```json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "composite": true,
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,

    /* Path mapping */
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"],
      "@abe-stack/shared": ["../../packages/shared/src"],
      "@abe-stack/ui": ["../../packages/ui/src"],
      "@components/*": ["./src/components/*"],
      "@hooks/*": ["./src/hooks/*"],
      "@services/*": ["./src/services/*"],
      "@config/*": ["./src/config/*"],
      "@layouts/*": ["./src/layouts/*"],
      "@routes/*": ["./src/routes/*"],
      "@utils/*": ["./src/utils/*"],
      "@api/*": ["./src/api/*"]
    },
    "tsBuildInfoFile": "./node_modules/.cache/tsconfig.web.tsbuildinfo"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "__tests__"],
  "references": [
    { "path": "../../packages/shared" },
    { "path": "../../packages/ui" }
  ]
}
```

---

### Packages Configuration

#### packages/api-client/package.json

```json
{
  "name": "@abe-stack/api-client",
  "version": "1.0.0",
  "description": "Shared API client utilities for abe-stack (web/desktop/mobile)",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc --project tsconfig.json",
    "dev": "tsc --watch --project tsconfig.json",
    "clean": "rm -rf dist",
    "type-check": "tsc --noEmit"
  },
  "author": "",
  "license": "ISC",
  "sideEffects": false,
  "dependencies": {
    "@tanstack/react-query": "^5.59.9",
    "@abe-stack/shared": "workspace:*"
  },
  "devDependencies": {
    "typescript": "^5.9.3"
  }
}
```

#### packages/api-client/src/index.ts

```ts
export * from "./types";
```

#### packages/api-client/src/types.ts

```ts
import { loginRequestSchema, loginResponseSchema } from "@abe-stack/shared";
import { z } from "zod";

// Example shapes pulled from shared contracts; expand as APIs are added.
export type LoginRequest = z.infer<typeof loginRequestSchema>;
export type LoginResponse = z.infer<typeof loginResponseSchema>;

export interface ApiClientOptions {
  baseUrl?: string;
  fetchImpl?: typeof fetch;
}
```

#### packages/api-client/tsconfig.json

```json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src",
    "composite": true,
    "declaration": true,
    "declarationMap": true,
    "tsBuildInfoFile": "./node_modules/.cache/tsconfig.api-client.tsbuildinfo",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "**/*.test.ts", "**/*.spec.ts"]
}
```

#### packages/shared/package.json

```json
{
  "name": "@abe-stack/shared",
  "version": "1.0.0",
  "description": "Shared utilities, types, and constants for abe-stack",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "exports": {
    ".": {
      "import": "./dist/index.js",
      "types": "./dist/index.d.ts"
    }
  },
  "scripts": {
    "build": "tsc --project tsconfig.json",
    "dev": "tsc --watch --project tsconfig.json",
    "clean": "rm -rf dist",
    "type-check": "tsc --noEmit"
  },
  "keywords": [
    "abe-stack",
    "shared",
    "utilities"
  ],
  "author": "",
  "license": "ISC",
  "sideEffects": false,
  "dependencies": {
    "zod": "^4.1.13"
  },
  "devDependencies": {
    "@types/node": "^25.0.3",
    "typescript": "^5.9.3"
  }
}
```

#### packages/shared/src/constants/index.ts

```ts
// Shared constants
// Add your shared constants here

export {};
```

#### packages/shared/src/contracts/auth.ts

```ts
import { z } from "zod";

export const loginRequestSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
});

export const loginResponseSchema = z.object({
  token: z.string(),
  refreshToken: z.string().optional(),
  userId: z.string().uuid(),
});

export const registerRequestSchema = z.object({
  email: z.string().email(),
  username: z.string().min(3),
  password: z.string().min(8),
});

export const registerResponseSchema = z.object({
  userId: z.string().uuid(),
  email: z.string().email(),
  username: z.string(),
});

export type LoginRequest = z.infer<typeof loginRequestSchema>;
export type LoginResponse = z.infer<typeof loginResponseSchema>;
export type RegisterRequest = z.infer<typeof registerRequestSchema>;
export type RegisterResponse = z.infer<typeof registerResponseSchema>;
```

#### packages/shared/src/contracts/index.ts

```ts
export * from "./auth";
```

#### packages/shared/src/env.ts

```ts
import { z } from "zod";

export const serverEnvSchema = z.object({
  DATABASE_URL: z.string().url(),
  REDIS_URL: z.string().url(),
  PORT: z.coerce.number().default(8080),
});

export type ServerEnv = z.infer<typeof serverEnvSchema>;

export function loadServerEnv(raw: Record<string, unknown>): ServerEnv {
  const parsed = serverEnvSchema.safeParse(raw);
  if (!parsed.success) {
    // eslint-disable-next-line no-console
    console.error("Invalid server environment variables", parsed.error.format());
    process.exit(1);
  }
  return parsed.data;
}
```

#### packages/shared/src/index.ts

```ts
// Shared types, utilities, and constants
export * from './types';
export * from './utils';
export * from './constants';
export * from './env';
export * from './contracts';
```

#### packages/shared/src/types/index.ts

```ts
// Shared types
// Add your shared TypeScript types here

export {};
```

#### packages/shared/src/utils/index.ts

```ts
// Shared utilities
// Add your shared utility functions here

export {};
```

#### packages/shared/tsconfig.json

```json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src",
    "composite": true,
    "declaration": true,
    "declarationMap": true,
    "tsBuildInfoFile": "./node_modules/.cache/tsconfig.shared.tsbuildinfo"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "**/*.test.ts", "**/*.spec.ts"]
}
```

#### packages/ui/package.json

```json
{
  "name": "@abe-stack/ui",
  "version": "1.0.0",
  "description": "Shared UI components for abe-stack (web, desktop, mobile)",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "exports": {
    ".": {
      "import": "./dist/index.js",
      "types": "./dist/index.d.ts"
    }
  },
  "scripts": {
    "build": "tsc --project tsconfig.json",
    "dev": "tsc --watch --project tsconfig.json",
    "clean": "rm -rf dist",
    "type-check": "tsc --noEmit"
  },
  "keywords": [
    "abe-stack",
    "ui",
    "components",
    "react"
  ],
  "author": "",
  "license": "ISC",
  "sideEffects": false,
  "dependencies": {
    "@abe-stack/shared": "workspace:*"
  },
  "peerDependencies": {
    "react": "^19.2.3",
    "react-dom": "^19.2.3",
    "react-router-dom": "^7.11.0"
  },
  "devDependencies": {
    "@types/react": "^19.2.7",
    "@types/react-dom": "^19.2.3",
    "typescript": "^5.9.3"
  }
}
```

#### packages/ui/src/components/Badge.tsx

```tsx
import React from "react";

export function Badge(props: {
  children: React.ReactNode;
  style?: React.CSSProperties;
  onClick?: React.MouseEventHandler;
  onKeyDown?: React.KeyboardEventHandler;
  tabIndex?: 0 | -1;
}) {
  return (
    <div
      style={{
        display: "inline-block",
        fontSize: "0.8em",
        padding: "0.2em 0.4em",
        borderRadius: "0.2em",
        backgroundColor: "var(--gray3)",
        ...props.style,
      }}
      tabIndex={props.tabIndex}
      onClick={props.onClick}
      onKeyDown={props.onKeyDown}
    >
      {props.children}
    </div>
  );
}
```

#### packages/ui/src/components/Box/index.native.tsx

```tsx
import React from "react";
import { View, type ViewStyle } from "react-native";
import type { BoxProps } from "./types";

export const Box = ({
  children,
  style,
  padding,
  flexDirection,
}: BoxProps) => {
  const nativeStyle: ViewStyle = {
    flexDirection: flexDirection || "column",
    padding: typeof padding === "number" ? padding : 0,
    ...(style as ViewStyle),
  };

  return <View style={nativeStyle}>{children}</View>;
};
```

#### packages/ui/src/components/Box/index.web.tsx

```tsx
import React from "react";
import type { BoxProps } from "./types";

export const Box = ({
  children,
  style,
  className,
  padding,
  flexDirection,
}: BoxProps) => {
  const combinedStyle: React.CSSProperties = {
    display: "flex",
    flexDirection: flexDirection || "column",
    padding,
    ...style,
  };

  return (
    <div className={className} style={combinedStyle}>
      {children}
    </div>
  );
};
```

#### packages/ui/src/components/Box/types.ts

```ts
import type { ReactNode, CSSProperties } from "react";

export interface BoxProps {
  children?: ReactNode;
  style?: CSSProperties;
  className?: string;
  padding?: number | string;
  flexDirection?: "row" | "column";
}
```

#### packages/ui/src/components/Button.tsx

```tsx
import { ComponentPropsWithoutRef, forwardRef } from "react";
import "./button.css";

interface ButtonProps extends ComponentPropsWithoutRef<"button"> {
  variant?: "primary" | "secondary" | "text";
  size?: "small" | "medium" | "large";
}

const Button = forwardRef<HTMLButtonElement, ButtonProps>((props, ref) => {
  const {
    variant = "primary",
    size = "medium",
    className = "",
    ...rest
  } = props;
  const buttonClass = `btn btn-${variant} btn-${size} ${className}`;

  return <button ref={ref} className={buttonClass} {...rest} />;
});

Button.displayName = "Button";

export { Button };
export default Button;
```

#### packages/ui/src/components/Card.tsx

```tsx
import React from "react";

interface CardProps extends React.HTMLAttributes<HTMLDivElement> {
  children: React.ReactNode;
  className?: string;
}

export const Card: React.FC<CardProps> = ({
  children,
  className = "",
  ...props
}) => {
  return (
    <div
      className={`bg-white shadow-md rounded-lg overflow-hidden ${className}`}
      {...props}
    >
      {children}
    </div>
  );
};
```

#### packages/ui/src/components/ComboBox.tsx

```tsx
import React, {
  useEffect,
  useLayoutEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { Button } from "./Button";
import { FuzzyString } from "./FuzzyString";
import { Input } from "./Input";
import { MenuItem } from "./MenuItem";
import { Popup, PopupFrame } from "./Popup";
import { fuzzyMatch } from "../../../server/shared/utils";
import { useRefPrevious } from "../../hooks/useRefPrevious";
import { isShortcut } from "../../hooks/useShortcut";

interface ComboBoxProps<T> {
  items: T[];
  renderItem: (item: T) => React.ReactNode;
  onSelect: (item: T) => void;
  value?: T;
  placeholder?: string;
  onChange?: (value: T) => void;
}

export function ComboBox<T>({
  items,
  renderItem,
  onSelect,
  value,
  placeholder,
  onChange,
}: ComboBoxProps<T>) {
  const [open, setOpen] = useState(false);
  const [search, setSearch] = useState("");
  const buttonRef = useRef<HTMLButtonElement>(null);
  const [hoveredIndex, setHoveredIndex] = useState<number | null>(null);

  const filteredItems = items.filter((item) => {
    const renderedItem = renderItem(item);
    if (typeof renderedItem === "string") {
      return renderedItem.toLowerCase().includes(search.toLowerCase());
    }
    return true; // Skip filtering for non-string items
  });

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        buttonRef.current &&
        !buttonRef.current.contains(event.target as Node)
      ) {
        setOpen(false);
      }
    };

    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, []);

  const handleSelect = (item: T) => {
    onSelect(item);
    onChange?.(item);
    setOpen(false);
    setSearch("");
  };

  return (
    <div>
      <Button ref={buttonRef} onClick={() => setOpen(!open)}>
        {value ? renderItem(value) : placeholder || "Select..."}
      </Button>
      {open && buttonRef.current && (
        <Popup
          open={open}
          anchor={buttonRef.current}
          onDismiss={() => setOpen(false)}
        >
          <div
            style={{
              padding: "0.5rem",
              backgroundColor: "white",
              borderRadius: "0.25rem",
              boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)",
            }}
          >
            <div style={{ marginBottom: "0.5rem" }}>
              <Input
                value={search}
                onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
                  setSearch(e.target.value)
                }
                placeholder="Search..."
              />
            </div>
            <div style={{ maxHeight: "200px", overflowY: "auto" }}>
              {filteredItems.map((item, index) => (
                <div
                  key={index}
                  onClick={() => handleSelect(item)}
                  onMouseEnter={() => setHoveredIndex(index)}
                  onMouseLeave={() => setHoveredIndex(null)}
                  style={{
                    padding: "0.5rem",
                    cursor: "pointer",
                    backgroundColor:
                      value === item || hoveredIndex === index
                        ? "#e2e8f0"
                        : "transparent",
                    transition: "background-color 0.2s ease",
                  }}
                >
                  {renderItem(item)}
                </div>
              ))}
            </div>
          </div>
        </Popup>
      )}
    </div>
  );
}

export function ComboBoxSelect(props: {
  items: string[];
  placeholder: string;
  value: string | undefined;
  onChange: (value: string) => void;
}) {
  const [open, setOpen] = React.useState(false);
  const buttonRef = useRef<HTMLButtonElement>(null);
  const prevOpen = useRefPrevious(open);

  useLayoutEffect(() => {
    if (prevOpen.current && !open) {
      buttonRef.current?.focus();
    }
  }, [prevOpen, open]);

  if (open) {
    return (
      <ComboBoxSearch
        autoFocus
        items={props.items}
        value={props.value}
        onChange={(newValue: string) => {
          props.onChange(newValue);
          setOpen(false);
        }}
        onDismiss={() => {
          setOpen(false);
        }}
      />
    );
  }

  return (
    <Button
      ref={buttonRef}
      onClick={() => setOpen(true)}
      style={{ textAlign: "left" }}
    >
      {props.value || (
        <span style={{ color: "var(--text-color2" }}>{props.placeholder} </span>
      )}{" "}
      <span style={{ fontSize: "0.7rem", verticalAlign: "middle" }}>▼</span>
    </Button>
  );
}

export function ComboBoxSearch(props: {
  items: string[];
  value: string | undefined;
  onChange: (value: string) => void;
  onDismiss?: () => void;
  autoFocus?: boolean;
  notice?: React.ReactNode;
}) {
  const inputRef = useRef<HTMLInputElement>(null);
  const [focused, setFocused] = useState(false);

  useEffect(() => {
    if (props.autoFocus) inputRef.current?.focus();
  }, [props.autoFocus]);

  const [text, setText] = useState("");

  const filteredItems = useMemo(() => {
    return props.items
      .map((str) => ({ value: str, match: fuzzyMatch(text, str) || undefined }))
      .filter(({ match }) => Boolean(match));
  }, [text, props.items]);

  const [selectedIndex, setSelectedIndex] = useState(0);

  const handleKeydown = (event: React.KeyboardEvent) => {
    if (isShortcut("down", event.nativeEvent)) {
      event.preventDefault();
      setSelectedIndex((i) => {
        if (i >= filteredItems.length - 1) return filteredItems.length - 1;
        else return i + 1;
      });
      return;
    }
    if (isShortcut("up", event.nativeEvent)) {
      event.preventDefault();
      setSelectedIndex((i) => {
        if (i === 0) return i;
        else return i - 1;
      });
      return;
    }
    if (isShortcut("enter", event.nativeEvent)) {
      event.preventDefault();
      if (filteredItems[selectedIndex]) {
        props.onChange(filteredItems[selectedIndex].value);
      }
      return;
    }
    if (isShortcut("escape", event.nativeEvent)) {
      event.preventDefault();
      props.onDismiss?.();
      return;
    }
  };

  // TODO: filter selected on key change to maintain selectedIndex position?
  return (
    <>
      <Input
        ref={inputRef}
        onFocus={() => setFocused(true)}
        onBlur={() => {
          setFocused(false);
          props.onDismiss?.();
        }}
        value={text}
        onChange={(e) => {
          setText(e.target.value);
          setSelectedIndex(0);
        }}
        onKeyDown={handleKeydown}
      />

      <Popup
        open={focused && filteredItems.length > 0}
        anchor={inputRef.current}
        onDismiss={props.onDismiss}
      >
        <PopupFrame>
          {props.notice}
          {filteredItems.map((item, i) => (
            <MenuItem
              key={item.value}
              selected={selectedIndex === i}
              onClick={() => props.onChange(item.value)}
              onMouseDown={(e) => e.preventDefault()}
              onMouseEnter={() => setSelectedIndex(i)}
            >
              <FuzzyString match={item.match} />
            </MenuItem>
          ))}
        </PopupFrame>
      </Popup>
    </>
  );
}
```

#### packages/ui/src/components/DropdownMenu.tsx

```tsx
import React, { CSSProperties } from "react";

import { usePopper } from "../../hooks/usePopper";

interface DropdownMenuProps {
  style?: CSSProperties;
  items: Array<{
    label: string;
    onClick: () => void;
  }>;
  onClose: () => void;
}

export function DropdownMenu({ style, items, onClose }: DropdownMenuProps) {
  const [referenceElement, _setReferenceElement] =
    React.useState<HTMLElement | null>(null);
  const [popperElement, setPopperElement] = React.useState<HTMLElement | null>(
    null,
  );
  const [selectedIndex, setSelectedIndex] = React.useState(0);
  const [hoveredIndex, setHoveredIndex] = React.useState<number | null>(null);

  const popperInstance = usePopper(referenceElement, popperElement, {
    placement: "bottom-start",
    modifiers: [
      {
        name: "offset",
        options: {
          offset: [0, 4],
        },
      },
    ],
  }) as unknown as {
    styles: { popper: CSSProperties };
    attributes: { popper: Record<string, string> };
  };

  // Default empty styles and attributes if they don't exist
  const styles = popperInstance.styles || {};
  const attributes = popperInstance.attributes || {};

  React.useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        popperElement &&
        !popperElement.contains(event.target as Node) &&
        referenceElement &&
        !referenceElement.contains(event.target as Node)
      ) {
        onClose();
      }
    };

    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [popperElement, referenceElement, onClose]);

  const handleKeyDown = (event: React.KeyboardEvent) => {
    switch (event.key) {
      case "ArrowDown":
        event.preventDefault();
        setSelectedIndex((i) => (i + 1) % items.length);
        break;
      case "ArrowUp":
        event.preventDefault();
        setSelectedIndex((i) => (i - 1 + items.length) % items.length);
        break;
      case "Enter":
        event.preventDefault();
        items[selectedIndex].onClick();
        onClose();
        break;
      case "Escape":
        event.preventDefault();
        onClose();
        break;
    }
  };

  return (
    <div style={style} onKeyDown={handleKeyDown}>
      <div ref={setPopperElement} style={styles.popper} {...attributes.popper}>
        {items.map((item, i) => (
          <div
            key={i}
            onClick={() => {
              item.onClick();
              onClose();
            }}
            onMouseEnter={() => setHoveredIndex(i)}
            onMouseLeave={() => setHoveredIndex(null)}
            style={{
              padding: "0.5rem 1rem",
              cursor: "pointer",
              backgroundColor:
                i === selectedIndex || i === hoveredIndex
                  ? "#e2e8f0"
                  : "transparent",
              transition: "background-color 0.2s ease",
            }}
          >
            {item.label}
          </div>
        ))}
      </div>
    </div>
  );
}
```

#### packages/ui/src/components/FileUpload.tsx

```tsx
import React, {
  ChangeEvent,
  ComponentPropsWithoutRef,
  DragEvent,
  useRef,
  useState,
} from "react";

import { DeferredPromise } from "@infrastructure/promises";
import { randomId } from "@infrastructure/utils/randomId";

import { passthroughRef } from "../../helpers/passthroughRef";

interface Upload {
  id: string;
  file: File;
  promise: DeferredPromise<void>;
  uploaded?: boolean;
}

interface FileUploadProps extends ComponentPropsWithoutRef<"div"> {
  onFileSelect: (file: File) => void;
  accept?: string;
  multiple?: boolean;
}

export function FileUpload({
  onFileSelect,
  accept,
  multiple,
  ...props
}: FileUploadProps) {
  const [isDragging, setIsDragging] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleDragOver = (event: DragEvent<HTMLDivElement>) => {
    event.preventDefault();
    setIsDragging(true);
  };

  const handleDragLeave = (event: DragEvent<HTMLDivElement>) => {
    event.preventDefault();
    setIsDragging(false);
  };

  const handleDrop = (event: DragEvent<HTMLDivElement>) => {
    event.preventDefault();
    setIsDragging(false);

    const files = Array.from(event.dataTransfer.files);
    if (files.length > 0) {
      onFileSelect(files[0]);
    }
  };

  const handleClick = () => {
    fileInputRef.current?.click();
  };

  const handleFileChange = (event: ChangeEvent<HTMLInputElement>) => {
    const files = event.target.files;
    if (files && files.length > 0) {
      onFileSelect(files[0]);
    }
  };

  return (
    <div
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
      onDrop={handleDrop}
      onClick={handleClick}
      style={{
        border: `2px dashed ${isDragging ? "#3b82f6" : "#e2e8f0"}`,
        borderRadius: "0.5rem",
        padding: "2rem",
        textAlign: "center",
        cursor: "pointer",
        backgroundColor: isDragging ? "rgba(59, 130, 246, 0.1)" : "transparent",
        transition: "all 0.2s ease",
        ...props.style,
      }}
      {...props}
    >
      <input
        ref={fileInputRef}
        type="file"
        accept={accept}
        multiple={multiple}
        onChange={handleFileChange}
        style={{ display: "none" }}
      />
      {isDragging ? "Drop files here" : "Click or drag files here to upload"}
    </div>
  );
}

export default FileUpload;

export function useFileUpload(
  onUpload: (
    file: File,
    onProgress: (progress: number) => void,
  ) => Promise<void>,
) {
  const [uploads, setUploads] = useState<Upload[]>([]);

  const handleDrop = async (event: DragEvent<HTMLDivElement>) => {
    event.preventDefault();
    const files = Array.from(event.dataTransfer.files);
    for (const file of files) {
      const upload: Upload = {
        id: randomId(),
        file,
        promise: new DeferredPromise(),
      };
      setUploads((uploads) => [...uploads, upload]);
      try {
        await onUpload(file, (_progress) => {
          // Update progress
        });
        upload.uploaded = true;
        upload.promise.resolve();
      } catch (error) {
        upload.promise.reject(error);
      }
    }
  };

  return {
    uploads,
    handleDrop,
  };
}

export function UploadPreview({ file, uploaded }: Upload) {
  const [preview, setPreview] = useState<string | null>(null);

  React.useEffect(() => {
    const reader = new FileReader();
    reader.onloadend = () => {
      setPreview(reader.result as string);
    };
    reader.readAsDataURL(file);
  }, [file]);

  return (
    <div
      style={{
        display: "flex",
        alignItems: "center",
        gap: "1rem",
        padding: "0.5rem",
        borderRadius: "0.25rem",
        backgroundColor: "#f8fafc",
      }}
    >
      {preview && (
        <img
          src={preview}
          alt={file.name}
          style={{
            width: "2rem",
            height: "2rem",
            objectFit: "cover",
            borderRadius: "0.25rem",
          }}
        />
      )}
      <div style={{ flex: 1 }}>{file.name}</div>
      <div>{uploaded ? "✅" : "❌"}</div>
    </div>
  );
}

export const FileUploadDropZone = passthroughRef(
  (
    props: ComponentPropsWithoutRef<"div"> & {
      selected?: boolean;
    },
  ) => {
    const [isDragging, setIsDragging] = useState(false);

    const handleDragEnter = (e: React.DragEvent<HTMLDivElement>) => {
      e.preventDefault();
      setIsDragging(true);
    };

    const handleDragExit = (e: React.DragEvent<HTMLDivElement>) => {
      e.preventDefault();
      setIsDragging(false);
    };

    const handleDragOver = (e: React.DragEvent<HTMLDivElement>) => {
      e.preventDefault();
    };

    const handleDrop = (e: React.DragEvent<HTMLDivElement>) => {
      setIsDragging(false);
      props.onDrop?.(e);
    };

    return (
      <div
        {...props}
        onDragEnter={handleDragEnter}
        onDragExit={handleDragExit}
        onDragOver={handleDragOver}
        onDrop={handleDrop}
        style={{
          border: isDragging
            ? "3px dashed var(--blue)"
            : "3px solid transparent",
          ...props.style,
        }}
      />
    );
  },
);

export async function uploadFile(
  file: File,
  url: string,
  onProgress: (progress: number) => void,
) {
  const xhr = new XMLHttpRequest();
  xhr.open("PUT", url, true);

  // Update progress
  xhr.upload.addEventListener("progress", (event) => {
    if (!event.lengthComputable) return;
    const progress = Math.round((event.loaded / event.total) * 100);
    onProgress(progress);
  });

  const deferred = new DeferredPromise<void>();

  // Handle errors
  xhr.onerror = (error) => {
    deferred.reject(error);
  };

  xhr.onreadystatechange = () => {
    if (xhr.readyState === XMLHttpRequest.DONE) {
      if (xhr.status === 200) {
        deferred.resolve();
      } else {
        const error = new Error(`UploadError: ${xhr.status} ${xhr.statusText}`);
        deferred.reject(error);
      }
    }
  };

  xhr.send(file);

  return deferred.promise;
}

const MB = 1024 * 1024;

export async function _renderPreview(file: File) {
  const deferred = new DeferredPromise<string | undefined>();

  if (file.type.startsWith("image/") && file.size <= 10 * MB) {
    const reader = new FileReader();
    reader.onload = (e) => {
      const preview = e.target?.result as string;
      deferred.resolve(preview);
    };
    reader.readAsDataURL(file);
  } else {
    deferred.resolve(undefined);
  }

  return deferred.promise;
}

export function FileUploadArea(
  props: ComponentPropsWithoutRef<"div"> & {
    onFileSelect: (files: FileList) => void;
    accept?: string;
    multiple?: boolean;
  },
): React.ReactElement {
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleClick = () => {
    fileInputRef.current?.click();
  };

  const handleFileChange = (event: ChangeEvent<HTMLInputElement>) => {
    const files = event.target.files;
    if (files) {
      props.onFileSelect(files);
    }
  };

  return (
    <div
      onClick={handleClick}
      style={{
        border: "2px dashed var(--border-color)",
        borderRadius: "0.5rem",
        padding: "2rem",
        textAlign: "center",
        cursor: "pointer",
        ...props.style,
      }}
      {...props}
    >
      <input
        ref={fileInputRef}
        type="file"
        accept={props.accept}
        multiple={props.multiple}
        onChange={handleFileChange}
        style={{ display: "none" }}
      />
      Click to select files
    </div>
  );
}
```

#### packages/ui/src/components/FuzzyString.tsx

```tsx
import { FuzzyMatchResult } from "../../../server/shared/utils";

interface FuzzyStringProps {
  match?: FuzzyMatchResult[];
  text?: string;
}

export function FuzzyString({ match, text }: FuzzyStringProps) {
  if (!match) {
    return <span>{text}</span>;
  }

  return (
    <span>
      {match.map((item, i) => (
        <span
          key={i}
          style={{
            fontWeight: "match" in item ? "bold" : "normal",
            color: "match" in item ? "#3b82f6" : "inherit",
          }}
        >
          {"match" in item ? item.match : item.skip}
        </span>
      ))}
    </span>
  );
}
```

#### packages/ui/src/components/Input.tsx

```tsx
import { ComponentPropsWithoutRef, forwardRef } from "react";

export const Input = forwardRef<
  HTMLInputElement,
  ComponentPropsWithoutRef<"input">
>((props, ref) => {
  return (
    <input
      ref={ref}
      {...props}
      style={{
        padding: "0.5rem",
        border: "1px solid #e2e8f0",
        borderRadius: "0.25rem",
        outline: "none",
        width: "100%",
        ...props.style,
      }}
    />
  );
});

Input.displayName = "Input";

// Also export as default for backward compatibility
export default Input;
```

#### packages/ui/src/components/Link.tsx

```tsx
import React from "react";

import { useClientEnvironment } from "../../services/ClientEnvironment";
import { Route, useRoute } from "../../services/Router";

interface LinkProps extends React.AnchorHTMLAttributes<HTMLAnchorElement> {
  to: string;
  activeStyle?: React.CSSProperties;
  activeClass?: string;
}

export function Link({
  to,
  activeStyle,
  activeClass,
  style,
  className,
  onClick,
  ...props
}: LinkProps) {
  const environment = useClientEnvironment();
  const route = useRoute();

  // Determine if this link is active based on the current route
  const isActive = isLinkActive(route, to);

  const handleClick = (event: React.MouseEvent<HTMLAnchorElement>) => {
    event.preventDefault();
    if (onClick) {
      onClick(event);
    }
    environment.router.navigate(to);
  };

  return (
    <a
      {...props}
      href={to}
      onClick={handleClick}
      style={{
        ...style,
        ...(isActive ? activeStyle : {}),
      }}
      className={`${className || ""} ${isActive ? activeClass || "" : ""}`}
    />
  );
}

// Helper function to determine if a link is active based on the current route
function isLinkActive(route: Route, to: string): boolean {
  if (to === "/" && route.type === "root") {
    return true;
  }

  if (to === "/home" && route.type === "home") {
    return true;
  }

  if (to === "/media" && route.type === "media") {
    return true;
  }

  if (to === "/social" && route.type === "social") {
    return true;
  }

  if (to === "/settings" && route.type === "settings") {
    return true;
  }

  if (to === "/dashboard" && route.type === "dashboard") {
    return true;
  }

  if (to === "/profile" && route.type === "profile") {
    return true;
  }

  if (to === "/upload" && route.type === "upload") {
    return true;
  }

  if (to === "/explore" && route.type === "explore") {
    return true;
  }

  if (to === "/notifications" && route.type === "notifications") {
    return true;
  }

  if (to.startsWith("/design/") && route.type === "design") {
    return to.slice("/design/".length) === route.page;
  }

  return false;
}
```

#### packages/ui/src/components/ListBox.tsx

```tsx
import React, { ComponentPropsWithoutRef } from "react";

interface ListBoxProps<T> {
  items: T[];
  selectedIndex: number;
  onSelectIndex: (index: number) => void;
  children: (item: T, props: ListItemProps) => React.ReactNode;
  autoFocus?: boolean;
}

interface ListItemProps extends ComponentPropsWithoutRef<"div"> {
  selected?: boolean;
}

export function ListBox<T>({
  items,
  selectedIndex,
  onSelectIndex,
  children,
  autoFocus,
}: ListBoxProps<T>) {
  const containerRef = React.useRef<HTMLDivElement>(null);

  React.useEffect(() => {
    if (autoFocus) {
      containerRef.current?.focus();
    }
  }, [autoFocus]);

  const handleKeyDown = (event: React.KeyboardEvent) => {
    switch (event.key) {
      case "ArrowDown":
        event.preventDefault();
        onSelectIndex((selectedIndex + 1) % items.length);
        break;
      case "ArrowUp":
        event.preventDefault();
        onSelectIndex((selectedIndex - 1 + items.length) % items.length);
        break;
      case "Enter":
        event.preventDefault();
        // Handle selection
        break;
    }
  };

  return (
    <div
      ref={containerRef}
      tabIndex={0}
      onKeyDown={handleKeyDown}
      style={{
        outline: "none",
      }}
    >
      {items.map((item, index) =>
        children(item, {
          key: index,
          onClick: () => onSelectIndex(index),
          selected: index === selectedIndex,
        }),
      )}
    </div>
  );
}

export function ListItem({ selected, style, ...props }: ListItemProps) {
  return (
    <div
      {...props}
      style={{
        cursor: "pointer",
        backgroundColor: selected ? "#e2e8f0" : "transparent",
        transition: "background-color 0.2s ease",
        ...style,
      }}
    />
  );
}
```

#### packages/ui/src/components/MenuItem.tsx

```tsx
import React, { ComponentPropsWithoutRef } from "react";

interface MenuItemProps extends ComponentPropsWithoutRef<"div"> {
  selected?: boolean;
  onSubmit?: () => void;
}

export function MenuItem({
  selected,
  onSubmit,
  style,
  ...props
}: MenuItemProps) {
  const handleKeyDown = (event: React.KeyboardEvent) => {
    if (event.key === "Enter" && onSubmit) {
      event.preventDefault();
      onSubmit();
    }
  };

  return (
    <div
      role="menuitem"
      tabIndex={0}
      onKeyDown={handleKeyDown}
      style={{
        padding: "0.5rem 1rem",
        cursor: "pointer",
        backgroundColor: selected ? "#e2e8f0" : "transparent",
        transition: "background-color 0.2s ease",
        ...style,
      }}
      {...props}
    />
  );
}
```

#### packages/ui/src/components/OfflineBadge.tsx

```tsx
import { Badge } from "./Badge";
import { useOnline } from "../../hooks/useOnline";

export function OfflineBadge() {
  const online = useOnline();
  return (
    <Badge style={{ backgroundColor: online ? undefined : "var(--orange)" }}>
      {online ? "Online" : <strong>Offline</strong>}
    </Badge>
  );
}
```

#### packages/ui/src/components/Popup.tsx

```tsx
import React, { useLayoutEffect, useMemo } from "react";
import { createPortal } from "react-dom";

import { passthroughRef } from "../../helpers/passthroughRef";
import { Placement, createPopper } from "../../hooks/usePopper";
import { useShortcut } from "../../hooks/useShortcut";

export function Popup(props: {
  open: boolean;
  anchor: HTMLElement | undefined | null;
  placement?: Placement;
  children?: React.ReactNode;
  onDismiss?: () => void;
}) {
  // Create the overlay div.
  const container = useMemo(() => {
    const div = document.createElement("div");
    document.body.appendChild(div);
    return div;
  }, []);

  useMemo(() => {
    container.style.visibility = props.open ? "visible" : "hidden";
  }, [container.style, props.open]);

  // Cleanup
  useLayoutEffect(() => {
    return () => {
      document.body.removeChild(container);
    };
  }, [container]);

  // Render the popup
  useLayoutEffect(() => {
    if (!props.anchor) return;
    if (!props.open) return;

    const popupDiv = (
      props.onDismiss ? container.children[1] : container.children[0]
    ) as HTMLElement;

    const popper = createPopper(props.anchor, popupDiv, {
      placement: props.placement || "bottom-start",
      modifiers: [
        {
          name: "offset",
          options: {
            offset: [0, 8],
          },
        },
      ],
    });
    return () => {
      popper.destroy();
    };
  }, [
    container.children,
    props.onDismiss,
    props.placement,
    props.anchor,
    props.open,
  ]);

  const { onDismiss } = props;

  useShortcut("escape", () => onDismiss?.());

  // Render the portal
  if (!props.open) return false;
  else
    return createPortal(
      <>
        {onDismiss && (
          <div
            style={{ position: "fixed", top: 0, left: 0, right: 0, bottom: 0 }}
            onClick={() => onDismiss()}
          />
        )}
        {props.children}
      </>,
      container,
    );
}

export const PopupFrame = passthroughRef(
  (props: React.HTMLProps<HTMLDivElement>) => {
    return (
      <div
        {...props}
        className="popup"
        style={{
          background: "var(--popup-background)",
          boxShadow: "var(--shadow)",
          padding: 4,
          borderRadius: 4,
          ...props.style,
        }}
      />
    );
  },
);
```

#### packages/ui/src/components/Spinner.tsx

```tsx
/** Consider using <Loading/> instead. */
export function Spinner(props: { size?: string }) {
  return (
    <span
      style={{ height: props.size, width: props.size }}
      className="spinner"
    ></span>
  );
}
```

#### packages/ui/src/components/Throttle.tsx

```tsx
import React, { useEffect, useRef, useState } from "react";

// TODO: I don't think this thing works very well.

/**
 * Don't show the spinner unless we have a very slow request.
 * If we show the spinner, hold it for a moment.
 * Hold previous children while we wait for the spinner.
 */
export function Throttle(props: {
  showSpinner: boolean;
  showDelay?: number;
  showHold?: number;
  spinner: React.ReactNode;
  children: React.ReactNode;
}) {
  const showDelay = typeof props.showDelay === "number" ? props.showDelay : 300;
  const showHold = typeof props.showHold === "number" ? props.showHold : 300;

  const [showSpinner, setShowSpinner] = useState(false);

  useEffect(() => {
    let canceled = false;

    if (props.showSpinner && !showSpinner) {
      setTimeout(() => {
        if (canceled) return;
        setShowSpinner(true);
      }, showDelay);
    }

    if (!props.showSpinner && showSpinner) {
      setTimeout(() => {
        if (canceled) return;
        setShowSpinner(false);
      }, showHold);
    }

    return () => {
      canceled = true;
    };
  }, [showDelay, showHold, showSpinner, props.showSpinner]);

  const prevChildrenRef = useRef(props.children);
  const prevChildren = prevChildrenRef.current;
  prevChildrenRef.current = props.children;

  // If we're blocking the spinner, show previous children.
  if (props.showSpinner && !showSpinner) return prevChildren;
  if (showSpinner) return props.spinner;
  return props.children;
}
```

#### packages/ui/src/components/demos/BadgeDemo.tsx

```tsx
import { Badge } from "../Badge";

export function BadgeDemo() {
  return (
    <div style={{ display: "flex", gap: 4, padding: 12 }}>
      <Badge>Hello</Badge>
      <Badge style={{ background: "LightCoral", color: "white" }}>World</Badge>
      <Badge style={{ background: "PowderBlue" }}>Yay!</Badge>
    </div>
  );
}
```

#### packages/ui/src/components/demos/ButtonDemo.tsx

```tsx
import { Button } from "../Button";

export function ButtonDemo() {
  return (
    <div>
      <div style={{ marginBottom: 8 }}>
        <Button>Default Button</Button>
      </div>
      <div style={{ marginBottom: 8 }}>
        <Button variant="primary">Primary Button</Button>
      </div>
      <div style={{ marginBottom: 8 }}>
        <Button variant="text">Naked Button</Button>
      </div>
    </div>
  );
}
```

#### packages/ui/src/components/demos/CalendarDemo.tsx

```tsx
import { useMemo, useState } from "react";

// TODO: this is very much a work in progress!
export function CalendarDemo() {
  const initialDatetime = useMemo(() => {
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    tomorrow.setHours(9, 0, 0, 0);

    const tzOffset = tomorrow.getTimezoneOffset() * 60000;
    const localISOTime = new Date(tomorrow.getTime() - tzOffset);
    return localISOTime.toISOString().slice(0, "YYYY-MM-DDTHH:MM".length);
  }, []);

  const [datetime, setDatetime] = useState(initialDatetime);

  return (
    <div>
      <input
        type="datetime-local"
        value={datetime}
        onChange={(event) => setDatetime(event.target.value)}
      />
    </div>
  );
}
```

#### packages/ui/src/components/demos/ComboBoxDemo.tsx

```tsx
import { useState } from "react";

import { ComboBox } from "../ComboBox";

const items = [
  "Apple",
  "Banana",
  "Cherry",
  "Date",
  "Elderberry",
  "Fig",
  "Grape",
  "Honeydew",
  "Kiwi",
  "Lemon",
  "Mango",
  "Orange",
  "Papaya",
  "Quince",
  "Raspberry",
  "Strawberry",
  "Tangerine",
  "Ugli fruit",
  "Watermelon",
];

export function ComboBoxDemo() {
  const [value, setValue] = useState<string>();

  return (
    <div>
      <div style={{ marginBottom: 8 }}>
        <ComboBox
          items={items}
          renderItem={(item) => item}
          onSelect={setValue}
          value={value}
          placeholder="Select a fruit..."
        />
      </div>
      <div>Selected value: {value || "None"}</div>
    </div>
  );
}
```

#### packages/ui/src/components/demos/DropdownDemo.tsx

```tsx
import React, { useState } from "react";

import { Button } from "../Button";
import { DropdownMenu } from "../DropdownMenu";

export function DropdownDemo() {
  const [open, setOpen] = useState(false);
  const buttonRef = React.useRef<HTMLButtonElement>(null);

  return (
    <div>
      <Button ref={buttonRef} onClick={() => setOpen(true)}>
        Open Dropdown
      </Button>
      {open && (
        <DropdownMenu
          onClose={() => setOpen(false)}
          items={[
            { label: "Item 1", onClick: () => console.log("Item 1") },
            { label: "Item 2", onClick: () => console.log("Item 2") },
            { label: "Item 3", onClick: () => console.log("Item 3") },
          ]}
        />
      )}
    </div>
  );
}
```

#### packages/ui/src/components/demos/FileUploadDemo.tsx

```tsx
import { sleep } from "../../../../server/infrastructure/lifecycle/sleep";
import {
  FileUploadDropZone,
  UploadPreview,
  useFileUpload,
} from "../FileUpload";

export function FileUploadDemo() {
  const { uploads, handleDrop } = useFileUpload(async (_upload, onProgress) => {
    for (let i = 0; i < 100; i += Math.round(Math.random() * 10)) {
      await sleep(100);
      onProgress(i);
    }
  });

  return (
    <FileUploadDropZone
      onDrop={(files) => void handleDrop(files)}
      style={{ display: "inline-flex", flexWrap: "wrap", gap: 12, padding: 12 }}
    >
      {uploads.length === 0 && "Drop files here!"}
      {uploads.map((upload) => (
        <UploadPreview key={upload.id} {...upload} />
      ))}
    </FileUploadDropZone>
  );
}
```

#### packages/ui/src/components/demos/FormDemo.tsx

```tsx
import React, { useState } from "react";

import { ComboBox } from "../ComboBox";
import { Input } from "../Input";

const colors = ["Red", "Orange", "Yellow", "Green", "Blue", "Indigo", "Violet"];

// TODO: this is very much a work in progress!
export function FormDemo() {
  const [name, setName] = useState("");
  const [email, setEmail] = useState("");
  const [color, setColor] = useState<string>();

  return (
    <div>
      <div style={{ marginBottom: 8 }}>
        <label>
          Name:
          <Input
            value={name}
            onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
              setName(e.target.value)
            }
            placeholder="Enter your name"
          />
        </label>
      </div>
      <div style={{ marginBottom: 8 }}>
        <label>
          Email:
          <Input
            type="email"
            value={email}
            onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
              setEmail(e.target.value)
            }
            placeholder="Enter your email"
          />
        </label>
      </div>
      <div style={{ marginBottom: 8 }}>
        <label>
          Favorite Color:
          <ComboBox
            items={colors}
            renderItem={(item) => item}
            onSelect={setColor}
            value={color}
            placeholder="Select a color..."
          />
        </label>
      </div>
      <div>
        <div>Name: {name || "Not set"}</div>
        <div>Email: {email || "Not set"}</div>
        <div>Favorite Color: {color || "Not set"}</div>
      </div>
    </div>
  );
}
```

#### packages/ui/src/components/demos/FuzzyStringDemo.tsx

```tsx
import { useState } from "react";
import { FuzzyString } from "../FuzzyString";
import { Input } from "../Input";
import { fuzzyMatch } from "@/server/shared/utils";

const sampleTexts = [
  "hello world",
  "The quick brown fox jumps over the lazy dog",
  "Lorem ipsum dolor sit amet",
  "React is awesome",
  "TypeScript makes JavaScript better",
];

export function FuzzyStringDemo() {
  const [value, setValue] = useState("");

  return (
    <div>
      <div style={{ marginBottom: 8 }}>
        <Input
          value={value}
          onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
            setValue(e.target.value)
          }
          placeholder="Type to search..."
        />
      </div>
      <div style={{ display: "flex", flexDirection: "column", gap: "0.5rem" }}>
        {sampleTexts.map((text, i) => {
          const match = fuzzyMatch(value, text);
          return (
            <div key={i}>
              <FuzzyString match={match || undefined} text={text} />
            </div>
          );
        })}
      </div>
    </div>
  );
}
```

#### packages/ui/src/components/demos/ListBoxDemo.tsx

```tsx
import { useState } from "react";

import { ListBox, ListItem } from "../ListBox";

const items = ["Item 1", "Item 2", "Item 3", "Item 4", "Item 5"];

export function ListBoxDemo() {
  const [selectedIndex, setSelectedIndex] = useState(0);

  return (
    <div>
      <ListBox
        items={items}
        selectedIndex={selectedIndex}
        onSelectIndex={setSelectedIndex}
        autoFocus
      >
        {(item, props) => <ListItem {...props}>{item}</ListItem>}
      </ListBox>
      <div style={{ marginTop: 8 }}>Selected: {items[selectedIndex]}</div>
    </div>
  );
}
```

#### packages/ui/src/components/demos/PopupDemo.tsx

```tsx
import React, { useState } from "react";

import { Button } from "../Button";
import { Popup } from "../Popup";

export function PopupDemo() {
  const [open, setOpen] = useState(false);
  const buttonRef = React.useRef<HTMLButtonElement>(null);

  return (
    <div>
      <Button ref={buttonRef} onClick={() => setOpen(true)}>
        Open Popup
      </Button>
      <Popup
        open={open}
        anchor={buttonRef.current}
        onDismiss={() => setOpen(false)}
      >
        <div
          style={{
            padding: "1rem",
            backgroundColor: "white",
            borderRadius: "0.25rem",
            boxShadow: "0 2px 4px rgba(0, 0, 0, 0.1)",
          }}
        >
          This is a popup!
        </div>
      </Popup>
    </div>
  );
}
```

#### packages/ui/src/components/demos/SpinnerDemo.tsx

```tsx
import { Spinner } from "../Spinner";

// TODO: Throttle component
export function SpinnerDemo() {
  return (
    <div style={{ display: "flex", gap: 4, padding: 12 }}>
      <Spinner />
    </div>
  );
}
```

#### packages/ui/src/components/demos/TokenInputDemo.tsx

```tsx
export function TokenInputDemo() {
  return <div>Work in progress</div>;
}

// function TokenInput<T, V>(props: {
// 	tokens: T[]
// 	children: [
// 		(token: T, props: { selected: boolean }) => void,
// 		(value: V, props: { selected: boolean }) => void
// 	]

// 	text: string
// 	setText: (text: string) => void

// 	result:
// 		| { loading: true }
// 		| { loading: false; error: string }
// 		| { loading: false; error?: undefined; result: V[] }
// }) {
// 	return (
// 		<div>
// 			<ListBox items={[...props.tokens, "INPUT"]} selectedIndex={props.tokens.length} ></ListBox>

// 			{props.tokens.map((token) => props.children[0](token))}
// 			<span>
// 				<Input
// 					ref={inputRef}
// 					type="text"
// 					value={text}
// 					onChange={(e) => setText(e.target.value)}
// 					onFocus={() => setFocused(true)}
// 					onBlur={() => setFocused(false)}
// 				/>
// 				<Popup open={focused && text.length > 0} anchor={inputRef.current}>
// 					{error ? (
// 						<span style={{ color: "var(--red)" }}>{error}</span>
// 					) : !userIds ? (
// 						<Spinner />
// 					) : userIds.length === 0 ? (
// 						"No results..."
// 					) : (
// 						<ListBox items={userIds}>
// 							{(userId, { focused, selected }) => (
// 								<ListItem focused={focused} selected={selected}>
// 									<Username userId={userId} key={userId} />
// 								</ListItem>
// 							)}
// 						</ListBox>
// 					)}
// 				</Popup>
// 			</span>
// 		</div>
// 	)
// }
```

#### packages/ui/src/components/demos/autoindex.ts

```ts
/* WARNING: this file is generated! */

import * as BadgeDemo from "./BadgeDemo";
import * as ButtonDemo from "./ButtonDemo";
import * as CalendarDemo from "./CalendarDemo";
import * as ComboBoxDemo from "./ComboBoxDemo";
import * as DropdownDemo from "./DropdownDemo";
import * as FileUploadDemo from "./FileUploadDemo";
import * as FormDemo from "./FormDemo";
import * as FuzzyStringDemo from "./FuzzyStringDemo";
import * as ListBoxDemo from "./ListBoxDemo";
import * as PopupDemo from "./PopupDemo";
import * as SpinnerDemo from "./SpinnerDemo";
import * as TokenInputDemo from "./TokenInputDemo";

export {
  BadgeDemo,
  ButtonDemo,
  CalendarDemo,
  ComboBoxDemo,
  DropdownDemo,
  FileUploadDemo,
  FormDemo,
  FuzzyStringDemo,
  ListBoxDemo,
  PopupDemo,
  SpinnerDemo,
  TokenInputDemo,
};
```

#### packages/ui/src/components/index.ts

```ts
// Base UI Components
export { default as Badge } from './Badge';
export { default as Button } from './Button';
export { default as Card } from './Card';
export { default as ComboBox } from './ComboBox';
export { default as DropdownMenu } from './DropdownMenu';
export { default as FileUpload } from './FileUpload';
export { default as FuzzyString } from './FuzzyString';
export { default as Input } from './Input';
export { default as Link } from './Link';
export { default as ListBox } from './ListBox';
export { default as MenuItem } from './MenuItem';
export { default as OfflineBadge } from './OfflineBadge';
export { default as Popup } from './Popup';
export { default as Spinner } from './Spinner';
export { default as Throttle } from './Throttle';
export { Box } from './Box';
```

#### packages/ui/src/contexts/AuthContext.tsx

```tsx
import React, { createContext, useContext, useEffect, useState } from "react";

interface User {
  id: string;
  username: string;
  email: string;
  displayName: string | null;
  profileImage: string | null;
}

interface AuthResponse {
  status: string;
  data: {
    user: User;
  };
}

interface ErrorResponse {
  status: string;
  message: string;
}

interface AuthContextType {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  login: (email: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
  checkAuth: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | null>(null);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  const checkAuth = async () => {
    try {
      const response = await fetch("/api/auth/me", {
        credentials: "include",
      });

      if (response.ok) {
        const data = (await response.json()) as AuthResponse;
        setUser(data.data.user);
      } else {
        setUser(null);
      }
    } catch {
      setUser(null);
    } finally {
      setIsLoading(false);
    }
  };

  const login = async (email: string, password: string) => {
    setIsLoading(true);
    try {
      const response = await fetch("/api/auth/login", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        credentials: "include",
        body: JSON.stringify({ email, password }),
      });

      if (!response.ok) {
        const errorData = (await response.json()) as ErrorResponse;
        throw new Error(errorData.message || "Login failed");
      }

      const data = (await response.json()) as AuthResponse;
      setUser(data.data.user);
    } finally {
      setIsLoading(false);
    }
  };

  const logout = async () => {
    try {
      await fetch("/api/auth/logout", {
        method: "POST",
        credentials: "include",
      });
      setUser(null);
    } catch (error) {
      console.error("Logout failed:", error);
    }
  };

  useEffect(() => {
    void checkAuth();
  }, []);

  return (
    <AuthContext.Provider
      value={{
        user,
        isAuthenticated: !!user,
        isLoading,
        login,
        logout,
        checkAuth,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
};
```

#### packages/ui/src/contexts/SocialContext.tsx

```tsx
import React, {
  createContext,
  useCallback,
  useContext,
  useEffect,
  useState,
} from "react";

import { socialService } from "../services/social";

export interface User {
  id: string;
  username: string;
  displayName: string;
  avatar: string;
  bio: string;
  followersCount: number;
  followingCount: number;
  postsCount: number;
  isFollowing: boolean;
}

interface Post {
  id: string;
  userId: string;
  username: string;
  userAvatar: string;
  content: string;
  media?: {
    type: "image" | "video" | "audio";
    url: string;
    thumbnail?: string;
  };
  likesCount: number;
  commentsCount: number;
  sharesCount: number;
  isLiked: boolean;
  createdAt: string;
}

interface SocialContextType {
  currentUser: User | null;
  feed: Post[];
  isLoading: boolean;
  error: string | null;
  followUser: (userId: string) => Promise<void>;
  unfollowUser: (userId: string) => Promise<void>;
  likePost: (postId: string) => Promise<void>;
  unlikePost: (postId: string) => Promise<void>;
  sharePost: (postId: string) => Promise<void>;
  createPost: (content: string, media?: File) => Promise<void>;
  refreshFeed: () => Promise<void>;
}

const SocialContext = createContext<SocialContextType | null>(null);

export const useSocial = () => {
  const context = useContext(SocialContext);
  if (!context) {
    throw new Error("useSocial must be used within a SocialProvider");
  }
  return context;
};

interface SocialProviderProps {
  children: React.ReactNode;
}

export const SocialProvider: React.FC<SocialProviderProps> = ({ children }) => {
  const [currentUser, setCurrentUser] = useState<User | null>(null);
  const [feed, setFeed] = useState<Post[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const refreshFeed = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);
      const response = await socialService.getFeed("home");
      setFeed(response.posts);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to refresh feed");
    } finally {
      setIsLoading(false);
    }
  }, []);

  const initializeSocial = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);
      const user = await socialService.getUserProfile("current");
      setCurrentUser(user);
      await refreshFeed();
    } catch (err) {
      setError(
        err instanceof Error ? err.message : "Failed to initialize social",
      );
    } finally {
      setIsLoading(false);
    }
  }, [refreshFeed]);

  useEffect(() => {
    void initializeSocial();
  }, [initializeSocial]);

  const followUser = async (userId: string) => {
    try {
      setError(null);
      await socialService.followUser(userId);
      if (currentUser) {
        setCurrentUser({
          ...currentUser,
          followingCount: currentUser.followingCount + 1,
        });
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to follow user");
      throw err;
    }
  };

  const unfollowUser = async (userId: string) => {
    try {
      setError(null);
      await socialService.unfollowUser(userId);
      if (currentUser) {
        setCurrentUser({
          ...currentUser,
          followingCount: currentUser.followingCount - 1,
        });
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to unfollow user");
      throw err;
    }
  };

  const likePost = async (postId: string) => {
    try {
      setError(null);
      await socialService.likePost(postId);
      setFeed((prev) =>
        prev.map((post) =>
          post.id === postId
            ? { ...post, isLiked: true, likesCount: post.likesCount + 1 }
            : post,
        ),
      );
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to like post");
      throw err;
    }
  };

  const unlikePost = async (postId: string) => {
    try {
      setError(null);
      await socialService.unlikePost(postId);
      setFeed((prev) =>
        prev.map((post) =>
          post.id === postId
            ? { ...post, isLiked: false, likesCount: post.likesCount - 1 }
            : post,
        ),
      );
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to unlike post");
      throw err;
    }
  };

  const sharePost = async (postId: string) => {
    try {
      setError(null);
      await socialService.sharePost(postId);
      setFeed((prev) =>
        prev.map((post) =>
          post.id === postId
            ? { ...post, sharesCount: post.sharesCount + 1 }
            : post,
        ),
      );
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to share post");
      throw err;
    }
  };

  const createPost = async (content: string, media?: File) => {
    try {
      setError(null);
      const newPost = await socialService.createPost(content, media);
      setFeed((prev) => [newPost, ...prev]);
      if (currentUser) {
        setCurrentUser({
          ...currentUser,
          postsCount: currentUser.postsCount + 1,
        });
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to create post");
      throw err;
    }
  };

  const value = {
    currentUser,
    feed,
    isLoading,
    error,
    followUser,
    unfollowUser,
    likePost,
    unlikePost,
    sharePost,
    createPost,
    refreshFeed,
  };

  return (
    <SocialContext.Provider value={value}>{children}</SocialContext.Provider>
  );
};
```

#### packages/ui/src/contexts/index.ts

```ts
// Shared contexts
// Export contexts here as they are created
export {};
```

#### packages/ui/src/features/auth/AuthContext.tsx

```tsx
import {
  createContext,
  ReactNode,
  useContext,
  useEffect,
  useState,
} from "react";

// Inline auth API to avoid import issues
const authApi = {
  // Base API URL - use relative path for Vite proxy
  baseUrl: "/api",

  async login(email: string, password: string) {
    console.log("Login attempt with:", email);

    // Try to connect to the backend through the Vite proxy
    try {
      const response = await fetch(`${this.baseUrl}/auth/login`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ email, password }),
        credentials: "include",
      });

      if (!response.ok) {
        const errorData = await response.json();
        console.error("Login failed:", errorData);
        return {
          success: false,
          message: errorData.error || "Login failed",
        };
      }

      const data = await response.json();
      return {
        success: true,
        user: data.user,
        accessToken: data.accessToken,
        requireMfa: data.requireMfa,
        message: data.message,
      };
    } catch (error) {
      console.error("API connection error:", error);

      // Fall back to mock data for development
      return {
        success: true,
        message: "Using mock data: backend connection failed",
        user: {
          id: "123",
          username: "testuser",
          email,
          displayName: "Test User",
          firstName: "Test",
          lastName: "User",
          bio: null,
          profileImage: null,
          bannerImage: null,
          role: "user",
          isVerified: true,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
        },
        accessToken: "dummy-token-123",
      };
    }
  },

  async testDatabaseConnection() {
    try {
      const response = await fetch(`${this.baseUrl}/auth/test-db`);

      if (!response.ok) {
        const errorData = await response.json();
        console.error("Database test failed:", errorData);
        return {
          success: false,
          connected: false,
          message: errorData.error || "Database test failed",
        };
      }

      const data = await response.json();
      return {
        success: true,
        connected: Boolean(data.connected),
        message: data.message,
      };
    } catch (error) {
      console.error("Database test error:", error);
      return {
        success: false,
        connected: false,
        message: error instanceof Error ? error.message : "Connection error",
      };
    }
  },

  async register(userData: any) {
    console.log("Register attempt with:", userData.email);

    try {
      // Make actual API call to backend
      console.log("Registration data:", userData);

      const response = await fetch(`${this.baseUrl}/auth/register`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          email: userData.email,
          password: userData.password,
          firstName: userData.firstName,
          lastName: userData.lastName,
          username: userData.username,
        }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.message || "Registration failed");
      }

      console.log("Registration successful:", data);
      console.log("Verification email sent to:", userData.email);

      return {
        success: data.success,
        message: data.message,
        requireEmailVerification: data.requireEmailVerification,
        userId: data.userId,
      };
    } catch (error) {
      console.error("Registration API error:", error);
      return {
        success: false,
        message: error instanceof Error ? error.message : "Registration failed",
      };
    }
  },

  async logout() {
    return { success: true };
  },

  async refreshToken() {
    return { success: true, accessToken: "new-dummy-token-456" };
  },

  async getCurrentUser() {
    const userData = localStorage.getItem("user");
    if (userData) {
      return { success: true, user: JSON.parse(userData) };
    }
    return { success: false, message: "Not authenticated" };
  },
};

// Define the user type
interface User {
  id: string;
  username: string;
  email: string;
  displayName: string | null;
  firstName: string | null;
  lastName: string | null;
  bio: string | null;
  profileImage: string | null;
  bannerImage: string | null;
  role: string;
  isVerified: boolean;
  createdAt: string;
  updatedAt: string;
}

// Define the auth context type
interface AuthContextType {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  login: (email: string, password: string) => Promise<void>;
  register: (
    username: string,
    firstName: string,
    lastName: string,
    email: string,
    password: string
  ) => Promise<{ success: boolean; requireVerification: boolean } | void>;
  logout: () => void;
  error: string | null;
  showVerificationModal: boolean;
  setShowVerificationModal: (show: boolean) => void;
  verificationEmail: string;
  setVerificationEmail: (email: string) => void;
  testDatabaseConnection: () => Promise<{
    success: boolean;
    connected: boolean;
    message: string;
  }>;
}

// Create the auth context with default values
const AuthContext = createContext<AuthContextType>({
  user: null,
  isAuthenticated: false,
  isLoading: true,
  login: async () => {},
  register: async () => {},
  logout: () => {},
  error: null,
  showVerificationModal: false,
  setShowVerificationModal: () => {},
  verificationEmail: "",
  setVerificationEmail: () => {},
  testDatabaseConnection: async () => ({
    success: false,
    connected: false,
    message: "",
  }),
});

// Custom hook to use the auth context
export const useAuth = () => useContext(AuthContext);

interface AuthProviderProps {
  children: ReactNode;
}

export function AuthProvider({ children }: AuthProviderProps) {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showVerificationModal, setShowVerificationModal] = useState(false);
  const [verificationEmail, setVerificationEmail] = useState("");

  // Check authentication status on component mount
  useEffect(() => {
    const checkAuthStatus = async () => {
      try {
        // First test the auth API connection
        try {
          const response = await fetch(`${authApi.baseUrl}/auth/test`);
          if (response.ok) {
            const data = await response.json();
            console.log("Auth API connected:", data);
          } else {
            console.warn(
              "Auth API test failed:",
              response.status,
              response.statusText
            );
          }
        } catch (error) {
          console.error("Failed to connect to Auth API:", error);
        }

        // Test database connection
        try {
          const dbResult = await authApi.testDatabaseConnection();
          console.log("Database connection test:", dbResult);
          if (dbResult.success && dbResult.connected) {
            console.log("✅ Database connection successful");
          } else {
            console.warn("⚠️ Database connection failed:", dbResult.message);
          }
        } catch (error) {
          console.error("Database test error:", error);
        }

        // Check if we have a token
        const token = localStorage.getItem("token");
        if (!token) {
          setIsLoading(false);
          return;
        }

        // Validate token with the server
        const result = await authApi.getCurrentUser();

        if (result.success && result.user) {
          setUser(result.user);
          localStorage.setItem("user", JSON.stringify(result.user));
        } else {
          // Token invalid, try to refresh
          const refreshResult = await authApi.refreshToken();

          if (refreshResult.success && refreshResult.accessToken) {
            localStorage.setItem("token", refreshResult.accessToken);

            // Try to get user data again
            const userResult = await authApi.getCurrentUser();
            if (userResult.success && userResult.user) {
              setUser(userResult.user);
              localStorage.setItem("user", JSON.stringify(userResult.user));
            } else {
              throw new Error("Could not get user data");
            }
          } else {
            throw new Error("Token refresh failed");
          }
        }
      } catch (error) {
        console.error("Auth check error:", error);
        // Clear invalid auth data
        localStorage.removeItem("user");
        localStorage.removeItem("token");
      } finally {
        setIsLoading(false);
      }
    };

    void checkAuthStatus();
  }, []);

  // Login function
  const login = async (email: string, password: string) => {
    setIsLoading(true);
    setError(null);

    try {
      const result = await authApi.login(email, password);

      if (!result.success) {
        throw new Error(result.message || "Login failed");
      }

      // Check if MFA is required
      if (result.requireMfa) {
        setError(
          "Multi-factor authentication is required but not implemented in this demo"
        );
        throw new Error("Multi-factor authentication required");
      }

      // Save user data to localStorage
      localStorage.setItem("user", JSON.stringify(result.user));
      if (result.accessToken) {
        localStorage.setItem("token", result.accessToken);
      }

      // Update state
      setUser(result.user);
    } catch (error) {
      console.error("Login error:", error);
      setError(
        error instanceof Error
          ? error.message
          : "Login failed. Please try again."
      );
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  // Register function
  const register = async (
    username: string,
    firstName: string,
    lastName: string,
    email: string,
    password: string
  ) => {
    setIsLoading(true);
    setError(null);

    try {
      const result = await authApi.register({
        email,
        password,
        firstName,
        lastName,
        username,
      });

      if (!result.success) {
        throw new Error(result.message || "Registration failed");
      }

      // Always show verification email modal
      setVerificationEmail(email);
      setShowVerificationModal(true);

      return { success: true, requireVerification: true };
    } catch (error) {
      console.error("Registration error:", error);
      setError(
        error instanceof Error
          ? error.message
          : "Registration failed. Please try again."
      );
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  // Logout function
  const logout = async () => {
    try {
      await authApi.logout();
    } catch (error) {
      console.error("Logout error:", error);
    } finally {
      // Remove user data from localStorage
      localStorage.removeItem("user");
      localStorage.removeItem("token");

      // Update state
      setUser(null);
    }
  };

  // Create the context value
  const value = {
    user,
    isAuthenticated: !!user,
    isLoading,
    login,
    register,
    logout,
    error,
    showVerificationModal,
    setShowVerificationModal,
    verificationEmail,
    setVerificationEmail,
    testDatabaseConnection: authApi.testDatabaseConnection,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}
```

#### packages/ui/src/features/auth/AuthModal.tsx

```tsx
import React, { useState } from "react";

import { useAuth } from "./AuthContext";
import { LoginModal } from "./LoginModal";
import { RegisterModal } from "./RegisterModal";
import { VerificationModal } from "./VerificationModal";

export type AuthModalType = "login" | "register" | null;

interface AuthModalProps {
  isOpen: boolean;
  modalType: AuthModalType;
  onClose: () => void;
}

export function AuthModal({ isOpen, modalType, onClose }: AuthModalProps) {
  const [activeModal, setActiveModal] = useState<AuthModalType>(modalType);
  const {
    login,
    register,
    showVerificationModal,
    setShowVerificationModal,
    verificationEmail,
  } = useAuth();

  // Reset active modal when props change
  React.useEffect(() => {
    setActiveModal(modalType);
  }, [modalType]);

  const handleSwitchToLogin = () => {
    setActiveModal("login");
  };

  const handleSwitchToRegister = () => {
    setActiveModal("register");
  };

  const handleLogin = async (email: string, password: string) => {
    try {
      await login(email, password);
      onClose();
    } catch (error) {
      // Error is handled in the AuthContext
      console.error("Login failed:", error);
    }
  };

  const handleRegister = async (
    username: string,
    firstName: string,
    lastName: string,
    email: string,
    password: string,
  ) => {
    try {
      await register(username, firstName, lastName, email, password);
      // Don't close the modal if verification is needed
      // The verification modal will be shown instead
      if (!showVerificationModal) {
        onClose();
      }
    } catch (error) {
      // Error is handled in the AuthContext
      console.error("Registration failed:", error);
    }
  };

  // Void-returning wrappers for event handlers
  const handleLoginWrapper = (email: string, password: string): void => {
    void handleLogin(email, password);
  };

  const handleRegisterWrapper = (
    username: string,
    firstName: string,
    lastName: string,
    email: string,
    password: string,
  ): void => {
    void handleRegister(username, firstName, lastName, email, password);
  };

  const handleCloseVerificationModal = () => {
    setShowVerificationModal(false);
    onClose();
  };

  if (!isOpen && !showVerificationModal) return null;

  return (
    <>
      <LoginModal
        isOpen={activeModal === "login" && isOpen}
        onClose={onClose}
        onSwitchToRegister={handleSwitchToRegister}
        onLogin={handleLoginWrapper}
      />

      <RegisterModal
        isOpen={activeModal === "register" && isOpen}
        onClose={onClose}
        onSwitchToLogin={handleSwitchToLogin}
        onRegister={handleRegisterWrapper}
      />

      <VerificationModal
        isOpen={showVerificationModal}
        onClose={handleCloseVerificationModal}
        email={verificationEmail}
      />
    </>
  );
}
```

#### packages/ui/src/features/auth/ConfirmEmail.tsx

```tsx
import React, { useEffect, useMemo, useState } from "react";

import { AuthClient } from "../../services/AuthClient";
import { useRouter } from "../../services/Router";
import { Button } from "../ui/Button";
import { Card } from "../ui/Card";
import { Spinner } from "../ui/Spinner";

interface ApiResponse {
  success: boolean;
  error?: string;
}

// Define response type
interface EmailConfirmationResponse {
  status: "success" | "error";
  message?: string;
}

/**
 * Email confirmation component
 * Handles email verification using token from URL
 */
export const ConfirmEmail: React.FC = () => {
  const [status, setStatus] = useState<"loading" | "success" | "error">(
    "loading",
  );
  const [message, setMessage] = useState("Verifying your email...");
  const router = useRouter();

  // Use useMemo to create the authClient instance
  const authClient = useMemo(() => new AuthClient(), []);

  useEffect(() => {
    const confirmEmail = async () => {
      try {
        // Get token from URL
        const urlParams = new URLSearchParams(window.location.search);
        const token = urlParams.get("token");

        if (!token) {
          setStatus("error");
          setMessage("Invalid verification link. No token provided.");
          return;
        }

        // Call API to verify email
        const response = (await authClient.confirmEmail(token)) as ApiResponse;

        // Convert response to expected type
        const typedResponse: EmailConfirmationResponse = {
          status: response.success ? "success" : "error",
          message: response.error,
        };

        if (typedResponse.status === "success") {
          setStatus("success");
          setMessage("Your email has been verified successfully!");

          // Redirect to login after 3 seconds
          setTimeout(() => {
            router.navigate("/auth/login");
          }, 3000);
        } else {
          setStatus("error");
          setMessage(
            typedResponse.message ||
              "Failed to verify email. Please try again.",
          );
        }
      } catch (error) {
        setStatus("error");
        setMessage("An error occurred during verification. Please try again.");
        console.error("Email verification error:", error);
      }
    };

    void confirmEmail();
  }, [router, authClient]);

  return (
    <div className="flex justify-center items-center min-h-screen bg-gray-100">
      <Card className="w-full max-w-md p-8">
        <div className="text-center">
          <h1 className="text-2xl font-bold mb-6">Email Verification</h1>

          {status === "loading" && (
            <div className="flex flex-col items-center">
              <div className="mb-4">
                <Spinner size="lg" />
              </div>
              <p>{message}</p>
            </div>
          )}

          {status === "success" && (
            <div className="text-center">
              <div className="text-green-500 text-5xl mb-4">✓</div>
              <p className="mb-6">{message}</p>
              <p className="text-sm text-gray-500">
                Redirecting to login page...
              </p>
            </div>
          )}

          {status === "error" && (
            <div className="text-center">
              <div className="text-red-500 text-5xl mb-4">✗</div>
              <p className="mb-6">{message}</p>
              <Button
                onClick={() => router.navigate("/auth/login")}
                variant="primary"
                className="w-full"
              >
                Go to Login
              </Button>
            </div>
          )}
        </div>
      </Card>
    </div>
  );
};
```

#### packages/ui/src/features/auth/LoginModal.tsx

```tsx
import React, { useState } from "react";

interface LoginModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSwitchToRegister: () => void;
  onLogin: (email: string, password: string) => void;
}

export function LoginModal({
  isOpen,
  onClose,
  onSwitchToRegister,
  onLogin,
}: LoginModalProps) {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState<string | null>(null);

  if (!isOpen) return null;

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();

    // Basic validation
    if (!email.trim()) {
      setError("Email is required");
      return;
    }

    if (!password.trim()) {
      setError("Password is required");
      return;
    }

    // Clear any previous errors
    setError(null);

    // Call the login function
    onLogin(email, password);
  };

  return (
    <div
      style={{
        position: "fixed",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: "rgba(0, 0, 0, 0.5)",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        zIndex: 1000,
      }}
      onClick={onClose}
    >
      <div
        onClick={(e) => e.stopPropagation()}
        style={{
          position: "relative",
          backgroundColor: "var(--surface)",
          color: "var(--text-primary)",
          borderRadius: "8px",
          padding: "24px",
          width: "400px",
          maxWidth: "90%",
          maxHeight: "90vh",
          overflowY: "auto",
          boxShadow: "0 4px 12px rgba(0, 0, 0, 0.15)",
        }}
      >
        <h2 style={{ marginTop: 0, color: "var(--accent)" }}>Log In</h2>

        {error && (
          <div
            style={{
              backgroundColor: "rgba(255, 0, 0, 0.1)",
              color: "red",
              padding: "10px",
              borderRadius: "4px",
              marginBottom: "16px",
            }}
          >
            {error}
          </div>
        )}

        <form onSubmit={handleSubmit}>
          <div style={{ marginBottom: "16px" }}>
            <label
              htmlFor="email"
              style={{
                display: "block",
                marginBottom: "6px",
                fontWeight: "bold",
              }}
            >
              Email
            </label>
            <input
              id="email"
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              style={{
                width: "100%",
                padding: "10px",
                borderRadius: "4px",
                border: "1px solid var(--border-color)",
                fontSize: "16px",
                backgroundColor: "var(--input-bg)",
                color: "var(--text-primary)",
              }}
              placeholder="Enter your email"
            />
          </div>

          <div style={{ marginBottom: "16px" }}>
            <label
              htmlFor="password"
              style={{
                display: "block",
                marginBottom: "6px",
                fontWeight: "bold",
              }}
            >
              Password
            </label>
            <input
              id="password"
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              style={{
                width: "100%",
                padding: "10px",
                borderRadius: "4px",
                border: "1px solid var(--border-color)",
                fontSize: "16px",
                backgroundColor: "var(--input-bg)",
                color: "var(--text-primary)",
              }}
              placeholder="Enter your password"
            />
          </div>

          <button
            type="submit"
            style={{
              width: "100%",
              padding: "12px",
              backgroundColor: "var(--accent)",
              color: "white",
              border: "none",
              borderRadius: "4px",
              fontSize: "16px",
              cursor: "pointer",
              marginBottom: "16px",
            }}
          >
            Log In
          </button>
        </form>

        <div style={{ textAlign: "center" }}>
          <p>
            Don&apos;t have an account?{" "}
            <button
              onClick={onSwitchToRegister}
              style={{
                background: "none",
                border: "none",
                color: "var(--accent)",
                cursor: "pointer",
                padding: 0,
                fontSize: "inherit",
                textDecoration: "underline",
              }}
            >
              Register
            </button>
          </p>
        </div>

        <button
          onClick={onClose}
          style={{
            position: "absolute",
            top: "16px",
            right: "16px",
            background: "none",
            border: "none",
            fontSize: "24px",
            cursor: "pointer",
            color: "var(--text-secondary)",
          }}
        >
          &times;
        </button>
      </div>
    </div>
  );
}
```

#### packages/ui/src/features/auth/RegisterModal.tsx

```tsx
import React, { useState } from "react";

interface RegisterModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSwitchToLogin: () => void;
  onRegister: (
    username: string,
    firstName: string,
    lastName: string,
    email: string,
    password: string,
  ) => void;
}

export function RegisterModal({
  isOpen,
  onClose,
  onSwitchToLogin,
  onRegister,
}: RegisterModalProps) {
  const [username, setUsername] = useState("");
  const [firstName, setFirstName] = useState("");
  const [lastName, setLastName] = useState("");
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [confirmPassword, setConfirmPassword] = useState("");
  const [error, setError] = useState<string | null>(null);

  if (!isOpen) return null;

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();

    // Basic validation
    if (!username.trim()) {
      setError("Username is required");
      return;
    }

    if (!firstName.trim()) {
      setError("First name is required");
      return;
    }

    if (!lastName.trim()) {
      setError("Last name is required");
      return;
    }

    if (!email.trim()) {
      setError("Email is required");
      return;
    }

    if (!password.trim()) {
      setError("Password is required");
      return;
    }

    if (password !== confirmPassword) {
      setError("Passwords do not match");
      return;
    }

    // Validate username format
    if (!/^[a-zA-Z0-9_-]+$/.test(username)) {
      setError(
        "Username can only contain letters, numbers, underscores, and hyphens",
      );
      return;
    }

    // Clear any previous errors
    setError(null);

    // Call the register function
    onRegister(username, firstName, lastName, email, password);
  };

  return (
    <div
      style={{
        position: "fixed",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: "rgba(0, 0, 0, 0.5)",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        zIndex: 1000,
      }}
      onClick={onClose}
    >
      <div
        onClick={(e) => e.stopPropagation()}
        style={{
          position: "relative",
          backgroundColor: "var(--surface)",
          color: "var(--text-primary)",
          borderRadius: "8px",
          padding: "24px",
          width: "400px",
          maxWidth: "90%",
          maxHeight: "90vh",
          overflowY: "auto",
          boxShadow: "0 4px 12px rgba(0, 0, 0, 0.15)",
        }}
      >
        <h2 style={{ marginTop: 0, color: "var(--accent)" }}>Create Account</h2>

        {error && (
          <div
            style={{
              backgroundColor: "rgba(255, 0, 0, 0.1)",
              color: "red",
              padding: "10px",
              borderRadius: "4px",
              marginBottom: "16px",
            }}
          >
            {error}
          </div>
        )}

        <form onSubmit={handleSubmit}>
          <div style={{ marginBottom: "16px" }}>
            <label
              htmlFor="username"
              style={{
                display: "block",
                marginBottom: "6px",
                fontWeight: "bold",
              }}
            >
              Username
            </label>
            <input
              id="username"
              type="text"
              value={username}
              onChange={(e) => setUsername(e.target.value)}
              style={{
                width: "100%",
                padding: "10px",
                borderRadius: "4px",
                border: "1px solid var(--border-color)",
                fontSize: "16px",
                backgroundColor: "var(--input-bg)",
                color: "var(--text-primary)",
              }}
              placeholder="Choose a username"
            />
          </div>

          <div style={{ marginBottom: "16px" }}>
            <label
              htmlFor="firstName"
              style={{
                display: "block",
                marginBottom: "6px",
                fontWeight: "bold",
              }}
            >
              First Name
            </label>
            <input
              id="firstName"
              type="text"
              value={firstName}
              onChange={(e) => setFirstName(e.target.value)}
              style={{
                width: "100%",
                padding: "10px",
                borderRadius: "4px",
                border: "1px solid var(--border-color)",
                fontSize: "16px",
                backgroundColor: "var(--input-bg)",
                color: "var(--text-primary)",
              }}
              placeholder="Enter your first name"
            />
          </div>

          <div style={{ marginBottom: "16px" }}>
            <label
              htmlFor="lastName"
              style={{
                display: "block",
                marginBottom: "6px",
                fontWeight: "bold",
              }}
            >
              Last Name
            </label>
            <input
              id="lastName"
              type="text"
              value={lastName}
              onChange={(e) => setLastName(e.target.value)}
              style={{
                width: "100%",
                padding: "10px",
                borderRadius: "4px",
                border: "1px solid var(--border-color)",
                fontSize: "16px",
                backgroundColor: "var(--input-bg)",
                color: "var(--text-primary)",
              }}
              placeholder="Enter your last name"
            />
          </div>

          <div style={{ marginBottom: "16px" }}>
            <label
              htmlFor="email"
              style={{
                display: "block",
                marginBottom: "6px",
                fontWeight: "bold",
              }}
            >
              Email
            </label>
            <input
              id="email"
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              style={{
                width: "100%",
                padding: "10px",
                borderRadius: "4px",
                border: "1px solid var(--border-color)",
                fontSize: "16px",
                backgroundColor: "var(--input-bg)",
                color: "var(--text-primary)",
              }}
              placeholder="Enter your email"
            />
          </div>

          <div style={{ marginBottom: "16px" }}>
            <label
              htmlFor="password"
              style={{
                display: "block",
                marginBottom: "6px",
                fontWeight: "bold",
              }}
            >
              Password
            </label>
            <input
              id="password"
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              style={{
                width: "100%",
                padding: "10px",
                borderRadius: "4px",
                border: "1px solid var(--border-color)",
                fontSize: "16px",
                backgroundColor: "var(--input-bg)",
                color: "var(--text-primary)",
              }}
              placeholder="Create a password"
            />
          </div>

          <div style={{ marginBottom: "16px" }}>
            <label
              htmlFor="confirmPassword"
              style={{
                display: "block",
                marginBottom: "6px",
                fontWeight: "bold",
              }}
            >
              Confirm Password
            </label>
            <input
              id="confirmPassword"
              type="password"
              value={confirmPassword}
              onChange={(e) => setConfirmPassword(e.target.value)}
              style={{
                width: "100%",
                padding: "10px",
                borderRadius: "4px",
                border: "1px solid var(--border-color)",
                fontSize: "16px",
                backgroundColor: "var(--input-bg)",
                color: "var(--text-primary)",
              }}
              placeholder="Confirm your password"
            />
          </div>

          <button
            type="submit"
            style={{
              width: "100%",
              padding: "12px",
              backgroundColor: "var(--accent)",
              color: "white",
              border: "none",
              borderRadius: "4px",
              fontSize: "16px",
              cursor: "pointer",
              marginBottom: "16px",
            }}
          >
            Create Account
          </button>
        </form>

        <div style={{ textAlign: "center" }}>
          <p>
            Already have an account?{" "}
            <button
              onClick={onSwitchToLogin}
              style={{
                background: "none",
                border: "none",
                color: "var(--accent)",
                cursor: "pointer",
                padding: 0,
                fontSize: "inherit",
                textDecoration: "underline",
              }}
            >
              Log In
            </button>
          </p>
        </div>

        <button
          onClick={onClose}
          style={{
            position: "absolute",
            top: "16px",
            right: "16px",
            background: "none",
            border: "none",
            fontSize: "24px",
            cursor: "pointer",
            color: "var(--text-secondary)",
          }}
        >
          &times;
        </button>
      </div>
    </div>
  );
}
```

#### packages/ui/src/features/auth/ResendVerification.tsx

```tsx
import React, { useState } from "react";

import { AuthClient } from "../../services/AuthClient";
import { Button } from "../ui/Button";
import { Card } from "../ui/Card";
import { Input } from "../ui/Input";
import { Spinner } from "../ui/Spinner";

// Define response type
interface VerificationResponse {
  status: "success" | "error";
  message?: string;
}

interface ApiResponse {
  success: boolean;
  error?: string;
}

// Define error response type
interface ApiError {
  response?: {
    status: number;
    data?: {
      message?: string;
    };
  };
  message: string;
}

/**
 * ResendVerification component
 * Allows users to request a new verification email
 */
export const ResendVerification: React.FC = () => {
  const [email, setEmail] = useState("");
  const [status, setStatus] = useState<
    "idle" | "loading" | "success" | "error"
  >("idle");
  const [message, setMessage] = useState("");
  const [countdown, setCountdown] = useState(0);
  const authClient = new AuthClient();

  const handleSubmitAsync = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!email) {
      setStatus("error");
      setMessage("Please enter your email address");
      return;
    }

    try {
      setStatus("loading");
      setMessage("Sending verification email...");

      const response = (await authClient.resendConfirmationEmail(
        email,
      )) as ApiResponse;
      const typedResponse: VerificationResponse = {
        status: response.success ? "success" : "error",
      };

      if (typedResponse.status === "success") {
        setStatus("success");
        setMessage("Verification email sent! Please check your inbox.");

        // Start countdown for rate limiting (60 seconds)
        setCountdown(60);
        const timer = setInterval(() => {
          setCountdown((prev) => {
            if (prev <= 1) {
              clearInterval(timer);
              return 0;
            }
            return prev - 1;
          });
        }, 1000);
      } else {
        setStatus("error");
        setMessage(
          response.error ||
            "Failed to send verification email. Please try again.",
        );
      }
    } catch (error) {
      const err = error as ApiError;
      setStatus("error");

      // Handle rate limiting error
      if (err.response?.status === 429) {
        setMessage("Please wait before requesting another email.");

        // Extract time from error message if available
        const timeMatch = err.response?.data?.message?.match(/(\d+)/);
        if (timeMatch && timeMatch[1]) {
          const seconds = parseInt(timeMatch[1], 10);
          setCountdown(seconds);

          const timer = setInterval(() => {
            setCountdown((prev) => {
              if (prev <= 1) {
                clearInterval(timer);
                return 0;
              }
              return prev - 1;
            });
          }, 1000);
        }
      } else {
        setMessage("An error occurred. Please try again later.");
      }

      console.error("Resend verification error:", err);
    }
  };

  // Wrapper function that returns void
  const handleSubmit = (e: React.FormEvent): void => {
    void handleSubmitAsync(e);
  };

  return (
    <div className="flex justify-center items-center min-h-screen bg-gray-100">
      <Card className="w-full max-w-md p-8">
        <div className="text-center mb-6">
          <h1 className="text-2xl font-bold">Resend Verification Email</h1>
          <p className="text-gray-600 mt-2">
            Enter your email address to receive a new verification link
          </p>
        </div>

        <form onSubmit={handleSubmit}>
          <div className="mb-4">
            <Input
              type="email"
              placeholder="Email address"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              disabled={status === "loading" || countdown > 0}
              required
            />
          </div>

          {status === "error" && (
            <div className="mb-4 p-3 bg-red-100 text-red-700 rounded">
              {message}
            </div>
          )}

          {status === "success" && (
            <div className="mb-4 p-3 bg-green-100 text-green-700 rounded">
              {message}
            </div>
          )}

          <Button
            type="submit"
            variant="primary"
            className="w-full"
            disabled={status === "loading" || countdown > 0}
          >
            {status === "loading" ? (
              <div className="mr-2">
                <Spinner size="sm" />
              </div>
            ) : countdown > 0 ? (
              `Resend (${countdown}s)`
            ) : (
              "Send Verification Email"
            )}
          </Button>
        </form>
      </Card>
    </div>
  );
};
```

#### packages/ui/src/features/auth/VerificationModal.tsx

```tsx
import { useState } from "react";

import { AuthClient } from "../../services/AuthClient";

// Define response type
interface VerificationResponse {
  success: boolean;
  message?: string;
}

// Define error response type
interface ApiError {
  response?: {
    status: number;
    data?: {
      message?: string;
    };
  };
  message: string;
}

interface VerificationModalProps {
  isOpen: boolean;
  onClose: () => void;
  email: string;
}

export function VerificationModal({
  isOpen,
  onClose,
  email,
}: VerificationModalProps) {
  const [isResending, setIsResending] = useState(false);
  const [resendStatus, setResendStatus] = useState<
    "idle" | "success" | "error"
  >("idle");
  const [message, setMessage] = useState("");
  const [countdown, setCountdown] = useState(0);
  const authClient = new AuthClient();

  if (!isOpen) return null;

  const handleResendEmailAsync = async () => {
    if (isResending || countdown > 0) return;

    setIsResending(true);
    setResendStatus("idle");
    setMessage("");

    try {
      const response = (await authClient.resendConfirmationEmail(
        email,
      )) as VerificationResponse;

      if (response.success) {
        setResendStatus("success");
        setMessage("Verification email sent! Please check your inbox.");

        // Start countdown for rate limiting (60 seconds)
        setCountdown(60);
        const timer = setInterval(() => {
          setCountdown((prev) => {
            if (prev <= 1) {
              clearInterval(timer);
              return 0;
            }
            return prev - 1;
          });
        }, 1000);
      } else {
        setResendStatus("error");
        setMessage(
          response.message ||
            "Failed to send verification email. Please try again.",
        );
      }
    } catch (error) {
      const err = error as ApiError;
      setResendStatus("error");

      // Handle rate limiting error
      if (err.response?.status === 429) {
        setMessage("Please wait before requesting another email.");

        // Extract time from error message if available
        const timeMatch = err.response?.data?.message?.match(/(\d+)/);
        if (timeMatch && timeMatch[1]) {
          const seconds = parseInt(timeMatch[1], 10);
          setCountdown(seconds);

          const timer = setInterval(() => {
            setCountdown((prev) => {
              if (prev <= 1) {
                clearInterval(timer);
                return 0;
              }
              return prev - 1;
            });
          }, 1000);
        }
      } else {
        setMessage("An error occurred. Please try again later.");
      }

      console.error("Resend verification error:", err);
    } finally {
      setIsResending(false);
    }
  };

  // Wrapper function that returns void
  const handleResendEmail = (): void => {
    void handleResendEmailAsync();
  };

  return (
    <div
      style={{
        position: "fixed",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        backgroundColor: "rgba(0, 0, 0, 0.5)",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        zIndex: 1000,
      }}
      onClick={onClose}
    >
      <div
        onClick={(e) => e.stopPropagation()}
        style={{
          position: "relative",
          backgroundColor: "var(--surface)",
          color: "var(--text-primary)",
          borderRadius: "8px",
          padding: "24px",
          width: "400px",
          maxWidth: "90%",
          maxHeight: "90vh",
          overflowY: "auto",
          boxShadow: "0 4px 12px rgba(0, 0, 0, 0.15)",
        }}
      >
        <h2 style={{ marginTop: 0, color: "var(--accent)" }}>
          Verify Your Email
        </h2>

        <div style={{ marginBottom: "20px" }}>
          <p>
            We&apos;ve sent a verification email to <strong>{email}</strong>.
            Please check your inbox and click the verification link to activate
            your account.
          </p>
          <p>If you don&apos;t see the email, please check your spam folder.</p>
        </div>

        {resendStatus === "success" && (
          <div
            style={{
              backgroundColor: "rgba(0, 255, 0, 0.1)",
              color: "green",
              padding: "10px",
              borderRadius: "4px",
              marginBottom: "16px",
            }}
          >
            {message}
          </div>
        )}

        {resendStatus === "error" && (
          <div
            style={{
              backgroundColor: "rgba(255, 0, 0, 0.1)",
              color: "red",
              padding: "10px",
              borderRadius: "4px",
              marginBottom: "16px",
            }}
          >
            {message}
          </div>
        )}

        <div
          style={{
            display: "flex",
            justifyContent: "space-between",
            marginTop: "20px",
          }}
        >
          <button
            onClick={onClose}
            style={{
              padding: "10px 16px",
              borderRadius: "4px",
              border: "1px solid var(--border-color)",
              backgroundColor: "transparent",
              color: "var(--text-primary)",
              cursor: "pointer",
              fontSize: "14px",
            }}
          >
            Close
          </button>

          <button
            onClick={handleResendEmail}
            disabled={isResending || countdown > 0}
            style={{
              padding: "10px 16px",
              borderRadius: "4px",
              border: "none",
              backgroundColor:
                isResending || countdown > 0
                  ? "var(--accent-disabled)"
                  : "var(--accent)",
              color: "white",
              cursor: isResending || countdown > 0 ? "not-allowed" : "pointer",
              fontSize: "14px",
            }}
          >
            {isResending
              ? "Sending..."
              : countdown > 0
                ? `Resend (${countdown}s)`
                : "Resend Email"}
          </button>
        </div>
      </div>
    </div>
  );
}
```

#### packages/ui/src/features/auth/index.tsx

```tsx
export { AuthProvider, useAuth } from "./AuthContext";
export { AuthModal } from "./AuthModal";
export type { AuthModalType } from "./AuthModal";
export { VerificationModal } from "./VerificationModal";
```

#### packages/ui/src/features/index.ts

```ts
// Feature modules
export * from './auth';
export * from './media';
export * from './social';
export * from './theme';
```

#### packages/ui/src/features/media/AudioPlayer.tsx

```tsx
import React, { useCallback, useEffect, useRef, useState } from "react";

import { formatDuration } from "../../helpers/formatters";

interface AudioPlayerProps {
  trackUrl: string;
  trackTitle: string;
  artistName: string;
  coverArtUrl?: string;
  autoplay?: boolean;
  onEnded?: () => void;
  onPlay?: () => void;
  onPause?: () => void;
}

const AudioPlayer: React.FC<AudioPlayerProps> = ({
  trackUrl,
  trackTitle,
  artistName,
  coverArtUrl,
  autoplay = false,
  onEnded,
  onPlay,
  onPause,
}) => {
  const [isPlaying, setIsPlaying] = useState(false);
  const [duration, setDuration] = useState(0);
  const [currentTime, setCurrentTime] = useState(0);
  const [volume, setVolume] = useState(0.8);

  const audioRef = useRef<HTMLAudioElement>(null);
  const progressRef = useRef<HTMLDivElement>(null);

  const playAudio = useCallback(() => {
    if (audioRef.current) {
      audioRef.current
        .play()
        .then(() => {
          setIsPlaying(true);
          if (onPlay) onPlay();
        })
        .catch((error) => {
          console.error("Play failed:", error);
        });
    }
  }, [onPlay]);

  const pauseAudio = useCallback(() => {
    if (audioRef.current) {
      audioRef.current.pause();
      setIsPlaying(false);
      if (onPause) onPause();
    }
  }, [onPause]);

  useEffect(() => {
    if (audioRef.current) {
      const audio = audioRef.current;

      const handleLoadedMetadata = () => {
        setDuration(audio.duration);
      };

      const handleTimeUpdate = () => {
        setCurrentTime(audio.currentTime);
      };

      const handleEnded = () => {
        setIsPlaying(false);
        if (onEnded) onEnded();
      };

      // Add event listeners
      audio.addEventListener("loadedmetadata", handleLoadedMetadata);
      audio.addEventListener("timeupdate", handleTimeUpdate);
      audio.addEventListener("ended", handleEnded);

      // Set volume
      audio.volume = volume;

      // Handle autoplay
      if (autoplay) {
        playAudio();
      }

      // Clean up
      return () => {
        audio.removeEventListener("loadedmetadata", handleLoadedMetadata);
        audio.removeEventListener("timeupdate", handleTimeUpdate);
        audio.removeEventListener("ended", handleEnded);
      };
    }
  }, [trackUrl, autoplay, playAudio, pauseAudio, volume, onEnded]);

  const togglePlay = () => {
    if (isPlaying) {
      pauseAudio();
    } else {
      playAudio();
    }
  };

  const handleProgressClick = (e: React.MouseEvent<HTMLDivElement>) => {
    if (progressRef.current && audioRef.current) {
      const progressRect = progressRef.current.getBoundingClientRect();
      const clickPosition = e.clientX - progressRect.left;
      const percentageClicked = clickPosition / progressRect.width;
      const newTime = duration * percentageClicked;

      audioRef.current.currentTime = newTime;
      setCurrentTime(newTime);
    }
  };

  const handleVolumeChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newVolume = parseFloat(e.target.value);
    setVolume(newVolume);

    if (audioRef.current) {
      audioRef.current.volume = newVolume;
    }
  };

  return (
    <div style={styles.audioPlayer}>
      <audio ref={audioRef} src={trackUrl} preload="metadata" />

      <div className="player-container">
        {coverArtUrl && (
          <div className="cover-art">
            <img src={coverArtUrl} alt={`${trackTitle} by ${artistName}`} />
          </div>
        )}

        <div className="player-controls">
          <div className="track-info">
            <h3 className="track-title">{trackTitle}</h3>
            <p className="artist-name">{artistName}</p>
          </div>

          <div className="controls">
            <button
              className="skip-back"
              aria-label="Skip back 15 seconds"
              onClick={() => {
                if (audioRef.current) {
                  audioRef.current.currentTime = Math.max(0, currentTime - 15);
                }
              }}
            >
              ⏪
            </button>

            <button
              className="play-pause"
              aria-label={isPlaying ? "Pause" : "Play"}
              onClick={togglePlay}
            >
              {isPlaying ? "⏸️" : "▶️"}
            </button>

            <button
              className="skip-forward"
              aria-label="Skip forward 15 seconds"
              onClick={() => {
                if (audioRef.current) {
                  audioRef.current.currentTime = Math.min(
                    duration,
                    currentTime + 15,
                  );
                }
              }}
            >
              ⏩
            </button>
          </div>

          <div className="progress-container">
            <div className="time-display">{formatDuration(currentTime)}</div>

            <div
              className="progress-bar"
              ref={progressRef}
              onClick={handleProgressClick}
            >
              <div
                className="progress-fill"
                style={{ width: `${(currentTime / duration) * 100}%` }}
              ></div>
            </div>

            <div className="time-display">{formatDuration(duration)}</div>
          </div>

          <div className="volume-control">
            <span className="volume-icon">🔊</span>
            <input
              type="range"
              min="0"
              max="1"
              step="0.01"
              value={volume}
              onChange={handleVolumeChange}
              className="volume-slider"
            />
          </div>
        </div>
      </div>
    </div>
  );
};

const styles = {
  audioPlayer: {
    width: "100%",
    maxWidth: "600px",
    background: "var(--background2)",
    borderRadius: "12px",
    padding: "20px",
    boxShadow: "0 4px 12px rgba(0, 0, 0, 0.1)",
    margin: "20px auto",
  },
  playerContainer: {
    display: "flex",
    alignItems: "center",
  },
  coverArt: {
    width: "100px",
    height: "100px",
    marginRight: "20px",
    flexShrink: 0,
  },
  coverArtImg: {
    width: "100%",
    height: "100%",
    objectFit: "cover",
    borderRadius: "8px",
  },
  playerControls: {
    flexGrow: 1,
  },
  trackTitle: {
    margin: "0 0 5px 0",
    fontSize: "18px",
    color: "var(--text-color)",
  },
  artistName: {
    margin: 0,
    fontSize: "14px",
    color: "var(--text-color2)",
  },
  controls: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    margin: "15px 0",
  },
  controlsButton: {
    background: "transparent",
    border: "none",
    cursor: "pointer",
    fontSize: "24px",
    padding: "5px 15px",
    borderRadius: "50%",
    transition: "background-color 0.2s",
  },
  controlsButtonHover: {
    backgroundColor: "var(--hover)",
  },
  playPause: {
    margin: "0 15px",
  },
  progressContainer: {
    display: "flex",
    alignItems: "center",
    marginBottom: "15px",
  },
  timeDisplay: {
    fontSize: "12px",
    color: "var(--text-color2)",
    width: "45px",
  },
  progressBar: {
    flexGrow: 1,
    height: "6px",
    backgroundColor: "var(--transparent2)",
    borderRadius: "3px",
    margin: "0 10px",
    cursor: "pointer",
    position: "relative",
  },
  progressFill: {
    position: "absolute",
    top: 0,
    left: 0,
    height: "100%",
    backgroundColor: "var(--blue)",
    borderRadius: "3px",
  },
  volumeControl: {
    display: "flex",
    alignItems: "center",
  },
  volumeIcon: {
    marginRight: "10px",
    fontSize: "16px",
  },
  volumeSlider: {
    "-webkit-appearance": "none",
    width: "100px",
    height: "4px",
    background: "var(--transparent2)",
    borderRadius: "2px",
    outline: "none",
  },
  volumeSliderThumb: {
    "-webkit-appearance": "none",
    width: "12px",
    height: "12px",
    borderRadius: "50%",
    background: "var(--blue)",
    cursor: "pointer",
  },
};

export default AudioPlayer;
```

#### packages/ui/src/features/media/ImageGallery.tsx

```tsx
import React, { useCallback, useEffect, useRef, useState } from "react";

import { imageGalleryStyles } from "../../styles";
import { mergeStyles } from "../../utils/styleUtils";

// Define interface for document with vendor prefixed fullscreen properties
interface DocumentWithFullscreen extends Document {
  webkitFullscreenElement?: Element | null;
  mozFullScreenElement?: Element | null;
  webkitExitFullscreen?: () => Promise<void>;
  mozCancelFullScreen?: () => Promise<void>;
}

interface ElementWithFullscreen extends HTMLElement {
  webkitRequestFullscreen?: () => Promise<void>;
  mozRequestFullScreen?: () => Promise<void>;
}

interface ImageItem {
  src: string;
  width: number;
  height: number;
  alt?: string;
}

interface ImageGalleryProps {
  images: ImageItem[];
  aspectRatio?: number; // width/height ratio, default 1:1 (square)
  showThumbnails?: boolean;
  showNavigation?: boolean;
  initialIndex?: number;
  autoPlay?: boolean;
  autoPlayInterval?: number; // in milliseconds
  onImageChange?: (index: number) => void;
  onClick?: (index: number) => void;
}

const ImageGallery: React.FC<ImageGalleryProps> = ({
  images,
  aspectRatio = 1,
  showThumbnails = true,
  showNavigation = true,
  initialIndex = 0,
  autoPlay = false,
  autoPlayInterval = 3000,
  onImageChange,
  onClick,
}) => {
  const [currentIndex, setCurrentIndex] = useState(initialIndex);
  const [touchStartX, setTouchStartX] = useState(0);
  const [isSwiping, setIsSwiping] = useState(false);
  const [swipeDistance, setSwipeDistance] = useState(0);
  const [isFullscreen, setIsFullscreen] = useState(false);

  const galleryRef = useRef<HTMLDivElement>(null);
  const autoPlayRef = useRef<NodeJS.Timeout | null>(null);

  const isSingleImage = images.length === 1;

  // Reset current index if images change
  useEffect(() => {
    setCurrentIndex(initialIndex < images.length ? initialIndex : 0);
  }, [images, initialIndex]);

  const goToNextImage = useCallback(() => {
    setCurrentIndex((prevIndex) => {
      const nextIndex = (prevIndex + 1) % images.length;
      if (onImageChange) onImageChange(nextIndex);
      return nextIndex;
    });
  }, [images.length, onImageChange]);

  // Handle autoplay
  useEffect(() => {
    if (autoPlayRef.current) {
      clearInterval(autoPlayRef.current);
      autoPlayRef.current = null;
    }

    if (autoPlay && images.length > 1) {
      autoPlayRef.current = setInterval(() => {
        goToNextImage();
      }, autoPlayInterval);
    }

    return () => {
      if (autoPlayRef.current) {
        clearInterval(autoPlayRef.current);
      }
    };
  }, [autoPlay, autoPlayInterval, currentIndex, images.length, goToNextImage]);

  // Handle fullscreen changes
  useEffect(() => {
    const handleFullscreenChange = () => {
      setIsFullscreen(
        Boolean(
          document.fullscreenElement ||
            (document as DocumentWithFullscreen).webkitFullscreenElement ||
            (document as DocumentWithFullscreen).mozFullScreenElement,
        ),
      );
    };

    document.addEventListener("fullscreenchange", handleFullscreenChange);
    document.addEventListener("webkitfullscreenchange", handleFullscreenChange);
    document.addEventListener("mozfullscreenchange", handleFullscreenChange);

    return () => {
      document.removeEventListener("fullscreenchange", handleFullscreenChange);
      document.removeEventListener(
        "webkitfullscreenchange",
        handleFullscreenChange,
      );
      document.removeEventListener(
        "mozfullscreenchange",
        handleFullscreenChange,
      );
    };
  }, []);

  const goToPrevImage = () => {
    setCurrentIndex((prevIndex) => {
      const nextIndex = (prevIndex - 1 + images.length) % images.length;
      if (onImageChange) onImageChange(nextIndex);
      return nextIndex;
    });
  };

  const handleThumbnailClick = (index: number) => {
    setCurrentIndex(index);
    if (onImageChange) onImageChange(index);
  };

  const handleTouchStart = (e: React.TouchEvent) => {
    setTouchStartX(e.touches[0].clientX);
    setIsSwiping(true);
    setSwipeDistance(0);
  };

  const handleTouchMove = (e: React.TouchEvent) => {
    if (!isSwiping) return;

    const currentX = e.touches[0].clientX;
    const distance = currentX - touchStartX;
    setSwipeDistance(distance);
  };

  const handleTouchEnd = () => {
    if (!isSwiping) return;

    if (swipeDistance > 50) {
      goToPrevImage();
    } else if (swipeDistance < -50) {
      goToNextImage();
    }

    setIsSwiping(false);
    setSwipeDistance(0);
  };

  const handleImageClick = () => {
    if (onClick) {
      onClick(currentIndex);
    } else if (images.length > 1 && !isFullscreen) {
      goToNextImage();
    }
  };

  const toggleFullscreen = () => {
    if (!galleryRef.current) return;

    if (isFullscreen) {
      if (document.exitFullscreen) {
        void document.exitFullscreen();
      } else if ((document as DocumentWithFullscreen).webkitExitFullscreen) {
        void (document as DocumentWithFullscreen).webkitExitFullscreen?.();
      } else if ((document as DocumentWithFullscreen).mozCancelFullScreen) {
        void (document as DocumentWithFullscreen).mozCancelFullScreen?.();
      }
    } else {
      if (galleryRef.current.requestFullscreen) {
        void galleryRef.current.requestFullscreen();
      } else if (
        (galleryRef.current as ElementWithFullscreen).webkitRequestFullscreen
      ) {
        void (
          galleryRef.current as ElementWithFullscreen
        ).webkitRequestFullscreen?.();
      } else if (
        (galleryRef.current as ElementWithFullscreen).mozRequestFullScreen
      ) {
        void (
          galleryRef.current as ElementWithFullscreen
        ).mozRequestFullScreen?.();
      }
    }
  };

  // If no images, return nothing
  if (!images.length) return null;

  return (
    <div style={{ position: "relative", width: "100%", maxWidth: "100%" }}>
      <div
        ref={galleryRef}
        style={mergeStyles(
          imageGalleryStyles.imageGallery as React.CSSProperties,
          { aspectRatio: aspectRatio.toString() },
          isFullscreen
            ? (imageGalleryStyles.imageGalleryFullscreen as React.CSSProperties)
            : {},
        )}
      >
        <div
          style={imageGalleryStyles.galleryMain as React.CSSProperties}
          onTouchStart={handleTouchStart}
          onTouchMove={handleTouchMove}
          onTouchEnd={handleTouchEnd}
        >
          {images.map((image, index) => (
            <div
              key={index}
              style={mergeStyles(
                imageGalleryStyles.galleryImageContainer as React.CSSProperties,
                {
                  transform: isSwiping
                    ? `translateX(calc(-${currentIndex * 100}% + ${swipeDistance}px))`
                    : `translateX(-${currentIndex * 100}%)`,
                },
              )}
            >
              <img
                src={image.src}
                alt={image.alt || `Image ${index + 1}`}
                style={mergeStyles(
                  imageGalleryStyles.galleryImage as React.CSSProperties,
                  isFullscreen
                    ? (imageGalleryStyles.imageGalleryFullscreenImage as React.CSSProperties)
                    : {},
                )}
                onClick={handleImageClick}
              />
            </div>
          ))}

          {!isSingleImage && showNavigation && (
            <>
              <button
                style={mergeStyles(
                  imageGalleryStyles.galleryNav as React.CSSProperties,
                  imageGalleryStyles.galleryPrev as React.CSSProperties,
                )}
                onClick={goToPrevImage}
                aria-label="Previous image"
                onMouseOver={(e) => {
                  e.currentTarget.style.opacity = "1";
                }}
                onMouseOut={(e) => {
                  e.currentTarget.style.opacity = "0.7";
                }}
              >
                ◀
              </button>
              <button
                style={mergeStyles(
                  imageGalleryStyles.galleryNav as React.CSSProperties,
                  imageGalleryStyles.galleryNext as React.CSSProperties,
                )}
                onClick={goToNextImage}
                aria-label="Next image"
                onMouseOver={(e) => {
                  e.currentTarget.style.opacity = "1";
                }}
                onMouseOut={(e) => {
                  e.currentTarget.style.opacity = "0.7";
                }}
              >
                ▶
              </button>
            </>
          )}

          <button
            style={imageGalleryStyles.galleryFullscreen as React.CSSProperties}
            onClick={toggleFullscreen}
            aria-label={isFullscreen ? "Exit fullscreen" : "Enter fullscreen"}
            onMouseOver={(e) => {
              e.currentTarget.style.opacity = "1";
            }}
            onMouseOut={(e) => {
              e.currentTarget.style.opacity = "0.7";
            }}
          >
            {isFullscreen ? "↙️" : "↗️"}
          </button>
        </div>

        {!isSingleImage && showThumbnails && (
          <div
            style={imageGalleryStyles.galleryThumbnails as React.CSSProperties}
          >
            {images.map((image, index) => (
              <div
                key={index}
                style={mergeStyles(
                  imageGalleryStyles.galleryThumbnail as React.CSSProperties,
                  index === currentIndex
                    ? (imageGalleryStyles.galleryThumbnailActive as React.CSSProperties)
                    : {},
                )}
                onClick={() => handleThumbnailClick(index)}
                onMouseOver={(e) => {
                  if (index !== currentIndex) {
                    e.currentTarget.style.opacity = "0.9";
                  }
                }}
                onMouseOut={(e) => {
                  if (index !== currentIndex) {
                    e.currentTarget.style.opacity = "0.7";
                  }
                }}
              >
                <img
                  src={image.src}
                  alt={`Thumbnail ${index + 1}`}
                  style={
                    imageGalleryStyles.galleryThumbnailImg as React.CSSProperties
                  }
                />
              </div>
            ))}
          </div>
        )}

        {!isSingleImage && (
          <div
            style={imageGalleryStyles.galleryIndicators as React.CSSProperties}
          >
            {images.map((_, index) => (
              <button
                key={index}
                style={mergeStyles(
                  imageGalleryStyles.galleryIndicator as React.CSSProperties,
                  index === currentIndex
                    ? (imageGalleryStyles.galleryIndicatorActive as React.CSSProperties)
                    : {},
                )}
                onClick={() => handleThumbnailClick(index)}
                aria-label={`Go to image ${index + 1}`}
              />
            ))}
          </div>
        )}
      </div>
    </div>
  );
};

export default ImageGallery;
```

#### packages/ui/src/features/media/MediaGallery.tsx

```tsx
import React, { useCallback, useEffect, useRef, useState } from "react";

interface MediaItem {
  id: string;
  src: string;
  type: "image" | "video" | "audio";
  title?: string;
  thumbnail?: string;
  description?: string;
  duration?: number;
}

interface MediaGalleryProps {
  items: MediaItem[];
  columns?: number;
  gap?: number;
  className?: string;
}

export const MediaGallery: React.FC<MediaGalleryProps> = ({
  items,
  columns = 3,
  gap = 16,
  className,
}) => {
  const [selectedItem, setSelectedItem] = useState<MediaItem | null>(null);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [isPlaying, setIsPlaying] = useState(false);
  const [volume, setVolume] = useState(1);
  const [isMuted, setIsMuted] = useState(false);
  const [_isFullscreen, setIsFullscreen] = useState(false);
  const videoRef = useRef<HTMLVideoElement>(null);
  const audioRef = useRef<HTMLAudioElement>(null);
  const mediaRef = selectedItem?.type === "video" ? videoRef : audioRef;

  const styles = {
    gallery: {
      display: "grid",
      gridTemplateColumns: `repeat(${columns}, 1fr)`,
      gap: `${gap}px`,
      padding: "16px",
      ...(className && { className }),
    },
    item: {
      position: "relative" as const,
      aspectRatio: "1",
      cursor: "pointer",
      overflow: "hidden",
      borderRadius: "8px",
      backgroundColor: "#f5f5f5",
      transition: "transform 0.2s ease",
      "&:hover": {
        transform: "scale(1.02)",
      },
    },
    thumbnail: {
      width: "100%",
      height: "100%",
      objectFit: "cover" as const,
    },
    overlay: {
      position: "absolute" as const,
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: "rgba(0, 0, 0, 0.5)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      opacity: 0,
      transition: "opacity 0.2s ease",
      "&:hover": {
        opacity: 1,
      },
    },
    title: {
      color: "white",
      fontSize: "1rem",
      fontWeight: 500,
      textAlign: "center" as const,
      padding: "8px",
    },
    modal: {
      position: "fixed" as const,
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      backgroundColor: "rgba(0, 0, 0, 0.9)",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      zIndex: 1000,
    },
    modalContent: {
      position: "relative" as const,
      maxWidth: "90vw",
      maxHeight: "90vh",
      backgroundColor: "#fff",
      borderRadius: "8px",
      overflow: "hidden",
    },
    closeButton: {
      position: "absolute" as const,
      top: "16px",
      right: "16px",
      backgroundColor: "rgba(0, 0, 0, 0.5)",
      color: "white",
      border: "none",
      borderRadius: "50%",
      width: "32px",
      height: "32px",
      cursor: "pointer",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      transition: "background-color 0.2s",
      "&:hover": {
        backgroundColor: "rgba(0, 0, 0, 0.7)",
      },
    },
    media: {
      maxWidth: "100%",
      maxHeight: "90vh",
      objectFit: "contain" as const,
    },
    controls: {
      position: "absolute" as const,
      bottom: 0,
      left: 0,
      right: 0,
      padding: "16px",
      backgroundColor: "rgba(0, 0, 0, 0.7)",
      display: "flex",
      alignItems: "center",
      gap: "16px",
    },
    playButton: {
      backgroundColor: "transparent",
      border: "none",
      color: "white",
      cursor: "pointer",
      padding: "8px",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
    },
    timeSlider: {
      flex: 1,
      height: "4px",
      backgroundColor: "rgba(255, 255, 255, 0.3)",
      borderRadius: "2px",
      cursor: "pointer",
      "&:hover": {
        backgroundColor: "rgba(255, 255, 255, 0.5)",
      },
    },
    timeFill: {
      height: "100%",
      backgroundColor: "#2196f3",
      borderRadius: "2px",
      width: `${(currentTime / duration) * 100}%`,
    },
    volumeControl: {
      display: "flex",
      alignItems: "center",
      gap: "8px",
    },
    volumeSlider: {
      width: "100px",
      height: "4px",
      backgroundColor: "rgba(255, 255, 255, 0.3)",
      borderRadius: "2px",
      cursor: "pointer",
      "&:hover": {
        backgroundColor: "rgba(255, 255, 255, 0.5)",
      },
    },
    volumeFill: {
      height: "100%",
      backgroundColor: "#2196f3",
      borderRadius: "2px",
      width: `${volume * 100}%`,
    },
    timeDisplay: {
      color: "white",
      fontSize: "0.875rem",
      minWidth: "100px",
    },
  };

  useEffect(() => {
    if (selectedItem) {
      setIsPlaying(false);
      setCurrentTime(0);
      setDuration(0);
      setVolume(1);
      setIsMuted(false);
      setIsFullscreen(false);
    }
  }, [selectedItem]);

  const handleTimeUpdate = useCallback(() => {
    if (mediaRef.current) {
      setCurrentTime(mediaRef.current.currentTime);
    }
  }, [mediaRef]);

  const handleLoadedMetadata = useCallback(() => {
    if (mediaRef.current) {
      setDuration(mediaRef.current.duration);
    }
  }, [mediaRef]);

  const handleEnded = useCallback(() => {
    setIsPlaying(false);
    setCurrentTime(0);
  }, []);

  useEffect(() => {
    const currentMedia = mediaRef.current;

    if (currentMedia) {
      currentMedia.addEventListener("timeupdate", handleTimeUpdate);
      currentMedia.addEventListener("loadedmetadata", handleLoadedMetadata);
      currentMedia.addEventListener("ended", handleEnded);
    }

    return () => {
      if (currentMedia) {
        currentMedia.removeEventListener("timeupdate", handleTimeUpdate);
        currentMedia.removeEventListener(
          "loadedmetadata",
          handleLoadedMetadata,
        );
        currentMedia.removeEventListener("ended", handleEnded);
      }
    };
  }, [mediaRef, handleTimeUpdate, handleLoadedMetadata, handleEnded]);

  const togglePlay = () => {
    if (mediaRef.current) {
      if (isPlaying) {
        void mediaRef.current.pause();
      } else {
        void mediaRef.current.play();
      }
      setIsPlaying(!isPlaying);
    }
  };

  const toggleMute = () => {
    if (mediaRef.current) {
      mediaRef.current.muted = !isMuted;
      setIsMuted(!isMuted);
    }
  };

  const formatTime = (time: number): string => {
    const minutes = Math.floor(time / 60);
    const seconds = Math.floor(time % 60);
    return `${minutes}:${seconds.toString().padStart(2, "0")}`;
  };

  return (
    <>
      <div style={styles.gallery}>
        {items.map((item) => (
          <div
            key={item.id}
            style={styles.item}
            onClick={() => setSelectedItem(item)}
          >
            <img
              src={item.thumbnail || item.src}
              alt={item.title || ""}
              style={styles.thumbnail}
            />
            <div style={styles.overlay}>
              <h3 style={styles.title}>{item.title}</h3>
            </div>
          </div>
        ))}
      </div>

      {selectedItem && (
        <div style={styles.modal} onClick={() => setSelectedItem(null)}>
          <div style={styles.modalContent} onClick={(e) => e.stopPropagation()}>
            <button
              style={styles.closeButton}
              onClick={() => setSelectedItem(null)}
            >
              ×
            </button>

            {selectedItem.type === "image" ? (
              <img
                src={selectedItem.src}
                alt={selectedItem.title || ""}
                style={styles.media}
              />
            ) : selectedItem.type === "video" ? (
              <video
                ref={videoRef}
                src={selectedItem.src}
                style={styles.media}
                onTimeUpdate={handleTimeUpdate}
                onLoadedMetadata={handleLoadedMetadata}
                onEnded={handleEnded}
              />
            ) : (
              <audio
                ref={audioRef}
                src={selectedItem.src}
                onTimeUpdate={handleTimeUpdate}
                onLoadedMetadata={handleLoadedMetadata}
                onEnded={handleEnded}
              />
            )}

            {(selectedItem.type === "video" ||
              selectedItem.type === "audio") && (
              <div style={styles.controls}>
                <button style={styles.playButton} onClick={togglePlay}>
                  {isPlaying ? "⏸" : "▶"}
                </button>

                <div style={styles.timeSlider}>
                  <div style={styles.timeFill} />
                </div>

                <div style={styles.timeDisplay}>
                  {formatTime(currentTime)} / {formatTime(duration)}
                </div>

                <div style={styles.volumeControl}>
                  <button style={styles.playButton} onClick={toggleMute}>
                    {isMuted ? "🔇" : "🔊"}
                  </button>
                  <div style={styles.volumeSlider}>
                    <div
                      style={{
                        ...styles.volumeFill,
                        width: `${volume * 100}%`,
                      }}
                    />
                  </div>
                </div>
              </div>
            )}
          </div>
        </div>
      )}
    </>
  );
};
```

#### packages/ui/src/features/media/VideoPlayer.tsx

```tsx
import React, { useEffect, useRef, useState } from "react";

import { formatDuration } from "../../helpers/formatters";
import { videoPlayerStyles } from "../../styles";
import { mergeStyles } from "../../utils/styleUtils";

// Define interface for document with vendor-specific fullscreen properties
interface DocumentWithFullscreen extends Document {
  webkitFullscreenElement?: Element | null;
  mozFullScreenElement?: Element | null;
  webkitExitFullscreen?: () => Promise<void>;
  mozCancelFullScreen?: () => Promise<void>;
}

// Define interface for element with vendor-specific fullscreen methods
interface ElementWithFullscreen extends HTMLDivElement {
  webkitRequestFullscreen?: () => Promise<void>;
  mozRequestFullScreen?: () => Promise<void>;
}

interface VideoSource {
  src: string;
  quality: string;
  type: string;
}

interface VideoPlayerProps {
  sources: VideoSource[];
  poster?: string;
  title?: string;
  autoplay?: boolean;
  loop?: boolean;
  muted?: boolean;
  controls?: boolean;
  width?: number | string;
  height?: number | string;
  onPlay?: () => void;
  onPause?: () => void;
  onEnded?: () => void;
  onTimeUpdate?: (currentTime: number) => void;
  onQualityChange?: (quality: string) => void;
}

const VideoPlayer: React.FC<VideoPlayerProps> = ({
  sources,
  poster,
  title,
  autoplay = false,
  loop = false,
  muted = false,
  controls = true,
  width = "100%",
  height = "auto",
  onPlay,
  onPause,
  onEnded,
  onTimeUpdate,
  onQualityChange,
}) => {
  const [playing, setPlaying] = useState(autoplay);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [volume, setVolume] = useState(muted ? 0 : 1);
  const [showControls, setShowControls] = useState(false);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [selectedQuality, setSelectedQuality] = useState<string>(
    sources[0]?.quality || "auto",
  );
  const [showQualityMenu, setShowQualityMenu] = useState(false);

  const videoRef = useRef<HTMLVideoElement>(null);
  const playerRef = useRef<HTMLDivElement>(null);
  const progressRef = useRef<HTMLDivElement>(null);

  // Sort sources by quality (high to low)
  const sortedSources = [...sources].sort((a, b) => {
    // Extract numeric value from quality string (e.g., '720p' -> 720)
    const qualityA = parseInt(a.quality.replace(/[^\d]/g, ""), 10) || 0;
    const qualityB = parseInt(b.quality.replace(/[^\d]/g, ""), 10) || 0;
    return qualityB - qualityA;
  });

  // Get active source based on selected quality
  const activeSource =
    sortedSources.find((source) => source.quality === selectedQuality) ||
    sortedSources[0];

  useEffect(() => {
    const video = videoRef.current;
    if (!video) return;

    const handleTimeUpdate = () => {
      setCurrentTime(video.currentTime);
      if (onTimeUpdate) onTimeUpdate(video.currentTime);
    };

    const handleLoadedMetadata = () => {
      setDuration(video.duration);
    };

    const handlePlay = () => {
      setPlaying(true);
      if (onPlay) onPlay();
    };

    const handlePause = () => {
      setPlaying(false);
      if (onPause) onPause();
    };

    const handleEnded = () => {
      setPlaying(false);
      if (onEnded) onEnded();
    };

    // Set up event listeners
    video.addEventListener("timeupdate", handleTimeUpdate);
    video.addEventListener("loadedmetadata", handleLoadedMetadata);
    video.addEventListener("play", handlePlay);
    video.addEventListener("pause", handlePause);
    video.addEventListener("ended", handleEnded);

    // Set initial volume
    video.volume = volume;

    // Clean up event listeners
    return () => {
      video.removeEventListener("timeupdate", handleTimeUpdate);
      video.removeEventListener("loadedmetadata", handleLoadedMetadata);
      video.removeEventListener("play", handlePlay);
      video.removeEventListener("pause", handlePause);
      video.removeEventListener("ended", handleEnded);
    };
  }, [onPlay, onPause, onEnded, onTimeUpdate, volume]);

  // Handle fullscreen
  useEffect(() => {
    const handleFullscreenChange = () => {
      const doc = document as DocumentWithFullscreen;
      setIsFullscreen(
        Boolean(
          document.fullscreenElement ||
            doc.webkitFullscreenElement ||
            doc.mozFullScreenElement,
        ),
      );
    };

    document.addEventListener("fullscreenchange", handleFullscreenChange);
    document.addEventListener("webkitfullscreenchange", handleFullscreenChange);
    document.addEventListener("mozfullscreenchange", handleFullscreenChange);

    return () => {
      document.removeEventListener("fullscreenchange", handleFullscreenChange);
      document.removeEventListener(
        "webkitfullscreenchange",
        handleFullscreenChange,
      );
      document.removeEventListener(
        "mozfullscreenchange",
        handleFullscreenChange,
      );
    };
  }, []);

  const togglePlay = () => {
    if (!videoRef.current) return;

    if (playing) {
      videoRef.current.pause();
    } else {
      void videoRef.current.play();
    }
  };

  const seekTo = (e: React.MouseEvent<HTMLDivElement>) => {
    if (!progressRef.current || !videoRef.current) return;

    const progressRect = progressRef.current.getBoundingClientRect();
    const clickPosition = e.clientX - progressRect.left;
    const seekPercentage = clickPosition / progressRect.width;
    const seekTime = duration * seekPercentage;

    videoRef.current.currentTime = seekTime;
    setCurrentTime(seekTime);
  };

  const changeVolume = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newVolume = parseFloat(e.target.value);
    setVolume(newVolume);

    if (videoRef.current) {
      videoRef.current.volume = newVolume;
      videoRef.current.muted = newVolume === 0;
    }
  };

  const toggleMute = () => {
    if (!videoRef.current) return;

    if (volume === 0) {
      // Unmute and restore last volume
      const newVolume = 0.5;
      setVolume(newVolume);
      videoRef.current.volume = newVolume;
      videoRef.current.muted = false;
    } else {
      // Mute
      setVolume(0);
      videoRef.current.volume = 0;
      videoRef.current.muted = true;
    }
  };

  const toggleFullscreen = () => {
    if (!playerRef.current) return;

    if (isFullscreen) {
      const doc = document as DocumentWithFullscreen;
      if (document.exitFullscreen) {
        void document.exitFullscreen();
      } else if (doc.webkitExitFullscreen) {
        void doc.webkitExitFullscreen();
      } else if (doc.mozCancelFullScreen) {
        void doc.mozCancelFullScreen();
      }
    } else {
      const element = playerRef.current as ElementWithFullscreen;
      if (element.requestFullscreen) {
        void element.requestFullscreen();
      } else if (element.webkitRequestFullscreen) {
        void element.webkitRequestFullscreen();
      } else if (element.mozRequestFullScreen) {
        void element.mozRequestFullScreen();
      }
    }
  };

  const changeQuality = (quality: string) => {
    // Remember current playback time
    const currentPlaybackTime = videoRef.current?.currentTime || 0;
    const isPlaying = !videoRef.current?.paused;

    setSelectedQuality(quality);
    setShowQualityMenu(false);

    if (onQualityChange) {
      onQualityChange(quality);
    }

    // Let the video load and then restore playback state
    setTimeout(() => {
      if (videoRef.current) {
        videoRef.current.currentTime = currentPlaybackTime;
        if (isPlaying) {
          void videoRef.current.play();
        }
      }
    }, 0);
  };

  // Format buffered time for the progress bar
  const getBufferedTime = () => {
    if (!videoRef.current) return 0;

    const video = videoRef.current;
    if (video.buffered.length === 0) return 0;

    // Return the end time of the last buffered range
    return video.buffered.end(video.buffered.length - 1);
  };

  return (
    <div
      style={mergeStyles(videoPlayerStyles.videoPlayer as React.CSSProperties, {
        width,
        height,
      })}
      ref={playerRef}
      onMouseEnter={() => setShowControls(true)}
      onMouseLeave={() => setShowControls(false)}
    >
      <div style={videoPlayerStyles.videoContainer as React.CSSProperties}>
        <video
          ref={videoRef}
          style={videoPlayerStyles.videoElement as React.CSSProperties}
          poster={poster}
          autoPlay={autoplay}
          loop={loop}
          muted={muted}
          playsInline
        >
          <source src={activeSource.src} type={activeSource.type} />
          Your browser does not support the video tag.
        </video>

        <div
          style={mergeStyles(
            videoPlayerStyles.videoOverlay as React.CSSProperties,
            showControls || !playing
              ? (videoPlayerStyles.videoOverlayVisible as React.CSSProperties)
              : {},
          )}
          onClick={togglePlay}
        >
          {!playing && (
            <button
              style={videoPlayerStyles.playButton as React.CSSProperties}
              onClick={togglePlay}
              onMouseOver={(e) => {
                Object.assign(e.currentTarget.style, {
                  transform: "scale(1.1)",
                  background: "rgba(0, 0, 0, 0.8)",
                });
              }}
              onMouseOut={(e) => {
                Object.assign(e.currentTarget.style, {
                  transform: "scale(1)",
                  background: "rgba(0, 0, 0, 0.7)",
                });
              }}
            >
              ▶
            </button>
          )}
        </div>

        {controls && (
          <div
            style={mergeStyles(
              videoPlayerStyles.controls as React.CSSProperties,
              showControls || !playing
                ? (videoPlayerStyles.controlsVisible as React.CSSProperties)
                : {},
            )}
            onClick={(e) => e.stopPropagation()}
          >
            <div
              style={videoPlayerStyles.progressContainer as React.CSSProperties}
              ref={progressRef}
              onClick={seekTo}
            >
              <div
                style={mergeStyles(
                  videoPlayerStyles.progressBar as React.CSSProperties,
                  {
                    width: `${(currentTime / duration) * 100}%`,
                  },
                )}
              />
              <div
                style={mergeStyles(
                  videoPlayerStyles.progressBar as React.CSSProperties,
                  {
                    width: `${(getBufferedTime() / duration) * 100}%`,
                    opacity: 0.3,
                  },
                )}
              />
            </div>

            <div style={videoPlayerStyles.controlsRow as React.CSSProperties}>
              <div
                style={videoPlayerStyles.controlsGroup as React.CSSProperties}
              >
                <button
                  style={videoPlayerStyles.controlButton as React.CSSProperties}
                  onClick={togglePlay}
                  onMouseOver={(e) => {
                    e.currentTarget.style.opacity = "1";
                  }}
                  onMouseOut={(e) => {
                    e.currentTarget.style.opacity = "0.8";
                  }}
                >
                  {playing ? "⏸" : "▶"}
                </button>

                <div
                  style={
                    videoPlayerStyles.volumeContainer as React.CSSProperties
                  }
                >
                  <button
                    style={
                      videoPlayerStyles.controlButton as React.CSSProperties
                    }
                    onClick={toggleMute}
                    onMouseOver={(e) => {
                      e.currentTarget.style.opacity = "1";
                    }}
                    onMouseOut={(e) => {
                      e.currentTarget.style.opacity = "0.8";
                    }}
                  >
                    {volume === 0 ? "🔇" : volume < 0.5 ? "🔉" : "🔊"}
                  </button>
                  <input
                    type="range"
                    min="0"
                    max="1"
                    step="0.1"
                    value={volume}
                    onChange={changeVolume}
                    style={
                      videoPlayerStyles.volumeSlider as React.CSSProperties
                    }
                  />
                </div>

                <span
                  style={videoPlayerStyles.timeDisplay as React.CSSProperties}
                >
                  {formatDuration(currentTime)} / {formatDuration(duration)}
                </span>
              </div>

              <div
                style={videoPlayerStyles.controlsGroup as React.CSSProperties}
              >
                {sources.length > 1 && (
                  <div style={{ position: "relative" }}>
                    <button
                      style={
                        videoPlayerStyles.controlButton as React.CSSProperties
                      }
                      onClick={() => setShowQualityMenu(!showQualityMenu)}
                      onMouseOver={(e) => {
                        e.currentTarget.style.opacity = "1";
                      }}
                      onMouseOut={(e) => {
                        e.currentTarget.style.opacity = "0.8";
                      }}
                    >
                      {selectedQuality} ⚙️
                    </button>

                    {showQualityMenu && (
                      <div
                        style={{
                          position: "absolute",
                          bottom: "40px",
                          right: "0",
                          background: "rgba(0, 0, 0, 0.8)",
                          borderRadius: "4px",
                          padding: "8px",
                          zIndex: 10,
                        }}
                      >
                        {sortedSources.map((source) => (
                          <div
                            key={source.quality}
                            style={{
                              padding: "5px 10px",
                              cursor: "pointer",
                              color:
                                source.quality === selectedQuality
                                  ? "var(--blue, #1a73e8)"
                                  : "white",
                              fontWeight:
                                source.quality === selectedQuality
                                  ? "bold"
                                  : "normal",
                            }}
                            onClick={() => changeQuality(source.quality)}
                          >
                            {source.quality}
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                )}

                <button
                  style={mergeStyles(
                    videoPlayerStyles.controlButton as React.CSSProperties,
                    videoPlayerStyles.fullscreenButton as React.CSSProperties,
                  )}
                  onClick={toggleFullscreen}
                  onMouseOver={(e) => {
                    e.currentTarget.style.opacity = "1";
                  }}
                  onMouseOut={(e) => {
                    e.currentTarget.style.opacity = "0.8";
                  }}
                >
                  {isFullscreen ? "↙️" : "↗️"}
                </button>
              </div>
            </div>
          </div>
        )}
      </div>

      {title && (
        <div
          style={{
            padding: "10px",
            fontSize: "1rem",
            fontWeight: "bold",
            color: "var(--text-color)",
          }}
        >
          {title}
        </div>
      )}
    </div>
  );
};

export default VideoPlayer;
```

#### packages/ui/src/features/media/mediaPlayer.tsx

```tsx
// Import built-in modules first, then external packages
import React, { useEffect, useRef, useState } from "react";
// Import Plyr CSS
import "plyr/dist/plyr.css";

// Define interfaces for the player types
interface PlyrInstance {
  on(event: string, callback: (...args: unknown[]) => void): void;
  destroy(): void;
  currentTime?: number;
}

interface HlsInstance {
  loadSource(src: string): void;
  attachMedia(media: HTMLMediaElement): void;
  on(event: string, callback: (...args: unknown[]) => void): void;
  startLoad(): void;
  recoverMediaError(): void;
  destroy(): void;
}

// For dynamic imports and type safety
interface HlsConstructor {
  new (config?: Record<string, unknown>): HlsInstance;
  isSupported(): boolean;
}

// Dynamic imports for the actual implementations
const loadPlyr = () => import("plyr").then((m) => m.default);
const loadHls = () =>
  import("hls.js").then((m) => {
    const Hls = m.default as unknown as HlsConstructor;
    return { Hls, Events: m.Events };
  });

interface MediaPlayerProps {
  src: string;
  type: "video" | "audio";
  poster?: string;
  title?: string;
  autoplay?: boolean;
  muted?: boolean;
  crossOrigin?: "anonymous" | "use-credentials";
  onReady?: () => void;
  onPlay?: () => void;
  onPause?: () => void;
  onEnded?: () => void;
  onTimeUpdate?: (currentTime: number) => void;
  onError?: (error: unknown) => void;
  className?: string;
}

interface HlsError {
  type: string;
  fatal: boolean;
  details: string;
}

export const MediaPlayer: React.FC<MediaPlayerProps> = ({
  src,
  type,
  poster,
  title,
  autoplay = false,
  muted = false,
  crossOrigin = "anonymous",
  onReady,
  onPlay,
  onPause,
  onEnded,
  onTimeUpdate,
  onError,
  className,
}: MediaPlayerProps) => {
  const mediaRef = useRef<HTMLVideoElement | HTMLAudioElement>(null);
  const playerRef = useRef<PlyrInstance | null>(null);
  const hlsRef = useRef<HlsInstance | null>(null);

  const [_isReady, setIsReady] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!mediaRef.current) return;

    // Initialize Plyr
    void loadPlyr().then((PlyrConstructor) => {
      if (!mediaRef.current) return;

      playerRef.current = new PlyrConstructor(mediaRef.current, {
        controls: [
          "play-large",
          "play",
          "progress",
          "current-time",
          "mute",
          "volume",
          "captions",
          "settings",
          "pip",
          "airplay",
          "fullscreen",
        ],
        settings: ["quality", "speed", "loop"],
        quality: {
          default: 720,
          options: [1080, 720, 480, 360, 240],
        },
        speed: {
          selected: 1,
          options: [0.5, 0.75, 1, 1.25, 1.5, 2],
        },
      });

      // Set up event listeners
      playerRef.current.on("ready", () => {
        setIsReady(true);
        onReady?.();
      });

      playerRef.current.on("play", () => onPlay?.());
      playerRef.current.on("pause", () => onPause?.());
      playerRef.current.on("ended", () => onEnded?.());
      playerRef.current.on("timeupdate", () => {
        onTimeUpdate?.(playerRef.current?.currentTime || 0);
      });
      playerRef.current.on("error", (error: unknown) => {
        setError(error instanceof Error ? error.message : "Unknown error");
        onError?.(error);
      });
    });

    return () => {
      if (hlsRef.current) {
        hlsRef.current.destroy();
      }
      if (playerRef.current) {
        playerRef.current.destroy();
      }
    };
  }, [onEnded, onError, onPause, onPlay, onReady, onTimeUpdate]);

  useEffect(() => {
    if (!mediaRef.current || !src) return;

    const setupHLS = async () => {
      const { Hls, Events } = await loadHls();
      if (Hls.isSupported()) {
        hlsRef.current = new Hls({
          maxLoadingDelay: 4,
          maxMaxBufferLength: 30,
          lowLatencyMode: true,
        });

        if (mediaRef.current && hlsRef.current) {
          hlsRef.current.loadSource(src);
          hlsRef.current.attachMedia(mediaRef.current);

          hlsRef.current.on(Events.MANIFEST_PARSED, () => {
            if (autoplay && mediaRef.current) {
              mediaRef.current.play().catch(() => {
                // Autoplay failed, do nothing
              });
            }
          });

          hlsRef.current.on(Events.ERROR, (...args: unknown[]) => {
            const data = args[1] as HlsError;
            if (data.fatal) {
              switch (data.type) {
                case "networkError":
                  hlsRef.current?.startLoad();
                  break;
                case "mediaError":
                  hlsRef.current?.recoverMediaError();
                  break;
                default:
                  setError("Fatal HLS error");
                  onError?.(data);
                  break;
              }
            }
          });
        }
      } else if (
        mediaRef.current?.canPlayType("application/vnd.apple.mpegurl")
      ) {
        // Native HLS support (Safari)
        mediaRef.current.src = src;
      }
    };

    // Clean up previous instances
    if (hlsRef.current) {
      hlsRef.current.destroy();
      hlsRef.current = null;
    }

    // Set up new source
    if (src.includes(".m3u8")) {
      void setupHLS();
    } else {
      mediaRef.current.src = src;
    }
  }, [src, autoplay, onError]);

  const containerStyle: React.CSSProperties = {
    position: "relative",
    width: "100%",
    maxWidth: "100%",
    backgroundColor: "#000",
    aspectRatio: type === "video" ? "16/9" : "auto",
  };

  const mediaStyle: React.CSSProperties = {
    width: "100%",
    height: type === "video" ? "100%" : "auto",
  };

  const errorStyle: React.CSSProperties = {
    position: "absolute",
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)",
    color: "#fff",
    backgroundColor: "rgba(0, 0, 0, 0.7)",
    padding: "1rem",
    borderRadius: "4px",
    textAlign: "center",
  };

  return (
    <div style={containerStyle} className={className}>
      {type === "video" ? (
        <video
          ref={mediaRef as React.LegacyRef<HTMLVideoElement>}
          poster={poster}
          muted={muted}
          crossOrigin={crossOrigin}
          style={mediaStyle}
          title={title}
        >
          {error && <div style={errorStyle}>{error}</div>}
        </video>
      ) : (
        <audio
          ref={mediaRef as React.LegacyRef<HTMLAudioElement>}
          muted={muted}
          crossOrigin={crossOrigin}
          style={mediaStyle}
          title={title}
        >
          {error && <div style={errorStyle}>{error}</div>}
        </audio>
      )}
    </div>
  );
};
```

#### packages/ui/src/features/media/mediaUpload.tsx

```tsx
// src/client/components/media/MediaUpload.tsx
import React, { useCallback, useState } from "react";

interface MediaUploadProps {
  onUpload: (file: File) => Promise<void>;
  acceptedTypes?: string[];
  maxSize?: number; // in bytes
  className?: string;
}

export const MediaUpload: React.FC<MediaUploadProps> = ({
  onUpload,
  acceptedTypes = ["image/*", "audio/*", "video/*"],
  maxSize = 100 * 1024 * 1024, // 100MB default
  className,
}) => {
  const [isDragging, setIsDragging] = useState(false);
  const [isUploading, setIsUploading] = useState(false);
  const [progress, setProgress] = useState(0);
  const [error, setError] = useState<string | null>(null);
  const [preview, setPreview] = useState<string | null>(null);

  const handleDragEnter = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(true);
  }, []);

  const handleDragLeave = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(false);
  }, []);

  const handleDragOver = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
  }, []);

  const validateFile = useCallback(
    (file: File): string | null => {
      if (file.size > maxSize) {
        return `File size exceeds ${maxSize / (1024 * 1024)}MB limit`;
      }

      if (
        !acceptedTypes.some((type) => {
          if (type.endsWith("/*")) {
            const baseType = type.slice(0, -2);
            return file.type.startsWith(baseType);
          }
          return file.type === type;
        })
      ) {
        return "File type not accepted";
      }

      return null;
    },
    [maxSize, acceptedTypes],
  );

  const createPreview = (file: File) => {
    const reader = new FileReader();
    reader.onload = () => {
      setPreview(reader.result as string);
    };
    reader.readAsDataURL(file);
  };

  const handleUpload = useCallback(
    async (file: File) => {
      try {
        setIsUploading(true);
        setProgress(0);
        await onUpload(file);
        setProgress(100);
      } catch (err) {
        setError(err instanceof Error ? err.message : "Upload failed");
      } finally {
        setIsUploading(false);
      }
    },
    [onUpload],
  );

  const handleDrop = useCallback(
    async (e: React.DragEvent) => {
      e.preventDefault();
      e.stopPropagation();
      setIsDragging(false);

      const file = e.dataTransfer.files[0];
      if (!file) return;

      const validationError = validateFile(file);
      if (validationError) {
        setError(validationError);
        return;
      }

      setError(null);
      createPreview(file);
      await handleUpload(file);
    },
    [validateFile, handleUpload],
  );

  const handleFileSelect = useCallback(
    async (e: React.ChangeEvent<HTMLInputElement>) => {
      const file = e.target.files?.[0];
      if (!file) return;

      const validationError = validateFile(file);
      if (validationError) {
        setError(validationError);
        return;
      }

      setError(null);
      createPreview(file);
      await handleUpload(file);
    },
    [validateFile, handleUpload],
  );

  const getMediaIcon = () => {
    if (!preview)
      return (
        <svg className="media-upload-icon" viewBox="0 0 24 24">
          <path
            fill="currentColor"
            d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z"
          />
        </svg>
      );

    const type = preview.split(";")[0].split("/")[0];
    switch (type) {
      case "image":
        return (
          <svg className="media-upload-icon" viewBox="0 0 24 24">
            <path
              fill="currentColor"
              d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"
            />
          </svg>
        );
      case "audio":
        return (
          <svg className="media-upload-icon" viewBox="0 0 24 24">
            <path
              fill="currentColor"
              d="M12 3v18c-4.97 0-9-4.03-9-9s4.03-9 9-9zm0-2c-6.07 0-11 4.93-11 11s4.93 11 11 11 11-4.93 11-11S18.07 1 12 1zm-1 14h2V7h-2v8z"
            />
          </svg>
        );
      case "video":
        return (
          <svg className="media-upload-icon" viewBox="0 0 24 24">
            <path
              fill="currentColor"
              d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"
            />
          </svg>
        );
      default:
        return (
          <svg className="media-upload-icon" viewBox="0 0 24 24">
            <path
              fill="currentColor"
              d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z"
            />
          </svg>
        );
    }
  };

  const styles = {
    upload: {
      border: "2px dashed #ccc",
      borderRadius: "8px",
      padding: "24px",
      textAlign: "center" as const,
      backgroundColor: "#fff",
      transition: "all 0.2s ease",
      position: "relative" as const,
      ...(isDragging && {
        borderColor: "#2196f3",
        backgroundColor: "rgba(33, 150, 243, 0.05)",
      }),
    },
    input: {
      display: "none",
    },
    content: {
      display: "flex",
      flexDirection: "column" as const,
      alignItems: "center",
      gap: "16px",
    },
    icon: {
      width: "48px",
      height: "48px",
      color: "#666",
    },
    title: {
      margin: 0,
      fontSize: "1.25rem",
      fontWeight: 500,
      color: "#333",
    },
    text: {
      margin: 0,
      color: "#666",
    },
    button: {
      display: "inline-block",
      padding: "8px 16px",
      backgroundColor: "#2196f3",
      color: "white",
      borderRadius: "4px",
      cursor: "pointer",
      transition: "background-color 0.2s",
    },
    buttonHover: {
      backgroundColor: "#1976d2",
    },
    hint: {
      margin: 0,
      fontSize: "0.875rem",
      color: "#666",
    },
    error: {
      margin: 0,
      color: "#d32f2f",
    },
    progress: {
      width: "100%",
      maxWidth: "200px",
    },
    progressBar: {
      width: "100%",
      height: "4px",
      backgroundColor: "#e0e0e0",
      borderRadius: "2px",
      overflow: "hidden",
    },
    progressFill: {
      height: "100%",
      backgroundColor: "#2196f3",
      transition: "width 0.2s ease",
      width: `${progress}%`,
    },
    progressText: {
      margin: "4px 0 0",
      fontSize: "0.875rem",
      color: "#666",
    },
    preview: {
      marginTop: "16px",
      maxWidth: "100%",
      maxHeight: "200px",
      overflow: "hidden",
      borderRadius: "4px",
    },
    previewImage: {
      maxWidth: "100%",
      maxHeight: "200px",
      objectFit: "contain" as const,
    },
    previewVideo: {
      maxWidth: "100%",
      maxHeight: "200px",
    },
    previewAudio: {
      width: "100%",
      maxWidth: "300px",
    },
  };

  return (
    <div
      style={styles.upload}
      className={className}
      onDragEnter={handleDragEnter}
      onDragLeave={handleDragLeave}
      onDragOver={handleDragOver}
      onDrop={handleDrop as (e: React.DragEvent) => void}
    >
      <input
        type="file"
        accept={acceptedTypes.join(",")}
        onChange={
          handleFileSelect as (e: React.ChangeEvent<HTMLInputElement>) => void
        }
        style={styles.input}
        id="media-upload-input"
      />

      <div style={styles.content}>
        {getMediaIcon()}

        <h3 style={styles.title}>
          {isUploading ? "Uploading..." : "Drag & drop media here"}
        </h3>

        <p style={styles.text}>or</p>

        <label
          htmlFor="media-upload-input"
          style={styles.button}
          onMouseEnter={(e) =>
            (e.currentTarget.style.backgroundColor = "#1976d2")
          }
          onMouseLeave={(e) =>
            (e.currentTarget.style.backgroundColor = "#2196f3")
          }
        >
          Select File
        </label>

        <p style={styles.hint}>Supported formats: {acceptedTypes.join(", ")}</p>

        {error && <p style={styles.error}>{error}</p>}

        {isUploading && (
          <div style={styles.progress}>
            <div style={styles.progressBar}>
              <div style={styles.progressFill} />
            </div>
            <p style={styles.progressText}>{progress}%</p>
          </div>
        )}
      </div>

      {preview && !isUploading && (
        <div style={styles.preview}>
          {preview.startsWith("data:image/") ? (
            <img src={preview} alt="Preview" style={styles.previewImage} />
          ) : preview.startsWith("data:video/") ? (
            <video src={preview} controls style={styles.previewVideo} />
          ) : preview.startsWith("data:audio/") ? (
            <audio src={preview} controls style={styles.previewAudio} />
          ) : null}
        </div>
      )}
    </div>
  );
};
```

#### packages/ui/src/features/media/mediaView.tsx

```tsx
interface MediaViewProps {
  filename: string;
  type?: "audio" | "video" | "image";
  controls?: boolean;
  autoPlay?: boolean;
  width?: string | number;
  height?: string | number;
}

export function MediaView({
  filename,
  type,
  controls = true,
  autoPlay = false,
  width = "100%",
  height = "auto",
}: MediaViewProps) {
  // Construct media URL
  const mediaUrl = `/api/stream?filename=${encodeURIComponent(filename)}`;

  // Automatically detect type from filename extension if not provided
  const detectType = (): "audio" | "video" | "image" => {
    const ext = filename.split(".").pop()?.toLowerCase();

    if (["mp3", "wav", "ogg", "m4a", "flac"].includes(ext || ""))
      return "audio";
    if (["mp4", "webm", "mov", "avi"].includes(ext || "")) return "video";
    if (["jpg", "jpeg", "png", "gif", "webp", "svg"].includes(ext || ""))
      return "image";

    return "video"; // Default fallback
  };

  const mediaType = type || detectType();

  if (mediaType === "audio") {
    return (
      <audio
        src={mediaUrl}
        controls={controls}
        autoPlay={autoPlay}
        style={{ width }}
      />
    );
  }

  if (mediaType === "video") {
    return (
      <video
        src={mediaUrl}
        controls={controls}
        autoPlay={autoPlay}
        style={{ width, height }}
      />
    );
  }

  if (mediaType === "image") {
    return <img src={mediaUrl} alt={filename} style={{ width, height }} />;
  }

  return <div>Unsupported media type</div>;
}
```

#### packages/ui/src/features/social/CommentSection.tsx

```tsx
import React, { useCallback, useEffect, useState } from "react";

import { formatDate } from "../../../server/infrastructure/utils/dateHelpers";
import { socialService } from "../../services/social";

interface Comment {
  id: string;
  userId: string;
  username: string;
  userAvatar: string;
  content: string;
  likesCount: number;
  isLiked: boolean;
  createdAt: string;
  replies?: Comment[];
}

interface CommentSectionProps {
  postId: string;
  onClose: () => void;
}

export const CommentSection: React.FC<CommentSectionProps> = ({
  postId,
  onClose,
}) => {
  const [comments, setComments] = useState<Comment[]>([]);
  const [newComment, setNewComment] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [hasMore, setHasMore] = useState(false);
  const [offset, setOffset] = useState(0);

  const fetchComments = useCallback(async () => {
    setIsLoading(true);
    try {
      const response = await socialService.getComments(postId, offset);
      if (offset === 0) {
        setComments(response.comments);
      } else {
        setComments((prev) => [...prev, ...response.comments]);
      }
      setHasMore(response.hasMore);
    } catch (error) {
      console.error("Error fetching comments:", error);
    } finally {
      setIsLoading(false);
    }
  }, [postId, offset]);

  useEffect(() => {
    void fetchComments();
  }, [fetchComments]);

  const handleLoadMore = () => {
    setOffset((prev) => prev + 10);
    void fetchComments();
  };

  const handleSubmitComment = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!newComment.trim() || isLoading) return;

    setIsLoading(true);
    try {
      const comment = await socialService.createComment(postId, newComment);
      setComments((prev) => [comment, ...prev]);
      setNewComment("");
    } catch (error) {
      console.error("Error creating comment:", error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleLikeComment = async (commentId: string, isLiked: boolean) => {
    try {
      if (isLiked) {
        await socialService.unlikeComment(commentId);
      } else {
        await socialService.likeComment(commentId);
      }

      setComments((prev) =>
        prev.map((comment) =>
          comment.id === commentId
            ? {
                ...comment,
                isLiked: !isLiked,
                likesCount: isLiked
                  ? comment.likesCount - 1
                  : comment.likesCount + 1,
              }
            : comment,
        ),
      );
    } catch (error) {
      console.error("Error toggling comment like:", error);
    }
  };

  // Create void-returning wrapper functions for event handlers
  const handleLikeCommentWrapper = (commentId: string, isLiked: boolean) => {
    void handleLikeComment(commentId, isLiked);
  };

  const handleSubmitCommentWrapper = (e: React.FormEvent) => {
    void handleSubmitComment(e);
  };

  return (
    <div
      style={{
        position: "fixed",
        top: 0,
        right: 0,
        bottom: 0,
        width: "400px",
        backgroundColor: "white",
        boxShadow: "-2px 0 10px rgba(0,0,0,0.1)",
        zIndex: 1000,
        display: "flex",
        flexDirection: "column",
      }}
    >
      <div
        style={{
          padding: "16px",
          borderBottom: "1px solid #e0e0e0",
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
        }}
      >
        <h3 style={{ margin: 0 }}>Comments</h3>
        <button
          onClick={onClose}
          style={{
            background: "none",
            border: "none",
            fontSize: "1.5rem",
            cursor: "pointer",
          }}
        >
          ×
        </button>
      </div>

      <div
        style={{
          flex: 1,
          overflowY: "auto",
          padding: "16px",
        }}
      >
        {comments.length === 0 && !isLoading ? (
          <div style={{ textAlign: "center", padding: "20px", color: "#666" }}>
            No comments yet. Be the first to comment!
          </div>
        ) : (
          <>
            {comments.map((comment) => (
              <div
                key={comment.id}
                style={{
                  marginBottom: "16px",
                  padding: "12px",
                  backgroundColor: "#f9f9f9",
                  borderRadius: "8px",
                }}
              >
                <div
                  style={{
                    display: "flex",
                    alignItems: "center",
                    marginBottom: "8px",
                  }}
                >
                  <img
                    src={comment.userAvatar || "/default-avatar.png"}
                    alt={comment.username}
                    style={{
                      width: "32px",
                      height: "32px",
                      borderRadius: "50%",
                      marginRight: "8px",
                      objectFit: "cover",
                    }}
                  />
                  <div>
                    <div style={{ fontWeight: "bold", fontSize: "0.9rem" }}>
                      {comment.username}
                    </div>
                    <div style={{ fontSize: "0.7rem", color: "#666" }}>
                      {formatDate(comment.createdAt)}
                    </div>
                  </div>
                </div>

                <div style={{ marginBottom: "8px" }}>{comment.content}</div>

                <div style={{ display: "flex", alignItems: "center" }}>
                  <button
                    onClick={() =>
                      handleLikeCommentWrapper(comment.id, comment.isLiked)
                    }
                    style={{
                      background: "none",
                      border: "none",
                      display: "flex",
                      alignItems: "center",
                      color: comment.isLiked ? "var(--accent)" : "inherit",
                      fontWeight: comment.isLiked ? "bold" : "normal",
                      cursor: "pointer",
                      fontSize: "0.8rem",
                    }}
                  >
                    <span style={{ marginRight: "4px" }}>
                      {comment.isLiked ? "❤️" : "🤍"}
                    </span>
                    {comment.likesCount}
                  </button>
                </div>
              </div>
            ))}

            {hasMore && (
              <div style={{ textAlign: "center", marginTop: "16px" }}>
                <button
                  onClick={handleLoadMore}
                  disabled={isLoading}
                  style={{
                    padding: "8px 16px",
                    backgroundColor: "var(--accent)",
                    color: "white",
                    border: "none",
                    borderRadius: "4px",
                    cursor: "pointer",
                    opacity: isLoading ? 0.7 : 1,
                  }}
                >
                  {isLoading ? "Loading..." : "Load More"}
                </button>
              </div>
            )}
          </>
        )}
      </div>

      <form
        onSubmit={handleSubmitCommentWrapper}
        style={{
          padding: "16px",
          borderTop: "1px solid #e0e0e0",
          display: "flex",
        }}
      >
        <input
          type="text"
          value={newComment}
          onChange={(e) => setNewComment(e.target.value)}
          placeholder="Write a comment..."
          style={{
            flex: 1,
            padding: "8px 12px",
            border: "1px solid #e0e0e0",
            borderRadius: "20px",
            marginRight: "8px",
          }}
        />
        <button
          type="submit"
          disabled={!newComment.trim() || isLoading}
          style={{
            padding: "8px 16px",
            backgroundColor: "var(--accent)",
            color: "white",
            border: "none",
            borderRadius: "20px",
            cursor: "pointer",
            opacity: !newComment.trim() || isLoading ? 0.7 : 1,
          }}
        >
          {isLoading ? "..." : "Post"}
        </button>
      </form>
    </div>
  );
};
```

#### packages/ui/src/features/social/Comments.tsx

```tsx
import React, { useCallback, useEffect, useRef, useState } from "react";

interface Comment {
  id: string;
  userId: string;
  username: string;
  userAvatar: string;
  content: string;
  likesCount: number;
  isLiked: boolean;
  createdAt: string;
  replies?: Comment[];
}

// Define API response interfaces
interface CommentsResponse {
  comments: Comment[];
  hasMore: boolean;
}

interface CommentsProps {
  postId: string;
  onLoadMore?: () => Promise<void>;
  className?: string;
}

export const Comments: React.FC<CommentsProps> = ({
  postId,
  onLoadMore,
  className,
}) => {
  const [comments, setComments] = useState<Comment[]>([]);
  const [newComment, setNewComment] = useState("");
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [hasMore, setHasMore] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const observer = useRef<IntersectionObserver | null>(null);
  const lastCommentRef = useRef<HTMLDivElement>(null);
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  const fetchComments = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);
      // TODO: Replace with actual API call
      const response = await fetch(`/api/posts/${postId}/comments`);
      if (!response.ok) throw new Error("Failed to fetch comments");
      const data = (await response.json()) as CommentsResponse;
      setComments(data.comments);
      setHasMore(data.hasMore);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to load comments");
    } finally {
      setIsLoading(false);
    }
  }, [postId]);

  useEffect(() => {
    void fetchComments();
  }, [fetchComments]);

  const loadMore = useCallback(async () => {
    if (!hasMore || isLoading) return;

    try {
      setIsLoading(true);
      await onLoadMore?.();
      // TODO: Replace with actual API call
      const response = await fetch(
        `/api/posts/${postId}/comments?offset=${comments.length}`,
      );
      if (!response.ok) throw new Error("Failed to fetch more comments");
      const data = (await response.json()) as CommentsResponse;
      setComments((prev) => [...prev, ...data.comments]);
      setHasMore(data.hasMore);
    } catch (err) {
      setError(
        err instanceof Error ? err.message : "Failed to load more comments",
      );
    } finally {
      setIsLoading(false);
    }
  }, [hasMore, isLoading, onLoadMore, postId, comments.length]);

  useEffect(() => {
    observer.current = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting && hasMore && !isLoading) {
          void loadMore();
        }
      },
      { threshold: 0.5 },
    );

    if (lastCommentRef.current) {
      observer.current.observe(lastCommentRef.current);
    }

    return () => {
      if (observer.current) {
        observer.current.disconnect();
      }
    };
  }, [hasMore, isLoading, loadMore]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!newComment.trim()) return;

    try {
      setIsSubmitting(true);
      setError(null);
      // TODO: Replace with actual API call
      const response = await fetch(`/api/posts/${postId}/comments`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ content: newComment.trim() }),
      });

      if (!response.ok) throw new Error("Failed to post comment");

      const comment = (await response.json()) as Comment;
      setComments((prev) => [comment, ...prev]);
      setNewComment("");
      if (textareaRef.current) {
        textareaRef.current.style.height = "auto";
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to post comment");
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleLike = async (commentId: string) => {
    try {
      // TODO: Replace with actual API call
      const response = await fetch(`/api/comments/${commentId}/like`, {
        method: "POST",
      });
      if (!response.ok) throw new Error("Failed to like comment");

      setComments((prev) =>
        prev.map((comment) =>
          comment.id === commentId
            ? {
                ...comment,
                isLiked: !comment.isLiked,
                likesCount: comment.isLiked
                  ? comment.likesCount - 1
                  : comment.likesCount + 1,
              }
            : comment,
        ),
      );
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to like comment");
    }
  };

  // Void-returning wrapper for handleSubmit
  const handleSubmitWrapper = (e: React.FormEvent) => {
    void handleSubmit(e);
  };

  // Void-returning wrapper for handleLike
  const handleLikeWrapper = (commentId: string) => {
    void handleLike(commentId);
  };

  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    const now = new Date();
    const diff = now.getTime() - date.getTime();

    if (diff < 60000) return "just now";
    if (diff < 3600000) return `${Math.floor(diff / 60000)}m ago`;
    if (diff < 86400000) return `${Math.floor(diff / 3600000)}h ago`;
    return date.toLocaleDateString();
  };

  const styles = {
    container: {
      display: "flex",
      flexDirection: "column" as const,
      gap: "16px",
    },
    comment: {
      display: "flex",
      gap: "12px",
      padding: "12px",
      backgroundColor: "#f8f9fa",
      borderRadius: "8px",
    },
    avatar: {
      width: "40px",
      height: "40px",
      borderRadius: "50%",
      objectFit: "cover" as const,
    },
    content: {
      flex: 1,
    },
    header: {
      display: "flex",
      alignItems: "center",
      gap: "8px",
      marginBottom: "4px",
    },
    username: {
      fontSize: "14px",
      fontWeight: 600,
      color: "#1a1a1a",
    },
    timestamp: {
      fontSize: "12px",
      color: "#666",
    },
    text: {
      fontSize: "14px",
      lineHeight: "1.5",
      color: "#333",
      margin: "0 0 8px",
    },
    actions: {
      display: "flex",
      gap: "16px",
    },
    actionButton: {
      display: "flex",
      alignItems: "center",
      gap: "4px",
      background: "none",
      border: "none",
      color: "#666",
      cursor: "pointer",
      padding: "4px 8px",
      borderRadius: "4px",
      fontSize: "14px",
      transition: "background-color 0.2s",
      "&:hover": {
        backgroundColor: "#e9ecef",
      },
    },
    actionButtonLiked: {
      color: "#e91e63",
    },
    form: {
      display: "flex",
      gap: "12px",
      marginBottom: "16px",
    },
    textarea: {
      flex: 1,
      minHeight: "40px",
      maxHeight: "120px",
      padding: "8px 12px",
      border: "1px solid #ddd",
      borderRadius: "20px",
      fontSize: "14px",
      lineHeight: "1.5",
      resize: "none" as const,
      fontFamily: "inherit",
      "&:focus": {
        outline: "none",
        borderColor: "#2196f3",
      },
    },
    submitButton: {
      padding: "8px 16px",
      backgroundColor: "#2196f3",
      color: "#fff",
      border: "none",
      borderRadius: "20px",
      fontSize: "14px",
      fontWeight: 500,
      cursor: "pointer",
      transition: "background-color 0.2s",
      "&:hover": {
        backgroundColor: "#1976d2",
      },
      "&:disabled": {
        backgroundColor: "#ccc",
        cursor: "not-allowed",
      },
    },
    loading: {
      textAlign: "center" as const,
      padding: "16px",
      color: "#666",
    },
    error: {
      color: "#d32f2f",
      textAlign: "center" as const,
      padding: "16px",
    },
    replies: {
      marginLeft: "52px",
      borderLeft: "2px solid #e9ecef",
      paddingLeft: "12px",
    },
  };

  if (error) {
    return <div style={styles.error}>{error}</div>;
  }

  return (
    <div style={styles.container} className={className}>
      <form onSubmit={handleSubmitWrapper} style={styles.form}>
        <textarea
          ref={textareaRef}
          value={newComment}
          onChange={(e) => {
            setNewComment(e.target.value);
            e.target.style.height = "auto";
            e.target.style.height = `${e.target.scrollHeight}px`;
          }}
          placeholder="Write a comment..."
          style={styles.textarea}
        />
        <button
          type="submit"
          style={{
            ...styles.submitButton,
            ...(isSubmitting && { opacity: 0.7 }),
          }}
          disabled={isSubmitting || !newComment.trim()}
          onMouseEnter={(e) =>
            (e.currentTarget.style.backgroundColor = "#1976d2")
          }
          onMouseLeave={(e) =>
            (e.currentTarget.style.backgroundColor = "#2196f3")
          }
        >
          {isSubmitting ? "Posting..." : "Post"}
        </button>
      </form>

      {comments.map((comment, index) => (
        <div
          key={comment.id}
          ref={index === comments.length - 1 ? lastCommentRef : undefined}
          style={styles.comment}
        >
          <img
            src={comment.userAvatar}
            alt={comment.username}
            style={styles.avatar}
          />
          <div style={styles.content}>
            <div style={styles.header}>
              <span style={styles.username}>{comment.username}</span>
              <span style={styles.timestamp}>
                {formatDate(comment.createdAt)}
              </span>
            </div>
            <p style={styles.text}>{comment.content}</p>
            <div style={styles.actions}>
              <button
                style={{
                  ...styles.actionButton,
                  ...(comment.isLiked && styles.actionButtonLiked),
                }}
                onClick={() => handleLikeWrapper(comment.id)}
                onMouseEnter={(e) =>
                  (e.currentTarget.style.backgroundColor = "#e9ecef")
                }
                onMouseLeave={(e) =>
                  (e.currentTarget.style.backgroundColor = "transparent")
                }
              >
                {comment.isLiked ? "❤️" : "🤍"}
                <span>{comment.likesCount}</span>
              </button>
              <button
                style={styles.actionButton}
                onMouseEnter={(e) =>
                  (e.currentTarget.style.backgroundColor = "#e9ecef")
                }
                onMouseLeave={(e) =>
                  (e.currentTarget.style.backgroundColor = "transparent")
                }
              >
                💬 Reply
              </button>
            </div>

            {comment.replies && comment.replies.length > 0 && (
              <div style={styles.replies}>
                {comment.replies.map((reply) => (
                  <div key={reply.id} style={styles.comment}>
                    <img
                      src={reply.userAvatar}
                      alt={reply.username}
                      style={styles.avatar}
                    />
                    <div style={styles.content}>
                      <div style={styles.header}>
                        <span style={styles.username}>{reply.username}</span>
                        <span style={styles.timestamp}>
                          {formatDate(reply.createdAt)}
                        </span>
                      </div>
                      <p style={styles.text}>{reply.content}</p>
                      <div style={styles.actions}>
                        <button
                          style={{
                            ...styles.actionButton,
                            ...(reply.isLiked && styles.actionButtonLiked),
                          }}
                          onClick={() => handleLikeWrapper(reply.id)}
                          onMouseEnter={(e) =>
                            (e.currentTarget.style.backgroundColor = "#e9ecef")
                          }
                          onMouseLeave={(e) =>
                            (e.currentTarget.style.backgroundColor =
                              "transparent")
                          }
                        >
                          {reply.isLiked ? "❤️" : "🤍"}
                          <span>{reply.likesCount}</span>
                        </button>
                        <button
                          style={styles.actionButton}
                          onMouseEnter={(e) =>
                            (e.currentTarget.style.backgroundColor = "#e9ecef")
                          }
                          onMouseLeave={(e) =>
                            (e.currentTarget.style.backgroundColor =
                              "transparent")
                          }
                        >
                          💬 Reply
                        </button>
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
        </div>
      ))}

      {isLoading && <div style={styles.loading}>Loading more comments...</div>}
    </div>
  );
};
```

#### packages/ui/src/features/social/CreatePost.tsx

```tsx
import React, { useRef, useState } from "react";

import { MediaUpload } from "../media/mediaUpload";

interface CreatePostProps {
  onSubmit: (post: { content: string; media?: File }) => Promise<void>;
  className?: string;
}

export const CreatePost: React.FC<CreatePostProps> = ({
  onSubmit,
  className,
}) => {
  const [content, setContent] = useState("");
  const [media, setMedia] = useState<File | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!content.trim() && !media) return;

    try {
      setIsSubmitting(true);
      setError(null);
      await onSubmit({
        content: content.trim(),
        media: media || undefined,
      });
      setContent("");
      setMedia(null);
      if (textareaRef.current) {
        textareaRef.current.style.height = "auto";
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to create post");
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleContentChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setContent(e.target.value);
    e.target.style.height = "auto";
    e.target.style.height = `${e.target.scrollHeight}px`;
  };

  const handleMediaUpload = async (file: File): Promise<void> => {
    setMedia(file);
    return Promise.resolve();
  };

  // Void-returning wrapper for handleSubmit
  const handleSubmitWrapper = (e: React.FormEvent) => {
    void handleSubmit(e);
  };

  const styles = {
    container: {
      backgroundColor: "#fff",
      borderRadius: "8px",
      boxShadow: "0 2px 4px rgba(0,0,0,0.1)",
      padding: "16px",
    },
    form: {
      display: "flex",
      flexDirection: "column" as const,
      gap: "16px",
    },
    textarea: {
      width: "100%",
      minHeight: "100px",
      padding: "12px",
      border: "1px solid #ddd",
      borderRadius: "4px",
      fontSize: "16px",
      lineHeight: "1.5",
      resize: "none" as const,
      fontFamily: "inherit",
      "&:focus": {
        outline: "none",
        borderColor: "#2196f3",
      },
    },
    mediaPreview: {
      marginTop: "16px",
      maxWidth: "100%",
      maxHeight: "300px",
      borderRadius: "4px",
      overflow: "hidden",
    },
    mediaImage: {
      maxWidth: "100%",
      maxHeight: "300px",
      objectFit: "contain" as const,
    },
    actions: {
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
    },
    submitButton: {
      padding: "8px 24px",
      backgroundColor: "#2196f3",
      color: "#fff",
      border: "none",
      borderRadius: "20px",
      fontSize: "16px",
      fontWeight: 500,
      cursor: "pointer",
      transition: "background-color 0.2s",
      "&:hover": {
        backgroundColor: "#1976d2",
      },
      "&:disabled": {
        backgroundColor: "#ccc",
        cursor: "not-allowed",
      },
    },
    error: {
      color: "#d32f2f",
      fontSize: "14px",
      marginTop: "8px",
    },
  };

  return (
    <div style={styles.container} className={className}>
      <form onSubmit={handleSubmitWrapper} style={styles.form}>
        <textarea
          ref={textareaRef}
          value={content}
          onChange={handleContentChange}
          placeholder="What's on your mind?"
          style={styles.textarea}
        />

        {media && (
          <div style={styles.mediaPreview}>
            {media.type.startsWith("image/") ? (
              <img
                src={URL.createObjectURL(media)}
                alt="Preview"
                style={styles.mediaImage}
              />
            ) : (
              <MediaUpload
                onUpload={handleMediaUpload}
                acceptedTypes={[media.type]}
                maxSize={media.size}
              />
            )}
          </div>
        )}

        <div style={styles.actions}>
          <MediaUpload
            onUpload={handleMediaUpload}
            acceptedTypes={["image/*", "video/*", "audio/*"]}
            maxSize={100 * 1024 * 1024} // 100MB
          />
          <button
            type="submit"
            style={{
              ...styles.submitButton,
              ...(isSubmitting && { opacity: 0.7 }),
            }}
            disabled={isSubmitting || (!content.trim() && !media)}
            onMouseEnter={(e) =>
              (e.currentTarget.style.backgroundColor = "#1976d2")
            }
            onMouseLeave={(e) =>
              (e.currentTarget.style.backgroundColor = "#2196f3")
            }
          >
            {isSubmitting ? "Posting..." : "Post"}
          </button>
        </div>

        {error && <div style={styles.error}>{error}</div>}
      </form>
    </div>
  );
};
```

#### packages/ui/src/features/social/CreatePostForm.tsx

```tsx
import React, { useRef, useState } from "react";

import { socialService } from "../../services/social";

interface CreatePostFormProps {
  onPostCreated: () => void;
}

export const CreatePostForm: React.FC<CreatePostFormProps> = ({
  onPostCreated,
}) => {
  const [content, setContent] = useState("");
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [previewUrl, setPreviewUrl] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files.length > 0) {
      const file = e.target.files[0];
      setSelectedFile(file);

      // Create preview URL for images
      if (file.type.startsWith("image/")) {
        const reader = new FileReader();
        reader.onloadend = () => {
          setPreviewUrl(reader.result as string);
        };
        reader.readAsDataURL(file);
      } else {
        setPreviewUrl(null);
      }
    }
  };

  const handleRemoveFile = () => {
    setSelectedFile(null);
    setPreviewUrl(null);
    if (fileInputRef.current) {
      fileInputRef.current.value = "";
    }
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if ((!content.trim() && !selectedFile) || isLoading) return;

    setIsLoading(true);
    try {
      await socialService.createPost(content, selectedFile || undefined);
      setContent("");
      setSelectedFile(null);
      setPreviewUrl(null);
      if (fileInputRef.current) {
        fileInputRef.current.value = "";
      }
      onPostCreated();
    } catch (error) {
      console.error("Error creating post:", error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div
      style={{
        border: "1px solid #e0e0e0",
        borderRadius: "8px",
        padding: "16px",
        marginBottom: "24px",
        backgroundColor: "white",
        boxShadow: "0 1px 3px rgba(0,0,0,0.1)",
      }}
    >
      <form onSubmit={handleSubmit as (e: React.FormEvent) => void}>
        <textarea
          value={content}
          onChange={(e) => setContent(e.target.value)}
          placeholder="What's on your mind?"
          style={{
            width: "100%",
            minHeight: "100px",
            padding: "12px",
            border: "1px solid #e0e0e0",
            borderRadius: "8px",
            resize: "vertical",
            marginBottom: "12px",
          }}
        />

        {previewUrl && (
          <div style={{ position: "relative", marginBottom: "12px" }}>
            <img
              src={previewUrl}
              alt="Preview"
              style={{
                maxWidth: "100%",
                maxHeight: "300px",
                borderRadius: "8px",
                objectFit: "cover",
              }}
            />
            <button
              type="button"
              onClick={handleRemoveFile}
              style={{
                position: "absolute",
                top: "8px",
                right: "8px",
                width: "24px",
                height: "24px",
                borderRadius: "50%",
                backgroundColor: "rgba(0,0,0,0.5)",
                color: "white",
                border: "none",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                cursor: "pointer",
              }}
            >
              ×
            </button>
          </div>
        )}

        {selectedFile && !previewUrl && (
          <div
            style={{
              display: "flex",
              alignItems: "center",
              backgroundColor: "#f5f5f5",
              padding: "8px 12px",
              borderRadius: "4px",
              marginBottom: "12px",
            }}
          >
            <div style={{ flex: 1 }}>
              <div style={{ fontWeight: "bold" }}>{selectedFile.name}</div>
              <div style={{ fontSize: "0.8rem", color: "#666" }}>
                {(selectedFile.size / 1024 / 1024).toFixed(2)} MB
              </div>
            </div>
            <button
              type="button"
              onClick={handleRemoveFile}
              style={{
                background: "none",
                border: "none",
                color: "#666",
                cursor: "pointer",
                fontSize: "1.2rem",
              }}
            >
              ×
            </button>
          </div>
        )}

        <div
          style={{
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
          }}
        >
          <div>
            <input
              type="file"
              id="file-input"
              ref={fileInputRef}
              onChange={handleFileChange}
              accept="image/*,video/*,audio/*"
              style={{ display: "none" }}
            />
            <button
              type="button"
              onClick={() => fileInputRef.current?.click()}
              style={{
                background: "none",
                border: "none",
                color: "var(--accent)",
                cursor: "pointer",
                display: "flex",
                alignItems: "center",
              }}
            >
              <span style={{ marginRight: "4px" }}>📎</span>
              Add Media
            </button>
          </div>

          <button
            type="submit"
            disabled={(!content.trim() && !selectedFile) || isLoading}
            style={{
              padding: "8px 24px",
              backgroundColor: "var(--accent)",
              color: "white",
              border: "none",
              borderRadius: "20px",
              cursor: "pointer",
              opacity:
                (!content.trim() && !selectedFile) || isLoading ? 0.7 : 1,
            }}
          >
            {isLoading ? "Posting..." : "Post"}
          </button>
        </div>
      </form>
    </div>
  );
};
```

#### packages/ui/src/features/social/Feed.tsx

```tsx
import React, { useCallback, useEffect, useRef, useState } from "react";

import { MediaPlayer } from "../media/mediaPlayer";

interface Post {
  id: string;
  userId: string;
  username: string;
  userAvatar: string;
  content: string;
  media?: {
    type: "image" | "video" | "audio";
    url: string;
    thumbnail?: string;
  };
  likesCount: number;
  commentsCount: number;
  sharesCount: number;
  isLiked: boolean;
  createdAt: string;
}

// Add API response type definitions
interface FeedResponse {
  posts: Post[];
  hasMore: boolean;
}

interface FeedProps {
  type: "home" | "profile" | "explore";
  userId?: string;
  onLoadMore?: () => Promise<void>;
  className?: string;
}

export const Feed: React.FC<FeedProps> = ({
  type,
  userId,
  onLoadMore,
  className,
}) => {
  const [posts, setPosts] = useState<Post[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [hasMore, setHasMore] = useState(true);
  const observer = useRef<IntersectionObserver | null>(null);
  const lastPostRef = useRef<HTMLDivElement>(null);

  const fetchPosts = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);
      // TODO: Replace with actual API call
      const response = await fetch(
        `/api/feed?type=${type}${userId ? `&userId=${userId}` : ""}`,
      );
      if (!response.ok) throw new Error("Failed to fetch posts");
      const data = (await response.json()) as FeedResponse;
      setPosts(data.posts);
      setHasMore(data.hasMore);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to load posts");
    } finally {
      setIsLoading(false);
    }
  }, [type, userId]);

  const loadMore = useCallback(async () => {
    if (!hasMore || isLoading) return;

    try {
      setIsLoading(true);
      await onLoadMore?.();
      // TODO: Replace with actual API call
      const response = await fetch(
        `/api/feed?type=${type}${userId ? `&userId=${userId}` : ""}&offset=${posts.length}`,
      );
      if (!response.ok) throw new Error("Failed to fetch more posts");
      const data = (await response.json()) as FeedResponse;
      setPosts((prev) => [...prev, ...data.posts]);
      setHasMore(data.hasMore);
    } catch (err) {
      setError(
        err instanceof Error ? err.message : "Failed to load more posts",
      );
    } finally {
      setIsLoading(false);
    }
  }, [hasMore, isLoading, onLoadMore, posts.length, type, userId]);

  useEffect(() => {
    void fetchPosts();
  }, [fetchPosts, type, userId]);

  useEffect(() => {
    observer.current = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting && hasMore && !isLoading) {
          void loadMore();
        }
      },
      { threshold: 0.5 },
    );

    if (lastPostRef.current) {
      observer.current.observe(lastPostRef.current);
    }

    return () => {
      if (observer.current) {
        observer.current.disconnect();
      }
    };
  }, [loadMore, hasMore, isLoading]);

  const handleLike = async (postId: string) => {
    try {
      // TODO: Replace with actual API call
      const response = await fetch(`/api/posts/${postId}/like`, {
        method: "POST",
      });
      if (!response.ok) throw new Error("Failed to like post");

      setPosts((prev) =>
        prev.map((post) =>
          post.id === postId
            ? {
                ...post,
                isLiked: !post.isLiked,
                likesCount: post.isLiked
                  ? post.likesCount - 1
                  : post.likesCount + 1,
              }
            : post,
        ),
      );
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to like post");
    }
  };

  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    const now = new Date();
    const diff = now.getTime() - date.getTime();

    if (diff < 60000) return "just now";
    if (diff < 3600000) return `${Math.floor(diff / 60000)}m ago`;
    if (diff < 86400000) return `${Math.floor(diff / 3600000)}h ago`;
    return date.toLocaleDateString();
  };

  const styles = {
    container: {
      display: "flex",
      flexDirection: "column" as const,
      gap: "16px",
      maxWidth: "600px",
      margin: "0 auto",
      padding: "16px",
    },
    post: {
      backgroundColor: "#fff",
      borderRadius: "8px",
      boxShadow: "0 2px 4px rgba(0,0,0,0.1)",
      overflow: "hidden",
    },
    postHeader: {
      display: "flex",
      alignItems: "center",
      padding: "12px",
      gap: "12px",
    },
    avatar: {
      width: "40px",
      height: "40px",
      borderRadius: "50%",
      objectFit: "cover" as const,
    },
    userInfo: {
      flex: 1,
    },
    username: {
      fontSize: "16px",
      fontWeight: 600,
      color: "#1a1a1a",
      margin: 0,
    },
    timestamp: {
      fontSize: "14px",
      color: "#666",
      margin: "4px 0 0",
    },
    content: {
      padding: "0 12px 12px",
      fontSize: "16px",
      lineHeight: "1.5",
      color: "#333",
    },
    media: {
      width: "100%",
      maxHeight: "600px",
      objectFit: "cover" as const,
    },
    actions: {
      display: "flex",
      padding: "12px",
      gap: "16px",
      borderTop: "1px solid #eee",
    },
    actionButton: {
      display: "flex",
      alignItems: "center",
      gap: "8px",
      background: "none",
      border: "none",
      color: "#666",
      cursor: "pointer",
      padding: "4px 8px",
      borderRadius: "4px",
      transition: "background-color 0.2s",
      "&:hover": {
        backgroundColor: "#f5f5f5",
      },
    },
    actionButtonLiked: {
      color: "#e91e63",
    },
    actionCount: {
      fontSize: "14px",
    },
    loading: {
      textAlign: "center" as const,
      padding: "24px",
      color: "#666",
    },
    error: {
      color: "#d32f2f",
      textAlign: "center" as const,
      padding: "16px",
    },
  };

  if (error) {
    return <div style={styles.error}>{error}</div>;
  }

  return (
    <div style={styles.container} className={className}>
      {posts.map((post, index) => (
        <div
          key={post.id}
          ref={index === posts.length - 1 ? lastPostRef : undefined}
          style={styles.post}
        >
          <div style={styles.postHeader}>
            <img
              src={post.userAvatar}
              alt={post.username}
              style={styles.avatar}
            />
            <div style={styles.userInfo}>
              <p style={styles.username}>{post.username}</p>
              <p style={styles.timestamp}>{formatDate(post.createdAt)}</p>
            </div>
          </div>

          <p style={styles.content}>{post.content}</p>

          {post.media &&
            (post.media.type === "image" ? (
              <img src={post.media.url} alt="Post media" style={styles.media} />
            ) : (
              <MediaPlayer
                src={post.media.url}
                type={post.media.type}
                poster={post.media.thumbnail}
              />
            ))}

          <div style={styles.actions}>
            <button
              style={{
                ...styles.actionButton,
                ...(post.isLiked && styles.actionButtonLiked),
              }}
              onClick={() => void handleLike(post.id)}
              onMouseEnter={(e) =>
                (e.currentTarget.style.backgroundColor = "#f5f5f5")
              }
              onMouseLeave={(e) =>
                (e.currentTarget.style.backgroundColor = "transparent")
              }
            >
              {post.isLiked ? "❤️" : "🤍"}
              <span style={styles.actionCount}>{post.likesCount}</span>
            </button>
            <button
              style={styles.actionButton}
              onMouseEnter={(e) =>
                (e.currentTarget.style.backgroundColor = "#f5f5f5")
              }
              onMouseLeave={(e) =>
                (e.currentTarget.style.backgroundColor = "transparent")
              }
            >
              💬
              <span style={styles.actionCount}>{post.commentsCount}</span>
            </button>
            <button
              style={styles.actionButton}
              onMouseEnter={(e) =>
                (e.currentTarget.style.backgroundColor = "#f5f5f5")
              }
              onMouseLeave={(e) =>
                (e.currentTarget.style.backgroundColor = "transparent")
              }
            >
              🔄
              <span style={styles.actionCount}>{post.sharesCount}</span>
            </button>
          </div>
        </div>
      ))}

      {isLoading && <div style={styles.loading}>Loading more posts...</div>}
    </div>
  );
};
```

#### packages/ui/src/features/social/PostCard.tsx

```tsx
import React, { useState } from "react";

import { formatDate } from "@/client/helpers/formatters";

import { socialService } from "../../services/social";

interface Post {
  id: string;
  userId: string;
  username: string;
  userAvatar: string;
  content: string;
  media?: {
    type: "image" | "video" | "audio";
    url: string;
    thumbnail?: string;
  };
  likesCount: number;
  commentsCount: number;
  sharesCount: number;
  isLiked: boolean;
  createdAt: string;
}

interface PostCardProps {
  post: Post;
  onCommentClick: (postId: string) => void;
  onRefresh: () => void;
}

export const PostCard: React.FC<PostCardProps> = ({
  post,
  onCommentClick,
  onRefresh,
}) => {
  const [isLiked, setIsLiked] = useState(post.isLiked);
  const [likesCount, setLikesCount] = useState(post.likesCount);
  const [isLoading, setIsLoading] = useState(false);

  const handleLikeToggle = async () => {
    if (isLoading) return;

    setIsLoading(true);
    try {
      if (isLiked) {
        await socialService.unlikePost(post.id);
        setIsLiked(false);
        setLikesCount((prev) => prev - 1);
      } else {
        await socialService.likePost(post.id);
        setIsLiked(true);
        setLikesCount((prev) => prev + 1);
      }
    } catch (error) {
      console.error("Error toggling like:", error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleShare = async () => {
    if (isLoading) return;

    setIsLoading(true);
    try {
      await socialService.sharePost(post.id);
      onRefresh();
    } catch (error) {
      console.error("Error sharing post:", error);
    } finally {
      setIsLoading(false);
    }
  };

  const renderMedia = () => {
    if (!post.media) return null;

    switch (post.media.type) {
      case "image":
        return (
          <div style={{ marginTop: "12px" }}>
            <img
              src={post.media.url}
              alt="Post media"
              style={{
                maxWidth: "100%",
                borderRadius: "8px",
                maxHeight: "400px",
                objectFit: "cover",
              }}
            />
          </div>
        );
      case "video":
        return (
          <div style={{ marginTop: "12px" }}>
            <video
              src={post.media.url}
              controls
              poster={post.media.thumbnail}
              style={{
                maxWidth: "100%",
                borderRadius: "8px",
                maxHeight: "400px",
              }}
            />
          </div>
        );
      case "audio":
        return (
          <div style={{ marginTop: "12px" }}>
            <audio src={post.media.url} controls style={{ width: "100%" }} />
          </div>
        );
      default:
        return null;
    }
  };

  return (
    <div
      style={{
        border: "1px solid #e0e0e0",
        borderRadius: "8px",
        padding: "16px",
        marginBottom: "16px",
        backgroundColor: "white",
        boxShadow: "0 1px 3px rgba(0,0,0,0.1)",
      }}
    >
      <div
        style={{ display: "flex", alignItems: "center", marginBottom: "12px" }}
      >
        <img
          src={post.userAvatar || "/default-avatar.png"}
          alt={post.username}
          style={{
            width: "40px",
            height: "40px",
            borderRadius: "50%",
            marginRight: "12px",
            objectFit: "cover",
          }}
        />
        <div>
          <div style={{ fontWeight: "bold" }}>{post.username}</div>
          <div style={{ fontSize: "0.8rem", color: "#666" }}>
            {formatDate(post.createdAt)}
          </div>
        </div>
      </div>

      <div style={{ marginBottom: "12px" }}>{post.content}</div>

      {renderMedia()}

      <div
        style={{
          display: "flex",
          justifyContent: "space-between",
          marginTop: "16px",
          padding: "8px 0",
          borderTop: "1px solid #f0f0f0",
        }}
      >
        <div style={{ display: "flex", alignItems: "center" }}>
          <button
            onClick={() => void handleLikeToggle()}
            style={{
              background: "none",
              border: "none",
              display: "flex",
              alignItems: "center",
              color: isLiked ? "var(--accent)" : "inherit",
              fontWeight: isLiked ? "bold" : "normal",
              cursor: "pointer",
            }}
          >
            <span style={{ marginRight: "4px" }}>{isLiked ? "❤️" : "🤍"}</span>
            {likesCount}
          </button>
        </div>

        <div>
          <button
            onClick={() => onCommentClick(post.id)}
            style={{
              background: "none",
              border: "none",
              display: "flex",
              alignItems: "center",
              cursor: "pointer",
              marginRight: "16px",
            }}
          >
            <span style={{ marginRight: "4px" }}>💬</span>
            {post.commentsCount}
          </button>
        </div>

        <div>
          <button
            onClick={() => void handleShare()}
            style={{
              background: "none",
              border: "none",
              display: "flex",
              alignItems: "center",
              cursor: "pointer",
            }}
          >
            <span style={{ marginRight: "4px" }}>🔄</span>
            {post.sharesCount}
          </button>
        </div>
      </div>
    </div>
  );
};
```

#### packages/ui/src/features/social/SocialFeed.tsx

```tsx
import React, { useEffect, useState } from "react";

import { formatRelativeTime } from "../../helpers/formatters";
import { socialFeedStyles } from "../../styles";
import { mergeStyles } from "../../utils/styleUtils";
import AudioPlayer from "../media/AudioPlayer";
import ImageGallery from "../media/ImageGallery";
import VideoPlayer from "../media/VideoPlayer";

// Types for different media content
interface TrackData {
  id: string;
  title: string;
  artist: string;
  coverArt: string;
  audioUrl: string;
}

interface ImageData {
  src: string;
  width: number;
  height: number;
  alt?: string;
}

interface VideoData {
  sources: Array<{
    src: string;
    quality: string;
    type: string;
  }>;
  poster?: string;
  title?: string;
  duration?: number;
}

interface PostData {
  id: string;
  userId: string;
  username: string;
  userAvatar: string;
  content: string;
  mediaType?: "image" | "video" | "audio" | "carousel";
  track?: TrackData;
  image?: ImageData;
  video?: VideoData;
  carousel?: ImageData[];
  likesCount: number;
  commentsCount: number;
  sharesCount: number;
  viewsCount?: number;
  isLiked: boolean;
  tags?: string[];
  location?: string;
  createdAt: string;
}

interface SocialFeedProps {
  initialPosts?: PostData[];
  onLikePost?: (postId: string, isLiked: boolean) => void;
  onCommentPost?: (postId: string, comment: string) => void;
  onSharePost?: (postId: string) => void;
  onViewPost?: (postId: string) => void;
}

const SocialFeed: React.FC<SocialFeedProps> = ({
  initialPosts = [],
  onLikePost,
  onCommentPost,
  onSharePost,
  onViewPost,
}) => {
  const [posts, setPosts] = useState<PostData[]>(initialPosts);
  const [newComment, setNewComment] = useState<string>("");
  const [activePostId, setActivePostId] = useState<string | null>(null);
  const [expandedCaption, setExpandedCaption] = useState<string | null>(null);

  useEffect(() => {
    // In a real app, you would fetch posts from an API
    if (initialPosts.length === 0) {
      // Mock data for demonstration
      const mockPosts: PostData[] = [
        {
          id: "1",
          userId: "user1",
          username: "JohnDoe",
          userAvatar: "/images/avatars/user1.jpg",
          content:
            "Check out this awesome new track I discovered! #newmusic #recommended",
          mediaType: "audio",
          track: {
            id: "track1",
            title: "Awesome Track",
            artist: "Amazing Artist",
            coverArt: "/images/covers/track1.jpg",
            audioUrl: "/audio/track1.mp3",
          },
          likesCount: 42,
          commentsCount: 7,
          sharesCount: 3,
          isLiked: false,
          tags: ["newmusic", "recommended"],
          createdAt: new Date(Date.now() - 3600000).toISOString(), // 1 hour ago
        },
        {
          id: "2",
          userId: "user2",
          username: "TravelLover",
          userAvatar: "/images/avatars/user2.jpg",
          content:
            "Amazing view from my hotel this morning! #travel #vacation #sunrise",
          mediaType: "image",
          image: {
            src: "/images/posts/travel1.jpg",
            width: 1080,
            height: 1350,
            alt: "Sunrise view from hotel balcony",
          },
          likesCount: 128,
          commentsCount: 14,
          sharesCount: 5,
          isLiked: true,
          location: "Bali, Indonesia",
          tags: ["travel", "vacation", "sunrise"],
          createdAt: new Date(Date.now() - 86400000).toISOString(), // 1 day ago
        },
        {
          id: "3",
          userId: "user3",
          username: "FoodieChef",
          userAvatar: "/images/avatars/user3.jpg",
          content:
            "Made this delicious pasta dish yesterday! Swipe to see the process 👨‍🍳 #homemade #cooking #pasta",
          mediaType: "carousel",
          carousel: [
            {
              src: "/images/posts/food1.jpg",
              width: 1080,
              height: 1080,
              alt: "Finished pasta dish",
            },
            {
              src: "/images/posts/food2.jpg",
              width: 1080,
              height: 1080,
              alt: "Cooking process",
            },
            {
              src: "/images/posts/food3.jpg",
              width: 1080,
              height: 1080,
              alt: "Ingredients",
            },
          ],
          likesCount: 89,
          commentsCount: 9,
          sharesCount: 2,
          isLiked: false,
          tags: ["homemade", "cooking", "pasta"],
          createdAt: new Date(Date.now() - 172800000).toISOString(), // 2 days ago
        },
        {
          id: "4",
          userId: "user4",
          username: "FilmCreator",
          userAvatar: "/images/avatars/user4.jpg",
          content:
            "Just finished editing my latest short film! Check it out and let me know what you think 🎬 #shortfilm #filmmaker #cinematography",
          mediaType: "video",
          video: {
            sources: [
              {
                src: "/videos/film1.mp4",
                quality: "720p",
                type: "video/mp4",
              },
              {
                src: "/videos/film1-480p.mp4",
                quality: "480p",
                type: "video/mp4",
              },
            ],
            poster: "/images/posts/film1-poster.jpg",
            title: "My Short Film",
          },
          likesCount: 215,
          commentsCount: 32,
          sharesCount: 18,
          viewsCount: 1240,
          isLiked: false,
          tags: ["shortfilm", "filmmaker", "cinematography"],
          createdAt: new Date(Date.now() - 259200000).toISOString(), // 3 days ago
        },
      ];

      setPosts(mockPosts);
    }
  }, [initialPosts]);

  const handleLike = (postId: string) => {
    setPosts((prevPosts) =>
      prevPosts.map((post) => {
        if (post.id === postId) {
          const newIsLiked = !post.isLiked;
          const likeDelta = newIsLiked ? 1 : -1;

          if (onLikePost) {
            onLikePost(postId, newIsLiked);
          }

          return {
            ...post,
            isLiked: newIsLiked,
            likesCount: post.likesCount + likeDelta,
          };
        }
        return post;
      }),
    );
  };

  const handleComment = (postId: string) => {
    if (!newComment.trim()) return;

    if (onCommentPost) {
      onCommentPost(postId, newComment);
    }

    setPosts((prevPosts) =>
      prevPosts.map((post) => {
        if (post.id === postId) {
          return {
            ...post,
            commentsCount: post.commentsCount + 1,
          };
        }
        return post;
      }),
    );

    setNewComment("");
    setActivePostId(null);
  };

  const handleShare = (postId: string) => {
    if (onSharePost) {
      onSharePost(postId);
    }

    setPosts((prevPosts) =>
      prevPosts.map((post) => {
        if (post.id === postId) {
          return {
            ...post,
            sharesCount: post.sharesCount + 1,
          };
        }
        return post;
      }),
    );
  };

  const handleView = (postId: string) => {
    if (onViewPost) {
      onViewPost(postId);
    }
  };

  const toggleCaption = (postId: string) => {
    setExpandedCaption(expandedCaption === postId ? null : postId);
  };

  const renderTags = (tags?: string[]) => {
    if (!tags || tags.length === 0) return null;

    return (
      <div className="post-tags">
        {tags.map((tag) => (
          <a
            key={tag}
            href={`/tag/${tag}`}
            className="tag"
            onClick={(e) => {
              e.preventDefault();
              // Handle tag click
            }}
          >
            #{tag}
          </a>
        ))}
      </div>
    );
  };

  const renderMediaContent = (post: PostData) => {
    switch (post.mediaType) {
      case "audio":
        if (!post.track) return null;
        return (
          <div className="post-media post-audio">
            <AudioPlayer
              trackUrl={post.track.audioUrl}
              trackTitle={post.track.title}
              artistName={post.track.artist}
              coverArtUrl={post.track.coverArt}
              onPlay={() => handleView(post.id)}
            />
          </div>
        );

      case "image":
        if (!post.image) return null;
        return (
          <div className="post-media post-image">
            <ImageGallery
              images={[post.image]}
              showThumbnails={false}
              showNavigation={false}
              aspectRatio={post.image.width / post.image.height}
              onClick={() => handleView(post.id)}
            />
          </div>
        );

      case "video":
        if (!post.video) return null;
        return (
          <div className="post-media post-video">
            <VideoPlayer
              sources={post.video.sources}
              poster={post.video.poster}
              title={post.video.title}
              onPlay={() => handleView(post.id)}
            />
            {post.viewsCount !== undefined && (
              <div className="view-count">
                {post.viewsCount.toLocaleString()} views
              </div>
            )}
          </div>
        );

      case "carousel":
        if (!post.carousel || post.carousel.length === 0) return null;
        return (
          <div className="post-media post-carousel">
            <ImageGallery
              images={post.carousel}
              showThumbnails={false}
              aspectRatio={post.carousel[0].width / post.carousel[0].height}
              onClick={() => handleView(post.id)}
            />
          </div>
        );

      default:
        return null;
    }
  };

  return (
    <div style={socialFeedStyles.socialFeed as React.CSSProperties}>
      <div style={socialFeedStyles.feedHeader as React.CSSProperties}>
        <h2 style={socialFeedStyles.feedTitle as React.CSSProperties}>Feed</h2>
        <div style={socialFeedStyles.feedFilter as React.CSSProperties}>
          <button
            style={mergeStyles(
              socialFeedStyles.filterButton as React.CSSProperties,
              socialFeedStyles.filterButtonActive as React.CSSProperties,
            )}
          >
            For You
          </button>
          <button
            style={socialFeedStyles.filterButton as React.CSSProperties}
            onMouseOver={(e) => {
              e.currentTarget.style.background = "var(--hover)";
            }}
            onMouseOut={(e) => {
              e.currentTarget.style.background = "var(--background2)";
            }}
          >
            Following
          </button>
          <button
            style={socialFeedStyles.filterButton as React.CSSProperties}
            onMouseOver={(e) => {
              e.currentTarget.style.background = "var(--hover)";
            }}
            onMouseOut={(e) => {
              e.currentTarget.style.background = "var(--background2)";
            }}
          >
            Popular
          </button>
        </div>
      </div>

      {posts.length === 0 ? (
        <div style={socialFeedStyles.emptyFeed as React.CSSProperties}>
          No posts to display
        </div>
      ) : (
        <div style={socialFeedStyles.postList as React.CSSProperties}>
          {posts.map((post) => (
            <div
              key={post.id}
              style={socialFeedStyles.postCard as React.CSSProperties}
            >
              <div style={socialFeedStyles.postHeader as React.CSSProperties}>
                <div style={socialFeedStyles.postAvatar as React.CSSProperties}>
                  <img
                    src={post.userAvatar}
                    alt={`${post.username}'s avatar`}
                    style={
                      socialFeedStyles.postAvatarImg as React.CSSProperties
                    }
                  />
                </div>
                <div
                  style={socialFeedStyles.postUserInfo as React.CSSProperties}
                >
                  <h3
                    style={socialFeedStyles.postUsername as React.CSSProperties}
                  >
                    {post.username}
                  </h3>
                  <p style={socialFeedStyles.postTime as React.CSSProperties}>
                    {formatRelativeTime(new Date(post.createdAt))}
                    {post.location && ` • ${post.location}`}
                  </p>
                </div>
                <button
                  style={socialFeedStyles.postOptions as React.CSSProperties}
                  onMouseOver={(e) => {
                    e.currentTarget.style.background = "var(--hover)";
                  }}
                  onMouseOut={(e) => {
                    e.currentTarget.style.background = "transparent";
                  }}
                >
                  ⋮
                </button>
              </div>

              {post.mediaType && (
                <div style={socialFeedStyles.postMedia as React.CSSProperties}>
                  {renderMediaContent(post)}
                </div>
              )}

              <div style={socialFeedStyles.postContent as React.CSSProperties}>
                {post.content.length > 150 && expandedCaption !== post.id ? (
                  <>
                    {post.content.substring(0, 150)}...{" "}
                    <button
                      onClick={() => toggleCaption(post.id)}
                      style={{
                        background: "transparent",
                        border: "none",
                        color: "var(--text-color2)",
                        cursor: "pointer",
                        padding: 0,
                      }}
                    >
                      more
                    </button>
                  </>
                ) : (
                  <>
                    {post.content}
                    {post.content.length > 150 && (
                      <button
                        onClick={() => toggleCaption(post.id)}
                        style={{
                          background: "transparent",
                          border: "none",
                          color: "var(--text-color2)",
                          cursor: "pointer",
                          padding: 0,
                          marginLeft: "5px",
                        }}
                      >
                        less
                      </button>
                    )}
                  </>
                )}

                {post.tags && post.tags.length > 0 && (
                  <div style={{ marginTop: "8px" }}>
                    {renderTags(post.tags)}
                  </div>
                )}
              </div>

              <div style={socialFeedStyles.postActions as React.CSSProperties}>
                <button
                  style={mergeStyles(
                    socialFeedStyles.postAction as React.CSSProperties,
                    post.isLiked
                      ? (socialFeedStyles.postActionLiked as React.CSSProperties)
                      : {},
                  )}
                  onClick={() => handleLike(post.id)}
                  onMouseOver={(e) => {
                    if (!post.isLiked) {
                      e.currentTarget.style.background = "var(--hover)";
                    }
                  }}
                  onMouseOut={(e) => {
                    if (!post.isLiked) {
                      e.currentTarget.style.background = "transparent";
                    }
                  }}
                >
                  {post.isLiked ? "❤️" : "🤍"} {post.likesCount}
                </button>

                <button
                  style={socialFeedStyles.postAction as React.CSSProperties}
                  onClick={() =>
                    setActivePostId(activePostId === post.id ? null : post.id)
                  }
                  onMouseOver={(e) => {
                    e.currentTarget.style.background = "var(--hover)";
                  }}
                  onMouseOut={(e) => {
                    e.currentTarget.style.background = "transparent";
                  }}
                >
                  💬 {post.commentsCount}
                </button>

                <button
                  style={socialFeedStyles.postAction as React.CSSProperties}
                  onClick={() => handleShare(post.id)}
                  onMouseOver={(e) => {
                    e.currentTarget.style.background = "var(--hover)";
                  }}
                  onMouseOut={(e) => {
                    e.currentTarget.style.background = "transparent";
                  }}
                >
                  🔄 {post.sharesCount}
                </button>

                {post.viewsCount && (
                  <span
                    style={{
                      marginLeft: "auto",
                      color: "var(--text-color2)",
                      fontSize: "0.9rem",
                    }}
                  >
                    👁️ {post.viewsCount}
                  </span>
                )}
              </div>

              {activePostId === post.id && (
                <div
                  style={{
                    padding: "10px 15px",
                    display: "flex",
                    gap: "10px",
                    borderTop: "1px solid var(--separator)",
                  }}
                >
                  <input
                    type="text"
                    placeholder="Add a comment..."
                    value={newComment}
                    onChange={(e) => setNewComment(e.target.value)}
                    style={{
                      flex: 1,
                      padding: "8px 12px",
                      borderRadius: "20px",
                      border: "1px solid var(--separator)",
                      background: "var(--background3)",
                    }}
                    onKeyPress={(e) => {
                      if (e.key === "Enter") {
                        handleComment(post.id);
                      }
                    }}
                  />
                  <button
                    onClick={() => handleComment(post.id)}
                    disabled={!newComment.trim()}
                    style={{
                      padding: "8px 15px",
                      borderRadius: "20px",
                      border: "none",
                      background: newComment.trim()
                        ? "var(--blue)"
                        : "var(--gray4)",
                      color: newComment.trim() ? "white" : "var(--text-color3)",
                      cursor: newComment.trim() ? "pointer" : "not-allowed",
                    }}
                  >
                    Post
                  </button>
                </div>
              )}
            </div>
          ))}
        </div>
      )}

      <button
        style={socialFeedStyles.loadMore as React.CSSProperties}
        onClick={() => {
          // In a real app, this would load more posts
          console.log("Load more posts");
        }}
        onMouseOver={(e) => {
          e.currentTarget.style.background = "var(--hover)";
        }}
        onMouseOut={(e) => {
          e.currentTarget.style.background = "var(--background2)";
        }}
      >
        Load More
      </button>
    </div>
  );
};

export default SocialFeed;
```

#### packages/ui/src/features/social/UserProfile.tsx

```tsx
import React, { useCallback, useEffect, useState } from "react";

interface User {
  id: string;
  username: string;
  displayName: string;
  avatar: string;
  bio: string;
  followersCount: number;
  followingCount: number;
  postsCount: number;
  isFollowing: boolean;
}

interface UserProfileProps {
  userId: string;
  onFollow?: (userId: string) => Promise<void>;
  onUnfollow?: (userId: string) => Promise<void>;
  className?: string;
}

export const UserProfile: React.FC<UserProfileProps> = ({
  userId,
  onFollow,
  onUnfollow,
  className,
}) => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchUserProfile = useCallback(async () => {
    try {
      setIsLoading(true);
      // TODO: Replace with actual API call
      const response = await fetch(`/api/users/${userId}`);
      if (!response.ok) throw new Error("Failed to fetch user profile");
      const data = (await response.json()) as User;
      setUser(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to load profile");
    } finally {
      setIsLoading(false);
    }
  }, [userId]);

  useEffect(() => {
    void fetchUserProfile();
  }, [fetchUserProfile]);

  const handleFollowToggle = async () => {
    if (!user) return;

    try {
      if (user.isFollowing) {
        await onUnfollow?.(userId);
        setUser((prev) =>
          prev
            ? {
                ...prev,
                isFollowing: false,
                followersCount: prev.followersCount - 1,
              }
            : null,
        );
      } else {
        await onFollow?.(userId);
        setUser((prev) =>
          prev
            ? {
                ...prev,
                isFollowing: true,
                followersCount: prev.followersCount + 1,
              }
            : null,
        );
      }
    } catch (err) {
      setError(
        err instanceof Error ? err.message : "Failed to update follow status",
      );
    }
  };

  const styles = {
    container: {
      padding: "24px",
      backgroundColor: "#fff",
      borderRadius: "8px",
      boxShadow: "0 2px 4px rgba(0,0,0,0.1)",
    },
    header: {
      display: "flex",
      alignItems: "center",
      gap: "24px",
      marginBottom: "24px",
    },
    avatar: {
      width: "120px",
      height: "120px",
      borderRadius: "50%",
      objectFit: "cover" as const,
    },
    info: {
      flex: 1,
    },
    name: {
      fontSize: "24px",
      fontWeight: 600,
      margin: "0 0 8px",
      color: "#1a1a1a",
    },
    username: {
      fontSize: "16px",
      color: "#666",
      margin: "0 0 16px",
    },
    bio: {
      fontSize: "16px",
      lineHeight: "1.5",
      color: "#333",
      margin: "0 0 16px",
    },
    stats: {
      display: "flex",
      gap: "24px",
      marginBottom: "24px",
    },
    stat: {
      display: "flex",
      flexDirection: "column" as const,
      alignItems: "center",
    },
    statValue: {
      fontSize: "20px",
      fontWeight: 600,
      color: "#1a1a1a",
    },
    statLabel: {
      fontSize: "14px",
      color: "#666",
    },
    followButton: {
      padding: "8px 24px",
      borderRadius: "20px",
      border: "none",
      fontSize: "16px",
      fontWeight: 500,
      cursor: "pointer",
      transition: "background-color 0.2s",
      backgroundColor: user?.isFollowing ? "#e0e0e0" : "#2196f3",
      color: user?.isFollowing ? "#333" : "#fff",
      "&:hover": {
        backgroundColor: user?.isFollowing ? "#d0d0d0" : "#1976d2",
      },
    },
    loading: {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      minHeight: "200px",
    },
    error: {
      color: "#d32f2f",
      textAlign: "center" as const,
      padding: "16px",
    },
  };

  if (isLoading) {
    return <div style={styles.loading}>Loading...</div>;
  }

  if (error) {
    return <div style={styles.error}>{error}</div>;
  }

  if (!user) {
    return <div style={styles.error}>User not found</div>;
  }

  return (
    <div style={styles.container} className={className}>
      <div style={styles.header}>
        <img src={user.avatar} alt={user.displayName} style={styles.avatar} />
        <div style={styles.info}>
          <h1 style={styles.name}>{user.displayName}</h1>
          <p style={styles.username}>@{user.username}</p>
          <p style={styles.bio}>{user.bio}</p>
          <button
            style={styles.followButton}
            onClick={() => void handleFollowToggle()}
            onMouseEnter={(e) =>
              (e.currentTarget.style.backgroundColor = user.isFollowing
                ? "#d0d0d0"
                : "#1976d2")
            }
            onMouseLeave={(e) =>
              (e.currentTarget.style.backgroundColor = user.isFollowing
                ? "#e0e0e0"
                : "#2196f3")
            }
          >
            {user.isFollowing ? "Following" : "Follow"}
          </button>
        </div>
      </div>

      <div style={styles.stats}>
        <div style={styles.stat}>
          <span style={styles.statValue}>{user.postsCount}</span>
          <span style={styles.statLabel}>Posts</span>
        </div>
        <div style={styles.stat}>
          <span style={styles.statValue}>{user.followersCount}</span>
          <span style={styles.statLabel}>Followers</span>
        </div>
        <div style={styles.stat}>
          <span style={styles.statValue}>{user.followingCount}</span>
          <span style={styles.statLabel}>Following</span>
        </div>
      </div>
    </div>
  );
};
```

#### packages/ui/src/features/social/UserProfileCard.tsx

```tsx
import React, { useState } from "react";

import { useClientEnvironment } from "../../services/ClientEnvironment";
import { socialService } from "../../services/social";

interface User {
  id: string;
  username: string;
  displayName: string;
  avatar: string;
  bio: string;
  followersCount: number;
  followingCount: number;
  postsCount: number;
  isFollowing: boolean;
}

interface UserProfileCardProps {
  user: User;
}

export const UserProfileCard: React.FC<UserProfileCardProps> = ({ user }) => {
  const environment = useClientEnvironment();
  const [isFollowing, setIsFollowing] = useState(user.isFollowing);
  const [followersCount, setFollowersCount] = useState(user.followersCount);
  const [isLoading, setIsLoading] = useState(false);

  const handleFollowToggle = async () => {
    if (isLoading) return;

    setIsLoading(true);
    try {
      if (isFollowing) {
        await socialService.unfollowUser(user.id);
        setIsFollowing(false);
        setFollowersCount((prev) => prev - 1);
      } else {
        await socialService.followUser(user.id);
        setIsFollowing(true);
        setFollowersCount((prev) => prev + 1);
      }
    } catch (error) {
      console.error("Error toggling follow:", error);
    } finally {
      setIsLoading(false);
    }
  };

  const navigateToProfile = () => {
    environment.router.navigate(`/profile/${user.id}`);
  };

  return (
    <div
      style={{
        border: "1px solid #e0e0e0",
        borderRadius: "8px",
        padding: "16px",
        marginBottom: "16px",
        backgroundColor: "white",
        boxShadow: "0 1px 3px rgba(0,0,0,0.1)",
      }}
    >
      <div style={{ display: "flex", alignItems: "center" }}>
        <img
          src={user.avatar || "/default-avatar.png"}
          alt={user.displayName}
          style={{
            width: "80px",
            height: "80px",
            borderRadius: "50%",
            marginRight: "16px",
            objectFit: "cover",
            cursor: "pointer",
          }}
          onClick={navigateToProfile}
        />
        <div style={{ flex: 1 }}>
          <div
            style={{
              fontWeight: "bold",
              fontSize: "1.2rem",
              cursor: "pointer",
            }}
            onClick={navigateToProfile}
          >
            {user.displayName}
          </div>
          <div style={{ color: "#666", marginBottom: "8px" }}>
            @{user.username}
          </div>
          <div style={{ marginBottom: "12px" }}>{user.bio}</div>
          <div
            style={{
              display: "flex",
              gap: "16px",
              color: "#666",
              fontSize: "0.9rem",
            }}
          >
            <div>
              <strong>{user.postsCount}</strong> posts
            </div>
            <div>
              <strong>{followersCount}</strong> followers
            </div>
            <div>
              <strong>{user.followingCount}</strong> following
            </div>
          </div>
        </div>
        <div>
          <button
            onClick={() => void handleFollowToggle()}
            disabled={isLoading}
            style={{
              padding: "8px 16px",
              backgroundColor: isFollowing ? "white" : "var(--accent)",
              color: isFollowing ? "var(--accent)" : "white",
              border: isFollowing ? "1px solid var(--accent)" : "none",
              borderRadius: "20px",
              cursor: "pointer",
              fontWeight: "bold",
              opacity: isLoading ? 0.7 : 1,
            }}
          >
            {isLoading ? "..." : isFollowing ? "Unfollow" : "Follow"}
          </button>
        </div>
      </div>
    </div>
  );
};
```

#### packages/ui/src/features/theme/ThemeContext.tsx

```tsx
import {
  createContext,
  ReactNode,
  useContext,
  useEffect,
  useState,
} from "react";

type ThemeMode = "light" | "dark";

interface ThemeContextType {
  theme: ThemeMode;
  toggleTheme: () => void;
  setTheme: (theme: ThemeMode) => void;
  useSystemTheme: () => void;
  isUsingSystemTheme: boolean;
}

const ThemeContext = createContext<ThemeContextType>({
  theme: "light",
  toggleTheme: () => {},
  setTheme: () => {},
  useSystemTheme: () => {},
  isUsingSystemTheme: false,
});

export const useTheme = () => useContext(ThemeContext);

interface ThemeProviderProps {
  children: ReactNode;
}

// Helper function to get system preference
const getSystemThemePreference = (): ThemeMode => {
  if (
    window.matchMedia &&
    window.matchMedia("(prefers-color-scheme: dark)").matches
  ) {
    return "dark";
  }
  return "light";
};

export function ThemeProvider({ children }: ThemeProviderProps) {
  // Track if we're using system theme
  const [isUsingSystemTheme, setIsUsingSystemTheme] = useState<boolean>(() => {
    return localStorage.getItem("useSystemTheme") === "true";
  });

  // Initialize theme from localStorage or system preference
  const [theme, setThemeState] = useState<ThemeMode>(() => {
    // Check if we should use system theme
    if (localStorage.getItem("useSystemTheme") === "true") {
      return getSystemThemePreference();
    }

    // Check if theme is stored in localStorage
    const savedTheme = localStorage.getItem("theme") as ThemeMode;
    if (savedTheme && (savedTheme === "light" || savedTheme === "dark")) {
      return savedTheme;
    }

    // Default to system preference
    setIsUsingSystemTheme(true);
    return getSystemThemePreference();
  });

  // Listen for system theme changes
  useEffect(() => {
    const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");

    const handleChange = (e: MediaQueryListEvent) => {
      if (isUsingSystemTheme) {
        setThemeState(e.matches ? "dark" : "light");
      }
    };

    // Modern browsers
    if (mediaQuery.addEventListener) {
      mediaQuery.addEventListener("change", handleChange);
    } else {
      // Fallback for older browsers
      mediaQuery.addListener(handleChange);
    }

    return () => {
      if (mediaQuery.removeEventListener) {
        mediaQuery.removeEventListener("change", handleChange);
      } else {
        mediaQuery.removeListener(handleChange);
      }
    };
  }, [isUsingSystemTheme]);

  // Apply theme to document when it changes
  useEffect(() => {
    document.documentElement.setAttribute("data-theme", theme);

    // Only save to localStorage if not using system theme
    if (!isUsingSystemTheme) {
      localStorage.setItem("theme", theme);
    }
  }, [theme, isUsingSystemTheme]);

  // Toggle between light and dark mode
  const toggleTheme = () => {
    setIsUsingSystemTheme(false);
    localStorage.setItem("useSystemTheme", "false");
    setThemeState((prevTheme) => (prevTheme === "light" ? "dark" : "light"));
  };

  // Set theme directly
  const setTheme = (newTheme: ThemeMode) => {
    setIsUsingSystemTheme(false);
    localStorage.setItem("useSystemTheme", "false");
    setThemeState(newTheme);
  };

  // Use system theme
  const useSystemTheme = () => {
    setIsUsingSystemTheme(true);
    localStorage.setItem("useSystemTheme", "true");
    setThemeState(getSystemThemePreference());
  };

  return (
    <ThemeContext.Provider
      value={{
        theme,
        toggleTheme,
        setTheme,
        useSystemTheme,
        isUsingSystemTheme,
      }}
    >
      {children}
    </ThemeContext.Provider>
  );
}
```

#### packages/ui/src/features/theme/index.ts

```ts
export { ThemeProvider, useTheme } from "./ThemeContext";
```

#### packages/ui/src/hooks/index.ts

```ts
// Shared hooks
// Export hooks here as they are created
export {};
```

#### packages/ui/src/hooks/useAsync.ts

```ts
import isEqual from "lodash/isEqual";
import { useEffect, useRef, useState } from "react";

import { useRefCurrent } from "./useRefCurrent";
import { useRefPrevious } from "./useRefPrevious";

export function useAsync<T, Args extends unknown[]>(
  fn: (...args: Args) => Promise<T>,
  args: Args,
) {
  const [state, setState] = useState<T | undefined>(undefined);

  const currentFn = useRefCurrent(fn);

  const changeCount = useRef(0);
  const prevArgs = useRefPrevious(args);
  const same = isEqual(prevArgs.current, args);
  if (!same) changeCount.current += 1;

  useEffect(() => {
    const currentCount = changeCount.current;
    void currentFn.current(...args).then((result) => {
      if (changeCount.current === currentCount) {
        setState(result);
      }
    });
    return;
  }, [args, currentFn]);

  return state;
}
```

#### packages/ui/src/hooks/useCounter.ts

```ts
import { useState } from "react";

// This is useful for forcing a re-render.
export function useCounter() {
  const [count, setCount] = useState(0);
  const inc = () => setCount((s) => s + 1);
  return [count, inc] as const;
}
```

#### packages/ui/src/hooks/useOnline.ts

```ts
import { useEffect, useState } from "react";

// TODO: an improved online/offline detector would ping the server to see if its online.
// When the browser is online, but the server is down, this still says online.
// You can also monitor api requests or the websocket connection as well.
export function useOnline() {
  const [state, setState] = useState(navigator.onLine);
  useEffect(() => {
    const setOnline = () => setState(true);
    const setOffline = () => setState(false);
    window.addEventListener("online", setOnline);
    window.addEventListener("offline", setOffline);
    return () => {
      window.removeEventListener("online", setOnline);
      window.removeEventListener("offline", setOffline);
    };
  }, []);
  return state;
}
```

#### packages/ui/src/hooks/usePopper.ts

```ts
import { useEffect, useRef } from "react";

// Define types similar to what popper.js provides
export type Placement =
  | "top"
  | "bottom"
  | "right"
  | "left"
  | "top-start"
  | "top-end"
  | "bottom-start"
  | "bottom-end"
  | "right-start"
  | "right-end"
  | "left-start"
  | "left-end";

export interface Options {
  placement?: Placement;
  modifiers?: Array<{ name: string; options?: Record<string, unknown> }>;
  strategy?: "absolute" | "fixed";
}

export interface Instance {
  destroy: () => void;
  update: () => Promise<{ placement: Placement }>;
  state: { placement: Placement };
}

// Simple positioning function to replace popper.js
function createSimplePopper(
  referenceElement: HTMLElement,
  popperElement: HTMLElement,
  options: Options = {},
): Instance {
  const placement = options.placement || "bottom";
  const strategy = options.strategy || "absolute";

  function update() {
    if (!referenceElement || !popperElement) {
      return Promise.resolve({ placement });
    }

    const refRect = referenceElement.getBoundingClientRect();

    popperElement.style.position = strategy;

    // Basic positioning based on placement
    switch (placement) {
      case "top":
        popperElement.style.bottom = `${window.innerHeight - refRect.top}px`;
        popperElement.style.left = `${refRect.left + refRect.width / 2 - popperElement.offsetWidth / 2}px`;
        break;
      case "bottom":
        popperElement.style.top = `${refRect.bottom}px`;
        popperElement.style.left = `${refRect.left + refRect.width / 2 - popperElement.offsetWidth / 2}px`;
        break;
      case "left":
        popperElement.style.right = `${window.innerWidth - refRect.left}px`;
        popperElement.style.top = `${refRect.top + refRect.height / 2 - popperElement.offsetHeight / 2}px`;
        break;
      case "right":
        popperElement.style.left = `${refRect.right}px`;
        popperElement.style.top = `${refRect.top + refRect.height / 2 - popperElement.offsetHeight / 2}px`;
        break;
      case "bottom-start":
        popperElement.style.top = `${refRect.bottom}px`;
        popperElement.style.left = `${refRect.left}px`;
        break;
      case "bottom-end":
        popperElement.style.top = `${refRect.bottom}px`;
        popperElement.style.left = `${refRect.right - popperElement.offsetWidth}px`;
        break;
      // Add other placements as needed
      default:
        popperElement.style.top = `${refRect.bottom}px`;
        popperElement.style.left = `${refRect.left}px`;
    }

    return Promise.resolve({ placement });
  }

  // Initial positioning
  void update();

  // Return an instance similar to popper.js
  return {
    destroy: () => {},
    update,
    state: { placement },
  };
}

export function usePopper(
  referenceElement: HTMLElement | null,
  popperElement: HTMLElement | null,
  options: Options = {},
) {
  const popperInstanceRef = useRef<Instance | null>(null);

  useEffect(() => {
    if (referenceElement && popperElement) {
      // Create new popper instance
      popperInstanceRef.current = createSimplePopper(
        referenceElement,
        popperElement,
        options,
      );

      // Clean up on unmount
      return () => {
        if (popperInstanceRef.current) {
          popperInstanceRef.current.destroy();
          popperInstanceRef.current = null;
        }
      };
    }
    return undefined;
  }, [referenceElement, popperElement, options]);

  return { update: () => popperInstanceRef.current?.update() };
}

export { createSimplePopper as createPopper };
```

#### packages/ui/src/hooks/useRefCurrent.ts

```ts
import { useRef } from "react";

export function useRefCurrent<T>(value: T) {
  const ref = useRef<T>(value);
  ref.current = value;
  return ref;
}
```

#### packages/ui/src/hooks/useRefPrevious.ts

```ts
import { useEffect, useRef } from "react";

export function useRefPrevious<T>(value: T) {
  const ref = useRef<T>(value);
  useEffect(() => {
    ref.current = value;
  });
  return ref;
}
```

#### packages/ui/src/hooks/useShortcut.ts

```ts
// Adapted from https://github.com/marijnh/w3c-keyname
// The shift keycode map was removed so we can use Shift as a modifier.
// For example: "Shift-]" instead of "}

import { useEffect } from "react";

import { useRefCurrent } from "./useRefCurrent";

// Simple capitalize utility (replaces lodash/capitalize)
const capitalize = (str: string): string =>
  str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();

const base: { [key: number]: string } = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'",
};

const chrome =
  typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
const safari =
  typeof navigator != "undefined" && /Apple Computer/.test(navigator.vendor);
const gecko =
  typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
const mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
const ie =
  typeof navigator != "undefined" &&
  /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
const brokenModifierNames =
  (chrome && (mac || +chrome[1] < 57)) || (gecko && mac);

// Fill in the digit keys
for (let i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);

// The function keys
for (let i = 1; i <= 24; i++) base[i + 111] = "F" + i;

// And the alphabetic keys
for (let i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
}

function keyName(event: KeyboardEvent) {
  const ignoreKey =
    (brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey)) ||
    ((safari || ie) && event.shiftKey && event.key && event.key.length == 1);
  let name =
    (!ignoreKey && event.key) ||
    base[event.keyCode] ||
    event.key ||
    "Unidentified";
  // Edge sometimes produces wrong names (Issue #3)
  if (name == "Esc") name = "Escape";
  if (name == "Del") name = "Delete";
  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/
  if (name == "Left") name = "ArrowLeft";
  if (name == "Up") name = "ArrowUp";
  if (name == "Right") name = "ArrowRight";
  if (name == "Down") name = "ArrowDown";
  return name;
}

// Aliases for various keyboard events, allowing shortcuts to be defined
// using some more colloquial terms.
const keyboardAliases: Record<string, string | undefined> = {
  ctrl: "control",
  mod: "meta",
  cmd: "meta",
  " ": "space",
  left: "arrowleft",
  right: "arrowright",
  down: "arrowdown",
  up: "arrowup",
  option: "alt",
  opt: "alt",
  delete: "backspace",
};

// Used for view test keyboard event mocking
export function shortcutToEvent(shortcut: string) {
  const keys = shortcut
    .split(/-(?!$)/)
    .map((str) => str.toLowerCase())
    .map((char) => keyboardAliases[char] || char);

  const parsed: ParsedShortcut = {};
  for (const key of keys) {
    if (key === "meta") parsed.metaKey = true;
    else if (key === "control") parsed.ctrlKey = true;
    else if (key === "alt") parsed.altKey = true;
    else if (key === "shift") parsed.shiftKey = true;
    // Used to emulate the behavior that all non-alphabetic keys in keyboard events
    // are capitalized:
    // https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_key_values
    else
      parsed.key = key.length === 1 ? key : key[0].toUpperCase() + key.slice(1);
  }

  return new KeyboardEvent("keydown", parsed);
}

interface ParsedShortcut {
  shiftKey?: boolean;
  altKey?: boolean;
  ctrlKey?: boolean;
  metaKey?: boolean;
  key?: string;
}

function parseShortcut(shortcut: string) {
  const keys = shortcut
    .split(/-(?!$)/)
    .map((str) => str.toLowerCase())
    .map((char) => keyboardAliases[char] || char);

  const parsed: ParsedShortcut = {};
  for (const key of keys) {
    if (key === "meta") parsed.metaKey = true;
    else if (key === "control") parsed.ctrlKey = true;
    else if (key === "alt") parsed.altKey = true;
    else if (key === "shift") parsed.shiftKey = true;
    else parsed.key = key.toLowerCase();
  }
  return parsed;
}

function formatShortcutKeys(parsed: ParsedShortcut) {
  const keys: Array<string> = [];
  if (parsed.shiftKey) keys.push("shift");
  if (parsed.altKey) keys.push("alt");
  if (parsed.ctrlKey) keys.push("control");
  if (parsed.metaKey) keys.push("meta");
  if (parsed.key) keys.push(parsed.key);
  return keys;
}

function formatShortcut(parsed: ParsedShortcut) {
  return formatShortcutKeys(parsed).join("-");
}

function normalizeShortcut(shortcut: string) {
  return formatShortcut(parseShortcut(shortcut));
}

const modifierCodes = new Set([
  "ControlLeft",
  "ControlRight",
  "ShiftLeft",
  "ShiftRight",
  "AltLeft",
  "AltRight",
  "MetaLeft",
  "MetaRight",
]);

function parseKeyboardEvent(event: KeyboardEvent) {
  const parsed: ParsedShortcut = {};
  if (event.shiftKey) parsed.shiftKey = true;
  if (event.altKey) parsed.altKey = true;
  if (event.ctrlKey) parsed.ctrlKey = true;
  if (event.metaKey) parsed.metaKey = true;
  if (!modifierCodes.has(event.code)) parsed.key = keyName(event).toLowerCase();
  return parsed;
}

function normalizeKeyboardShortcut(event: KeyboardEvent) {
  return formatShortcut(parseKeyboardEvent(event));
}

export function isShortcut(shortcut: string, event: KeyboardEvent) {
  return normalizeShortcut(shortcut) === normalizeKeyboardShortcut(event);
}

const isMac = true as boolean; // process.platform === "darwin"

const shortKeys: Record<string, string> = {
  meta: isMac ? "⌘" : "^",
  control: "^",
  alt: "⌥",
  shift: "⇧",
  enter: "↵",
  tab: "⇥",
  arrowleft: "←",
  arrowright: "→",
  arrowup: "↑",
  arrowdown: "↓",
};

export function displayShortcut(shortcut: string) {
  const parsed = parseShortcut(shortcut);
  const keys = formatShortcutKeys(parsed);
  return keys
    .map((char) => shortKeys[char] || char)
    .map((char) => capitalize(char))
    .join("");
}

type KeyboardEventHandler = (event: KeyboardEvent) => void;

/** Use with care. Prefer to put listeners on DOM elements to work better with focus. */
export function useShortcut(shortcut: string, fn: () => void) {
  const fnRef = useRefCurrent(fn);
  const shortcutRef = useRefCurrent(shortcut);

  useEffect(() => {
    const onKeydown: KeyboardEventHandler = (event) => {
      if (isShortcut(shortcutRef.current, event)) {
        event.preventDefault();
        fnRef.current();
      }
    };
    window.addEventListener("keydown", onKeydown);
    return () => {
      window.removeEventListener("keydown", onKeydown);
    };
  }, [fnRef, shortcutRef]);
}
```

#### packages/ui/src/hooks/useSocialInteractions.ts

```ts
import { useCallback, useState } from "react";

import { useSocial, type User } from "../contexts/SocialContext";
import { socialService } from "../services/social";

interface UseSocialInteractionsProps {
  onError?: (error: Error) => void;
}

export type { User };
export const useSocialInteractions = ({
  onError,
}: UseSocialInteractionsProps = {}) => {
  const { currentUser, refreshFeed } = useSocial();
  const [isLoading, setIsLoading] = useState(false);

  const handleError = useCallback(
    (error: Error) => {
      onError?.(error);
    },
    [onError],
  );

  const followUser = useCallback(
    async (userId: string) => {
      try {
        setIsLoading(true);
        await socialService.followUser(userId);
        await refreshFeed();
      } catch (error) {
        handleError(
          error instanceof Error ? error : new Error("Failed to follow user"),
        );
        throw error;
      } finally {
        setIsLoading(false);
      }
    },
    [refreshFeed, handleError],
  );

  const unfollowUser = useCallback(
    async (userId: string) => {
      try {
        setIsLoading(true);
        await socialService.unfollowUser(userId);
        await refreshFeed();
      } catch (error) {
        handleError(
          error instanceof Error ? error : new Error("Failed to unfollow user"),
        );
        throw error;
      } finally {
        setIsLoading(false);
      }
    },
    [refreshFeed, handleError],
  );

  const likePost = useCallback(
    async (postId: string) => {
      try {
        setIsLoading(true);
        await socialService.likePost(postId);
        await refreshFeed();
      } catch (error) {
        handleError(
          error instanceof Error ? error : new Error("Failed to like post"),
        );
        throw error;
      } finally {
        setIsLoading(false);
      }
    },
    [refreshFeed, handleError],
  );

  const unlikePost = useCallback(
    async (postId: string) => {
      try {
        setIsLoading(true);
        await socialService.unlikePost(postId);
        await refreshFeed();
      } catch (error) {
        handleError(
          error instanceof Error ? error : new Error("Failed to unlike post"),
        );
        throw error;
      } finally {
        setIsLoading(false);
      }
    },
    [refreshFeed, handleError],
  );

  const sharePost = useCallback(
    async (postId: string) => {
      try {
        setIsLoading(true);
        await socialService.sharePost(postId);
        await refreshFeed();
      } catch (error) {
        handleError(
          error instanceof Error ? error : new Error("Failed to share post"),
        );
        throw error;
      } finally {
        setIsLoading(false);
      }
    },
    [refreshFeed, handleError],
  );

  const createPost = useCallback(
    async (content: string, media?: File) => {
      try {
        setIsLoading(true);
        await socialService.createPost(content, media);
        await refreshFeed();
      } catch (error) {
        handleError(
          error instanceof Error ? error : new Error("Failed to create post"),
        );
        throw error;
      } finally {
        setIsLoading(false);
      }
    },
    [refreshFeed, handleError],
  );

  const createComment = useCallback(
    async (postId: string, content: string) => {
      try {
        setIsLoading(true);
        await socialService.createComment(postId, content);
        await refreshFeed();
      } catch (error) {
        handleError(
          error instanceof Error
            ? error
            : new Error("Failed to create comment"),
        );
        throw error;
      } finally {
        setIsLoading(false);
      }
    },
    [refreshFeed, handleError],
  );

  const likeComment = useCallback(
    async (commentId: string) => {
      try {
        setIsLoading(true);
        await socialService.likeComment(commentId);
        await refreshFeed();
      } catch (error) {
        handleError(
          error instanceof Error ? error : new Error("Failed to like comment"),
        );
        throw error;
      } finally {
        setIsLoading(false);
      }
    },
    [refreshFeed, handleError],
  );

  const unlikeComment = useCallback(
    async (commentId: string) => {
      try {
        setIsLoading(true);
        await socialService.unlikeComment(commentId);
        await refreshFeed();
      } catch (error) {
        handleError(
          error instanceof Error
            ? error
            : new Error("Failed to unlike comment"),
        );
        throw error;
      } finally {
        setIsLoading(false);
      }
    },
    [refreshFeed, handleError],
  );

  const replyToComment = useCallback(
    async (commentId: string, content: string) => {
      try {
        setIsLoading(true);
        await socialService.replyToComment(commentId, content);
        await refreshFeed();
      } catch (error) {
        handleError(
          error instanceof Error
            ? error
            : new Error("Failed to reply to comment"),
        );
        throw error;
      } finally {
        setIsLoading(false);
      }
    },
    [refreshFeed, handleError],
  );

  return {
    currentUser,
    isLoading,
    followUser,
    unfollowUser,
    likePost,
    unlikePost,
    sharePost,
    createPost,
    createComment,
    likeComment,
    unlikeComment,
    replyToComment,
  };
};
```

#### packages/ui/src/index.ts

```ts
// Shared UI components for all platforms (web, desktop, mobile)

// Base components
export * from './components';

// Feature modules
export * from './features';

// Layouts
export * from './layouts';

// Hooks
export * from './hooks';

// Contexts
export * from './contexts';
```

#### packages/ui/src/layouts/MainLayout.tsx

```tsx
import React, { useEffect, useState } from "react";

import { AuthModal, AuthModalType, useAuth } from "../components/auth";
import { useTheme } from "../components/theme";
import { Button } from "../components/ui/Button";
import { Link } from "../components/ui/Link";
import "./main-layout.css";

export default function MainLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const [showSidebar, setShowSidebar] = useState(true);
  const [showRightPanel, setShowRightPanel] = useState(false);
  const [showTopbar, setShowTopbar] = useState(true);
  const [showBottomBar, setShowBottomBar] = useState(true);
  const [isMobile, setIsMobile] = useState(false);
  const [authModal, setAuthModal] = useState<{
    show: boolean;
    type: AuthModalType;
  }>({
    show: false,
    type: "login",
  });

  const { isAuthenticated, user, logout } = useAuth();
  const { theme, toggleTheme, isUsingSystemTheme } = useTheme();

  // Check if viewport is mobile size
  useEffect(() => {
    const checkIfMobile = () => {
      setIsMobile(window.innerWidth <= 768);
      // Auto-hide sidebar on mobile
      if (window.innerWidth <= 768) {
        setShowSidebar(false);
      } else {
        setShowSidebar(true);
      }
    };

    // Initial check
    checkIfMobile();

    // Add event listener
    window.addEventListener("resize", checkIfMobile);

    // Cleanup
    return () => window.removeEventListener("resize", checkIfMobile);
  }, []);

  const openLoginModal = () => {
    setAuthModal({ show: true, type: "login" });
  };

  const openRegisterModal = () => {
    setAuthModal({ show: true, type: "register" });
  };

  const closeAuthModal = () => {
    setAuthModal({ show: false, type: authModal.type });
  };

  const handleLogout = () => {
    logout();
  };

  // Get the appropriate theme icon
  const getThemeIcon = () => {
    if (isUsingSystemTheme) {
      return "🖥️";
    } else {
      return theme === "light" ? "🌙" : "☀️";
    }
  };

  // Handle theme button click
  const handleThemeButtonClick = () => {
    if (!isUsingSystemTheme) {
      toggleTheme();
    }
  };

  // Toggle sidebar for mobile
  const toggleMobileSidebar = () => {
    setShowSidebar(!showSidebar);
  };

  return (
    <div className="main-layout">
      {showTopbar && (
        <div className="top-bar">
          {isMobile && (
            <button
              className="mobile-menu-toggle"
              onClick={toggleMobileSidebar}
              aria-label={showSidebar ? "Close menu" : "Open menu"}
            >
              <span></span>
              <span></span>
              <span></span>
            </button>
          )}
          <Link
            to="/"
            style={{
              textDecoration: "none",
              display: "flex",
              alignItems: "center",
            }}
          >
            <div className="logo">ABE Stack</div>
          </Link>
          <div className="top-bar-actions">
            <button
              className={`theme-toggle-btn ${isUsingSystemTheme ? "system-theme" : ""}`}
              onClick={handleThemeButtonClick}
              aria-label={
                isUsingSystemTheme
                  ? "Using system theme preference"
                  : `Switch to ${theme === "light" ? "dark" : "light"} mode`
              }
              title={
                isUsingSystemTheme
                  ? "Using system theme preference (change in settings)"
                  : `Switch to ${theme === "light" ? "dark" : "light"} mode`
              }
            >
              {getThemeIcon()}
            </button>
            {isAuthenticated ? (
              <div className="user-profile">
                <div
                  style={{
                    width: "32px",
                    height: "32px",
                    borderRadius: "50%",
                    backgroundColor: "var(--accent)",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    color: "white",
                    fontWeight: "bold",
                  }}
                >
                  {user?.displayName?.charAt(0) || "U"}
                </div>
                {!isMobile && (
                  <span className="username">
                    {user?.displayName || "User"}
                  </span>
                )}
                <Button onClick={handleLogout}>Logout</Button>
              </div>
            ) : (
              <>
                <Button onClick={openLoginModal}>Log In</Button>
                <Button onClick={openRegisterModal}>Register</Button>
              </>
            )}
          </div>
        </div>
      )}

      <div className="content-area">
        {showSidebar && (
          <div className={`left-panel ${isMobile ? "mobile" : ""}`}>
            <nav className="main-nav">
              {isMobile && (
                <div className="mobile-nav-header">
                  <button
                    className="close-mobile-nav"
                    onClick={() => setShowSidebar(false)}
                    aria-label="Close menu"
                  >
                    &times;
                  </button>
                </div>
              )}
              <Link
                to="/"
                onClick={isMobile ? () => setShowSidebar(false) : undefined}
              >
                Home
              </Link>
              <Link
                to="/dashboard"
                onClick={isMobile ? () => setShowSidebar(false) : undefined}
              >
                Dashboard
              </Link>
              <Link
                to="/profile"
                onClick={isMobile ? () => setShowSidebar(false) : undefined}
              >
                Profile
              </Link>
              <Link
                to="/upload"
                onClick={isMobile ? () => setShowSidebar(false) : undefined}
              >
                Upload
              </Link>
              <Link
                to="/explore"
                onClick={isMobile ? () => setShowSidebar(false) : undefined}
              >
                Explore
              </Link>
              <Link
                to="/notifications"
                onClick={isMobile ? () => setShowSidebar(false) : undefined}
              >
                Notifications
              </Link>
              <Link
                to="/media"
                onClick={isMobile ? () => setShowSidebar(false) : undefined}
              >
                Media
              </Link>
              <Link
                to="/settings"
                onClick={isMobile ? () => setShowSidebar(false) : undefined}
              >
                Settings
              </Link>
            </nav>
          </div>
        )}

        <div className="main-content">{children}</div>

        {showRightPanel && (
          <div className="right-panel">
            <h3>Additional Info</h3>
            <p>
              This panel can contain contextual information, notifications, or
              other supplementary content.
            </p>
          </div>
        )}
      </div>

      {showBottomBar && (
        <div className="bottom-bar">
          <div>© 2023 ABE Stack</div>
          {!isMobile && (
            <div className="layout-controls">
              <button onClick={() => setShowSidebar(!showSidebar)}>
                {showSidebar ? "Hide" : "Show"} Left Panel
              </button>
              <button onClick={() => setShowRightPanel(!showRightPanel)}>
                {showRightPanel ? "Hide" : "Show"} Right Panel
              </button>
              <button onClick={() => setShowTopbar(!showTopbar)}>
                {showTopbar ? "Hide" : "Show"} Top Bar
              </button>
              <button onClick={() => setShowBottomBar(!showBottomBar)}>
                Hide Bottom Bar
              </button>
            </div>
          )}
        </div>
      )}

      {isMobile && showSidebar && (
        <div
          className="mobile-overlay"
          onClick={() => setShowSidebar(false)}
        ></div>
      )}

      <AuthModal
        isOpen={authModal.show}
        modalType={authModal.type}
        onClose={closeAuthModal}
      />
    </div>
  );
}
```

#### packages/ui/src/layouts/PageContent.tsx

```tsx
import { ReactNode } from "react";
import "./page-content.css";

interface PageContentProps {
  children: ReactNode;
  title?: string;
  description?: string;
}

export function PageContent({
  children,
  title,
  description,
}: PageContentProps) {
  return (
    <div className="page-content">
      {title && <h1 className="page-title">{title}</h1>}
      {description && <p className="page-description">{description}</p>}
      <div
        className={`page-content-body ${!title && !description ? "no-header" : ""}`}
      >
        {children}
      </div>
    </div>
  );
}
```

#### packages/ui/src/layouts/index.ts

```ts
// Layout components
// Export layouts here as they are created
export {};
```

#### packages/ui/tsconfig.json

```json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src",
    "composite": true,
    "declaration": true,
    "declarationMap": true,
    "jsx": "react-jsx",
    "lib": ["ES2023", "DOM", "DOM.Iterable"],
    "tsBuildInfoFile": "./node_modules/.cache/tsconfig.ui.tsbuildinfo",
    "baseUrl": ".",
    "paths": {
      "@components/*": ["./src/components/*"],
      "@layouts/*": ["./src/layouts/*"],
      "@hooks/*": ["./src/hooks/*"],
      "@utils/*": ["./src/utils/*"]
    }
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "**/*.test.tsx", "**/*.spec.tsx"]
}
```

---

### Config Configuration

#### config/env/.env.development

```development
# =============================================================================
# ABE STACK - Development Environment
# =============================================================================

# =============================================================================
# DATABASE (PostgreSQL)
# =============================================================================
POSTGRES_DB=abe_stack_dev
POSTGRES_USER=postgres
POSTGRES_PASSWORD=postgres
POSTGRES_PORT=5432
POSTGRES_HOST=localhost

# =============================================================================
# REDIS (Cache, Sessions, Queues)
# =============================================================================
REDIS_PORT=6379
REDIS_HOST=localhost

# =============================================================================
# APPLICATION
# =============================================================================
NODE_ENV=development
APP_PORT=3000
API_PORT=8080

# =============================================================================
# SECURITY (Development - Not for production!)
# =============================================================================
JWT_SECRET=dev_jwt_secret_change_in_production
SESSION_SECRET=dev_session_secret_change_in_production

# =============================================================================
# EXTERNAL SERVICES (Optional)
# =============================================================================
# AWS_ACCESS_KEY_ID=
# AWS_SECRET_ACCESS_KEY=
# STRIPE_SECRET_KEY=
# SENDGRID_API_KEY=
```

#### config/env/.env.example

```example
# =============================================================================
# ABE STACK - Environment Configuration Example
# =============================================================================
# Copy this file to .env.development or .env.production and update values
# Usage: docker-compose --env-file config/env/.env.development up

# =============================================================================
# DATABASE (PostgreSQL)
# =============================================================================
POSTGRES_DB=abe_stack_dev
POSTGRES_USER=postgres
POSTGRES_PASSWORD=change_me_in_production
POSTGRES_PORT=5432
POSTGRES_HOST=localhost

# =============================================================================
# REDIS (Cache, Sessions, Queues)
# =============================================================================
REDIS_PORT=6379
REDIS_HOST=localhost

# =============================================================================
# APPLICATION
# =============================================================================
NODE_ENV=development
APP_PORT=3000
API_PORT=8080

# =============================================================================
# SECURITY
# =============================================================================
JWT_SECRET=change_me_generate_random_secret
SESSION_SECRET=change_me_generate_random_secret

# =============================================================================
# EXTERNAL SERVICES (Optional)
# =============================================================================
# AWS_ACCESS_KEY_ID=
# AWS_SECRET_ACCESS_KEY=
# STRIPE_SECRET_KEY=
# SENDGRID_API_KEY=
```

#### config/env/.env.production

```production
# =============================================================================
# ABE STACK - Production Environment
# =============================================================================
# WARNING: Never commit this file to version control!
# Use environment variables from your hosting provider or secrets manager

# =============================================================================
# DATABASE (PostgreSQL)
# =============================================================================
POSTGRES_DB=abe_stack_prod
POSTGRES_USER=postgres
POSTGRES_PASSWORD=CHANGE_ME_USE_STRONG_PASSWORD
POSTGRES_PORT=5432
POSTGRES_HOST=localhost

# =============================================================================
# REDIS (Cache, Sessions, Queues)
# =============================================================================
REDIS_PORT=6379
REDIS_HOST=localhost

# =============================================================================
# APPLICATION
# =============================================================================
NODE_ENV=production
APP_PORT=3000
API_PORT=8080

# =============================================================================
# SECURITY (CRITICAL: Generate strong random secrets!)
# =============================================================================
JWT_SECRET=CHANGE_ME_GENERATE_RANDOM_SECRET_MIN_32_CHARS
SESSION_SECRET=CHANGE_ME_GENERATE_RANDOM_SECRET_MIN_32_CHARS

# =============================================================================
# EXTERNAL SERVICES
# =============================================================================
# AWS_ACCESS_KEY_ID=
# AWS_SECRET_ACCESS_KEY=
# STRIPE_SECRET_KEY=
# SENDGRID_API_KEY=
```

#### config/test/playwright.config.ts

```ts
import { defineConfig, devices } from "@playwright/test";

const CI = Boolean(process.env.CI);
const DB_PATH = `db/data-${Math.round(Math.random() * 1e10)}.json`;

export default defineConfig({
  // Look for test files in the "tests" directory, relative to this configuration file.
  testDir: "../../src",
  testMatch: /.*\.e2e\.(ts|tsx)/,
  reporter: [
    ["list"],
    ["html", { open: CI ? "never" : "on-failure" }],
    CI ? ["github"] : ["line"]
  ],
  fullyParallel: !CI, // Enable parallel execution in development
  forbidOnly: CI,

  retries: CI ? 2 : 0, // Retry failed tests in CI

  expect: {
    timeout: CI ? 10000 : 5000,
  },
  timeout: CI ? 30000 : 15000,

  use: {
    headless: CI, // Run headless in CI, headful in development

    // Base URL to use in actions like `await page.goto('/')`.
    baseURL: "http://localhost:8080",

    // Collect trace when retrying the failed test.
    trace: "on-first-retry",
    video: "retain-on-failure",
    screenshot: "only-on-failure",
  },
  // Configure projects for major browsers.
  projects: [
    {
      name: "chromium",
      use: { ...devices["Desktop Chrome"] },
    },
  ],
  // Run your local dev server before starting the tests.
  webServer: {
    command: `DB_PATH='${DB_PATH}' npm start`,
    url: "http://localhost:8080",
    // reuseExistingServer: !CI,
  },
});
```

#### config/test/vitest.config.ts

```ts
import { defineConfig } from "vitest/config";
import type { UserConfig } from "vitest/config";

export default defineConfig({
  test: {
    globals: true,
    environment: "node",
    include: [
      "**/tests/unit/**/*.{test,spec}.{js,ts}",
      "**/src/**/*.{test,spec}.{js,ts}",
    ],
    exclude: [
      "**/node_modules/**",
      "**/dist/**",
      "**/tests/integration/**",
      "**/tests/e2e/**",
      "**/backup/**",
    ],
    coverage: {
      provider: "v8",
      reporter: ["text", "json", "html"],
      exclude: [
        "**/node_modules/**",
        "**/dist/**",
        "**/backup/**",
        "**/config/**",
        "**/tools/**",
        "**/*.config.{js,ts}",
        "**/*.d.ts",
      ],
      thresholds: {
        global: {
          branches: 70,
          functions: 70,
          lines: 70,
          statements: 70,
        },
      },
    },
    testTimeout: 10000,
    hookTimeout: 10000,
  },
} satisfies UserConfig);
```

#### config/test/vitest.integration.config.ts

```ts
import { defineConfig } from "vitest/config";
import type { UserConfig } from "vitest/config";

export default defineConfig({
  test: {
    globals: true,
    environment: "node",
    include: ["**/tests/integration/**/*.{test,spec}.{js,ts}"],
    exclude: [
      "**/node_modules/**",
      "**/dist/**",
      "**/backup/**",
    ],
    testTimeout: 30000, // Longer timeout for integration tests
    hookTimeout: 30000,
    coverage: {
      provider: "v8",
      reporter: ["text", "json", "html"],
      exclude: [
        "**/node_modules/**",
        "**/dist/**",
        "**/backup/**",
        "**/config/**",
        "**/tools/**",
        "**/*.config.{js,ts}",
        "**/*.d.ts",
      ],
    },
  },
} satisfies UserConfig);
```

---

### Tools Configuration

#### tools/tsconfig.json

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "commonjs",
    "lib": ["ES2022"],
    "moduleResolution": "bundler",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "strict": true,
    "resolveJsonModule": true,
    "types": ["node"]
  },
  "include": ["*.ts"],
  "exclude": ["node_modules"]
}
```

---

## 4. Statistics

```
Total Files: 426
Configuration Files Extracted: 237
Source Files (in src/): 201

Files by Category:
  root: 15
  apps: 157
  packages: 96
  config: 6
  tools: 7
  docs: 13
  other: 132
```

