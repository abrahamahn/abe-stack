# config/docker/docker-compose.prod.yml
# Production Docker Compose for BSLT
#
# Usage:
#   docker compose -f config/docker/docker-compose.prod.yml --env-file config/env/.env.production up -d
#
# Prerequisites:
#   1. Create config/env/.env.production from .env.example
#   2. Set strong secrets: JWT_SECRET, SESSION_SECRET, POSTGRES_PASSWORD
#   3. Set DOMAIN and ACME_EMAIL for automatic TLS certificates
#
# Architecture:
#   Internet -> Caddy (80/443) -> Internal Network
#                  |
#                  +-> /health* -> api:8080
#                  +-> /ws      -> api:8080 (WebSocket)
#                  +-> /api/*   -> api:8080
#                  +-> /*       -> web:80
#
#   api:8080 -> pgbouncer:5432 (pool) -> postgres:5432

name: bslt-prod

services:
  # ===========================================================================
  # Caddy Reverse Proxy (TLS Termination)
  # ===========================================================================
  caddy:
    image: caddy:2-alpine
    container_name: bslt-caddy
    ports:
      - '80:80'
      - '443:443'
      - '443:443/udp' # HTTP/3 (QUIC)
    environment:
      DOMAIN: ${DOMAIN:-localhost}
      ACME_EMAIL: ${ACME_EMAIL:-admin@example.com}
    volumes:
      - ../../runtime/caddy/Caddyfile:/etc/caddy/Caddyfile:ro
      - caddy_data:/data
      - caddy_config:/config
    networks:
      - internal
    depends_on:
      api:
        condition: service_healthy
      web:
        condition: service_healthy
    healthcheck:
      test: ['CMD', 'wget', '--no-verbose', '--tries=1', '--spider', 'http://localhost:80']
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s
    restart: unless-stopped
    deploy:
      resources:
        limits:
          memory: 128M
          cpus: '0.25'
        reservations:
          memory: 64M

  # ===========================================================================
  # PostgreSQL Database
  # ===========================================================================
  postgres:
    image: postgres:16-alpine
    container_name: bslt-postgres
    environment:
      POSTGRES_DB: ${POSTGRES_DB:-abe_stack}
      POSTGRES_USER: ${POSTGRES_USER:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:?POSTGRES_PASSWORD is required}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - internal
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -U ${POSTGRES_USER:-postgres} -d ${POSTGRES_DB:-abe_stack}']
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    restart: unless-stopped
    deploy:
      resources:
        limits:
          memory: 512M
          cpus: '0.5'
        reservations:
          memory: 256M

  # ===========================================================================
  # PgBouncer â€” Connection Pooler
  # Sits between the API and Postgres to pool connections. Without this,
  # each Fastify worker holds a direct Postgres connection; under load
  # the server hits pg's max_connections limit and drops requests.
  #
  # Pool mode: transaction (efficient for request/response workloads).
  # Note: transaction mode does not support LISTEN/NOTIFY or advisory locks.
  # Switch to PGBOUNCER_POOL_MODE=session if the app uses those features.
  # ===========================================================================
  pgbouncer:
    image: bitnami/pgbouncer:latest
    container_name: bslt-pgbouncer
    environment:
      POSTGRESQL_HOST: postgres
      POSTGRESQL_PORT: 5432
      POSTGRESQL_USERNAME: ${POSTGRES_USER:-postgres}
      POSTGRESQL_PASSWORD: ${POSTGRES_PASSWORD:?POSTGRES_PASSWORD is required}
      POSTGRESQL_DATABASE: ${POSTGRES_DB:-abe_stack}
      PGBOUNCER_DATABASE: ${POSTGRES_DB:-abe_stack}
      PGBOUNCER_POOL_MODE: transaction
      PGBOUNCER_MAX_CLIENT_CONN: 100
      PGBOUNCER_DEFAULT_POOL_SIZE: 10
      PGBOUNCER_PORT: 5432
    networks:
      - internal
    depends_on:
      postgres:
        condition: service_healthy
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -h 127.0.0.1 -p 5432 -U ${POSTGRES_USER:-postgres}']
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 5s
    restart: unless-stopped
    deploy:
      resources:
        limits:
          memory: 64M
          cpus: '0.25'
        reservations:
          memory: 32M

  # ===========================================================================
  # API Server (Fastify)
  # ===========================================================================
  api:
    build:
      context: ../../..
      dockerfile: infra/docker/Dockerfile
    container_name: bslt-api
    env_file:
      - ../../../config/env/.env.production
    environment:
      NODE_ENV: production
      HOST: 0.0.0.0
      PORT: 8080
      POSTGRES_HOST: pgbouncer
      POSTGRES_PORT: 5432
      POSTGRES_DB: ${POSTGRES_DB:-abe_stack}
      POSTGRES_USER: ${POSTGRES_USER:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:?POSTGRES_PASSWORD is required}
      JWT_SECRET: ${JWT_SECRET:?JWT_SECRET is required}
      SESSION_SECRET: ${SESSION_SECRET:?SESSION_SECRET is required}
      # Trust reverse proxy for correct IP extraction
      TRUST_PROXY: ${TRUST_PROXY:-true}
      TRUSTED_PROXIES: ${TRUSTED_PROXIES:-172.16.0.0/12,10.0.0.0/8}
      MAX_PROXY_DEPTH: ${MAX_PROXY_DEPTH:-1}
      # Storage configuration
      STORAGE_PROVIDER: ${STORAGE_PROVIDER:-local}
      STORAGE_LOCAL_PATH: ${STORAGE_LOCAL_PATH:-/app/uploads}
      STORAGE_LOCAL_PUBLIC_URL: ${STORAGE_LOCAL_PUBLIC_URL:-/uploads}
      # Email configuration
      EMAIL_PROVIDER: ${EMAIL_PROVIDER:-console}
      EMAIL_FROM_NAME: ${EMAIL_FROM_NAME:-BSLT}
      EMAIL_FROM_ADDRESS: ${EMAIL_FROM_ADDRESS:-noreply@example.com}
    volumes:
      # Persistent storage for uploaded files (if using local storage)
      - uploads_data:/app/uploads
    networks:
      - internal
    depends_on:
      pgbouncer:
        condition: service_healthy
    healthcheck:
      test:
        [
          'CMD',
          'node',
          '-e',
          "require('http').get('http://localhost:8080/health', (r) => process.exit(r.statusCode === 200 ? 0 : 1))",
        ]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 15s
    restart: unless-stopped
    deploy:
      resources:
        limits:
          memory: 512M
          cpus: '1.0'
        reservations:
          memory: 256M

  # ===========================================================================
  # Web Frontend (Nginx serving static files)
  # ===========================================================================
  web:
    build:
      context: ../../..
      dockerfile: infra/docker/Dockerfile.web
      args:
        # Empty = relative URLs (reverse proxy handles /api routing)
        VITE_API_URL: ${VITE_API_URL:-}
    container_name: bslt-web
    networks:
      - internal
    depends_on:
      api:
        condition: service_healthy
    healthcheck:
      test: ['CMD', 'wget', '--no-verbose', '--tries=1', '--spider', 'http://localhost/health']
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 5s
    restart: unless-stopped
    deploy:
      resources:
        limits:
          memory: 128M
          cpus: '0.25'
        reservations:
          memory: 64M

networks:
  internal:
    driver: bridge

volumes:
  postgres_data:
    name: bslt-postgres-data
  uploads_data:
    name: bslt-uploads-data
  caddy_data:
    name: bslt-caddy-data
  caddy_config:
    name: bslt-caddy-config
