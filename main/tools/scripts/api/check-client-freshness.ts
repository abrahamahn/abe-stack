// main/tools/scripts/api/check-client-freshness.ts
/**
 * API Client Freshness Checker
 *
 * Runs the API client and hooks generators in dry-run mode and compares
 * the output against the existing generated files. Exits with a non-zero
 * exit code if the files are out of date.
 *
 * Usage:
 *   pnpm api:check            # Exit 1 if stale
 *   pnpm api:check --fix      # Regenerate if stale
 *
 * Can be called from pre-commit hooks or CI pipelines.
 */

import fs from 'node:fs';
import path from 'node:path';

import { generateManifest, populateRegistryFromRouteMaps } from '../audit/route-manifest';

// ---------------------------------------------------------------------------
// We re-use the same generation logic from the two generator scripts.
// Import the source-builders inline to avoid circular issues.
// ---------------------------------------------------------------------------

type ManifestEntry = {
  path: string;
  method: string;
  isPublic: boolean;
  module: string;
};

// ============================================================================
// Client source builder (copied from generate-client.ts to avoid coupling)
// ============================================================================

function toLiteral(value: string): string {
  return JSON.stringify(value);
}

function buildGeneratedClientSource(entries: ManifestEntry[]): string {
  const rows = entries
    .map(
      (entry) =>
        `  { method: ${toLiteral(entry.method.toUpperCase())}, path: ${toLiteral(entry.path)}, module: ${toLiteral(entry.module)}, public: ${entry.isPublic ? 'true' : 'false'} },`,
    )
    .join('\n');

  return `// main/client/api/src/generated/client.ts
/**
 * AUTO-GENERATED FILE. DO NOT EDIT.
 *
 * Generated by: main/tools/scripts/api/generate-client.ts
 * Source: route definitions registered via route-manifest.
 */

import { trimTrailingSlashes } from '../utils';

import type { BaseClientConfig } from '../utils';

export const generatedRouteDefinitions = [
${rows}
] as const;

export type GeneratedRouteDefinition = (typeof generatedRouteDefinitions)[number];
export type GeneratedApiPath = GeneratedRouteDefinition['path'];
export type GeneratedApiMethod = GeneratedRouteDefinition['method'];
export type GeneratedRouteModule = GeneratedRouteDefinition['module'];

export type MethodsForPath<P extends GeneratedApiPath> = Extract<
  GeneratedRouteDefinition,
  { path: P }
>['method'];

export interface GeneratedApiClientConfig extends BaseClientConfig {
  defaultHeaders?: HeadersInit;
}

export interface GeneratedApiRequest<P extends GeneratedApiPath, M extends GeneratedApiMethod> {
  path: P;
  method: M;
  body?: unknown;
  query?: Record<string, string | number | boolean | null | undefined>;
  headers?: HeadersInit;
  signal?: AbortSignal;
}

function buildQueryString(
  query: Record<string, string | number | boolean | null | undefined> | undefined,
): string {
  if (query === undefined) return '';
  const params = new URLSearchParams();
  for (const [key, value] of Object.entries(query)) {
    if (value === undefined || value === null) continue;
    params.set(key, String(value));
  }
  const encoded = params.toString();
  return encoded.length > 0 ? \`?\${encoded}\` : '';
}

export function createGeneratedApiClient(config: GeneratedApiClientConfig) {
  const baseUrl = trimTrailingSlashes(config.baseUrl);
  const fetchImpl = config.fetchImpl ?? fetch;
  const defaultHeaders = config.defaultHeaders;

  async function request<P extends GeneratedApiPath>(
    payload: GeneratedApiRequest<P, MethodsForPath<P>>,
  ): Promise<unknown> {
    const { path, method, body, headers, query, signal } = payload;
    const url = \`\${baseUrl}\${path}\${buildQueryString(query)}\`;
    const mergedHeaders: HeadersInit = {
      'Content-Type': 'application/json',
      ...defaultHeaders,
      ...headers,
    };

    const requestInit: RequestInit = {
      method,
      headers: mergedHeaders,
      credentials: 'include',
      body: body === undefined ? null : JSON.stringify(body),
    };
    if (signal !== undefined) {
      requestInit.signal = signal;
    }

    const response = await fetchImpl(url, requestInit);

    const contentType = response.headers.get('content-type') ?? '';
    const isJson = contentType.includes('application/json');
    const parsedBody = isJson ? await response.json() : await response.text();

    if (!response.ok) {
      throw new Error(
        typeof parsedBody === 'string'
          ? parsedBody
          : JSON.stringify(parsedBody ?? { message: 'Request failed' }),
      );
    }

    return parsedBody;
  }

  return {
    routes: generatedRouteDefinitions,
    request,
  };
}
`;
}

function buildGeneratedIndexSource(): string {
  return [
    '// main/client/api/src/generated/index.ts',
    "export { createGeneratedApiClient, generatedRouteDefinitions } from './client';",
    'export type {',
    '  GeneratedApiClientConfig,',
    '  GeneratedApiMethod,',
    '  GeneratedApiPath,',
    '  GeneratedApiRequest,',
    '  GeneratedRouteDefinition,',
    '  GeneratedRouteModule,',
    '  MethodsForPath,',
    "} from './client';",
    "export { queryKeys, queryOptions, mutationOptions } from './hooks';",
    "export type { GeneratedClient } from './hooks';",
    '',
  ].join('\n');
}

// ============================================================================
// Hooks source builder (imported from generate-hooks.ts logic)
// ============================================================================

function toPascal(segment: string): string {
  return segment
    .split('-')
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join('');
}

function pathToName(routePath: string): string {
  const segments = routePath.replace(/^\/api\//, '').split('/');
  const parts: string[] = [];

  for (const segment of segments) {
    if (segment.startsWith(':')) {
      const paramName = segment.slice(1);
      const pascalParam = paramName.charAt(0).toUpperCase() + paramName.slice(1);
      parts.push(`By${pascalParam}`);
    } else {
      parts.push(toPascal(segment));
    }
  }

  return parts.join('');
}

function buildHookName(method: string, routePath: string): string {
  const pascalName = pathToName(routePath);
  const upper = method.toUpperCase();
  if (upper === 'GET') {
    return `get${pascalName}`;
  }
  return `mutate${pascalName}`;
}

function buildQueryKeyName(routePath: string): string {
  const pascal = pathToName(routePath);
  return pascal.charAt(0).toLowerCase() + pascal.slice(1);
}

function extractParams(routePath: string): string[] {
  const params: string[] = [];
  for (const segment of routePath.split('/')) {
    if (segment.startsWith(':')) {
      params.push(segment.slice(1));
    }
  }
  return params;
}

function buildPathExpression(routePath: string): string {
  const expr = routePath.replace(/:([a-zA-Z][a-zA-Z0-9]*)/g, '${params.$1}');
  return '`' + expr + '`';
}

function buildParamsType(params: string[]): string {
  return `{ ${params.map((p) => `${p}: string`).join('; ')} }`;
}

function generateQueryKeyFactories(queries: ManifestEntry[]): string {
  const lines: string[] = [];
  const seen = new Set<string>();

  for (const entry of queries) {
    const name = buildQueryKeyName(entry.path);
    if (seen.has(name)) continue;
    seen.add(name);

    const params = extractParams(entry.path);
    if (params.length > 0) {
      const paramsType = buildParamsType(params);
      lines.push(
        `  ${name}: (params: ${paramsType}) => [${JSON.stringify(entry.path)}, params] as const,`,
      );
    } else {
      lines.push(`  ${name}: () => [${JSON.stringify(entry.path)}] as const,`);
    }
  }

  return lines.join('\n');
}

function generateQueryOptionFactory(entry: ManifestEntry): string {
  const hookName = buildHookName(entry.method, entry.path);
  const params = extractParams(entry.path);
  const keyName = buildQueryKeyName(entry.path);
  const lines: string[] = [];

  if (params.length > 0) {
    const paramsType = buildParamsType(params);
    const pathExpr = buildPathExpression(entry.path);
    lines.push(`  ${hookName}(client: GeneratedClient, params: ${paramsType}) {`);
    lines.push(`    return {`);
    lines.push(`      queryKey: queryKeys.${keyName}(params),`);
    lines.push(
      `      queryFn: () => client.request({ path: ${pathExpr} as GeneratedApiPath, method: ${JSON.stringify(entry.method.toUpperCase())} as GeneratedApiMethod, }),`,
    );
    lines.push(`    };`);
    lines.push(`  },`);
  } else {
    lines.push(`  ${hookName}(client: GeneratedClient) {`);
    lines.push(`    return {`);
    lines.push(`      queryKey: queryKeys.${keyName}(),`);
    lines.push(
      `      queryFn: () => client.request({ path: ${JSON.stringify(entry.path)} as GeneratedApiPath, method: ${JSON.stringify(entry.method.toUpperCase())} as GeneratedApiMethod, }),`,
    );
    lines.push(`    };`);
    lines.push(`  },`);
  }

  return lines.join('\n');
}

function generateMutationOptionFactory(entry: ManifestEntry): string {
  const hookName = buildHookName(entry.method, entry.path);
  const params = extractParams(entry.path);
  const lines: string[] = [];

  if (params.length > 0) {
    const paramsType = buildParamsType(params);
    const pathExpr = buildPathExpression(entry.path);
    lines.push(
      `  ${hookName}(client: GeneratedClient, params: ${paramsType}) {`,
    );
    lines.push(`    return {`);
    lines.push(`      mutationFn: (body?: unknown) =>`);
    lines.push(
      `        client.request({ path: ${pathExpr} as GeneratedApiPath, method: ${JSON.stringify(entry.method.toUpperCase())} as GeneratedApiMethod, body, }),`,
    );
    lines.push(`    };`);
    lines.push(`  },`);
  } else {
    lines.push(`  ${hookName}(client: GeneratedClient) {`);
    lines.push(`    return {`);
    lines.push(`      mutationFn: (body?: unknown) =>`);
    lines.push(
      `        client.request({ path: ${JSON.stringify(entry.path)} as GeneratedApiPath, method: ${JSON.stringify(entry.method.toUpperCase())} as GeneratedApiMethod, body, }),`,
    );
    lines.push(`    };`);
    lines.push(`  },`);
  }

  return lines.join('\n');
}

function buildHooksSource(entries: ManifestEntry[]): string {
  const queries = entries.filter((e) => e.method.toUpperCase() === 'GET');
  const mutations = entries.filter((e) => e.method.toUpperCase() !== 'GET');

  const queryKeyFactoryLines = generateQueryKeyFactories(queries);
  const queryOptionLines = queries.map((e) => generateQueryOptionFactory(e)).join('\n\n');
  const mutationOptionLines = mutations
    .map((e) => generateMutationOptionFactory(e))
    .join('\n\n');

  return `// main/client/api/src/generated/hooks.ts
/**
 * AUTO-GENERATED FILE. DO NOT EDIT.
 *
 * Generated by: main/tools/scripts/api/generate-hooks.ts
 * Source: route definitions registered via route-manifest.
 *
 * Usage with @bslt/react query hooks:
 *
 *   import { queryKeys, queryOptions, mutationOptions } from '@bslt/api/hooks';
 *   import { useQuery, useMutation } from '@bslt/react';
 *
 *   // Query with typed key
 *   const { data } = useQuery(queryOptions.getUsersMe(client));
 *
 *   // Mutation
 *   const { mutate } = useMutation(mutationOptions.mutateAuthLogin(client));
 *
 *   // Manual cache invalidation
 *   cache.invalidateQuery(queryKeys.usersMe());
 */

import type { GeneratedApiMethod, GeneratedApiPath } from './client';

// ============================================================================
// Client Interface
// ============================================================================

/** Minimal client interface expected by generated hooks. */
export interface GeneratedClient {
  request: (payload: {
    path: GeneratedApiPath;
    method: GeneratedApiMethod;
    body?: unknown;
    query?: Record<string, string | number | boolean | null | undefined>;
    headers?: HeadersInit;
    signal?: AbortSignal;
  }) => Promise<unknown>;
}

// ============================================================================
// Query Keys
// ============================================================================

/**
 * Type-safe query key factories for all GET routes.
 * Use these for cache invalidation, prefetching, and query matching.
 */
export const queryKeys = {
${queryKeyFactoryLines}
} as const;

// ============================================================================
// Query Option Factories (GET routes)
// ============================================================================

/**
 * Query option factories for all GET routes.
 * Returns objects compatible with useQuery({ queryKey, queryFn }).
 */
export const queryOptions = {
${queryOptionLines}
} as const;

// ============================================================================
// Mutation Option Factories (POST/PUT/PATCH/DELETE routes)
// ============================================================================

/**
 * Mutation option factories for all non-GET routes.
 * Returns objects compatible with useMutation({ mutationFn }).
 */
export const mutationOptions = {
${mutationOptionLines}
} as const;
`;
}

// ============================================================================
// Diff Logic
// ============================================================================

interface FileDiff {
  filePath: string;
  status: 'match' | 'mismatch' | 'missing';
}

function compareFile(filePath: string, expected: string): FileDiff {
  if (!fs.existsSync(filePath)) {
    return { filePath, status: 'missing' };
  }
  const existing = fs.readFileSync(filePath, 'utf8');
  return {
    filePath,
    status: existing === expected ? 'match' : 'mismatch',
  };
}

// ============================================================================
// Main
// ============================================================================

function run(): void {
  const fixMode = process.argv.includes('--fix');

  populateRegistryFromRouteMaps();
  const manifest = generateManifest() as ManifestEntry[];

  const outputDir = path.resolve('main/client/api/src/generated');

  // Build expected file contents
  const expectedClient = buildGeneratedClientSource(manifest);
  const expectedIndex = buildGeneratedIndexSource();
  const expectedHooks = buildHooksSource(manifest);

  const files: Array<{ path: string; expected: string }> = [
    { path: path.join(outputDir, 'client.ts'), expected: expectedClient },
    { path: path.join(outputDir, 'index.ts'), expected: expectedIndex },
    { path: path.join(outputDir, 'hooks.ts'), expected: expectedHooks },
  ];

  // Compare each file
  const diffs = files.map((f) => compareFile(f.path, f.expected));
  const staleFiles = diffs.filter((d) => d.status !== 'match');

  if (staleFiles.length === 0) {
    process.stdout.write(
      `All ${String(files.length)} generated API client files are up to date.\n`,
    );
    process.exit(0);
  }

  // Report stale files
  process.stderr.write(`Generated API client files are out of date:\n`);
  for (const diff of staleFiles) {
    const label = diff.status === 'missing' ? 'MISSING' : 'STALE';
    process.stderr.write(`  [${label}] ${diff.filePath}\n`);
  }

  if (fixMode) {
    fs.mkdirSync(outputDir, { recursive: true });
    for (const f of files) {
      fs.writeFileSync(f.path, f.expected, 'utf8');
    }
    process.stdout.write(
      `Regenerated ${String(files.length)} files (${String(manifest.length)} routes).\n`,
    );
    process.exit(0);
  }

  process.stderr.write(
    `\nRun "pnpm api:generate-client && pnpm api:generate-hooks" to regenerate.\n`,
  );
  process.stderr.write(`Or run "pnpm api:check --fix" to auto-fix.\n`);
  process.exit(1);
}

run();
