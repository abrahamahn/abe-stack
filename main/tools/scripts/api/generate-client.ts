// main/tools/scripts/api/generate-client.ts
/**
 * Generated API Client Builder
 *
 * Generates a typed fetch client from registered route definitions.
 * Source of truth: route map registry via route-manifest population.
 *
 * Usage:
 *   pnpm api:generate-client
 */

import fs from 'node:fs';
import path from 'node:path';

import { generateManifest, populateRegistryFromRouteMaps } from '../audit/route-manifest';

type ManifestEntry = {
  path: string;
  method: string;
  isPublic: boolean;
  module: string;
};

function toLiteral(value: string): string {
  return JSON.stringify(value);
}

function buildGeneratedClientSource(entries: ManifestEntry[]): string {
  const rows = entries
    .map(
      (entry) =>
        `  { method: ${toLiteral(entry.method.toUpperCase())}, path: ${toLiteral(entry.path)}, module: ${toLiteral(entry.module)}, public: ${entry.isPublic ? 'true' : 'false'} },`,
    )
    .join('\n');

  return `// main/client/api/src/generated/client.ts
/**
 * AUTO-GENERATED FILE. DO NOT EDIT.
 *
 * Generated by: main/tools/scripts/api/generate-client.ts
 * Source: route definitions registered via route-manifest.
 */

import { trimTrailingSlashes } from '../utils';

import type { BaseClientConfig } from '../utils';

export const generatedRouteDefinitions = [
${rows}
] as const;

export type GeneratedRouteDefinition = (typeof generatedRouteDefinitions)[number];
export type GeneratedApiPath = GeneratedRouteDefinition['path'];
export type GeneratedApiMethod = GeneratedRouteDefinition['method'];
export type GeneratedRouteModule = GeneratedRouteDefinition['module'];

export type MethodsForPath<P extends GeneratedApiPath> = Extract<
  GeneratedRouteDefinition,
  { path: P }
>['method'];

export interface GeneratedApiClientConfig extends BaseClientConfig {
  defaultHeaders?: HeadersInit;
}

export interface GeneratedApiRequest<P extends GeneratedApiPath, M extends GeneratedApiMethod> {
  path: P;
  method: M;
  body?: unknown;
  query?: Record<string, string | number | boolean | null | undefined>;
  headers?: HeadersInit;
  signal?: AbortSignal;
}

function buildQueryString(
  query: Record<string, string | number | boolean | null | undefined> | undefined,
): string {
  if (query === undefined) return '';
  const params = new URLSearchParams();
  for (const [key, value] of Object.entries(query)) {
    if (value === undefined || value === null) continue;
    params.set(key, String(value));
  }
  const encoded = params.toString();
  return encoded.length > 0 ? \`?\${encoded}\` : '';
}

export function createGeneratedApiClient(config: GeneratedApiClientConfig) {
  const baseUrl = trimTrailingSlashes(config.baseUrl);
  const fetchImpl = config.fetchImpl ?? fetch;
  const defaultHeaders = config.defaultHeaders;

  async function request<P extends GeneratedApiPath>(
    payload: GeneratedApiRequest<P, MethodsForPath<P>>,
  ): Promise<unknown> {
    const { path, method, body, headers, query, signal } = payload;
    const url = \`\${baseUrl}\${path}\${buildQueryString(query)}\`;
    const mergedHeaders: HeadersInit = {
      'Content-Type': 'application/json',
      ...defaultHeaders,
      ...headers,
    };

    const requestInit: RequestInit = {
      method,
      headers: mergedHeaders,
      credentials: 'include',
      body: body === undefined ? null : JSON.stringify(body),
    };
    if (signal !== undefined) {
      requestInit.signal = signal;
    }

    const response = await fetchImpl(url, requestInit);

    const contentType = response.headers.get('content-type') ?? '';
    const isJson = contentType.includes('application/json');
    const parsedBody = isJson ? await response.json() : await response.text();

    if (!response.ok) {
      throw new Error(
        typeof parsedBody === 'string'
          ? parsedBody
          : JSON.stringify(parsedBody ?? { message: 'Request failed' }),
      );
    }

    return parsedBody;
  }

  return {
    routes: generatedRouteDefinitions,
    request,
  };
}
`;
}

function run(): void {
  populateRegistryFromRouteMaps();
  const manifest = generateManifest() as ManifestEntry[];

  const outputDir = path.resolve('main/client/api/src/generated');
  fs.mkdirSync(outputDir, { recursive: true });

  const clientPath = path.join(outputDir, 'client.ts');
  const indexPath = path.join(outputDir, 'index.ts');

  const content = buildGeneratedClientSource(manifest);
  fs.writeFileSync(clientPath, content, 'utf8');
  fs.writeFileSync(
    indexPath,
    [
      '// main/client/api/src/generated/index.ts',
      "export { createGeneratedApiClient, generatedRouteDefinitions } from './client';",
      "export type {",
      '  GeneratedApiClientConfig,',
      '  GeneratedApiMethod,',
      '  GeneratedApiPath,',
      '  GeneratedApiRequest,',
      '  GeneratedRouteDefinition,',
      '  GeneratedRouteModule,',
      '  MethodsForPath,',
      "} from './client';",
      '',
    ].join('\n'),
    'utf8',
  );

  process.stdout.write(
    `Generated typed API client with ${String(manifest.length)} routes -> ${clientPath}\n`,
  );
}

run();
