```markdown
# Abe Stack: Architectural Master Plan

## 1. Executive Summary
The goal of this architecture is to separate concerns between **Marketing** (Speed/SEO), **Product IP** (Security/Value), and **Community** (Growth). 

We utilize a **"Trinity Repository"** structure where the Private Core repository acts as the single source of truth, feeding downstream updates to the Public Open Source repository via automated scripts.

---

## 2. High-Level Diagram

```mermaid
graph TD
    subgraph "Public Internet"
        Marketing[Repo 1: Marketing Site] -->|Link| SaaS[Live SaaS App]
        Marketing -->|Link| OSS[Repo 3: OSS Lite]
    end

    subgraph "Private Development"
        Core[Repo 2: Core Monorepo]
        Dev[You (Developer)] -->|Commits Code| Core
    end

    %% Flows
    Core -->|Env Var: DEMO_MODE=true| SaaS
    Core -->|1. Strip Script| Dist[Cleaned Dist Folder]
    Dist -->|2. GitHub Action Sync| OSS

    %% Contribution Flow
    OSS -.->|PR Submitted| Contributor[External Dev]
    Contributor -.->|Manual 'Patch & Port'| Core

```

---

## 3. Repository Breakdown

### Repository 1: `abe-stack-marketing` (The Facade)

* **Purpose:** Pure marketing, landing pages, SEO, and conversion funnel.
* **Tech Stack:** **Vanilla Vite + TypeScript**.
* *Why:* Zero dependencies, maximum cache-ability, instant load times, no complex build steps.


* **Relationship:** Completely isolated. Links to the App via URL (`app.abestack.com`).
* **Hosting:** Netlify or Vercel (Static CDN).

### Repository 2: `abe-stack-core` (The Mastermind)

* **Purpose:** The actual product. Contains **ALL** code (OSS + Standard + Pro + Max).
* **Visibility:** **Private**.
* **Architecture:** Monorepo (Superset Pattern).
* **Strategy for Tiers:**
* **Codebase:** We maintain ONE single codebase.
* **Pro Features:** Wrapped in `// @feature-start: PRO` comments or isolated in specific folders.
* **Demo Product:** Not a separate repo. It is this exact repo deployed with `IS_DEMO_MODE=true` environment variable.
* **Customer Deliverables:** Generated by running a `build-release` script that strips Pro/Max features and zips the result.



### Repository 3: `abe-stack-lite` (The Funnel)

* **Purpose:** Marketing tool, free tier, community engagement.
* **Visibility:** **Public**.
* **Relationship:** A "Read-Only Mirror" of the Core repo.
* **Content:** The Core repo *minus* all "Pro" folders and features.
* **Sync Strategy:** Automatic "Downstream Sync" via GitHub Actions.
* **Contribution Policy:** "Shadow Workflow" (See Section 6).

---

## 4. Technical Implementation

### A. The "Stripper" Script

*File Location: `abe-stack-core/scripts/build-oss.js*`

This script is the engine that generates the Lite version. It copies your private code to a temp folder, removes sensitive folders, and scrubs proprietary code blocks.

```javascript
// scripts/build-oss.js logic overview
// 1. Copy 'abe-stack-core' to 'dist-oss'
// 2. Delete excluded paths: ['.git', 'packages/billing', 'packages/ai-engine']
// 3. Scan all files for regex: /\/\/ @feature-start: PRO[\s\S]*?\/\/ @feature-end: PRO/g
// 4. Replace matches with "// [Pro Feature Removed]"

```

### B. The Sync Automation (GitHub Action)

*File Location: `abe-stack-core/.github/workflows/sync-oss.yml*`

Triggers on every push to `main` in the Private Core repo.

1. Checkout `abe-stack-core`.
2. Checkout `abe-stack-lite` (into a subdir).
3. Run `node scripts/build-oss.js`.
4. `rsync` the cleaned files *over* the `abe-stack-lite` files.
5. Force push to `abe-stack-lite/main`.

---

## 5. Development Workflows

### Scenario A: Developing a New Feature

1. Open `abe-stack-core` (Private).
2. If it is a **Pro feature**:
* Wrap imports/logic in `// @feature-start: PRO` markers.
* Or place files in `packages/pro-feature-x`.


3. If it is a **Core feature**:
* Write normally.


4. Commit & Push.
5. *Result:* The Sync Action runs. The Core feature appears on `lite` repo automatically. The Pro feature is stripped out.

### Scenario B: Deploying the Demo

1. Deploy `abe-stack-core` to your hosting provider (e.g., Railway/AWS).
2. Set Environment Variable: `IS_DEMO_MODE=true`.
3. *In Code:* Ensure critical mutations (DELETE users, Change Password) check this flag and return `403 Forbidden`.

### Scenario C: Selling the Code

1. Run local script: `npm run package:standard`.
* Runs the stripper script for "Standard" tier.
* Zips the output to `abe-stack-standard-v1.zip`.


2. Upload zip to payment provider (Gumroad/Stripe).

---

## 6. Handling Open Source Contributions

Since `abe-stack-lite` is a mirror, we cannot merge Pull Requests (PRs) directly on GitHub, or the repositories will diverge.

**The "Shadow" Workflow:**

1. **User Action:** User submits PR to `abe-stack-lite` fixing a bug.
2. **Review:** You review the PR on GitHub.
3. **Porting:**
* Open your **Private Core** repo locally.
* Manually apply the fix/change.
* *Critial Check:* Ensure the fix doesn't break any Pro features that the OSS user couldn't see.


4. **Commit:** Push to Private Core `main`.
5. **Sync:** The Action automatically overwrites `abe-stack-lite` with the new code (containing the fix).
6. **Close:** Comment on the user's PR: *"Fixed in Core commit X. Thanks!"* and close the PR.

---

## 7. Next Steps Checklist

* [ ] **Initialize Repo 1:** Create `abe-stack-marketing` (Vite + TS).
* [ ] **Initialize Repo 2:** Create `abe-stack-core` (Your Monorepo).
* [ ] **Initialize Repo 3:** Create `abe-stack-lite` (Empty public repo).
* [ ] **Scripting:** Write `scripts/build-oss.js` in Core.
* [ ] **CI/CD:** Add the Sync Action to Core's `.github/workflows`.
* [ ] **Documentation:** Add `CONTRIBUTING.md` to Lite repo explaining the read-only mirror status.

```
